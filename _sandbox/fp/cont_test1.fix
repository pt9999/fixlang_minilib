module Main;

import Minilib.Common.Common;
import Minilib.Common.IOEx;
import Minilib.Monad.Cont;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Monad.Trans;
import Minilib.Testing.UnitTest;

type [cm: * -> *] Label cm a b = box struct {
    // the argument of a jump
    arg: a,
    // current continuation of a jump
    cc: Label cm a b -> cm b
};

namespace Label {
    make: [cm: MonadCont] a -> cm (Label cm a b);
    make = |arg| (
        call_cc(|cc| pure $ Label { arg: arg, cc: cc })
    );

    jump: [cm: MonadCont] a -> Label cm a b -> cm b;
    jump = |arg, label| (
        (label.@cc)(label.set_arg(arg))
    );
}

test_label: TestCase;
test_label = (
    make_test("test_label") $ |_|
    let cont: ContT () IOFail () = do {
        let label = *Label::make(0);
        print(label.@arg.to_string + "> ").lift.lift_t;;
        let str = *read_line(IO::stdin).lift_t;
        let str = str.strip_last_newlines;
        if (str == "") { pure() };
        println(str).lift.lift_t;;
        label.jump(label.@arg + 1)
    };
    cont.run_cont_t(|_| pure())
);

// `postpone(g)` adds `g` as a postprocess function of `r`.
// Note that `postpone(f);; postpone(g)` is equivalent to `postpone(g >> f)`.
postpone: [m: Monad] (r -> r) -> ContT r m ();
postpone = |g| (
    cont_t $ |f: () -> m r| f().bind(g >> pure)
);

test_postpone: TestCase;
test_postpone = (
    make_test("test_postpone") $ |_|
    let cont: ContT (Array String) IOFail (Array String) = do {
        //postpone(reverse);;
        postpone(push_back("third"));;
        postpone(push_back("second"));;
        pure $ [ "first" ]
    };
    let arr = *cont.run_cont_t(|arr| pure $ arr);
    println(arr.to_string).lift
);

// Exits the continuation. The following part is ignored.
// The argument of `run_cont_t` is also ignored.
// Note that if you call `postpone` before `exit_cont`, the postponed functions will be executed.
exit_cont: [m: Monad] r -> ContT r m ();
exit_cont = |r| (
    cont_t $ |f: () -> m r| pure $ r
);

test_exit_cont: TestCase;
test_exit_cont = (
    make_test("test_exit_cont") $ |_|
    let cont: ContT (Array String) IOFail (Array String) = do {
        postpone(push_back("third"));;
        exit_cont $ [ "aborted" ];;
        postpone(push_back("second"));;
        pure $ [ "first" ]
    };
    let arr = *cont.run_cont_t(|arr| pure $ arr);
    println(arr.to_string).lift
);

test_loan_pattern1: TestCase;
test_loan_pattern1 = (
    make_test("test_loan_pattern1") $ |_|
    eval_cont_t $ do {
        let handle = *with_file("tmp.test.tmp", "w").cont_t;
        write_string(handle, "hello").lift_iofail
    };;
    eval_cont_t $ do {
        let handle = *with_file("tmp.test.tmp", "r").cont_t;
        let content = *read_string(handle).lift_iofail;
        assert_equal("eq", "hello", content)
    }
);

main: IO ();
main = (
    set_unbuffered_mode(stdout);;
    [
        test_postpone,
        test_exit_cont,
        //test_label,
        test_loan_pattern1,
    ]
    .run_test_driver
);

/*
type [cm: * -> *] LabelPair cm a b = box struct {
    label0: Label cm a b,
    label1: Label cm a b,
    code: I64,
};

coroutine0: [cm: MonadCont] LabelPair cm a b -> cm (LabelPair cm a b);
coroutine0 = |lp| (
    eval debug_eprintln("coroutine0 a");
    let lp = lp.set_code(0);
    let label0 = *Label::make(lp);
    let lp = label0.@arg;
    let lp = lp.set_label0(label0);
    if lp.@code == 0 {
        pure $ lp
    };
    if lp.@code < 1 {
        lp.@label1.jump(lp)
    };
    eval debug_eprintln("coroutine0 b");
    let lp = lp.set_code(2);
    let label0 = *Label::make(lp);
    let lp = label0.@arg;
    let lp = lp.set_label0(label0);
    if lp.@code == 2 {
        pure $ lp
    };
    if lp.@code < 3 {
        lp.@label1.jump(lp)
    };
    eval debug_eprintln("coroutine0 c");
    pure $ lp
);

coroutine1: [cm: MonadCont] LabelPair cm a b -> cm (LabelPair cm a b);
coroutine1 = |lp| (
    eval debug_eprintln("coroutine1 a");
    let lp = lp.set_code(1);
    let label1 = *Label::make(lp);
    let lp = label1.@arg;
    let lp = lp.set_label1(label1);
    if lp.@code == 1 {
        pure $ lp
    };
    if lp.@code < 2 {
        lp.@label0.jump(lp)
    };
    eval debug_eprintln("coroutine1 b");
    let lp = lp.set_code(3);
    let label1 = *Label::make(lp);
    let lp = label1.@arg;
    let lp = lp.set_label1(label1);
    if lp.@code == 3 {
        pure $ lp
    };
    if lp.@code < 4 {
        lp.@label0.jump(lp)
    };
    eval debug_eprintln("coroutine1 c");
    pure $ lp
);
*/
