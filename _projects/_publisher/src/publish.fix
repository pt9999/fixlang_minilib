module Publisher.Publish;

import Minilib.IO.Errno;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;

import Publisher.Common;
import Publisher.ProcessRunner;
import Publisher.ConsoleUi;
import Publisher.Fs;
import Publisher.Logger;
import Publisher.ProjectFile;

namespace GitTask {

    // Checks if the current directory is the root of a Git working tree.
    check_git_working_tree: [m: MonadFs, m: MonadError] m ();
    check_git_working_tree = (
        // `.git` is a directory in a standalone Git repository.
        // `.git` is a file in a submodule of a Git repository, or a worktree.
        let git_dir = DirName::git;
        check_if_directory_exists(git_dir).catch(|errmsg|
            check_if_file_exists(git_dir)
        )
    );

    // Checks if the current branch name is equal to the specified branch name.
    //
    // # Parameters
    // - `expected`: an expected branch name
    check_branch_name: [m: MonadLogger, m: MonadRunProcess, m: MonadError] String -> m ();
    check_branch_name = |expected| (
        log_message((expected,).format("### Checking if the current branch name is `{}`"));;
        let (stdout, stderr) = *run_process_quietly(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
        let actual = stdout.strip_spaces;
        if actual != expected {
            error $ (expected, actual).format("The current branch name is not `{}`: actual = `{}`")
        };
        pure()
    );

    // Checks if the uncommited files exist
    check_uncommitted_files: [m: MonadLogger, m: MonadRunProcess, m: MonadError] m ();
    check_uncommitted_files = (
        log_message("### Checking for uncommitted files");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only"]);
        if stdout != "" {
            error $ "Uncommitted file exists"
        };
        pure()
    );

    // Checks if there is any commit since the latest release
    no_commit_since_latest:  [m: MonadLogger, m: MonadRunProcess] m Bool;
    no_commit_since_latest = (
        log_message("### Checking if there is any commit since the latest release");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only", TagName::latest]);
        if stdout == "" {
            pure $ true
        };
        pure $ false
    );

    // Resets the lock files if modified.
    reset_lock_files:  [m: MonadRunProcess] m ();
    reset_lock_files = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        pure()
    );

    // Commits the lock files if modified.
    commit_lock_files: [m: MonadLogger, m: MonadRunProcess] m ();
    commit_lock_files = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        if stdout == "" { pure() };
        log_message("### Commit fixdeps.lock");;
        let (stdout, stderr) = *run_process(["git", "add", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update deps", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        pure()
    );

    // Commits the documents if modified.
    commit_documents: [m: MonadLogger, m: MonadRunProcess] m ();
    commit_documents = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", DirName::docs]);
        if stdout == "" { pure() };
        log_message("### Commit documents");;
        let (stdout, stderr) = *run_process(["git", "add", "--", DirName::docs]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update documents", "--", DirName::docs]);
        pure()
    );

    // Resets the documents if modified.
    reset_documents: [m: MonadRunProcess] m ();
    reset_documents = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", DirName::docs]);
        pure()
    );

    // Commits the project file if modified.
    commit_project_file: [m: MonadLogger, m: MonadRunProcess] Path -> String -> m ();
    commit_project_file = |filepath, version| (
        log_message("### Commit the project file");;
        let (stdout, stderr) = *run_process(["git", "add", "--verbose", "--", filepath]);
        let message = "version " + version;
        let (stdout, stderr) = *run_process(["git", "commit", "--verbose", "-m", message]);
        pure()
    );

    // Makes a version tag.
    make_version_tag: [m: MonadLogger, m: MonadRunProcess] String -> m ();
    make_version_tag = |version| (
        log_message("### Make a version tag");;
        let (stdout, stderr) = *run_process(["git", "tag", version]);
        let (stdout, stderr) = *run_process(["git", "tag", TagName::latest, "-f"]);
        pure()
    );

    push_branch_to_remote: [m: MonadLogger, m: MonadRunProcess] m ();
    push_branch_to_remote = (
        log_message("### Push to the remote repository");;
        let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin]);
        pure()
    );

    push_tags_to_remote: [m: MonadLogger, m: MonadRunProcess] String -> m ();
    push_tags_to_remote = |version| (
        log_message("### Push tags to the remote repository");;
        let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin, version]);
        let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin, TagName::latest, "-f"]);
        pure()
    );
}

namespace ProjectTask {

    // Changes the current working directory to the project directory.
    //
    // # Parameters
    // - `project_dir`: a project directory
    chdir_to_project_dir: [m: MonadLogger, m: MonadFs] Path -> m ();
    chdir_to_project_dir = |project_dir| (
        log_message("### Chdir to `" + project_dir + "`");;
        fs_chdir(project_dir)
    );

    // Checks if the project file (fixproj.toml) exists.
    check_project_file_exists: [m: MonadFs] m ();
    check_project_file_exists = (
        let project_file_path = FileName::fixproj_toml;
        check_if_file_exists(project_file_path)
    );

    // Checks if the specified file exists.
    //
    // # Parameters
    // - `filepath`: a filepath
    check_if_file_exists: [m: MonadFs] Path -> m ();
    check_if_file_exists = |filepath| (
        if ! *fs_file_exists(filepath) {
            error $ "File not found: " + filepath
        };
        pure()
    );

    check_if_directory_exists: [m: MonadFs] Path -> m ();
    check_if_directory_exists = |dirpath| (
        if ! *fs_directory_exists(dirpath) {
            error $ "Directory not found: " + dirpath
        };
        pure()
    );

    run_fix_clean: [m: MonadLogger, m: MonadRunProcess] m ();
    run_fix_clean = (
        log_message("### Clean");;
        let (stdout, stderr) = *run_process(["fix", "clean"]);
        pure()
    );

    run_fix_deps_update: [m: MonadLogger, m: MonadRunProcess] m ();
    run_fix_deps_update = (
        log_message("### Update deps");;
        let (stdout, stderr) = *run_process(["fix", "deps", "update"]);
        pure()
    );

    run_fix_test: [m: MonadLogger, m: MonadRunProcess] m ();
    run_fix_test = (
        log_message("### Run tests");;
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "basic"]);
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "max"]);
        pure()
    );

    run_fix_docs: [m: MonadLogger, m: MonadRunProcess] m ();
    run_fix_docs = (
        log_message("### Generate documents");;
        let (stdout, stderr) = *run_process(["fix", "docs", "-o", DirName::docs]);
        pure()
    );
}


type PublishArgs = unbox struct {
    project_dir: Path,
    new_version: Option String,
    release: Bool,
    confirm: Bool,
    test: Bool,
    commit: Bool,
    push: Bool,
    tag: Bool,
    update_document: Bool,
    check_branch: Bool,
};

namespace PublishArgs {
    empty: PublishArgs;
    empty = PublishArgs {
        project_dir: "",
        new_version: none(),
        release: false,
        confirm: false,
        test: true,
        commit: false,
        push: false,
        tag: false,
        update_document: false,
        check_branch: true,
    };

    update_realpath: [m: MonadFs] PublishArgs -> m PublishArgs;
    update_realpath = |args| (
        let args = *args.act_project_dir(fs_realpath);
        pure $ args
    );
}

do_publish: [m: MonadLogger, m: MonadConsoleUi, m: MonadFs, m: MonadRunProcess, m: MonadError] PublishArgs -> m ();
do_publish = |args| (
    let args = *args.update_realpath;

    chdir_to_project_dir(args.@project_dir);;

    // Checks preconditions
    check_git_working_tree;;
    check_project_file_exists;;
    check_branch_name(BranchName::main).when(args.@check_branch);;
    check_uncommitted_files;;

    // If there is no commit since the latest release, only run tests with the latest dependencies
    if *no_commit_since_latest {
        log_message("### No commit since latest, so only run tests with the latest dependencies");;
        run_fix_clean;;
        run_fix_deps_update;;
        run_fix_test.when(args.@test);;
        run_fix_docs;;
        reset_lock_files;;
        reset_documents;;
        log_message("### No need to publish");;
        pure()
    };

    // Clean, update deps, run tests, generate docs
    run_fix_clean;;
    run_fix_deps_update;;
    run_fix_test.when(args.@test);;
    run_fix_docs.when(args.@update_document);;

    log_message("### Update the project file");;
    let project_file_path = FileName::fixproj_toml;
    let new_version = *upgrade_project_version(project_file_path, args.@new_version, args.@release, args.@confirm);

    // Re-generates documents with the new version
    reset_documents.when(args.@update_document);;
    run_fix_docs.when(args.@update_document);;

    // Commits lock files
    commit_lock_files.when(args.@commit);;

    // Commits documents
    commit_documents.when(args.@commit && args.@update_document);;

    // Commits the project file
    commit_project_file(project_file_path, new_version).when(args.@commit);;

    make_version_tag(new_version).when(args.@tag);;
    push_branch_to_remote.when(args.@push);;
    push_tags_to_remote(new_version).when(args.@push && args.@tag);;

    pure()
);

type ProjectArgs = unbox struct {
    project_dir: Path,
};

namespace ProjectArgs {
    empty: ProjectArgs;
    empty = ProjectArgs {
        project_dir: "",
    };
}

do_project_show: [m: MonadLogger, m: MonadIO, m: MonadFs, m: MonadError] ProjectArgs -> m ();
do_project_show = |args| (
    chdir_to_project_dir(args.@project_dir);;
    let project_file_path = FileName::fixproj_toml;
    let project_file = *ProjectFile::from_file(project_file_path);
    let project_name = *project_file.get_project_name;
    let project_version = *project_file.get_project_version;
    mprintln(project_name + " = " + project_version)
);
