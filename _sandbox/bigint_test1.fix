module Main;

import Debug;
import Random;

import Minilib.Math.BigInt;
import Minilib.Math.BigIntPrime;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

test_prime: IO ();
test_prime = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(time.to_U64);
    let a = pow_by_U64(two, 512_U64);
    let (b, random) = random.generate_range(zero, a);
    //let _ = *println(a.to_string);
    let _ = *loop_m(
        (b, random), |(b, random)|
        // Miller-Rabin Primality test.
        let (ret, random) = miller_rabin(b, random);
        // Solovayâ€“Strassen primality test.
        let (ret2, random) = solovay_strassen(b, random);
        let judge = |b| if b { "prime" } else { "composite" };
        let _ = *println(
            (b, judge(ret), judge(ret2)).format("{}: {}: {}")
        );
        if ret {
            break_m $ ()
        };
        continue_m $ (b + one, random)
    );
    pure()
);

test_probable_prime: IO ();
test_probable_prime = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(time.to_U64);
    loop_m(
        128, |bit_length|
        if bit_length > 512 { break_m $ () };
        let _ = *println("Searching a probable prime of " + bit_length.to_string + " bits...");
        let ((n, random), time) = consumed_time_while(|_|
            probable_prime(bit_length, random)
        , ());
        let _ = *println(n.to_string);
        let _ = *println("time="+time.to_string);
        continue_m $ bit_length + 128
    )
);

main: IO ();
main = test_probable_prime;

