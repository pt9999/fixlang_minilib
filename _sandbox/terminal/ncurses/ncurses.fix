module Minilib.Terminal.Ncurses;

type Ncurses = unbox struct {
    dtor: Destructor ()
};

namespace Ncurses {
    run: (Window -> IOFail ()) -> IOFail ();
    run = |runner| (
        FFI_CALL_IO[() minilib_ncurses_initialize()].lift;;
        let ncurses = Ncurses {
            dtor: Destructor::make((), |_|
                FFI_CALL_IO[() minilib_ncurses_finialize()];;
                println("finalize done");;
                pure()
            )
        };
        let win = *ncurses.get_standard_window;
        runner(win);;
        eval ncurses;
        pure()
    );

    get_standard_window: Ncurses -> IOFail Window;
    get_standard_window = |ncurses| (
        let p_win = *FFI_CALL_IO[Ptr minilib_ncurses_get_standard_window()].lift;
        pure $ Window {
            dtor: Destructor::make(p_win, |p_win| pure $ nullptr)
        }
    );
}

type Window = unbox struct {
    dtor: Destructor Ptr
};

namespace Window {
    make_new_window: I64 -> I64 -> I64 -> I64 -> Window -> IOFail Window;
    make_new_window = |x, y, w, h, orig| (
        let p_win = *FFI_CALL_IO[Ptr newwin(CInt, CInt, CInt, CInt), h.to_CInt, w.to_CInt, y.to_CInt, x.to_CInt].lift;
        if p_win == nullptr {
            throw $ "newwin failed! (x,y,w,h)=" + (x,y,w,h).to_string
        };
        let win = Window {
            dtor: Destructor::make(p_win, |p_win|
                FFI_CALL_IO[() delwin(Ptr), p_win].when(p_win != nullptr);;
                pure $ nullptr
            )
        };
        pure $ win
    );

    make_sub_window: I64 -> I64 -> I64 -> I64 -> Window -> IOFail Window;
    make_sub_window = |x, y, w, h, parent| (
        let p_win = *parent.@dtor.borrow_io(|p_parent|
            FFI_CALL_IO[Ptr subwin(Ptr, CInt, CInt, CInt, CInt), p_parent, h.to_CInt, w.to_CInt, y.to_CInt, x.to_CInt]
        ).lift;
        if p_win == nullptr {
            throw $ "subwin failed! (x,y,w,h)=" + (x,y,w,h).to_string
        };
        let win = Window {
            dtor: Destructor::make(p_win, |p_win|
                FFI_CALL_IO[() delwin(Ptr), p_win].when(p_win != nullptr);;
                pure $ nullptr
            )
        };
        pure $ win
    );

    get_window_size: Window -> IOFail (I64, I64);
    get_window_size = |win| (
        let ret = *win.@dtor.borrow_io(|p_win|
            FFI_CALL_IO[CInt minilib_ncurses_get_window_size(Ptr), p_win]
        ).lift;
        let w = ret.to_I64.shift_right(16).bit_and(0xffff);
        let h = ret.to_I64.bit_and(0xffff);
        pure $ (w, h)
    );

    _check_cint_err: String -> Window -> (Ptr -> IO CInt) -> IOFail ();
    _check_cint_err = |name, win, ffi_call_io| (
        let err = *win.@dtor.borrow_io(|p_win| ffi_call_io(p_win)).lift;
        if err != 0.to_CInt { throw $ name + " failed!" };
        pure()
    );

    clear: Window -> IOFail ();
    clear = |win| (
        win._check_cint_err("clear") $ |p_win|
        FFI_CALL_IO[CInt erase(Ptr), p_win]
    );

    draw_border: Window -> IOFail ();
    draw_border = |win| (
        win._check_cint_err("draw_border") $ |p_win|
        FFI_CALL_IO[CInt minilib_ncurses_draw_border(Ptr), p_win]
    );

    set_attr: ChType -> Window -> IOFail ();
    set_attr = |chtype, win| (
        win._check_cint_err("set_attr") $ |p_win|
        FFI_CALL_IO[CInt wattrset(Ptr, U32), p_win, chtype]
    );

    set_color: I64 -> Attr -> Window -> IOFail ();
    set_color = |color_pair, attr, win| (
        win._check_cint_err("set_color") $ |p_win|
        FFI_CALL_IO[CInt wattr_set(Ptr, U32, U16, Ptr), p_win, attr, color_pair.to_U16, nullptr]
    );

    move_to: I64 -> I64 -> Window -> IOFail ();
    move_to = |x, y, win| (
        win._check_cint_err("move_to") $ |p_win|
        FFI_CALL_IO[CInt wmove(Ptr, CInt, CInt), p_win, y.to_CInt, x.to_CInt]
    );

    add_str: String -> Window -> IOFail ();
    add_str = |str, win| (
        win._check_cint_err("add_str") $ |p_win|
        str.borrow_c_str_io(|p_str|
            FFI_CALL_IO[CInt waddstr(Ptr, Ptr), p_win, p_str]
        )
    );

    move_add_str: I64 -> I64 -> String -> Window -> IOFail ();
    move_add_str = |x, y, str, win| (
        win._check_cint_err("move_add_str") $ |p_win|
        str.borrow_c_str_io(|p_str|
            FFI_CALL_IO[CInt mvwaddstr(Ptr, CInt, CInt, Ptr), p_win, y.to_CInt, x.to_CInt, p_str]
        )
    );

    getch: Window -> IOFail I64;
    getch = |win| (
        win.@dtor.borrow_io(|p_win|
            FFI_CALL_IO[CInt wgetch(Ptr), p_win]
        ).map(to_I64).lift
    );

}

type Color = I64;

namespace Color {
    black: Color;
    black = 0;

    red: Color;
    red = 1;

    green: Color;
    green = 2;

    yellow: Color;
    yellow = 3;

    blue: Color;
    blue = 4;

    magenta: Color;
    magenta = 5;

    cyan: Color;
    cyan = 6;

    white: Color;
    white = 7;
}

type ColorPair = I64;

namespace ColorPair {
    init_color_pair: ColorPair -> Color -> Color -> IOFail ();
    init_color_pair = |color_pair, fore_color, back_color| (
        let err = *FFI_CALL_IO[CInt init_pair(I16, I16, I16), color_pair.to_I16, fore_color.to_I16, back_color.to_I16].lift;
        if err != 0.to_CInt { throw $ "init_color_pair failed!" };
        pure()
    );

    color_pair: I64 -> ChType;
    color_pair = |i| (i.bit_and(255)).to_U32.shift_left(8_U32);
}

type ChType = U32;

_ncurses_bits: ChType -> ChType -> ChType;
_ncurses_bits = |shift, mask| mask.shift_left(shift + 8_U32);

type Attr = ChType;

make_attr: ColorPair -> Attr -> ChType;
make_attr = |pair, attr| (
    color_pair(pair).bit_or(attr)
);

namespace Attr {

    normal: Attr;
    normal = 0_U32;

    underline: Attr;
    underline = 1_U32._ncurses_bits(9_U32);

    reverse: Attr;
    reverse = 1_U32._ncurses_bits(10_U32);

    blink: Attr;
    blink = 1_U32._ncurses_bits(11_U32);

    dim: Attr;
    dim = 1_U32._ncurses_bits(12_U32);

    bold: Attr;
    bold = 1_U32._ncurses_bits(13_U32);
}
