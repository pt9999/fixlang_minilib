module Main;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13;

import Debug;

import Minilib.IO.Channel;
import Minilib.Encoding.Binary;
import Minilib.Monad.FunctorM;
import Minilib.Monad.Reader;
import Minilib.Monad.State;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

type ChannelConnection = unbox struct {
    input: Channel U8,
    output: Channel U8
};

namespace ChannelConnection {
    make: Channel U8 -> Channel U8 -> ChannelConnection;
    make = |input, output| ChannelConnection {
        input: input,
        output: output
    };

    swap: ChannelConnection -> ChannelConnection;
    swap = |conn| ChannelConnection {
        input: conn.@output,
        output: conn.@input
    };

    pipe: IO (ChannelConnection, ChannelConnection);
    pipe = do {
        let input = *Channel::make;
        let output = *Channel::make;
        let local_conn = ChannelConnection::make(input, output);
        let remote_conn = ChannelConnection::make(output, input);
        pure $ (local_conn, remote_conn)
    };
}

impl StateT ChannelConnection IOFail: TLSConnectionIF {
    send_bytes = |bytes| (
        let conn = *get_state;
        let output = conn.@output;
        bytes.map_m(|b| output.send(b))
    );

    recv_n_bytes = |length| (
        let conn = *get_state;
        let input = conn.@input;
        Array::fill(length, input.recv).map_m
    );
}

type MockServer = unbox struct {

};

namespace MockServer {
    make: IOHandle -> MockServer;
    make = |handle| MockServer {
        handle: handle
    };
}

import Minilib.Testing.UnitTest;

test_client_hello: TestCase;
test_client_hello = (
    let ()
);
