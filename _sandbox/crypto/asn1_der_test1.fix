module Main;

import Minilib.Crypto.Asn1.Der;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
import Minilib.Testing.UnitTest;

run_decoder: Array U8 -> StateT ByteBuffer IOFail a -> IOFail (Result ErrMsg a);
run_decoder = |arr, decoder| (
    let buf = ByteBuffer::make(arr, big_endian());
    let res = *decoder.run_state_t(buf).to_result.lift;
    pure $ res.map(@0)
);

test_decode_identifier: TestCase;
test_decode_identifier = (
    make_table_test("test_decode_identifier",
        [
            ([0x01_U8], ok $ Identifier::make(tc_universal, false, tag_boolean)),
            ([0x42_U8], ok $ Identifier::make(tc_application, false, tag_integer)),
            ([0x62_U8], ok $ Identifier::make(tc_application, true, tag_integer)),
            ([0x84_U8], ok $ Identifier::make(tc_context_specific, false, tag_octet_string)),
            ([0xE9_U8], ok $ Identifier::make(tc_private, true, tag_real)),
            ([0x1F_U8, 0x21_U8], ok $ Identifier::make(tc_universal, false, tag_date_time)),
        ],
        |(arr, expected)|
        let actual = *decode_identifier.run_decoder(arr);
        assert_equal("eq", expected, actual)
    )
);

test_decode_length: TestCase;
test_decode_length = (
    make_table_test("test_decode_length",
        [
            ([0x01_U8], ok $ 1),
            ([0x7F_U8], ok $ 127),
            ([0x81_U8, 0xAB_U8], ok $ 0xAB),
            ([0x82_U8, 0xAB_U8, 0xCD_U8], ok $ 0xABCD),
        ],
        |(arr, expected)|
        let actual = *decode_length.run_decoder(arr);
        assert_equal("eq", expected, actual)
    )
);

test_decode_n_bytes: TestCase;
test_decode_n_bytes = (
    make_table_test("test_decode_n_bytes",
        [
            ([0x01_U8, 0x02_U8, 0x03_U8], 2, ok $ [0x01_U8, 0x02_U8]),
        ],
        |(arr, length, expected)|
        let actual = *decode_n_bytes(length).run_decoder(arr);
        assert_equal("eq", expected, actual)
    )
);

decode_file: Path -> IOFail ();
decode_file = |path| (
    let bytes = *read_file_bytes(path);
    let buf = ByteBuffer::make(bytes, big_endian());
    let sm: StateT ByteBuffer IOFail () = loop_m(
        (), |_|
        let buf = *get_state;
        if buf.@position >= buf.get_size { break_m $ () };
        let identifier = *decode_identifier;
        let length = *decode_length;
        if identifier.@constructed {
            eval *println(
                identifier.to_string +
                " length=" + length.to_string
            ).lift.lift_t;
            continue_m $ ()
        };
        let contents = *decode_n_bytes(length);
        eval *println(
            identifier.to_string +
            " length=" + length.to_string +
            " contents=" + contents.to_string_hex +
            if identifier.@tag == tag_printable_string {
                " (" + contents._unsafe_to_string + ")"
            } else { "" }
        ).lift.lift_t;
        continue_m $ ()
    );
    sm.run_state_t(buf).forget
);

main: IO ();
main = (
    //eval *decode_file(Path::parse("https/tmp.cert_0.cer").as_some).try(eprintln);
    [
        test_decode_identifier,
        test_decode_length,
        test_decode_n_bytes,
    ]
    .run_test_driver
);

