module Main;

import Debug;

import Minilib.Testing.UnitTest;
import Minilib.Monad.Identity;


// Function monad. same as Reader monad
type Function a b = unbox struct {
    data: a -> b
};

namespace Function {
    make: (a -> b) -> Function a b;
    make = |f| Function { data: f };

    get: Function a b -> (a -> b);
    get = @data;
}

impl Function a: Functor {
    map = |f, mb| Function::make(mb.@data >> f);
}

impl Function a: Monad {
    pure = |b| Function::make(|_| b);
    bind = |f, mb| Function::make(|a|
        let mc = f((mb.@data)(a));
        (mc.@data)(a)
    );
}

//------------------------------------------------------------------------

// A trait for the interface of generic continuation  monads.
trait MonadCont = Monad + MonadContIF;

// A trait for generic continuation  monads.
trait [cm: * -> *] cm: MonadContIF {
    call_cc: ((a -> cm b) -> cm a) -> cm a;
}

// A continuation monad.
type [m: * -> *] ContT r m a = unbox struct {
    data: (a -> m r) -> m r
};

type Cont r a = ContT r Identity a;

namespace Cont {
    // Creates a ContT monad from a function.
    cont_t: [m: Monad] ((a -> m r) -> m r) -> ContT r m a;
    cont_t = |f| ContT { data: f };

    // Creates a Cont monad from a function.
    cont: ((a -> r) -> r) -> Cont r a;
    cont = |farr| cont_t $ |famr| (
        Identity::make $ farr $ famr >> Identity::get
    );

    run_cont_t: [m: Monad] (a -> m r) -> ContT r m a -> m r;
    run_cont_t = |fa_mr, cma| (
        (cma.@data)(fa_mr)
    );

    run_cont: (a -> r) -> Cont r a -> r;
    run_cont = |fa_r, cma| (
        cma.run_cont_t(fa_r >> Identity::make).Identity::get
    );
}

impl [m: Monad] ContT r m: Functor {
    map = |fab, cma| (          // fab: a -> b, cma: ContT r m a
        Cont::cont_t $ |fbmr|   // fbmr: b -> m r
        cma.run_cont_t(fab >> fbmr)
    );
}

impl [m: Monad] ContT r m: Monad {
    pure = |a| Cont::cont_t $ |famr| famr(a);
    bind = |facmb, cma| (       // facmb: a -> ContT r m b, cma: ContT r m a
        Cont::cont_t $ |fbmr|   // fbmr: b -> m r
        cma.run_cont_t(|a|
            let cmb = facmb(a); // cmb: ContT r m b
            cmb.run_cont_t(fbmr)
        )
    );
}

impl [m: Monad] ContT r m: MonadContIF {
    //call_cc: ((a -> cm b) -> cm a) -> cm a;
    call_cc = |fa_cmb_cma| (            // fa_cmb_cma: (a -> ContT r m b) -> ContT r m a
        Cont::cont_t $ |fa_mr|          // fa_mr: a -> m r
        let fa_cmb = |a| (              // fa_cmb: a -> ContT r m b
            Cont::cont_t $ |fb_mr|      // fb_mr: b -> m r (ignored)
            fa_mr(a)
        );
        let cma = fa_cmb_cma(fa_cmb);
        cma.run_cont_t(fa_mr)
    );
}

test_functor_cont: TestCase;
test_functor_cont = (
    make_test("test_functor_cont") $ |_|
    let cma: Cont (Array String) I64 = Cont::cont $ |far| far(42);
    let cmb = cma.map(to_string);
    let expected = ["foo-42", "bar-42"];
    let actual = cmb.run_cont(|str| ["foo-" + str, "bar-" + str]);
    assert_equal("eq", expected, actual)
);

test_functor_cont_t: TestCase;
test_functor_cont_t = (
    make_test("test_functor_cont_t") $ |_|
    let cma: ContT (Array String) IOFail I64 = Cont::cont_t $ |far| far(42);
    let cmb = cma.map(to_string);
    let expected = ["foo-42", "bar-42"];
    let actual = *cmb.run_cont_t(|str| pure $ ["foo-" + str, "bar-" + str]);
    assert_equal("eq", expected, actual)
);

test_monad_cont: TestCase;
test_monad_cont = (
    make_test("test_monad_cont") $ |_|
    let mc: Cont (Array String) (Array I64)  = do {
        let a = *pure(3);
        let b = *pure(4);
        pure $ [a, b]
    };
    let md: Cont (Array String) (Array String) = do {
        let ab = *mc;
        if ab.@(0) % 2 == 0 {
            pure $ ab.map(to_string)
        } else {
            pure $ ab.append(ab).map(to_string)
        }
    };
    let actual = md.run_cont(|x| x);
    let expected = ["3", "4", "3", "4"];
    //eval *println (actual.to_string).lift;
    assert_equal("eq", expected, actual)
);

test_call_cc: TestCase;
test_call_cc = (
    make_test("test_call_cc") $ |_|
    let cma: Cont String I64 = call_cc(|exit|
        loop_m(
            (0, 0), |(sum, i)|
            if i >= 10 { break_m $ sum };
            if i >= 5 { exit(sum) };
            let sum = sum + i;
            //eval debug_eprintln("i="+i.to_string+" sum="+sum.to_string);
            continue_m $ (sum, i + 1)
        )
    );
    let expected = "10";
    let actual = cma.run_cont(|sum| sum.to_string);
    assert_equal("eq", expected, actual)
);

//------------------------------------------------------------------------

main: IO ();
main = (
    [
        test_functor_cont,
        test_functor_cont_t,
        test_monad_cont,
        test_call_cc,
    ]
    .run_test_driver
);
