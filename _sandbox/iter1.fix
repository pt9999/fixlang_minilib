module Main;

import Minilib.Common.IteratorEx;

// same as `arr.to_iter.zip(arr.to_iter.pop_first)`
type AdjacentIterator a = unbox struct { arr : Array a, idx : I64 };

impl AdjacentIterator a : Iterator {
    type Item (AdjacentIterator a) = (a, a);
    advance = |AdjacentIterator { arr : arr, idx : idx }| (
        if idx + 1 >= arr.get_size { none() };
        let u = arr.@(idx);
        let v = arr.@(idx + 1);
        some((AdjacentIterator { arr: arr, idx: idx + 1 }, (u, v)))
    );
}

adjacent: Array a -> AdjacentIterator a;
adjacent = |arr| AdjacentIterator { arr: arr, idx: 0 };

test_adjacent: IO ();
test_adjacent = (
    println("=== test_adjacent ===");;
    [
        ([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]),
        ([1], []),
        ([], []),
    ]
    .to_iter.fold_m(
        (), |(arr, expected), _|
        let actual = arr.adjacent.to_array;
        let actual2 = arr.to_iter.zip(arr.to_iter.pop_first).to_array;
        println("arr=" + arr.to_string);;
        println("adjacent=" + actual.to_string);;
        println("actual2=" + actual2.to_string);;
        assert_eq(|_| "eq", expected, actual);;
        assert_eq(|_| "eq", expected, actual2)
    )
);

main: IO () = (
    test_adjacent;;
    pure()
);
