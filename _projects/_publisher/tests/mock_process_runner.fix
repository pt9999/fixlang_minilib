module Publisher.Tests.MockProcessRunner;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Testing.UnitTest;

import Publisher.Common;
import Publisher.ProcessRunner;

//  プロセス
type MockProcess = unbox struct {
    // コマンドライン引数
    args: Array String,
    // オプション("verbose", "has_input"等)
    options: Array String,
};

impl MockProcess: Eq {
    eq = |a, b| (
        a.@args == b.@args &&
        a.@options == b.@options
    );
}

impl MockProcess: ToString {
    to_string = |process| (
        "MockProcess {"
        + " args=" + process.@args.to_string
        + " options=" + process.@options.to_string
        + " }"
    );
}

namespace MockProcess {
    empty: MockProcess;
    empty = MockProcess {
        args: [],
        options: [],
    };

    // コマンドライン引数をもとにプロセスを作成する
    make: Array String -> MockProcess;
    make = |args| MockProcess::empty.set_args(args);

    // verboseオプションを設定する
    verbose: MockProcess -> MockProcess;
    verbose = mod_options(push_back("verbose"));

    // コマンドラインを取得する
    get_cmdline: MockProcess -> String;
    get_cmdline = |process| process.@args.to_iter.join(" ");
}

// プロセスの判定条件
// (何番目に実行されたか, プロセス) -> 判定条件を満たすなら true
type MockProcessMatcher = (I64, MockProcess) -> Bool; 

namespace MockProcessMatcher {
    // n番目に実行されたかどうか
    match_nth: I64 -> MockProcessMatcher;
    match_nth = |n| (
        |(index, process)| index == n
    );
    // コマンドラインが指定文字列に等しいかどうか
    match_cmdline: String -> MockProcessMatcher;
    match_cmdline = |cmdline| (
        |(index, process)| process.get_cmdline == cmdline
    );
}

// プロセスの実行結果。ok(stdout, stderr) または err(errmsg)
type MockProcessResult = Result ErrMsg (String, String);

// プロセスに対するアクション。プロセスの判定条件と実行結果。
type MockProcessAction = (MockProcessMatcher, MockProcessResult);

namespace MockProcessAction {
    // 判定条件を満たしたら標準出力に出力する
    then_print: String -> MockProcessMatcher -> MockProcessAction;
    then_print = |stdout, matcher| (matcher, ok $ (stdout, ""));

    // 判定条件を満たしたらエラーを通知する
    then_err: ErrMsg -> MockProcessMatcher -> MockProcessAction;
    then_err = |errmsg, matcher| (matcher, err $ errmsg);
}

//  モックのプロセス実行器
type MockProcessRunner = unbox struct {
    // プロセスが実行されたときにどのような結果を返すべきかを決めるリスト
    actions: Array MockProcessAction,
    // 実際に実行されたプロセスのリスト
    processes: Array MockProcess,
};

impl MockProcessRunner: Eq {
    eq = |a, b| (
        a.@processes == b.@processes
    );
}

impl MockProcessRunner: ToString {
    to_string = |runner| (
        "MockProcessRunner {"
        + " processes=" + runner.@processes.to_string
        + " }"
    );
}

namespace MockProcessRunner {
    empty: MockProcessRunner;
    empty = MockProcessRunner {
        actions: [],
        processes: [],
    };

    add_action: MockProcessAction -> MockProcessRunner -> MockProcessRunner;
    add_action = |action| mod_actions(push_back(action));

    find_action: I64 -> MockProcess -> MockProcessRunner -> Option (Result ErrMsg (String, String));
    find_action = |index, process, runner| (
        runner.@actions.to_iter.loop_iter(
            none(), |action, opt|
            let (matcher, res) = action;
            if matcher((index, process)) {
                break $ some $ res
            };
            continue $ none()
        )
    );

    next_stdout: String -> MockProcessRunner -> MockProcessRunner;
    next_stdout = |stdout| (
        let action = match_nth(0).then_print(stdout);
        add_action(action)
    );

    run: Array String -> Array String -> MockProcessRunner -> (MockProcessRunner, MockProcessResult);
    run = |args, options, runner| (
        // Record the process
        let process = MockProcess::empty.set_args(args).set_options(options);
        let index = runner.@processes.get_size;
        let runner = runner.mod_processes(push_back(process));
        let res = runner.find_action(index, process).as_some_or(ok $ ("", ""));
        (runner, res)
    );
}
