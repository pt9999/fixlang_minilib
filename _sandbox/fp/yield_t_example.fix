module Main;

import Minilib.Monad.YieldT;
import Minilib.Monad.Iden;
import Minilib.Monad.State;
import Minilib.Monad.IO;
import Minilib.Monad.Trans;
import Minilib.Trait.Traversable;

// 単純に Writer でもいい気がする
// YieldT は Writer よりは軽快

split_with_semicolon: IOHandle -> String -> YieldT String IOFail ();
split_with_semicolon = |handle, buf| (
    let pos = buf.find(";", 0);
    if pos.is_some { 
        let pos = pos.as_some;
        let line = buf.get_sub(0, pos + 1);
        let buf = buf.get_sub(pos + 1, buf.get_size);
        yield(line);;
        split_with_semicolon(handle, buf)   // tail-recursive
    };
    if *is_eof(handle).lift_io {
        yield(buf);;
        pure $ ()
    };
    let line = *read_line(handle).lift_iofail;
    let line = line.strip_spaces;
    let buf = buf + line;
    split_with_semicolon(handle, buf)   // tail-recursive
);

drop : [i: Iterator] I64 -> i -> i;
drop = |n, iter| (
    if n <= 0 { iter };
    match iter.advance {
        none() => iter,
        some((next, a)) => next.drop(n-1)
    }
);

test_split_with_semicolon: IO ();
test_split_with_semicolon = (
    println("=== test_split_with_semicolon ===");;
    do {
        let filepath = "yield_t_test.fix";
        with_file(filepath, "r", |handle| 
            let y = split_with_semicolon(handle, "");
            let (arr, res) = *y.collect_yield_t;
            arr.to_iter.drop(20).take(10).foreach_m(println).lift
        )
    }.try(eprintln)
);

yield_t_array: I64 -> YieldT I64 Array ();
yield_t_array = |i| (
    yield(i);;
    let j = *[ 2*i, 2*i + 1 ].lift_t;
    yield_t_array(j)
);

test_yield_t_array: IO ();
test_yield_t_array = (
    println("=== test_yield_t_array ===");;
    let y = yield_t_array(1);
    let arr: Array (Array I64) = y.take_array_t(5).map(Tuple2::@0);
    println(arr.to_string)
);

main: IO () = (
    test_split_with_semicolon;;
    test_yield_t_array;;
    pure()
);

