// Wavefront obj file format
//
// You can see obj file with a 3D viewer such as
// [Online3DViewer](https://github.com/kovacsv/Online3DViewer).
module Main;

import Minilib.Monad.FunctorM;

type Vec3 = Array F64;
type Vertex = Vec3;

namespace Vertex {
    scale: Vec3 -> Vertex -> Vertex;
    scale = |s, v| (
        s.to_iter.zip(v.to_iter).map(|(a,b)| a * b).to_array
    );

    translate: Vec3 -> Vertex -> Vertex;
    translate = |t, v| (
        t.to_iter.zip(v.to_iter).map(|(a,b)| a + b).to_array
    );
}

// 0-based index
type Face = Array I64;

type Object = unbox struct {
    vertices: Array Vertex,
    faces: Array Face
};

namespace Object {
    empty: Object;
    empty = (
        Object { vertices: [], faces: [] }
    );

    make: Array Vertex -> Array Face -> Object;
    make = |vertices, faces| (
        Object { vertices: vertices, faces: faces }
    );

    write_file: Path -> Object -> IOFail ();
    write_file = |file_path, obj| (
        let _ = *eprintln("writing file: " + file_path.to_string).lift;
        with_file(file_path, "w", |fh|
            let _ = *obj.@vertices.foreach_m(|v|
                write_string(fh, "v " + v.to_iter.map(to_string).join(" ") + "\n")
            );
            let _ = *obj.@faces.foreach_m(|f|
                write_string(fh, "f " + f.to_iter.map(add(1)).map(to_string).join(" ") + "\n")
            );
            pure()
        )
    );

    scale: Vec3 -> Object -> Object;
    scale = |s, obj| (
        obj.mod_vertices(map(scale(s)))
    );

    translate: Vec3 -> Object -> Object;
    translate = |t, obj| (
        obj.mod_vertices(map(translate(t)))
    );

    append: Object -> Object -> Object;
    append = |obj2, obj1| (
        let nv = obj1.@vertices.get_size;
        obj1.mod_vertices(append(obj2.@vertices))
        .mod_faces(append(obj2.@faces.map(map(add(nv)))))
    );

    appendF: Object -> Object -> Object;
    appendF = |obj1, obj2| (
        obj1.append(obj2)
    );
}

cube: Object;
cube = (
    let vertices = Iterator::range(0, 8).map(|i|
        let x = (i % 2) * 2 - 1;
        let y = ((i / 2) % 2) * 2 - 1;
        let z = ((i / 4) % 2) * 2 - 1;
        [x, y, z].map(to_F64)
    ).to_array;
    let faces = [
        [0, 1, 3, 2],
        [1, 5, 7, 3],
        [5, 4, 6, 7],
        [4, 0, 2, 6],
        [0, 4, 5, 1],
        [2, 3, 7, 6]
    ];
    Object::make(vertices, faces)
);

frame: Object;
frame = (
    let w = 0.05;
    let bars = [
        cube.scale([1.0, w, w]),
        cube.scale([w, 1.0, w]),
        cube.scale([w, w, 1.0])
    ];
    let iter = do {
        let axis = *Iterator::range(0, 3);
        let off1 = *Iterator::range(0, 2).map(|i| (i * 2 - 1).to_F64);
        let off2 = *Iterator::range(0, 2).map(|i| (i * 2 - 1).to_F64);
        let bar = bars.@(axis);
        let trans = [0.0, 0.0, 0.0];
        let trans = trans.set((axis+1)%3, off1);
        let trans = trans.set((axis+2)%3, off2);
        pure $ bar.translate(trans)
    };
    iter.fold(Object::empty, Object::append)
);

frame2: Object;
frame2 = (
    let w = 0.05;
    let bars = [
        cube.scale([1.0, w, w]),
        cube.scale([w, 1.0, w]),
        cube.scale([w, w, 1.0])
    ];
    let iter = do {
        let dir = *Iterator::range(0, 2);
        let axis = *Iterator::range(0, 3);
        let ibar = *Iterator::range(0, 3);
        if axis == ibar { Iterator::empty };
        let bar = bars.@(ibar);
        let trans = [0.0, 0.0, 0.0];
        let trans = trans.set(axis, dir.to_F64 - 0.5);
        pure $ bar.translate(trans)
    };
    iter.fold(Object::empty, Object::append)
);

main: IO ();
main = (
    let obj = frame;
    do {
        obj.write_file("tmp.obj".parse.as_some)
    }
    .try(eprintln)
);
