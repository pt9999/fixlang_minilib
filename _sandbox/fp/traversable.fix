module Minilib.Trait.Traversable;

import Minilib.Trait.Applicative;

trait [t: * -> *] t: Traversable {
    sequence_a: [f: Applicative] t (f a) -> f (t a);
    sequence: [m: Monad] t (m a) -> m (t a);
}

traverse: [f: Applicative, t: Traversable, t: Functor] (a -> f b) -> t a -> f (t b);
traverse = |f, ta| ta.map(f).sequence_a;

map_m: [m: Monad, t: Traversable, t: Functor] (a -> m b) -> t a -> m (t b);
map_m = |f, ta| ta.map(f).sequence;

foreach_m: [m: Monad, t: Traversable, t: Functor] (a -> m ()) -> t a -> m ();
foreach_m = |f, ta| ta.map(f).sequence.forget;

impl Array: Traversable {
    sequence_a = |array| (
        array.to_iter.fold(
            pure_a(Array::empty(array.get_size)), |output, a|
            lift_a2(push_back, a, output)
        )
    );
    sequence = |array| (
        array.to_iter.fold_m(
            Array::empty(array.get_size), |output, a|
            pure $ output.push_back(*a)
        )
    );
}

impl Iterator: Traversable {
    sequence_a = |iter| (
        iter.fold(
            pure_a([]), |output, a|
            lift_a2(push_back, a, output)
        ).app(pure_a(to_iter))
    );
    sequence = |iter| (
        iter.fold_m(
            [], |output, a|
            pure $ output.push_back(a)
        ).bind(to_iter >> pure)
    );
}
