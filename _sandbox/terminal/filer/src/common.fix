module Filer.Common;

import Minilib.Monad.State;
import Minilib.Terminal.Ncurses;
import Minilib.Text.StringEx;
//import Minilib.Text.Unicode;

type StateIOF s = StateT s IOFail;

select_state: [m: Monad] (s -> a) -> StateT s m a;
select_state = |selector| get_state.map(selector);

namespace StringUtils {
    // pads to the right and truncate to prefix
    xpad_right: I64 -> U8 -> String -> String;
    xpad_right = |result_size, char, str| (
        let str_size = str.get_size;
        if str_size >= result_size {
            str.get_sub(0, result_size)
        };
        let xpad_size = result_size - str_size;
        let pad = Array::fill(xpad_size, char)._unsafe_to_string;
        str + pad
    );

    // pads to the left and truncate to suffix
    xpad_left: I64 -> U8 -> String -> String;
    xpad_left = |result_size, char, str| (
        let str_size = str.get_size;
        if str_size >= result_size {
            str.get_sub(str_size - result_size, str_size)
        };
        let xpad_size = result_size - str_size;
        let pad = Array::fill(xpad_size, char)._unsafe_to_string;
        pad + str
    );

    ellipsis: I64 -> String -> String;
    ellipsis = |result_size, str| (
        let str_size = str.get_size;
        let result_size = max(0, result_size);
        if str_size <= result_size { str };
        if result_size < 3 { str.get_sub(0, result_size) };
        "..." + str.get_sub(str_size - (result_size - 3), str_size)
    );
}

/*

// TODO: implement ellipsis for UTFString

namespace UTF32StringUtils {
    ellipsis: I64 -> UTF32String -> UTF32String;
    ellipsis = |result_width, wstr| (
        let result_width = max(0, result_width);
        let wstr_width = wstr.get_width;
        if wstr_width <= result_width { wstr };
        // TODO: calculate substring considering full-width/half-width
        if result_width < 3 { str.get_sub(0, result_size) };
        "...".to_utf32_string + str.get_sub(str_size - (result_size - 3), str_size)
    );
}
*/

namespace CustomColorPair {
    cp_selected: ColorPair;
    cp_selected = 10;

    init: IOFail ();
    init = (
        pure();;    // make it lazy
        init_color_pair(cp_selected, white, blue);;
        pure()
    );
}

type ListViewId = I64;

type ListItem = unbox struct {
    text: String,
    attr: ChType
};

type Action = unbox union {
    no_action: (),
    action_quit: (),
    action_help: (),
    action_next_focus: (),
    action_select_prev_item: ListViewId,
    action_select_next_item: ListViewId,
    action_page_up: ListViewId,
    action_page_down: ListViewId,
    action_open_file: (),
    action_up_directory: (),
    action_update_file_items: (),
};

type AppEnv = unbox struct {
    disk_usage: DiskUsageServiceApi,
    shutdown: IOFail (),
};

// The disk usage service, defined in `Filer.DiskUsage`
type DiskUsageServiceApi = unbox struct {
    // returns `(size, active)`
    get_dir_size: Path -> IOFail (I64, I64),
    drain_errors: IOFail (Array String),
    shutdown: IOFail (),
};
