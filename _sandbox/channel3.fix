module Main;

import AsyncTask;
import Random;

import Minilib.Collection.Deque;
import Minilib.Text.StringEx;

namespace Channel {
    _ErrShutdown: ErrMsg;
    _ErrShutdown = "Shutdown";

    type ChannelData a = unbox struct {
        deque: Deque a,
        shutdown: Bool
    };

    type Channel a = unbox struct {
        var: Var (ChannelData a)
    };

    make: I64 -> IO (Channel a);
    make = |size| (
        let chan_data = ChannelData {
            deque: Deque::empty(size),
            shutdown: false
        };
        let var = *Var::make(chan_data);
        pure $ Channel { var: var }
    );

    shutdown: Channel a -> IO ();
    shutdown = |chan| (
        chan.@var.mod(set_shutdown(true))
    );

    is_shutdown: Channel a -> IO Bool;
    is_shutdown = |chan| (
        let data = *chan.@var.get;
        pure $ data.@shutdown
    );

    is_empty: Channel a -> IO Bool;
    is_empty = |chan| (
        let data = *chan.@var.get;
        pure $ data.@deque.is_empty
    );

    send: a -> Channel a -> IOFail ();
    send = |a, chan| (
        chan.@var.lock(
            |data|
            if data.@shutdown {
                pure $ err $ _ErrShutdown
            };
            let data = data.mod_deque(push_back(a));
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ ()
        ).lift.bind(from_result)
    );

    recv: Channel a -> IOFail a;
    recv = |chan| (
        chan.@var.wait_and_lock(
            |data| data.@shutdown || !data.@deque.is_empty,
            |data|
            if data.@shutdown {
                pure $ err $ _ErrShutdown
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ a
        ).lift.bind(from_result)
    );

    try_recv: Channel a -> IOFail (Option a);
    try_recv = |chan| (
        chan.@var.lock(
            |data|
            if data.@shutdown {
                pure $ err $ _ErrShutdown
            };
            if data.@deque.is_empty {
                pure $ ok $ none()
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ some(a)
        ).lift.bind(from_result)
    );
}

impl Var a: Eq {
    eq = |var1, var2| (
        var1.@_dtor.borrow(|handle1|
            var2.@_dtor.borrow(|handle2|
                handle1 == handle2
            )
        )
    );
}

impl Channel a: Eq {
    eq = |chan1, chan2| (
        chan1.@var == chan2.@var
    );
}

namespace Topic {
    type Topic a = unbox struct {
        subscribers: Iterator (Channel a)
    };

    empty: Topic a;
    empty = Topic {
        subscribers: []
    };

    subscribe: Channel a -> Topic a -> Topic a;
    subscribe = |chan, topic| (
        topic.mod_subscribers(push_front(chan))
    );
    
    unsubscribe: Channel a -> Topic a -> Topic a;
    unsubscribe = |chan, topic| (
        topic.mod_subscribers(filter(|ch| ch != chan))
    );

    notify: a -> Topic a -> IO ();
    notify = |value, topic| (
        topic.@subscribers.fold_m(
            (), |_, chan|
            chan.send(value)
        )
    );
}

map_m: [m : Monad] (a -> m b) -> Array a -> m (Array b);
map_m = |f, array| array.to_iter.fold_m(
    Array::empty(array.get_size), |output, a|
    let b = *f(a);
    pure $ output.push_back(b)
);

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);


test1: IO ();
test1 = (
    let _ = *pure();
    let rand_var = *Var::make(Random::init_by_seed(123_U64));
    let sleep_random: IO () = (
        let u64 = *rand_var.lock(|rand|
            let (u64, rand) = rand.generate_U64;
            let _ = *rand_var.Var::set(rand);
            pure $ u64
        );
        eval _usleep((u64 % 100000_U64).to_I64);
        pure()
    );
    let n = 20;
    let indices = Iterator::range(0, n).to_array;
    let channels = *indices.map_m(|_| Channel::make(4));
    let channel_result = *Channel::make(4);
    let task_func = |idx| (
        let _ = *eprintln(idx.to_string + ": 1st send to " + idx.to_string).lift;
        let _ = *channels.@(idx).send(idx);
        let _ = *sleep_random.lift;
        let _ = *eprintln(idx.to_string + ": 1st recv from " + ((idx+n/3)%n).to_string).lift;
        let val = *channels.@((idx+n/3)%n).recv;
        let _ = *sleep_random.lift;
        let _ = *eprintln(idx.to_string + ": 2nd send to " + idx.to_string).lift;
        let _ = *channels.@(idx).send(val);
        let _ = *sleep_random.lift;
        let _ = *eprintln(idx.to_string + ": 2nd recv from " + ((idx+n*2/3)%n).to_string).lift;
        let val = *channels.@((idx+n*2/3)%n).recv;
        let _ = *sleep_random.lift;
        let _ = *eprintln(idx.to_string + ": final send to " + idx.to_string).lift;
        let _ = *channel_result.send((idx,val));
        pure()
    );
    let tasks = *indices.map_m(
        |idx|
        AsyncIOTask::make(
            task_func(idx)
            .try(eprintln)
        )
    );
    do {
        let (idx, val) = *channel_result.recv;
        let _ = *tasks.map_m(get).lift;
        let _ = *eprintln("idx=" + idx.to_string + " val="+val.to_string).lift;
        loop_m(
            (), |_|
            let opt = *channel_result.try_recv;
            if opt.is_none { break_m $ () };
            let (idx, val) = opt.as_some;
            let _ = *eprintln("rest idx=" + idx.to_string + " val="+val.to_string).lift;
            continue_m $ ()
        )
    }
    .try(eprintln)
);

main: IO ();
main = test1;
