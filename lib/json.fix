module Json;

import HashMap;
//import SimpleParser;

type Json = box union {
    null: (),
    bool: Bool,
    number: F64,
    string: String,
    object: HashMap String Json,
    array:  Array Json
};

to_object: Array (String, Json) -> Json;
to_object = |arr| (
    let hashmap = arr.to_iter.fold(
        HashMap::empty(arr.get_size),
        |h, (k, v)| h.insert(k, v)
    );
    object $ hashmap
);

type EncodeParam = unbox struct {
    space: String,
    newline: String,
    indent: String,
    indent_incr: String
};

namespace EncodeParam {
    empty: EncodeParam;
    empty = EncodeParam {
        space: "",
        newline: "",
        indent: "",
        indent_incr: ""
    };
    
    pretty_print: EncodeParam;
    pretty_print = EncodeParam {
        space: " ",
        newline: "\n",
        indent: "",
        indent_incr: "  "
    };

    increment_indent: EncodeParam -> EncodeParam;
    increment_indent = |param| (
        param.set_indent(
            param.@indent +
            param.@indent_incr
        )
    );

    _indent_str: I64 -> String;
    _indent_str = |n| (
        Array::fill(n, " ").to_iter.concat_iter
    );

}

_DOUBLEQUOTE: U8;
_DOUBLEQUOTE = 34_U8; // '\"'

_BACKSLASH: U8;
_BACKSLASH = 92_U8; // '\\'

_ASCII_LOWER_U: U8;
_ASCII_LOWER_U = 117_U8; // 'u'


_escape_from: Array U8;
_escape_from = "\"\\\u0008\u000c\n\r\t".get_bytes.pop_back;

_escape_to: Array U8;
_escape_to = "\"\\bfnrt".get_bytes.pop_back;

_escape_table: Array U8;
_escape_table = (
    Iterator::count_up(0).take(256)
    .map(|i| 
        _escape_from.find_by(|x| x == i.to_U8)
        .map_or(0_U8,
            |pos| _escape_to.@(pos)
        )
    )
    .to_array
);

_hex_table: Array U8;
_hex_table = (
    Iterator::count_up(0).take(16)
    .map(|i|
        if i < 10 { /* '0' = */ 48_U8 + i.to_U8 } 
        else { /* 'a' = */ 97_U8 + (i - 10).to_U8 }
    )
    .to_array
);

_encode_string: String -> String;
_encode_string = |str| (
    let input: Array U8 = str.get_bytes.pop_back;
    let input_size = input.get_size;
    let output: Array U8 = Array::empty(input_size * 2);
    let output = output.push_back(_DOUBLEQUOTE);
    let output = loop (
        (0, output), |(i, output)| 
        if i >= input_size {
            break $ output
        };
        let c = input.@(i);
        let output = do {
            let escape_char = _escape_table.@(c.to_I64);
            if escape_char != 0_U8 {
                output.push_back(_BACKSLASH).push_back(escape_char)
            };
            if c <= 31_U8 {
                output.push_back(_BACKSLASH).push_back(_ASCII_LOWER_U)
                .push_back(_hex_table.@(0))
                .push_back(_hex_table.@(0))
                .push_back(_hex_table.@(c.to_I64.shift_right(4)))
                .push_back(_hex_table.@(c.to_I64.bit_and(15)))
            };
            output.push_back(c)
        };
        continue $ (i + 1, output)
    );
    let output = output.push_back(_DOUBLEQUOTE);
    _unsafe_from_c_str(output.push_back(0_U8))
);

_string_less_than: (String, String) -> Bool;
_string_less_than = |(str1, str2)| (
    let a1 = str1.get_bytes;
    let a2 = str2.get_bytes;
    let n1 = a1.get_size;
    let n2 = a2.get_size;
    loop(0, |i|
        if i >= n1 && i >= n2 {
            break $ false
        };
        if i >= n1 {
            break $ true
        };
        if i >= n2 {
            break $ false
        };
        let c1 = a1.@(i);
        let c2 = a2.@(i);
        if c1 < c2 {
            break $ true
        };
        if c1 > c2 {
            break $ false
        };
        continue $ i + 1
    )
);


_encode_object: EncodeParam -> Array String -> HashMap String Json -> Array String;
_encode_object = |param, output, hashmap| (
    let array = hashmap.to_iter.to_array;
    let array = array.sort_by(
        |((k1,v1), (k2,v2))| _string_less_than $ (k1, k2));
    let array_size = array.get_size;
    if array_size == 0 {
        output.push_back ("{}")
    };
    let output = output
        .push_back("{")
        .push_back(param.@newline);
    let param_inner = param.increment_indent;
    let output = loop (
        (0, output), |(i, output)|
        if i >= array_size {
            break $ output
        };
        let (k, v) = array.@(i);
        let output = output
            .push_back(param_inner.@indent)
            .push_back(k._encode_string)
            .push_back(":")
            .push_back(param_inner.@space);
        let output = v._encode(param_inner, output);
        let output = if i < array_size - 1 { output.push_back (",") } else { output };
        let output = output.push_back (param.@newline);
        continue $ (i + 1, output)
    );
    let output = output
            .push_back(param.@indent)
            .push_back("}");
    output
);

_encode_array: EncodeParam -> Array String -> Array Json -> Array String;
_encode_array = |param, output, array| (
    let array_size = array.get_size;
    if array_size == 0 {
        output.push_back("[]")
    };
    let output = output
        .push_back("[")
        .push_back(param.@newline);
    let param_inner = param.increment_indent;
    let output = loop (
        (0, output), |(i, output)|
        if i >= array_size {
            break $ output
        };
        let item = array.@(i);
        let output = output
            .push_back(param_inner.@indent);
        let output = item._encode(param_inner, output);
        let output = output
            .push_back(if i < array_size - 1 { "," } else { "" })
            .push_back(param_inner.@newline);
        continue $ (i + 1, output)
    );
    let output = output
            .push_back(param.@indent)
            .push_back("]");
    output
);

_encode: EncodeParam -> Array String -> Json -> Array String;
_encode = |param, output, json| (
    if json.is_null {
        output.push_back ("null")
    };
    if json.is_bool {
        output.push_back (if json.as_bool { "true" } else { "false" })
    };
    if json.is_number {
        output.push_back (json.as_number.to_string)
    };
    if json.is_string {
        output.push_back (json.as_string._encode_string)
    };
    if json.is_object {
        json.as_object._encode_object(param, output)
    };
    if json.is_array {
        json.as_array._encode_array(param, output)
    };
    output // abort?
);

encode_with_param: EncodeParam -> Json -> String;
encode_with_param = |param, json| (
    let output = Array::empty(1000);
    let output = _encode(param, output, json);
    output.to_iter.concat_iter
);

encode: Json -> String;
encode = |json| (
    encode_with_param(EncodeParam::empty, json)
);

encode_pretty: Json -> String;
encode_pretty = |json| (
    encode_with_param(EncodeParam::pretty_print, json)
);

decode: String -> Result ErrMsg Json;
decode = |str| err $ "";
