module Minilib.IO.Uv;

import Minilib.Monad.IO;

log_debug: String -> ();
log_debug = |str| debug_eprintln("\u001b[035m[Minilib.IO.Uv]\u001b[m " + str);
//log_debug = |str| ();

//-----------------------------------------------------------------
// MonadBorrow
//-----------------------------------------------------------------

trait MonadBorrow = Monad + MonadBorrowIF;

trait [m: * -> *] m: MonadBorrowIF {
    borrow_boxed_m: [a: Boxed] (Ptr -> m b) -> a -> m b;
    borrow_m: (a -> m b) -> Destructor a -> m b;
    borrow_c_str_m: (Ptr -> m b) -> String -> m b;
}

/*
impl Iden: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed(f >> Iden::get) >> Iden::make;
    borrow_m = |f| borrow(f >> Iden::get) >> Iden::make;
    borrow_c_str_m = |f| borrow_c_str(f >> Iden::get) >> Iden::make;
}
*/

impl IO: MonadBorrowIF {
    borrow_boxed_m = borrow_boxed_io;
    borrow_m = borrow_io;
    borrow_c_str_m = borrow_c_str_io;
}

impl IOFail: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed_io(f >> to_result) >> from_io_result;
    borrow_m = |f| borrow_io(f >> to_result) >> from_io_result;
    borrow_c_str_m =  |f| borrow_c_str_io(f >> to_result) >> from_io_result;
}

//-----------------------------------------------------------------
// FromPtr, BorrowPtrM
//-----------------------------------------------------------------

trait a: FromPtr {
    from_ptr: [m: MonadIO] Ptr -> m a;
}

trait a: BorrowPtrM {
    borrow_ptr_m: [m: MonadBorrow] (Ptr -> m b) -> a -> m b;
}

//-----------------------------------------------------------------
// UvPtrWithOwnership
//-----------------------------------------------------------------

type UvPtrWithOwnership = unbox union {
    owned: Destructor Ptr,
    borrowed: Ptr,
};

namespace UvPtrWithOwnership {
    make_owned: Ptr -> (Ptr -> IO Ptr) -> IO UvPtrWithOwnership;
    make_owned = |ptr, dtor| (
        pure $ owned $ *Destructor::make(ptr, dtor)
    );

    make_borrowed: Ptr -> UvPtrWithOwnership;
    make_borrowed = borrowed;
}

impl UvPtrWithOwnership: BorrowPtrM {
    borrow_ptr_m = |f, wrapped_ptr| (
        match wrapped_ptr {
            owned(dtor) => dtor.borrow_m(f),
            borrowed(ptr) => f(ptr),
        }
    );
}

//-----------------------------------------------------------------
// Error Handling
//-----------------------------------------------------------------

namespace Uv {
    strerror: CInt -> String;
    strerror = |err| (
        let buflen = 65536;
        let buf = Array::fill(buflen, 0_U8);
        let (buf, ()) = buf.mutate_boxed(|buf|
            FFI_CALL_IO[() uv_strerror_r(CInt, Ptr, CSizeT), err, buf, buflen.to_CSizeT]
        );
        let errmsg: String = buf.push_back(0_U8).from_bytes.as_ok;
        errmsg
    );

    eof: CInt;
    eof = FFI_CALL[CInt minilib_uv_get_uv_eof()];
}

_check_err_i: IO CInt -> IOFail CInt;
_check_err_i = |io| (
    let err = *io.lift;
    if err >= 0.to_CInt {
        pure $ err
    };
    throw $ Uv::strerror(err)
);

_check_err: IO CInt -> IOFail ();
_check_err = |io| (
    let err = *io._check_err_i;
    pure()
);

//-----------------------------------------------------------------
// UvLoop
//-----------------------------------------------------------------

type UvLoop = unbox struct {
    wptr: UvPtrWithOwnership
};

namespace UvLoop {
    make: IOFail UvLoop;
    make = (
        let ptr = *FFI_CALL_IO[Ptr minilib_uv_loop_init()].lift;
        if ptr == nullptr { throw $ "uv_loop_init failed!" };
        pure $ UvLoop {
            wptr: *UvPtrWithOwnership::make_owned(ptr, |ptr|
                FFI_CALL_IO[() minilib_uv_loop_close(Ptr), ptr].when(ptr != nullptr);;
                pure $ nullptr
            ).lift
        }
    );

    default: UvLoop;
    default = (
        UvLoop {
            wptr: UvPtrWithOwnership::make_borrowed $
                FFI_CALL[Ptr uv_default_loop()]
        }
    );

    run_default: UvLoop -> IOFail ();
    run_default = |loop| (
        loop.borrow_ptr_m(|p_loop|
            _check_err $ FFI_CALL_IO[CInt minilib_uv_loop_run_default(Ptr), p_loop]
        )
    );
}

impl UvLoop: BorrowPtrM {
    borrow_ptr_m = |f, loop| loop.@wptr.borrow_ptr_m(f);
}

//-----------------------------------------------------------------
// UvHandle
//-----------------------------------------------------------------

// t はハンドルの種類を表す任意のタグ。(Phantom type)
type UvHandle t = unbox struct {
    dtor: Destructor Ptr
};

impl UvHandle t: FromPtr {
    from_ptr = |p_handle| lift_io $ do {
        FFI_CALL_IO[() minilib_uv_handle_retain(Ptr), p_handle];;
        pure $ UvHandle {
            dtor: *Destructor::make(p_handle, |p_handle|
                FFI_CALL_IO[() minilib_uv_handle_release(Ptr), p_handle];;
                pure $ nullptr
            )
        }
    };
}

impl UvHandle t: BorrowPtrM {
    borrow_ptr_m = |f, handle| handle.@dtor.borrow_m(f);
}

namespace UvHandle {
    close: [m: MonadIO] UvHandle t -> m ();
    close = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            FFI_CALL_IO[() minilib_uv_handle_close(Ptr), p_handle]
        )
    };
    
    // ユーザが用意したコールバック関数を設定する。型を正しく合わせる必要がある。
    set_user_callback: [m: MonadIO] cb -> UvHandle t -> m ();
    set_user_callback = |cb, handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            let box_cb: Box cb = Box::make(cb);
            let p_cb: Ptr = *box_cb.boxed_to_retained_ptr;
            eval log_debug("UvHandle::set_user_callback: p_cb=" + p_cb.to_string);
            FFI_CALL_IO[() minilib_uv_handle_set_fix_cb(Ptr, Ptr), p_handle, p_cb]
        )
    };

    // ユーザが用意したコールバック関数を取得する。型を正しく合わせる必要がある。
    get_user_callback: [m: MonadIO] UvHandle t -> m cb;
    get_user_callback = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            let p_cb = *FFI_CALL_IO[Ptr minilib_uv_handle_get_fix_cb(Ptr), p_handle];
            eval log_debug("UvHandle::get_user_callback: p_cb=" + p_cb.to_string);
            let box_cb: Box cb = *p_cb.boxed_from_retained_ptr;
            pure $ box_cb.@value
        )
    };
}

//-----------------------------------------------------------------
// UvReq
//-----------------------------------------------------------------

// リクエスト(uv_req_t)を表す型。
// t はリクエストの種類を表す任意のタグ。(Phantom type)
type UvReq t = unbox struct {
    dtor: Destructor Ptr
};

impl UvReq t: FromPtr {
    from_ptr = |p_req| lift_io $ do {
        FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req];;
        pure $ UvReq {
            dtor: *Destructor::make(p_req, |p_req|
                FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req];;
                pure $ nullptr
            )
        }
    };
}

impl UvReq t: BorrowPtrM {
    borrow_ptr_m = |f, req| req.@dtor.borrow_m(f);
}

namespace UvReq {
    // uv_req_t* の参照カウンタを1増加する。
    retain: [m: MonadIO] UvReq t -> m ();
    retain = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req])
    };

    // uv_req_t* の参照カウンタを1減少する。参照カウンタが0になったら解放される。
    release: [m: MonadIO] UvReq t -> m ();
    release = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req])
    };

    // ユーザが用意したコールバック関数を設定する。型を正しく合わせる必要がある。
    set_user_callback: [m: MonadIO] cb -> UvReq t -> m ();
    set_user_callback = |cb, req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            let box_cb: Box cb = Box::make(cb);
            let p_cb: Ptr = *box_cb.boxed_to_retained_ptr;
            eval log_debug("UvReq::set_user_callback: p_cb=" + p_cb.to_string);
            FFI_CALL_IO[() minilib_uv_req_set_fix_cb(Ptr, Ptr), p_req, p_cb]
        )
    };

    // ユーザが用意したコールバック関数を取得する。型を正しく合わせる必要がある。
    get_user_callback: [m: MonadIO] UvReq t -> m cb;
    get_user_callback = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            let p_cb = *FFI_CALL_IO[Ptr minilib_uv_req_get_fix_cb(Ptr), p_req];
            eval log_debug("UvReq::get_user_callback: p_cb=" + p_cb.to_string);
            let box_cb: Box cb = *p_cb.boxed_from_retained_ptr;
            pure $ box_cb.@value
        )
    };

    // 追加データを設定する。
    set_extra_data: [m: MonadIO] Ptr -> UvReq t -> m ();
    set_extra_data = |extra_data, req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            FFI_CALL_IO[() minilib_uv_req_set_extra_data(Ptr, Ptr), p_req, extra_data]
        )
    };

    // 追加データを取得する。
    get_extra_data: [m: MonadIO] UvReq t -> m Ptr;
    get_extra_data = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            FFI_CALL_IO[Ptr minilib_uv_req_get_extra_data(Ptr), p_req]
        )
    };
}

//-----------------------------------------------------------------
// UvFile
//-----------------------------------------------------------------

// ファイルディスクリプタ(uv_file)を表す型。
type UvFile = CInt;

namespace UvFile {
    // 標準入力
    stdin: UvFile = 0.to_CInt;
    // 標準出力
    stdout: UvFile = 1.to_CInt;
    // 標準エラー出力
    stderr: UvFile = 2.to_CInt;
}

//-----------------------------------------------------------------
// UvStream
//-----------------------------------------------------------------

type UvStreamTag = unbox struct {};
trait tag: IsUvStreamTag {}
impl UvStreamTag: IsUvStreamTag {}

type UvStream = UvHandle UvStreamTag;

namespace UvStream {
    // read のコールバック
    // # Parameters
    // * stream: ストリーム(uv_stream_t*)
    // * nread: 読み込んだバイト数。0未満ならエラー。ただし Uv::eof の場合は EOFを表す。
    // * bytes: 読み込んだデータ
    type UvReadCallback = UvStream -> I64 -> Array U8 -> IO ();

    read_start: [t: IsUvStreamTag] UvReadCallback -> UvHandle t -> IOFail ();
    read_start = |cb, stream| (
        stream.borrow_ptr_m(|p_stream|
            let ret = *FFI_CALL_IO[CInt minilib_uv_is_read_started(Ptr), p_stream].lift;
            if ret != 0.to_CInt {
                throw $ "reading already started"
            };
            stream.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する(retain)
            FFI_CALL_IO[CInt minilib_uv_read_start(Ptr), p_stream]
            ._check_err
        )
    );
    minilib_uv_read_callback : Ptr -> I64 -> Ptr -> ();
    minilib_uv_read_callback = |p_stream, nread, p_buf| (
        eval log_debug("minilib_uv_read_callback: p_stream=" + p_stream.to_string);
        let stream: UvStream = *from_ptr(p_stream);
        let cb: UvReadCallback = *stream.get_user_callback;     // ユーザが用意したコールバック関数を取得する(release)
        stream.set_user_callback(cb);;     // ユーザが用意したコールバック関数を設定する(retain)
        let bytes = *if nread <= 0 { pure $ [] }
        else {
            let bytes = Array::fill(nread, 0_U8);
            let (bytes, ()) = *bytes.mutate_boxed_io(|p_bytes|
                FFI_CALL_IO[() memcpy(Ptr, Ptr, CSizeT), p_bytes, p_buf, nread.to_CSizeT]
            );
            pure $ bytes
        };
        cb(stream, nread, bytes)
    ).unsafe_perform;
    FFI_EXPORT[minilib_uv_read_callback, minilib_uv_read_callback];

    read_stop: [t: IsUvStreamTag] UvHandle t -> IOFail ();
    read_stop = |stream| (
        let ret = *stream.borrow_ptr_m(|p_stream|
            FFI_CALL_IO[CInt minilib_uv_is_read_started(Ptr), p_stream]
        ).lift;
        if ret == 0.to_CInt {
            pure()
        };
        let err = *stream.borrow_ptr_m(|p_stream|
            FFI_CALL_IO[CInt minilib_uv_read_stop(Ptr), p_stream]
        ).lift;
        let cb: UvReadCallback = *stream.get_user_callback.lift;     // ユーザが用意したコールバック関数を取得する(release)
        pure(err)._check_err
    );

}

//-----------------------------------------------------------------
// UvWrite
//-----------------------------------------------------------------

type UvWriteTag = unbox struct {};

type UvWrite = UvReq UvWriteTag;

namespace UvWrite {

    // write のコールバック
    // # Parameters
    // * req: リクエスト(uv_write_t*)
    // * status: ステータス。0未満ならエラー
    type UvWriteCallback = UvWrite -> CInt -> IO ();

    write: [t: IsUvStreamTag] Array U8 -> UvWriteCallback -> UvHandle t -> IOFail UvWrite;
    write = |buf, cb, stream| (
        let p_req = *FFI_CALL_IO[Ptr minilib_uv_write_init()].lift;
        let req = *from_ptr(p_req).lift;
        req.retain.lift;;    // リクエスト発生のためリテインする
        req.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する
        req.borrow_ptr_m(|p_req|
            stream.borrow_ptr_m(|p_handle|
                let bufsize = buf.get_size.to_CSizeT;
                buf.borrow_boxed_m(|p_buf|
                    FFI_CALL_IO[CInt minilib_uv_write(Ptr, Ptr, Ptr, CSizeT), p_req, p_handle, p_buf, bufsize]
                    ._check_err
                )
            )
        );;
        pure $ req
    );
    minilib_uv_write_callback : Ptr -> CInt -> ();
    minilib_uv_write_callback = |p_req, status| (
        eval log_debug("minilib_uv_write_callback: p_req=" + p_req.to_string);
        let req: UvWrite = *from_ptr(p_req);
        let cb: UvWriteCallback = *req.get_user_callback;
        cb(req, status);;
        req.release  // release on callback end
    ).unsafe_perform;
    FFI_EXPORT[minilib_uv_write_callback, minilib_uv_write_callback];

    get_stream: UvWrite -> IO UvStream;
    get_stream = |write| (
        let p_stream = *write.borrow_ptr_m(|p_write_req|
            FFI_CALL_IO[Ptr minilib_uv_write_get_stream(Ptr), p_write_req]
        );
        from_ptr(p_stream)
    );
}

//-----------------------------------------------------------------
// UvPipe
//-----------------------------------------------------------------

type UvPipeTag = unbox struct {};
impl UvPipeTag: IsUvStreamTag {}
type UvPipe = UvHandle UvPipeTag;

namespace UvPipe {
    // uv_pipe_t* を確保して初期化し、UvFsを作成する。
    init: UvLoop -> IOFail UvPipe;
    init = |loop| (
        loop.borrow_ptr_m(|p_loop|
            let p_pipe = *FFI_CALL_IO[Ptr minilib_uv_pipe_init(Ptr), p_loop].lift;
            if p_pipe == nullptr { throw $ "minilib_uv_pipe_init failed!" };
            from_ptr(p_pipe).lift
        )
    );

    // Open an existing file descriptor as a pipe.
    open: UvFile -> UvPipe -> IOFail ();
    open = |fd, pipe| (
        pipe.borrow_ptr_m(|p_pipe|
            FFI_CALL_IO[CInt minilib_uv_pipe_open(Ptr, CInt), p_pipe, fd]
            ._check_err
        )
    );
}