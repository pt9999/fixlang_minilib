module Main;

import Minilib.Encoding.Xml;
import Minilib.Testing.UnitTest;
import Minilib.Text.StringEx;

_default_xml_decl: String;
_default_xml_decl = "<?xml version='1.1' encoding='utf-8'?>";

test_xmldocument_empty: TestCase;
test_xmldocument_empty = (
    make_test("test_xmldocument_empty") $ |_|
    let doc = XmlDocument::empty;
    eval *assert_equal("xml_decl", _default_xml_decl, doc.@xml_decl.to_string);
    eval *assert_equal("prolog", [], doc.@prolog);
    eval *assert_equal("document_element", "root", doc.@document_element.@tag);
    eval *assert_equal("epilog", [], doc.@epilog);
    pure()
);

test_xmldocument_make: TestCase;
test_xmldocument_make = (
    make_test("test_xmldocument_empty") $ |_|
    let element = XmlElement::make("abc");
    let doc = XmlDocument::make(element);
    eval *assert_equal("xml_decl", _default_xml_decl, doc.@xml_decl.to_string);
    eval *assert_equal("prolog", [], doc.@prolog);
    eval *assert_equal("document_element", "abc", doc.@document_element.@tag);
    eval *assert_equal("epilog", [], doc.@epilog);
    pure()
);

// TODO: test add_to_prolog
// TODO: test add_to_epilog
// TODO: test eq

test_xmldocument_to_string: TestCase;
test_xmldocument_to_string = (
    make_test("test_xmldocument_to_string") $ |_|
    let element = XmlElement::make("abc").text("this is content");
    let doc = XmlDocument::make(element);
    let doc = doc.add_to_prolog(text_node $ XmlText::make("this is prolog"));
    let doc = doc.add_to_epilog(text_node $ XmlText::make("this is epilog"));
    let expected = "<?xml version='1.1' encoding='utf-8'?>this is prolog<abc>this is content</abc>this is epilog";
    let actual = doc.to_string;
    assert_equal("eq", expected, actual)
);


main: IO ();
main = (
    [
        test_xmldocument_empty,
        test_xmldocument_make,
        test_xmldocument_to_string,
        TestCase::empty
    ].run_test_driver
);
