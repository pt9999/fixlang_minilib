module Publisher.Tests.PublishTest;

import Minilib.Monad.State;
import Minilib.Testing.UnitTest;

import Publisher.Publish;
import Publisher.ProcessRunner;

type MockProcess = unbox struct {
    args: Array String,
    options: Array String,
};

impl MockProcess: Eq {
    eq = |a, b| (
        a.@args == b.@args &&
        a.@options == b.@options
    );
}

impl MockProcess: ToString {
    to_string = |process| (
        "MockProcess {"
        + " args=" + process.@args.to_string
        + " options=" + process.@options.to_string
        + " }"
    );
}

namespace MockProcess {
    empty: MockProcess;
    empty = MockProcess {
        args: [],
        options: [],
    };

    make: Array String -> MockProcess;
    make = |args| MockProcess::empty.set_args(args);

    verbose: MockProcess -> MockProcess;
    verbose = mod_options(push_back("verbose"));
}

type MockProcessRunner = unbox struct {
    processes: Array MockProcess,
    outputs: Array (String, String),
};

impl MockProcessRunner: Eq {
    eq = |a, b| (
        a.@processes == b.@processes &&
        a.@outputs == b.@outputs
    );
}

impl MockProcessRunner: ToString {
    to_string = |runner| (
        "MockProcessRunner {"
        + " processes=" + runner.@processes.to_string
        + " outputs=" + runner.@outputs.to_string
        + " }"
    );
}

impl MockProcessRunner: HasProcessRunner {
    get_process_runner: [m: Monad] MockProcessRunner -> Array String -> Array String -> StateT MockProcessRunner m (String, String)
    = |runner, args, options| (
        let process = MockProcess::empty.set_args(args).set_options(options);
        let index = runner.@processes.get_size;
        let outputs = runner.@outputs;
        let runner = runner.mod_processes(push_back(process));
        put_state(runner);;
        let (stdout, stderr) = if index < outputs.get_size { outputs.@(index) } else { ("", "") };
        pure $ (stdout, stderr)
    );
}

type SIO a = StateT MockProcessRunner IOFail a;

namespace MockProcessRunner {
    empty: MockProcessRunner;
    empty = MockProcessRunner {
        processes: [],
        outputs: [],
    };

    next_stdout: String -> MockProcessRunner -> MockProcessRunner;
    next_stdout = |stdout| mod_outputs(push_back((stdout, "")));

    setup: (MockProcessRunner -> MockProcessRunner) -> MockProcessRunner;
    setup = |setup_func| (
        MockProcessRunner::empty.setup_func
    );

    run: SIO a -> MockProcessRunner -> IOFail (MockProcessRunner, a);
    run = |sio, runner| (
        sio.run_state_t(runner)
    );

    run_catch: SIO a -> MockProcessRunner -> IOFail (Result ErrMsg (MockProcessRunner, a));
    run_catch = |sio, runner| (
        runner.run(sio).to_result.lift
    );
}

test_check_branch_name_ok: TestCase;
test_check_branch_name_ok = (
    make_test("test_check_branch_name_ok") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("  main  "));
    let (runner, ()) = *runner.run(check_branch_name("main"));
    let expected = [
        MockProcess::make(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    ];
    assert_equal("processes", expected, runner.@processes)
);

test_check_branch_name_ng: TestCase;
test_check_branch_name_ng = (
    make_test("test_check_branch_name_ng") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("  develop  "));
    let res = *runner.run_catch(check_branch_name("main"));
    assert_equal("res", err $ "The current branch name is not `main`: actual = `develop`", res)
);

test_check_uncommitted_files_ok: TestCase;
test_check_uncommitted_files_ok = (
    make_test("test_check_uncommitted_files_ok") $ |_|
    let runner = MockProcessRunner::setup(next_stdout(""));
    let (runner, ()) = *runner.run(check_uncommitted_files);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only"]).verbose
    ];
    assert_equal("processes", expected, runner.@processes)
);

test_check_uncommitted_files_ng: TestCase;
test_check_uncommitted_files_ng = (
    make_test("test_check_uncommitted_files_ng") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("some_file"));
    let res = *runner.run_catch(check_uncommitted_files);
    assert_equal("res", err $ "Uncommitted file exists", res)
);


test_no_commit_since_latest_ok: TestCase;
test_no_commit_since_latest_ok = (
    make_test("test_no_commit_since_latest_ok") $ |_|
    let runner = MockProcessRunner::setup(next_stdout(""));
    let (runner, result) = *runner.run(no_commit_since_latest);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", C::tag_latest]).verbose
    ];
    assert_equal("processes", expected, runner.@processes);;
    assert_equal("result", true, result)
);

test_no_commit_since_latest_ng: TestCase;
test_no_commit_since_latest_ng = (
    make_test("test_no_commit_since_latest_ng") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("some_commit"));
    let (runner, result) = *runner.run(no_commit_since_latest);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", C::tag_latest]).verbose
    ];
    assert_equal("processes", expected, runner.@processes);;
    assert_equal("result", false, result)
);

test_reset_fixdeps_lock_ok: TestCase;
test_reset_fixdeps_lock_ok = (
    make_test("test_reset_fixdeps_lock_ok") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("some_commit"));
    let (runner, ()) = *runner.run(reset_fixdeps_lock);
    let expected = [
        MockProcess::make(["git", "checkout", "--", C::fixdeps_lock]).verbose
    ];
    assert_equal("processes", expected, runner.@processes)
);

test_commit_fixdeps_lock_ok: TestCase;
test_commit_fixdeps_lock_ok = (
    make_test("test_commit_fixdeps_lock_ok") $ |_|
    let runner = MockProcessRunner::setup(next_stdout("fixdeps.lock"));
    let (runner, ()) = *runner.run(commit_fixdeps_lock);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", "--", C::fixdeps_lock]),
        MockProcess::make(["git", "add", "--", C::fixdeps_lock]).verbose,
        MockProcess::make(["git", "commit", "-m", "update deps", "--", C::fixdeps_lock]).verbose,
    ];
    assert_equal("processes", expected, runner.@processes)
);

test_commit_fixdeps_lock_ng: TestCase;
test_commit_fixdeps_lock_ng = (
    make_test("test_commit_fixdeps_lock_ng") $ |_|
    let runner = MockProcessRunner::setup(next_stdout(""));
    let (runner, ()) = *runner.run(commit_fixdeps_lock);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", "--", C::fixdeps_lock]),
    ];
    assert_equal("processes", expected, runner.@processes)
);

testsuite: TestCase;
testsuite = (
    [
        test_check_branch_name_ok,
        test_check_branch_name_ng,
        test_check_uncommitted_files_ok,
        test_check_uncommitted_files_ng,
        test_no_commit_since_latest_ok,
        test_no_commit_since_latest_ng,
        test_reset_fixdeps_lock_ok,
        test_commit_fixdeps_lock_ok,
        test_commit_fixdeps_lock_ng,
    ]
    .run_tests
);