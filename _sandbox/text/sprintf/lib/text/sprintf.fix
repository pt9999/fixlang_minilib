// This module provides `sprintf` function.
//
// Example:
// ```
//   let str = (123, "abc").sprintf("a=%d b=%s");
//   println(str);;  // "a=123 b=abc"
// ```
// # Format specification
// ```
// format = literal (conversion_spec literal)*
// literal = (<any char other than '%'> | '%' '%')*
// conversion_spec = '%' flags field_width? precision? length_modifier? conversion_specifier
// flags = '#' | '0' | '-' | ' ' | '+' | '\''
// field_width = [0-9]+
// precision = '.' '-'? [0-9]+
// length_modifier = 'h' 'h'? | 'l' 'l'? | 'q' | 'L' | 'j' | 'z' | 'Z' | 't'
// conversion_specifier = 'd' | 'i' | 'o' | 'u' | 'x' | 'X' | 'e' | 'E' |
//         'f' | 'F' | 'g' | 'G' | 'a' | 'A' | 'c' | 's' | 'C' | 'S' |
//         'p' | 'n' | 'm'
// ```
// # Limitations
// - These flags are not supported.
//   - Alternate form (`'#'`)
//   - Thousands grouping (`'\''`)
// - `*` or `*m$` in field width are not supported.
// - `*` or `*m$` in precision are not supported.
// - Length modifier (`hh`, `h`, `l`, `ll` etc.) are not supported.
// - These conversion specifiers are not supported.
//   - `a`, `A`, `C`, `S`, `p`, `n`, `m`
module Minilib.Text.Sprintf;

import Minilib.Text.Sprintf.SprintfInternal;

trait a: Sprintf {
    sprintf: String -> a -> Result ErrMsg String;
}

impl (): Sprintf {
    sprintf = |format, ()| (
        let formatter = *Formatter::make(format);
        formatter.get_output
    );
}

impl [a: Convertible] (a,): Sprintf {
    sprintf = |format, (a,)| (
        let formatter = *Formatter::make(format);
        let formatter = *formatter.convert_value(a);
        formatter.get_output
    );
}

impl [a: Convertible, b: Convertible] (a, b): Sprintf {
    sprintf = |format, (a, b)| (
        let formatter = *Formatter::make(format);
        let formatter = *formatter.convert_value(a);
        let formatter = *formatter.convert_value(b);
        formatter.get_output
    );
}

impl [a: Convertible, b: Convertible, c: Convertible] (a, b, c): Sprintf {
    sprintf = |format, (a, b, c)| (
        let formatter = *Formatter::make(format);
        let formatter = *formatter.convert_value(a);
        let formatter = *formatter.convert_value(b);
        let formatter = *formatter.convert_value(c);
        formatter.get_output
    );
}

impl [a: Convertible, b: Convertible, c: Convertible, d: Convertible] (a, b, c, d): Sprintf {
    sprintf = |format, (a, b, c, d)| (
        let formatter = *Formatter::make(format);
        let formatter = *formatter.convert_value(a);
        let formatter = *formatter.convert_value(b);
        let formatter = *formatter.convert_value(c);
        let formatter = *formatter.convert_value(d);
        formatter.get_output
    );
}

impl [a: Convertible, b: Convertible, c: Convertible, d: Convertible, e: Convertible] (a, b, c, d, e): Sprintf {
    sprintf = |format, (a, b, c, d, e)| (
        let formatter = *Formatter::make(format);
        let formatter = *formatter.convert_value(a);
        let formatter = *formatter.convert_value(b);
        let formatter = *formatter.convert_value(c);
        let formatter = *formatter.convert_value(d);
        let formatter = *formatter.convert_value(e);
        formatter.get_output
    );
}
