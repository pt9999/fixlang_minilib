module Minilib.Crypto.Cert.X509Path;

import Debug;
import HashMap;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.CACertificates;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;

type CertificatePath = unbox struct {
    data: Array Certificate,
};

namespace CertificatePath {
    make: [m: MonadError] Array Certificate -> CACertificates -> m CertificatePath;
    make = |certs, ca_certs| (
        if certs.get_size == 0 { error $ "certificate list is empty" };
        eval *_check_certs_order(certs);
        let ca = *_find_ca_cert(certs, ca_certs);
        pure $ CertificatePath {
            data: certs.push_back(ca)
        }
    );

    _check_certs_order: [m: MonadError] Array Certificate -> m ();
    _check_certs_order = |certs| (
        Iterator::range(0, certs.get_size - 1).foreach_m(|i|
            let prev_issuer = certs.@(i).@tbs_certificate.@issuer;
            let next_subject = certs.@(i + 1).@tbs_certificate.@subject;
            if prev_issuer != next_subject {
                error $ "issuer and subject unmatch:" +
                        (i, prev_issuer).format("\n  certs[{}].issuer={}") +
                        (i + 1, next_subject).format("\n  certs[{}].subject={}")
            };
            pure()
        )
    );

    _find_ca_cert: [m: MonadError] Array Certificate -> CACertificates -> m Certificate;
    _find_ca_cert = |certs, ca_certs| (
        let last_cert_issuer = certs.get_last.as_some.@tbs_certificate.@issuer;
        let ca = ca_certs.find(last_cert_issuer);
        if ca.is_none {
            error $ "ca certificate not found: " + last_cert_issuer.to_string
        };
        pure $ ca.as_some
    );
}

impl CertificatePath: ToString {
    to_string = |obj| (
        "CertificatePath {" +
        " data=" + obj.@data.map(|cert| cert.@tbs_certificate.@subject).to_string +
        " }"
    );
}