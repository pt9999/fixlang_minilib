module Main;

import Debug;
import Random;

import RBTree;
import UnitTest;
import ArrayTestUtil;


test_simple: TestCase;
test_simple = (
    make_test("test_simple") $ |_| 
    let node: RBNode I64 = [1,2,3].to_iter.from_iter;
    let node = node.remove(1);
    let _ = *eprintln(node.to_string).lift;
    let _ = *assert_equal("eq", 2, node.to_iter.to_array.get_size);
    pure()
);


test_insert_remove_ok: (I64, Reorder, Reorder) -> TestCase;
test_insert_remove_ok = |(n, insert_reorder, remove_reorder)| (
    let testname = "test_insert_remove_ok("+ n.to_string + "," + 
                    insert_reorder.to_string + "," +
                    remove_reorder.to_string + ")";
    make_test(testname) $ |_| 
    let array = Iterator::range(0, n).to_array;

    // test insert
    let shuffled = array.reorder(insert_reorder);
    //let _ = *eprintln("shuffled="+ shuffled.to_iter.map(to_string).join(",")).lift;
    let node: RBNode I64 = shuffled.to_iter.from_iter;
    let sorted = node.to_iter.to_array;
    //let _ = *eprintln("sorted="+sorted.to_iter.map(to_string).join(",")).lift;
    let _ = *assert_equal("array == sorted", array, sorted);

    // test remove    
    let shuffled = array.reorder(remove_reorder);
    let node = *shuffled.to_iter.zip(Iterator::count_up(0)).fold_m(
        node, |node, (i, idx)| 
        eval _debug_eprintln_lazy(|_| "removing: idx="+idx.to_string+" i="+i.to_string + " node="+node.to_string);
        eval _debug_eprintln_lazy(|_| "node.level=" + node.level.to_string);
        let node = node.remove(i);
        let expect_size = shuffled.get_size - idx - 1;
        let actual_size = node.to_iter.to_array.get_size;
        let _ = *assert_equal("expect_size == actual_size", expect_size, actual_size);
        pure $ node
    );
    let removed = node.to_iter.to_array;
    //let _ = *eprintln("removed="+removed.to_iter.map(to_string).join(",")).lift;
    let _ = *assert_true("removed.is_empty", removed.is_empty);

    pure()      // success
);

test_insert_remove: TestCase;
test_insert_remove = (
    do {
        let n = 30;
        let insert_reorder = *[skip(15), ascending(), descending(), shuffle(123)];
        let remove_reorder = *[skip(15), ascending(), descending(), shuffle(345)];
        pure $ test_insert_remove_ok $ (n, insert_reorder, remove_reorder)
    }.run_tests
);

test_find_range_ok: Reorder -> TestCase;
test_find_range_ok = |insert_reorder| (
    let testname = "test_find_range_ok(" + insert_reorder.to_string + ")";
    make_test(testname) $ |_|  
    let n = 30;
    let array = Iterator::range(0, n).to_array;
    let node: RBNode I64 = array.reorder(insert_reorder).to_iter.from_iter;
    let answer = |begin, end| (
        node.find_range(|x| x < begin, |x| x < end).to_array
    );
    let _ = *assert_equal("eq", [1,2,3,4,5], answer(1,6));
    let _ = *assert_equal("eq", [13,14,15,16,17,18,19,20], answer(13,21));
    let _ = *assert_equal("eq", [0,1,2,3], answer(0,4));
    let _ = *assert_equal("eq", [0,1,2,3], answer(-1,4));
    let _ = *assert_equal("eq", [n-3,n-2,n-1], answer(n-3, n));
    let _ = *assert_equal("eq", [n-3,n-2,n-1], answer(n-3, n+1));
    let _ = *assert_equal("eq", [3], answer(3, 4));
    let _ = *assert_equal("eq", [], answer(3, 3));
    let _ = *assert_equal("eq", [], answer(3, 2));
    let _ = *assert_equal("eq", [], answer(-1, 0));
    let _ = *assert_equal("eq", [], answer(n, n+1));
    pure() 
);

test_find_range: TestCase;
test_find_range = (
    do {
        let insert_reorder = *[ascending(), descending(), skip(13), shuffle(543)];
        pure $ test_find_range_ok $ insert_reorder
    }.run_tests
);


main: IO ();
main = (
    [
        test_simple,
        test_insert_remove,
        test_find_range,
        TestCase::empty
    ]
    .run_test_driver
);

