// https://en.wikipedia.org/wiki/ASN.1
// https://en.wikipedia.org/wiki/X.690
module Minilib.Crypto.Asn1.Der;

import Minilib.Crypto.Asn1;
import Minilib.Encoding.Binary;
import Minilib.Math.BigInt;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;

trait MonadReadByte = Functor + Monad + MonadErrorIF + MonadReadByteIF;

trait [m: * -> *] m: MonadReadByteIF {
    // Reads a byte. If the end-of-file is reached, it reports an error.
    read_byte: m U8;
    // Checks whether the end-of-file is reached.
    is_eof: m Bool;
    // Runs the inner monad with the inner contents.
    // The inner contents is created from current position to the position advanced by the specified length,
    run_inner: I64 -> m a -> m a;
}

impl [m: MonadError] StateT ByteBuffer m: MonadReadByteIF {
    read_byte = make_state_t_monad $ |buf| (
        if buf.get_position >= buf.get_size {
            error $ "EOF"
        };
        let res: Result ErrMsg (U8, ByteBuffer) = buf.unmarshal;
        if res.is_err {
            error $ res.as_err
        };
        pure $ res.as_ok
    );
    is_eof = (
        let buf = *get_state;
        pure $ buf.get_position >= buf.get_size
    );
    run_inner = |length, inner_monad| (
        let buf = *get_state;
        let inner_array = buf.@array.subarray(
            buf.@position,
            min(buf.@position + length, buf.get_size)
        );
        let inner_buf = ByteBuffer::make(inner_array, big_endian());
        inner_monad.run_state_t(inner_buf).map(@0)
    );
}

type Identifier = unbox struct {
    tag_class: TagClass,
    constructed: Bool,
    tag: Tag
}; 

namespace Identifier {
    make: TagClass -> Bool -> Tag -> Identifier;
    make = |tag_class, constructed, tag| Identifier {
        tag_class: tag_class,
        constructed: constructed,
        tag: tag
    };

    assert_tag: [m: MonadError] Tag -> Identifier -> m ();
    assert_tag = |tag, identifier| (
        if identifier.@tag != tag {
            error $ [tag, identifier.@tag].format("tag mismatch: expected={} actual={}")
        };
        pure $ ()
    );
}

impl Identifier: Eq {
    eq = |a, b| (
        a.@tag_class == b.@tag_class &&
        a.@constructed == b.@constructed &&
        a.@tag == b.@tag
    );
}

impl Identifier: ToString {
    to_string = |obj| (
        "Identifier {" +
        " tag_class=" + obj.@tag_class.to_string +
        " constructed=" + obj.@constructed.to_string +
        " tag=" + obj.@tag.to_string +
        " }"
    );
}

decode_identifier: [m: MonadReadByte] m Identifier;
decode_identifier = (
    let u8 = *read_byte;
    let tag_class = u8.shift_right(6_U8).bit_and(3_U8);
    let constructed = (u8.bit_and(0x20_U8) != 0_U8);
    let tag_type = u8.bit_and(31_U8);
    let tag_type = *(
        if tag_type < 31_U8 { pure $ tag_type };
        loop_m(
            0_U8, |tag_type|
            let u8 = *read_byte;
            let tag_type = tag_type.shift_left(7_U8).bit_or(u8.bit_and(0x3f_U8));
            if u8.bit_and(0x80_U8) == 0_U8 { break_m $ tag_type };
            continue_m $ tag_type
        )
    );
    pure $ Identifier {
        tag_class: tag_class,
        constructed: constructed,
        tag: tag_type
    }
);

decode_length: [m: MonadReadByte] m I64;
decode_length = (
    let u8 = *read_byte;
    if u8.bit_and(0x80_U8) == 0_U8 {
        pure $ u8.to_I64
    };
    let n = u8.bit_and(0x3F_U8).to_I64;
    if n == 0 {
        error $ "der does not allow indefinite length"
    };
    if n == 127 {
        error $ "der does not allow reserved length"
    };
    loop_m(
        (0, 0), |(length, i)|
        if i >= n { break_m $ length };
        let u8 = *read_byte;
        let length = length.shift_left(8).bit_or(u8.to_I64); 
        continue_m $ (length, i + 1)
    )
);

decode_n_bytes: [m: MonadReadByte] I64 -> m (Array U8);
decode_n_bytes = |length| (
    Array::fill(length, read_byte).map_m(|x| x)
);

decode_primitive: [m: MonadReadByte] m (Identifier, Array U8);
decode_primitive = (
    let identifier = *decode_identifier;
    if identifier.@constructed {
        error $ "not a primitive"
    };
    let length = *decode_length;
    let contents = *decode_n_bytes(length);
    pure $ (identifier, contents)
);

// `decode_constructed(tag, inner_monad)` reads the identifier and the length,
// then checks whether the identifier matches the `tag`,
// then runs `inner_monad` in the inner contents.
decode_constructed: [m: MonadReadByte] Tag -> m a -> m a;
decode_constructed = |tag, inner_monad| (
    let identifier = *decode_identifier;
    if identifier.@constructed {
        error $ "not a primitive"
    };
    eval *assert_tag(tag_integer, identifier);
    let length = *decode_length;
    run_inner(length, inner_monad)
);

// `repeat(inner_monad)` is a monad that repeatedly runs `inner_monad` until it reaches the end of the file.
repeat: [m: MonadReadByte] m a -> m (Array a);
repeat = |inner_monad| (
    loop_m(
        [], |arr|
        if *is_eof { break_m $ arr };
        let a = *inner_monad;
        continue_m $ arr.push_back(a)
    )
);

// `inner_monad.if_exists` is a monad that runs `inner_monad` as an optional value.
if_exists: [m: MonadReadByte] m a -> m (Option a);
if_exists = |inner_monad| (
    inner_monad.map(some).catch(|errmsg| pure $ none())
);

// `decode_sequence(inner_monad)` reads the identifier and the length,
// then checks whether the identifier matches `tag_sequence`,
// runs `inner_monad` in the inner contents for the .
decode_sequence: [m: MonadReadByte] m a -> m a;
decode_sequence = |inner_monad| (
    decode_constructed(tag_sequence, inner_monad)
);

decode_sequence_of: [m: MonadReadByte] m a -> m (Array a);
decode_sequence_of = |inner_monad| (
    decode_constructed(tag_sequence, repeat $ inner_monad)
);

decode_set_of: [m: MonadReadByte] m a -> m (Array a);
decode_set_of = |inner_monad| (
    decode_constructed(tag_set, repeat $ inner_monad)
);

choice: [m: MonadError] Array (m a) -> m a;
choice = |monads| (
    let inner = fix $ |inner, i| (
        if i >= monads.get_size - 1 { monads.@(i) };
        monads.@(i).catch(|err| inner(i + 1))
    );
    inner(0)
);

trait a: DecodeDer {
    decode_obj: [m: MonadReadByte] m a;
}

decode_integer: [m: MonadReadByte] m I64;
decode_integer = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_integer, identifier);
    if contents.get_size == 0 {
        pure $ 0
    };
    if contents.get_size > 8 {
        error $ "OutOfRange"
    };
    let sign = if contents.@(0).bit_and(0x80_U8) != 0_U8 { -1 } else { 1 };
    let bytes = if sign >= 0 { contents }
    else { contents.map(bit_xor(0xff_U8)) };    // reverse bits
    let u64: U64 = bytes.to_iter.fold(
        0_U64, |u64, u8|
        u64.shift_left(8_U64).bit_or(u8.to_U64)
    );
    if u64 >= I64::maximum.to_U64 { error $ "OutOfRange" };
    let i64: I64 = if sign >= 0 {
        u64.to_I64
    } else {
        -((u64 + 1_U64).to_I64)
    };
    pure $ i64
);

impl Asn1::Integer: DecodeDer {
    decode_obj = decode_integer;
}

decode_bigint: [m: MonadReadByte] m BigInt;
decode_bigint = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_integer, identifier);
    if contents.get_size == 0 {
        pure $ Zero::zero
    };
    let sign = if contents.@(0).bit_and(0x80_U8) != 0_U8 { -1 } else { 1 };
    let bytes = if sign >= 0 { contents }
    else { contents.map(bit_xor(0xff_U8)) };    // reverse bits

    let nat = (
        let u8_len = bytes.get_size;
        let u32_len = (u8_len + 3) / 4;
        if u32_len == 0 { ok $ zero };
        let bytes = if 4 * u32_len == u8_len { bytes }
        else { Array::fill(4 * u32_len - u8_len, 0_U8).append(bytes) };
        let nat = Array::from_map(u32_len, |i|
            bytes.get_u32_be(4 * (u32_len - 1 - i))     // big endian
        );
        if sign >= 0 {
            nat
        } else {    // if negative, add one (because of two's complement)
            nat._add(BigNat::one)
        }
    );
    pure $ BigInt::make(sign, nat)
);

impl Asn1::ObjectIdentifier: DecodeDer {
    decode_obj = (
        let (identifier, contents) = *decode_primitive;
        eval *assert_tag(tag_object_identifier, identifier);
        if contents.get_size <= 0 { error $ "invalid object identifier" };
        let first = contents.@(0) / 20_U8;
        let second = contents.@(0) % 20_U8;
        let numbers = [first, second].append(contents.subarray(1, contents.get_size));

        pure $ ObjectIdentifier { numbers: numbers }
    );
}

// ITU-T Rec. X.680 (02/2021)
// p.63 38	The time type
decode_time: [m: MonadReadByte] m String;
decode_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_time, identifier);
    // contents = hh:mm:ss
    pure $ contents._unsafe_to_string
);

decode_generalized_time: [m: MonadReadByte] m String;
decode_generalized_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_generalized_time, identifier);
    // contents = ????
    pure $ contents._unsafe_to_string
);

decode_utc_time: [m: MonadReadByte] m String;
decode_utc_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_utc_time, identifier);
    // contents = YYMMDDhhmm(ss)?(z|[+-]hhmm)
    pure $ contents._unsafe_to_string
);
