module Main;

import Sandbox.Xml;
import Sandbox.XmlParser;
import Minilib.Testing.UnitTest;
import Minilib.Text.SimpleParser;
import Minilib.Text.StringEx;

// trim err string like "Line 0, Column 13: XXXX"
trim_err: Result ErrMsg a -> Result ErrMsg a;
trim_err = |res| (
    if res.is_ok { res };
    let e = res.as_err;
    let (loc, e) = e.split_first(": ");
    if e == "" { res } else { err(e) }
);

// [15]   	Comment	   ::=   	'<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
test_parse_comment: TestCase;
test_parse_comment = (
    make_table_test("test_parse_comment",
        [
            ("<!--abc-->", ok("abc")),
            ("<!---a-a-aa-a-->", ok("-a-a-aa-a")),
            ("<!---a-a-aa-a--->", err("Missing end of comment"))
        ],
        |(input, expect)|
        let res = _parse_comment.run_parser_str(input);
        let res = res.map(|(node,_)| 
            if !node.is_comment_node { err $ "type" };
            ok $ node.as_comment_node.@content
        ).flatten.trim_err;
        assert_equal("res", expect, res)
    )
);

// [40]   	STag	   ::=   	'<' Name (S Attribute)* S? '>'
test_parse_stag: TestCase;
test_parse_stag = (
    make_table_test("test_parse_stag",
        [
            ("<aaa  >", ok $ (false, XmlElement::make("aaa"))),
            ("<aaa a='1' b=\"&amp;\" >", ok $ (false, XmlElement::make("aaa").attr("b", "&").attr("a", "1"))),
            ("<aaa a b=\"&amp;\" >", err $ "Missing '='"),
            ("<aaa &a='1' >", err $ "Missing '>'"),
            ("<aaa <bbb>", err $ "Missing '>'"),
            ("<aaa  ", err $ "Missing '>'")
        ],
        |(input, expect)|
        let res = _parse_empty_elem_tag_or_stag.run_parser_str(input);
        let res = res.map(|((empty, elem), _)| (empty, elem)).trim_err;
        assert_equal("res", expect, res)
    )
);


// [41]   	Attribute	   ::=   	Name Eq AttValue
test_parse_attribute: TestCase;
test_parse_attribute = (
    make_table_test("test_parse_attribute",
        [
            (":Aa0.='bbb'", ok $ (":Aa0.", "bbb")),
            ("_:Aa0.-  =  \"bbb &#12354;&#x6F22;&lt;&gt;&amp;&apos;&quot;\"", ok $ ("_:Aa0.-", "bbb あ漢<>&'\"")),
            ("_:Aa0.-  =  bbb", err $ "Missing start quote"),
            ("_:Aa0.-  =  \"bbb", err $ "Missing end quote"),
            ("_:Aa0.-  =  \"bbb<\"", err $ "Missing end quote"),
            ("_:Aa0.-  =  \"bbb&\"", err $ "Missing end quote")
        ],
        |(input, expect)|
        let res = _parse_attribute.run_parser_str(input);
        let res = res.map(|(attr, _)|
            (attr.@name, attr.@value)
        ).trim_err;
        assert_equal("res", expect, res)
    )
);

// [44]   	EmptyElemTag	   ::=   	'<' Name (S Attribute)* S? '/>'
test_parse_empty_elem: TestCase;
test_parse_empty_elem = (
    make_table_test("test_parse_empty_elem",
        [
            ("<aaa a='1' b=\"&amp;\" />", ok $ (true, XmlElement::make("aaa").attr("b", "&").attr("a", "1"))),
            ("<aaa a=1 b=\"&amp;\" />", err $ "Missing start quote"),
            ("<aaa/>", ok $ (true, XmlElement::make("aaa"))),
            ("<aaa/", err $ "Missing '>'")
        ],
        |(input, expect)|
        let res = _parse_empty_elem_tag_or_stag.run_parser_str(input);
        let res = res.map(|((empty, elem), _)| (empty, elem)).trim_err;
        assert_equal("res", expect, res)
    )
);


main: IO ();
main = (
    [
        test_parse_comment,
        test_parse_stag,
        test_parse_attribute,
        test_parse_empty_elem,
        TestCase::empty
    ].run_test_driver
);
