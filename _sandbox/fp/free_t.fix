module Minilib.Monad.FreeT;

import Minilib.Monad.Iden;

// Free Monad
// https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
// https://eed3si9n.com/herding-cats/ja/Free-monads.html
type [f: *->*, m: *->*] FreeT f m a = box struct {
    data: m (FreeU f m a),
};

type [f: *->*, m: *->*] FreeU f m a = unbox union {
    f_pure: a,
    f_free: f (FreeT f m a)
};

type [f: *->*] Free f = FreeT f Iden;

namespace FreeT {
    make: [f: Functor, m: Monad] m (FreeU f m a) -> FreeT f m a;
    make = |ma| FreeT { data: ma };
}

lift_f: [f: Functor, m: Monad] f a -> FreeT f m a;
lift_f = |command| FreeT::make $ pure $ f_free $ command.map(pure);

impl [f: Functor, m: Monad] FreeT f m: Functor {
    map = |g, ma| (
        FreeT::make $ do {
            match *ma.@data {
                f_pure(value) => pure $ f_pure(g(value)),
                f_free(fma) => pure $ f_free(fma.map(map(g))),
            }
        }
    );
}

impl [f: Functor, m: Monad] FreeT f m: Monad {
    pure = |a| FreeT::make $ pure $ f_pure(a);
    bind = |g, ma| (
        FreeT::make $ do {
            match *ma.@data {
                f_pure(value) => g(value).@data,
                f_free(fma) => pure $ f_free(fma.map(bind(g))),
            }
        }
    );
}

