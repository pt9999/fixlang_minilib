module Minilib.Task.TaskPool;

import AsyncTask;

import Minilib.IO.Channel;
import Minilib.Monad.FunctorM;
import Minilib.Task.Future;

type TaskPool = unbox struct {
    chan: Channel (IO ()),
    tasks: Array (IOTask ())
};

// `TaskPool::make(task_count)` creates a TaskPool.
make: I64 -> IO TaskPool;
make = |task_count| (
    let chan = *Channel::make;
    let tasks = *Iterator::range(0, task_count).to_array.map_m(|i|
        AsyncIOTask::make(_task_func(chan))
    );
    pure $ TaskPool {
        chan: chan,
        tasks: tasks
    }
);

// Sends `io` to the channel.
_send: IO () -> TaskPool -> IOFail ();
_send = |io, pool| (
    pool.@chan.send(io)
);

// Shutdowns a taskpool.
shutdown: TaskPool -> IO TaskPool;
shutdown = |pool| (
    let _ = *pool.@chan.close;
    let _ = *pool.@tasks.foreach_m(
        |task| task.get
    );
    pure $ pool.set_tasks([])
);

// The task function of the taskpool.
_task_func: Channel (IO ()) -> IO ();
_task_func = |chan| (
    loop_m(
        (), |_|
        let io = *chan.recv;
        let _ = *io.lift;
        continue_m $ ()
    )
    .try(|err|
        if err == Channel::closed_error {
            pure()    
        };
        eprintln(err)
    )
);

impl TaskPool: FutureRunner {
    run_future = _send;
}