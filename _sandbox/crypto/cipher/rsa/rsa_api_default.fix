module Minilib.Crypto.Cipher.Rsa.RsaApiDefault;

import Minilib.Crypto.Cipher.Rsa.RsaApi;
import Minilib.Crypto.Cipher.Rsa.Pkcs1;
import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Encoding.Binary;
import Minilib.Math.BigInt;
import Minilib.Monad.Error;
import Minilib.Monad.State;

make: [m: MonadError] m (RsaApi m);
make = (
    pure $ RsaApi {
        rsassa_pss_verify: _rsassa_pss_verify,
        rsassa_pkcs1_v1_5_verify: _rsassa_pkcs1_v1_5_verify,
    }
);

_rsassa_pss_verify: [m: MonadError] RsaHashName -> RsaPublicKey -> RsaSigMessage -> RsaSignature -> m ();
_rsassa_pss_verify = |hash_name, public_key, sig_message, signature| (
    let (n, e) = *_decode_public_key(public_key);
    let options = *_find_emsa_pss_options(hash_name);
    rsassa_pss_verify((n, e), sig_message, signature, options).from_result_t
);

_rsassa_pkcs1_v1_5_verify: [m: MonadError] RsaHashName -> RsaPublicKey -> RsaSigMessage -> RsaSignature -> m ();
_rsassa_pkcs1_v1_5_verify = |hash_name, public_key, sig_message, signature| (
    let (n, e) = *_decode_public_key(public_key);
    let options = *_find_emsa_pkcs1_options(hash_name);
    rsassa_pkcs1_v1_5_verify((n, e), sig_message, signature, options).from_result_t
);

_decode_public_key: [m: MonadError] RsaPublicKey -> m (BigInt, BigInt);
_decode_public_key = |public_key| (
    let sm = do {
        decode_sequence $ do {
            let n: BigInt = *decode_obj;
            let e: BigInt = *decode_obj;
            pure $ (n, e)
        }
    };
    let buf = ByteBuffer::make(public_key, big_endian());
    sm.eval_state_t(buf)
    .from_result_t
);

_find_emsa_pss_options: [m: MonadError] RsaHashName -> m EmsaPssOptions;
_find_emsa_pss_options = |hash_name| (
    if hash_name == "sha256" {
        pure $ Pkcs1::emsa_pss_options_sha256
    };
    if hash_name == "sha384" {
        pure $ Pkcs1::emsa_pss_options_sha384
    };
    if hash_name == "sha512" {
        pure $ Pkcs1::emsa_pss_options_sha512
    };
    error $ "unsupported hash: " + hash_name
);

_find_emsa_pkcs1_options: [m: MonadError] RsaHashName -> m EmsaPkcs1Options;
_find_emsa_pkcs1_options = |hash_name| (
    if hash_name == "sha1" {
        pure $ Pkcs1::emsa_pkcs1_options_sha1
    };
    if hash_name == "sha256" {
        pure $ Pkcs1::emsa_pkcs1_options_sha256
    };
    if hash_name == "sha384" {
        pure $ Pkcs1::emsa_pkcs1_options_sha384
    };
    if hash_name == "sha512" {
        pure $ Pkcs1::emsa_pkcs1_options_sha512
    };
    error $ "unsupported hash: " + hash_name
);
