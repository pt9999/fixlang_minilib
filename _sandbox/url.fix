module Main;

import StringEx;

type URL = unbox struct {
    url: String,
    scheme: String,
    host: String,
    port: String,
    path: String
};

namespace URL {
    _cut: String -> String -> (String, String);
    _cut = |delim, str| (
        let pos = str.find(delim, 0);
        if pos.is_none {
            (str, "")
        };
        let pos = pos.as_some;
        (str.substring(0, pos), str.substring(pos + delim.get_size, str.get_size))
    );

    parse: String -> Result ErrMsg URL;
    parse = |url| (
        let (scheme, rest) = if url.find("://", 0).is_some {
            url._cut("://")
        } else {
            ("http", url)
        };
        let (host_port, path) = rest._cut("/");
        let path = if path == "" { "/" } else { "/" + path };
        
        let (host, port) = host_port._cut(":");
        let port = if port == "" { "80" } else { port };
        
        ok $ URL { url:url, scheme:scheme, host:host, port:port, path:path }
    );

}

namespace URI {
    _unreserved_table: Array U8;
    _unreserved_table = (
        let char_ranges = [
            ('A', 'Z'),
            ('a', 'z'),
            ('0', '9'),
            ('-', '-'),
            ('.', '.'),
            ('_', '_'),
            ('~', '~')
        ];
        char_ranges.to_iter.fold(
            Array::fill(256, 0_U8), |array, (min, max)|
            Iterator::range(min.to_I64, max.to_I64 + 1).fold(
                array, |array, c| array.set(c, 1_U8)
            )
        )
    );

    encodeURIComponent: String -> String;
    encodeURIComponent = |str| (
        let input = str.get_bytes.pop_back;
        input.to_iter.fold(
            Array::empty(input.get_size * 3), |output, c|
            if _unreserved_table.@(c.to_I64) != 0_U8 {
                output.push_back(c)
            };
            let hi = c.shift_right(4_U8).bit_and(15_U8);
            let lo = c.bit_and(15_U8);
            output.push_back('%')
            .push_back(encode_hex_char(hi))
            .push_back(encode_hex_char(lo))
        )
        ._unsafe_to_string
    );

    decodeURIComponent: String -> Result ErrMsg String;
    decodeURIComponent = |str| (
        let input = str.get_bytes.pop_back;
        let input_size = input.get_size;
        let output = *loop_m(
            (Array::empty(input_size), 0), |(output, i)|
            if i >= input_size {
                break_m $ output
            };
            let c = input.@(i);
            if c != '%' {
                continue_m $ (output.push_back(c), i + 1)
            };
            if i + 2 >= input_size {
                err $ "Percent sign requires two characters"
            };
            let hi = *decode_hex_char(input.@(i + 1));
            let lo = *decode_hex_char(input.@(i + 2));
            let c = hi.shift_left(4_U8).bit_or(lo);
            continue_m $ (output.push_back(c), i + 3)
        );
        ok $ output._unsafe_to_string
    );
}

main: IO ();
main = (
    do {
        let e =  encodeURIComponent ("abc!#$%&-~_. hoge");
        let _ = *println ("encode: '" + e + "'").lift;
        let d = *decodeURIComponent ("abc%21%23%24%25%26-~_.%20hoge").from_result;
        let _ = *println ("decode: '" + d + "'").lift;
        pure()
    }
    .try(|err| eprintln(err))
);