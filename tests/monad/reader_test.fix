module Main;

import Debug;
import HashMap;

import Minilib.Monad.Reader;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

test_reader_functor: TestCase;
test_reader_functor = (
    make_test("test_reader_functor") $ |_|
    let r = reader(|e| e.@(0));
    let r = r.map(add(1));
    let r = r.map(to_string);
    assert_equal("eq", "3", r.run_reader([2]))
);

type Config = HashMap String String;

test_reader_monad: TestCase;
test_reader_monad = (
    make_test("test_reader_monad") $ |_|
    let get_config_value: String -> Reader Config String = |key| (
        let config = *ask;
        pure $ config.find(key).as_some_or("")
    );
    let r = do {
        let value1 = *get_config_value("key1");
        let value2 = *get_config_value("key2");
        pure $ "value1=" + value1 + " value2=" + value2
    };
    let config = HashMap::empty(0).insert("key1", "a").insert("key2", "b");
    eval *assert_equal("case1", "value1=a value2=b", r.run_reader(config));
    let rr = r.local(insert("key2", "bb"));
    eval *assert_equal("case2", "value1=a value2=bb", rr.run_reader(config));
    eval *assert_equal("case3", "value1= value2=bb", rr.run_reader(HashMap::empty(0)));
    pure()
);

test_sub_reader: TestCase;
test_sub_reader = (
    make_test("test_sub_reader") $ |_|
    let r_sub2 = |p:I64, q:I64| reader $ |r:I64| (p,q,r).format("p={}, q={}, r={}");
    let r_sub  = |p:I64| reader $ |q:I64| r_sub2(p,q);
    let r_main  = reader $ |p:I64| r_sub(p);
    let actual = r_main.run_reader(3).run_reader(4).run_reader(5);
    assert_equal("eq", "p=3, q=4, r=5", actual)
);

main: IO ();
main = (
    [
        test_reader_functor,
        test_reader_monad,
        test_sub_reader,
        TestCase::empty
    ]
    .run_test_driver
);

