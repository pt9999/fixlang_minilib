// Free Monad.
//
// You can create a Free Monad from any functor.
//
// Free monads allow you to compose a sequence of computations as a data structure,
// which can then be executed in interpreters customized for your purpose.
//
// The type of a free monad is `Free f a`, where `f` is a functor.
// Conceptually, `Free f a` is equal to `a | f a | f f a | f f f a | ...`.
//
// You can interpret the data structure recursively by matching against `f_pure` or `f_functor`.
//
// For more information, see the following article:
// - [Haskell for all: Why free monads matter](https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html)
module Minilib.Monad.Free;

import Minilib.Monad.IO;

// The type of Free Monad
type [f: *->*] Free f a = box union {
    // A pure state.
    f_pure: a,
    // An effectful (impure) state.
    f_functor: f (Free f a),
};

namespace Free {
    // Lifts a functor value into a free monad value.
    //
    // # Parameters
    // - `command`: a value of a functor
    lift_f: [f: Functor] f a -> Free f a;
    lift_f = |command| f_functor $ command.map(f_pure);
}

impl [f: Functor] Free f: Functor {
    map = |g, ma| (
        match ma {
            f_pure(value) => f_pure(g(value)),
            f_functor(fma) => f_functor(fma.map(map(g))),
        }
    );
}

impl [f: Functor] Free f: Monad {
    pure = f_pure;
    bind = |g, ma| (
        match ma {
            f_pure(value) => g(value),
            f_functor(fma) => f_functor(fma.map(bind(g))),
        }
    );
}

impl [f: Functor, f: MonadIOIF] Free f: MonadIOIF {
    lift_io = lift_io >> lift_f;
}

impl [f: Functor, f: MonadIOFailIF] Free f: MonadIOFailIF {
    lift_iofail = lift_iofail >> lift_f;
}
