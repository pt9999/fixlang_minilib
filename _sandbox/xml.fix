// XML handling, such as:
// - Very simple DOM model (XmlDocument, XmlElement)
// - Escape/unescape special characters
module Sandbox.Xml;

import Debug;
import Character;

import Minilib.Text.StringEx;
import Minilib.Text.Unicode;
import Minilib.Net.HTML;

// A type that represents an XML document.
type XmlDocument = unbox struct {
    document_element: XmlElement           // document element
};

namespace XmlDocument {
    // An empty XML document.
    empty: XmlDocument;
    empty = (
        XmlDocument {
            document_element: XmlElement::make("root")      // dummy
        }
    );

    make: XmlElement -> XmlDocument;
    make = |document_element| (
        XmlDocument {
            document_element: document_element
        }
    );

    // Adds a child element to document element.
    add: XmlElement -> XmlDocument -> XmlDocument;
    add = |child, doc| (
        doc.mod_document_element(add(child))
    );

    // Converts the XML document to XML string.
    _to_string: XmlDocument -> String;
    _to_string = |doc| (
        doc.@document_element._to_string
    );   
}

impl XmlDocument: ToString {
    to_string = _to_string;
}

// A type that represents an XML node.
type XmlNode = box union {
    element_node: XmlElement,      // XML element
    text_node: XmlText,            // text node
    comment_node: XmlComment,      // comment node
    cdata_section: XmlCDATASection, // cdata section
    processing_instruction: XmlProcessingInstruction    // processing instruction
};

impl XmlNode: Eq {
    eq = |a, b| (
        if a.is_element_node && b.is_element_node { a.as_element_node == b.as_element_node };
        if a.is_text_node && b.is_text_node { a.as_text_node == b.as_text_node };
        if a.is_comment_node && b.is_comment_node { a.as_comment_node == b.as_comment_node };
        if a.is_cdata_section && b.is_cdata_section { a.as_cdata_section == b.as_cdata_section };
        if a.is_processing_instruction && b.is_processing_instruction {
            a.as_processing_instruction == b.as_processing_instruction
        };
        false
    );
}

impl XmlNode: ToString {
    to_string = |node| (
        if node.is_element_node {
            node.as_element_node.to_string
        } else if node.is_text_node {
            node.as_text_node.to_string
        } else if node.is_comment_node {
            node.as_comment_node.to_string
        } else if node.is_cdata_section {
            node.as_cdata_section.to_string
        } else if node.is_processing_instruction {
            node.as_processing_instruction.to_string
        } else {
            eval assert(|_|"invalid node", false);
            ""
        }
    );
}

// A type that represents an XML element.
type XmlElement = unbox struct {
    tag: String,                   // tag name
    attrs: Array XmlAttribute,      // attributes
    children: Array XmlNode        // child nodes
};

namespace XmlElement {

    // `XmlElement::make(tag)` creates an empty element with specified tag name.
    make: String -> XmlElement;
    make = |tag| (
        XmlElement {
            tag: tag,
            attrs: Array::empty(0),
            children: Array::empty(0)
        }
    );

    // Synonym for `XmlElement::make`.
    element: String -> XmlElement;
    element = make;

    // `el.attr(name,value)` adds an attribute to `el`.
    // If an attribute of same name exists, it will be replaced.
    // NOTE: validity of attribute names are not checked.
    attr: String -> String -> XmlElement -> XmlElement;
    attr = |name, value, el| (
        let attr = XmlAttribute::make(name, value);
        el.mod_attrs(|attrs|
            let index = attrs.find_by(|attr2| attr2.@name == attr.@name);
            if index.is_some {
                attrs.set(index.as_some, attr)
            } else {
                attrs.push_back(attr)
            }
        )
    );

    // `parent.add_node(child_node)` adds a child node to `parent`.
    add_node: XmlNode -> XmlElement -> XmlElement;
    add_node = |child_node, parent| (
        parent.mod_children(push_back(child_node))
    );

    // `parent.add(child)` adds a child element to `parent`.
    add: XmlElement -> XmlElement -> XmlElement;
    add = |child, parent| (
        parent.mod_children(push_back(element_node(child)))
    );

    // `parent.addF $ child` adds a child element to `parent`.
    // This is a flipped version of `add`.
    addF: XmlElement -> XmlElement -> XmlElement;
    addF = |parent, child| (
        parent.mod_children(push_back(element_node(child)))
    );

    // `el.text(content)` adds a text node to `el`.
    text: String -> XmlElement -> XmlElement;
    text = |content, el| (
        el.mod_children(push_back(text_node $ XmlText::make(content)))
    );

    // `el.concat_text_nodes` concats adjuscent text nodes.
    concat_text_nodes: XmlElement -> XmlElement;
    concat_text_nodes = |el| (
        let concat_or_push_back: Array XmlNode -> XmlNode -> Array XmlNode =
            |children, child| (
                if children.is_empty {
                    children.push_back(child)
                };
                if !child.is_text_node {
                    children.push_back(child)
                };
                let last = children.get_last.as_some;
                if !last.is_text_node {
                    children.push_back(child)
                };
                children.pop_back.push_back(text_node $ last.as_text_node + child.as_text_node)
            );
        el.mod_children(|children|
            children.to_iter.fold(
                [], concat_or_push_back
            )
        )
    );
}

impl XmlElement: Eq {
    eq = |a, b| (
        a.@tag == b.@tag &&
        a.@attrs._sort_by_name == b.@attrs._sort_by_name &&
        a.@children == b.@children
    );
}

impl XmlElement: ToString {
    to_string = |el| (
        let output = "<" + el.@tag;
        let output = output + el.@attrs.to_iter.map(|attr| " " + attr.to_string).concat_iter;
        if el.@children.is_empty {
            output + "/>"
        };
        let output = output + ">";
        //let child_sep = if el.@children.get_size >= 1 { "\n" } else { "" };
        let child_sep = "";
        let output = output + child_sep;
        let output = el.@children.to_iter.fold(
            output, |output, node|
            output + node.to_string + child_sep
        );
        let output = output + "</" + el.@tag + ">";
        output
    );
}

// A type that represents name and value of an attribute.
type XmlAttribute = unbox struct {
    name: String,
    value: String
};

namespace XmlAttribute {
    make: String -> String -> XmlAttribute;
    make = |name, value| (
        // TODO: check name safety
        XmlAttribute { name: name, value: value }
    );

    _sort_by_name: Array XmlAttribute -> Array XmlAttribute;
    _sort_by_name = |attrs| (
        attrs.sort_by(|(a, b)| a.@name < b.@name)
    );
}

impl XmlAttribute: Eq {
    eq = |a, b| a.@name == b.@name && a.@value == b.@value;
}

impl XmlAttribute: ToString {
    to_string = |attr| (
        escape_special(attr.@name)      // for security
        + "=\""
        + escape_special(attr.@value)
        + "\""
    );
}


type XmlText = unbox struct {
    content: String
};

namespace XmlText {
    make: String -> XmlText;
    make = |content| XmlText { content: content };
}

impl XmlText: Eq {
    eq = |a, b| a.@content == b.@content;
}

impl XmlText: ToString {
    to_string = |text| escape_special(text.@content);
}

impl XmlText: Add {
    add = |a, b| XmlText::make(a.@content + b.@content);
}

type XmlCDATASection = unbox struct {
    content: String
};

namespace XmlCDATASection {
    make: String -> XmlCDATASection;
    make = |content| XmlCDATASection { content: content };
}

impl XmlCDATASection: Eq {
    eq = |a, b| a.@content == b.@content;
}

impl XmlCDATASection: ToString {
    to_string = |cdata_section| (
        "<![CDATA[" + cdata_section.@content + "]]>"
    );
}

type XmlComment = unbox struct {
    content: String
};

namespace XmlComment {
    make: String -> XmlComment;
    make = |content| XmlComment { content: content };

    _output_string: Array String -> XmlComment -> Array String;
    _output_string = |output, comment| (
        output.push_back("<!--")
        .push_back(comment.@content)
        .push_back("-->")
    );
}

impl XmlComment: Eq {
    eq = |a, b| a.@content == b.@content;
}

impl XmlComment: ToString {
    to_string = |comment| (
        "<!--" + comment.@content + "-->"
    );
}

type XmlProcessingInstruction = unbox struct {
    content: String
};

namespace XmlProcessingInstruction {
    make: String -> XmlProcessingInstruction;
    make = |content| XmlProcessingInstruction { content: content };
}

impl XmlProcessingInstruction: Eq {
    eq = |a, b| a.@content == b.@content;
}

impl XmlProcessingInstruction: ToString {
    to_string = |pi| (
        "<?" + pi.@content + "?>"
    );
}

namespace XmlHelpers {
    // Escapes XML special characters.
    // eg. `&` -> `&amp;`, `<` -> `&lt;`, `>` -> `&gt;`, `\"` -> `&quot;`, `'` -> `&#039;`
    escape_special: String -> String;
    escape_special = escape_html;

    // Unescapes XML special characters.
    // eg. `&amp;` -> `&`, `&lt;` -> `<`, `&gt;` -> `>`, `&quot;` -> `\"`, `&#039;` -> `'`.
    // NOTE: Other character references is also converted.
    unescape_special: String -> String;
    unescape_special = unescape_html;
}
