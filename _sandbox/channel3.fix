module Main;

import AsyncTask;
import Random;

import Minilib.Collection.Deque;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;

namespace Channel {
    type ChannelData a = unbox struct {
        deque: Deque a,
        closed: Bool
    };

    type Channel a = unbox struct {
        var: Var (ChannelData a)
    };

    // `Channel::make` creates a new channel.
    make: IO (Channel a);
    make = (
        let _ = *pure();        // make it lazy
        let chan_data = ChannelData {
            deque: Deque::empty(0),
            closed: false
        };
        let var = *Var::make(chan_data);
        pure $ Channel { var: var }
    );

    // `channel.close` closes a channel.
    // After close, `send()` will fail.
    close: Channel a -> IO ();
    close = |chan| (
        chan.@var.mod(set_closed(true))
    );

    // `channel.is_closed` checks whether the channel is closed.
    is_closed: Channel a -> IO Bool;
    is_closed = |chan| (
        let data = *chan.@var.get;
        pure $ data.@closed
    );

    // `channel.is_empty` checks whether the queue of the channel is empty.
    is_empty: Channel a -> IO Bool;
    is_empty = |chan| (
        let data = *chan.@var.get;
        pure $ data.@deque.is_empty
    );

    // `channel.send(a)` sends a data to the queue of the channel.
    // If the channel is closed, it throws `closed_error`.
    send: a -> Channel a -> IOFail ();
    send = |a, chan| (
        chan.@var.lock(
            |data|
            if data.@closed {
                pure $ err $ closed_error
            };
            let data = data.mod_deque(push_back(a));
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ ()
        ).lift.bind(from_result)
    );

    // `channel.recv` receives a data from the queue of the channel.
    // If the queue is empty, it waits until any data is sent, or the channel is closed.
    // If the channel is closed and the queue is empty, it throws `closed_error`.
    recv: Channel a -> IOFail a;
    recv = |chan| (
        chan.@var.wait_and_lock(
            |data| data.@closed || !data.@deque.is_empty,
            |data|
            if data.@closed && data.@deque.is_empty {
                pure $ err $ closed_error
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ a
        ).lift.bind(from_result)
    );

    // `channel.recv` tries to receive a data from a channel.
    // If there is no data, `none` is returned.
    // If the channel is closed and the queue is empty, it throws `closed_error`.
    try_recv: Channel a -> IOFail (Option a);
    try_recv = |chan| (
        chan.@var.lock(
            |data|
            if data.@closed && data.@deque.is_empty {
                pure $ err $ closed_error
            };
            if data.@deque.is_empty {
                pure $ ok $ none()
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ some(a)
        ).lift.bind(from_result)
    );

    // An error message which is reported when the channel is closed.
    closed_error: ErrMsg;
    closed_error = "Closed";
}


type Future a = unbox struct {
    var: Var (Option a)
};

namespace Future {
    // `Future::make(pool, io) creates a Future.
    // `io` is performed in a task function of the taskpool.
    // If the taskpool has been shutdown, the future will never be resolved.
    make: TaskPool -> IO a -> IOFail (Future a);
    make = |pool, io| (
        let var = *Var::make(none()).lift;
        let io_unit = do {
            let a = *io;
            var.Var::set(some $ a)
        };
        let _ = *pool._send(io_unit);
        pure $ Future {
            var: var
        }
    );

    // Gets the result of the Future.
    // If the `io` is not performed yet, wait until `io` is performed.
    // If the taskpool has been shutdown, it may or may not wait forever.
    get: Future a -> IO a;
    get = |future| (
        future.@var.wait_and_lock(
            is_some, as_some >> pure
        )
    );
}

type TaskPool = unbox struct {
    chan: Channel (IO ()),
    tasks: Array (IOTask ())
};

namespace TaskPool {

    // `TaskPool::make(task_count)` creates a TaskPool.
    make: I64 -> IO TaskPool;
    make = |task_count| (
        let chan = *Channel::make;
        let tasks = *Iterator::range(0, task_count).to_array.map_m(|i|
            AsyncIOTask::make(_task_func(chan))
        );
        pure $ TaskPool {
            chan: chan,
            tasks: tasks
        }
    );

    // Sends `io` to the channel.
    _send: IO () -> TaskPool -> IOFail ();
    _send = |io, pool| (
        pool.@chan.send(io)
    );

    // Shutdowns a taskpool.
    shutdown: TaskPool -> IO TaskPool;
    shutdown = |pool| (
        let _ = *pool.@chan.close;
        let _ = *pool.@tasks.foreach_m(
            |task| task.get
        );
        pure $ pool.set_tasks([])
    );

    // The task function of the taskpool.
    _task_func: Channel (IO ()) -> IO ();
    _task_func = |chan| (
        loop_m(
            (), |_|
            let io = *chan.recv;
            let _ = *io.lift;
            continue_m $ ()
        )
        .try(|err|
            if err == Channel::closed_error {
                pure()    
            };
            eprintln(err)
        )
    );
}


//---------------------------------------------------

parallel_map_m: TaskPool -> (a -> IO b) -> Array a -> IOFail (Array b);
parallel_map_m = |pool, f, arr| (
    let futures = *arr.map_m(
        |a| Future::make(pool, pure(a).bind(f))
    );
    futures.map_m(
        |future| future.get.lift
    )
);

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);

sleep_random: Var Random -> IO ();
sleep_random = |rand_var| (
    let u64 = *rand_var.lock(|rand|
        let (u64, rand) = rand.generate_U64;
        let _ = *rand_var.Var::set(rand);
        pure $ u64
    );
    eval _usleep((u64 % 5000000_U64).to_I64);
    pure()
);

// This function makes IOHandle to unbuffered mode. See `man 3 setbuf`.
// NOTE: When `fix run` is invoked `fixautolink`, it is invoked by `run_with_stream()`.
// Then the stdout and stderr is not a tty, but a file stream. 
// So the stdout becomes block-buffered. The stderr also seems to be block-buffered.
set_unbuffered_mode: IOHandle -> IO ();
set_unbuffered_mode = |handle| (
    let _ = *pure();
    eval CALL_C[() setbuf(Ptr, Ptr), handle._file_ptr, nullptr];
    pure()
);

test1: IO ();
test1 = (
    do {
        let _ = *eprintln("start").lift;
        let rand_var: Var Random = *Var::make(Random::init_by_seed(123_U64)).lift;
        let pool = *TaskPool::make(3).lift;
        let arr: Array I64 = Iterator::range(0, 30).to_array;
        let f = |i| (
            let _ = *pure();
            let thr = CALL_C[U32 pthread_self()];
            let _ = *eprintln(thr.to_string + ": " + i.to_string + ": start");
            let _ = *sleep_random(rand_var);
            let _ = *eprintln(thr.to_string + ": " + i.to_string + ": end");
            pure()
        );
        let futures = *arr.map_m(
            |a| Future::make(pool, f(a))
        );
        //let _ = *arr.parallel_map_m(pool, f);
        let pool = *pool.shutdown.lift;
        let _ = *futures.map_m(
            |future| future.get.lift
        );
        let _ = *eprintln("end").lift;
        pure()
    }.try(eprintln)
);

main: IO ();
main = (
    let _ = *set_unbuffered_mode(IO::stdout);
    let _ = *set_unbuffered_mode(IO::stderr);
    test1
);
