module Main;

import Debug;
import AsyncTask;

import Tcp;
import Deque;

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);

type ChatMember = unbox struct {
    addr: String,
    messages: Deque String
};

namespace ChatMember {
    make: String -> ChatMember;
    make = |addr| ChatMember {
        addr: addr,
        messages: Deque::empty(0)
    };
}

type ChatRoom = unbox struct {
    members: Array ChatMember
};

namespace ChatRoom {
    empty: ChatRoom;
    empty = ChatRoom {
        members: []
    };
    
    add_member: ChatMember -> ChatRoom -> ChatRoom;
    add_member = |member, room| (
        room.mod_members(push_back(member))
    );

    remove_member: String -> ChatRoom -> ChatRoom;
    remove_member = |addr, room| (
        room.mod_members(|members| members.to_iter.filter(
            |member| member.@addr == addr
        ).to_array)
    );

    find_member: String -> ChatRoom -> Option ChatMember;
    find_member = |addr, room| (
        room.@members.to_iter.filter(|member| member.@addr == addr).get_first
    );

    send_message: String -> ChatRoom -> ChatRoom;
    send_message = |message, room| (
        room.mod_members(map(mod_messages(push_back(message))))
    );

    receive_message: String -> ChatRoom -> (Option String, ChatRoom);
    receive_message = |addr, room| (
        let message: Option String = do {
            let member = *room.find_member(addr);
            member.@messages.get_front
        };
        if message.is_none {
            (message, room)
        };
        let room = room.mod_members(map(|member|
            if member.@addr != addr { member };
            member.mod_messages(pop_front)
        ));
        (message, room)
    );     

    receive_message_var: String -> Var ChatRoom -> IO (Option String);
    receive_message_var = |addr, room_var| (
        room_var.lock(|room|
            let (message, room) = room.receive_message(addr);
            let _ = *room_var.Var::set(room);
            pure $ message
        )
    );
}

chat: Socket -> String -> Var ChatRoom -> IOFail ();
chat = |socket, addr, room| (
    let _ = *eprintln("chat session start: socket=" + socket.to_string).lift;
    let member = ChatMember::make(addr);
    let _ = *room.mod(add_member(member)).lift;
    let bufsock = BufferedSocket::make(socket);
    let bufsock = *bufsock.write_str("> ");
    let bufsock = *bufsock.flush;
    loop_m(
        bufsock, |bufsock|
        //let _ = *eprintln("recv start").lift;
        let (line, bufsock) = *bufsock.read_line;
        eval _usleep(1000);
        //let _ = *eprintln("read_line end: size=" + line.get_size.to_string).lift;
        if line.get_size == 0 {
            let _ = *eprintln("chat session end").lift;
            let _ = *room.mod(remove_member(addr)).lift;    // TODO: use finally
            break_m $ ()
        };
        let _ = *eprint("> " + line).lift;
        let _ = *room.mod(send_message(line)).lift;
        let bufsock = *loop_m(
            bufsock, |bufsock|
            let message = *room.receive_message_var(addr).lift;
            if message.is_none {
                break_m $ bufsock
            }; 
            let bufsock = *bufsock.write_str(message.as_some);
            continue_m $ bufsock
        );
        let bufsock = *bufsock.write_str("> ");
        let bufsock = *bufsock.flush;
        continue_m $ bufsock
    )
);

server_test: IO ();
server_test = (
    do {
        let _ = *(lift $ eprintln ("Server started"));
        let server_host_port = "127.0.0.1:2525";
        let socket = *(listen_tcp_server(server_host_port, 10));
        let _ = *(lift $ eprintln ("Listening on " + server_host_port));
        let room = *Var::make(ChatRoom::empty).lift;
        loop_m(
            (), |_|
            let _ = *(lift $ eprintln ("Accepting connections"));
            let (accepted_socket, addr) = *(socket.accept);
            let addr = addr.to_string;
            let _ = *(lift $ eprintln ("Accepted new connection: addr=" + addr));
            if false {
                let _ = *chat(accepted_socket, addr, room);
                continue_m $ ()
            } else {
                let _ = *(lift $ eprintln ("creating task"));
                let task_policy = TaskPolicy::run_after_destructed.bit_or(
                    TaskPolicy::on_dedicated_thread
                );
                let task = *AsyncIOTask::make(
                    task_policy,
                    chat(accepted_socket, addr, room)
                    .try(|err| eprintln("error: " + err))
                ).lift;
                let _ = *(lift $ eprintln ("creating task done"));
                continue_m $ ()
            }
        )
    }
    .try(|err| eprintln (err))
);

main: IO ();
main = server_test;
