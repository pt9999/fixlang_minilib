// NFA (Nondeterministic Finite Automaton)
//
// For details, see web pages below.
// - https://swtch.com/~rsc/regexp/regexp1.html
// - https://zenn.dev/canalun/articles/regexp_and_automaton

module RegExpNFA;

import Debug;

import SimpleParser;
import StringEx;

import RegExpPattern;

// matched group `(begin, end)`. -1 is invalid position.
type Group = (I64, I64);

// The array of matched groups
type Groups = Array Group;

// NFA
type NFA = unbox struct {
    nodes: Array NFANode,     // array of nodes
    initial_node: NodeID,     // initial node
    accepting_node: NodeID,   // accepting node
    group_count: I64            // group count
};

namespace NFA {
    // An empty NFA.
    empty: NFA;
    empty = NFA {
        nodes: Array::empty(0),
        initial_node: _INVALID_NODE_ID,
        accepting_node: _INVALID_NODE_ID,
        group_count: 0
    };

    // Creates new node. Returns the new node id.
    new_node: NFA -> (NFA, NodeID);
    new_node = |nfa| (
        let id = NodeID { val: nfa.@nodes.get_size };
        let node = NFANode::empty;
        let node = node.set_id(id);
        let nfa = nfa.mod_nodes(push_back(node));
        (nfa, id)
    );

    // `nfa.get_node(id)` gets the node whose @id is `id`.
    get_node: NodeID -> NFA -> NFANode;
    get_node = |id, nfa| (
        nfa.@nodes.@(id.@val)
    );

    // `nfa.mod_node(id, f)` modifies the node whose @id is `id`.
    mod_node: NodeID -> (NFANode -> NFANode) -> NFA -> NFA;
    mod_node = |id, f, nfa| (
        nfa.mod_nodes(|nodes| nodes.set(id.@val, f(nodes.@(id.@val))))
    );

    // `nfa.set_frag_output(frag, out)` sets the output of the fragment to `out`.
    set_frag_output: NFAFrag -> NodeID -> NFA -> NFA;
    set_frag_output = |frag, out, nfa| (
        (frag.@set_output)(out, nfa)
    );

    // `NFA::compile(pattern)` compiles a pattern to NFA.
    compile: Pattern -> NFA;
    compile = |pattern| (
        let nfa = NFA::empty;
        let (group_count, pattern) = pattern._assign_group_number(0);
        let nfa = nfa.set_group_count(group_count);
        let (nfa, frag) = nfa.compile_pattern(pattern);
        let nfa = nfa.set_initial_node(frag.@input);
        let (nfa, accept_id) = nfa.new_node;
        let nfa = nfa.set_accepting_node(accept_id);
        let nfa = nfa.set_frag_output(frag, accept_id);
        nfa
    );

    // `nfa.execute(target)` executes matching.
    execute: String -> NFA -> Option Groups;
    execute = |target, nfa| (
        let stream: Stream = Stream::make(target);
        let executor = NFAExecutor::make(stream, nfa);
        executor.execute
    );

}

impl NFA: ToString {
    to_string = |nfa| (
        "NFA { nodes=\n"
        + nfa.@nodes.to_iter.map(|s| "  " + s.to_string + "\n").concat_iter
        + "  initial_node=" + nfa.@initial_node.to_string + "\n"
        + "  accepting_node=" + nfa.@accepting_node.to_string + "\n"
        +"}"
    );
}

type NFANodeAction = unbox union {
    sa_none: (),
    sa_char_match: CharClass,
    sa_assert: PAssertion,
    sa_group_begin: I64,
    sa_group_end: I64
};

impl NFANodeAction: ToString {
    to_string = |a| (
        if a.is_sa_none { "none" };
        if a.is_sa_char_match { a.as_sa_char_match.to_string };
        if a.is_sa_assert { a.as_sa_assert.to_string };
        if a.is_sa_group_begin { "<g" + a.as_sa_group_begin.to_string + ">" };
        if a.is_sa_group_end { "</g" + a.as_sa_group_end.to_string + ">" };
        ""
    );
}

// An NFA node
type NFANode = unbox struct {
    id: NodeID,                // node id
    action: NFANodeAction,     // action
    output_on_action: NodeID,  // next node when the action succeeded
    output: NodeID,            // next node with empty string
    output2: NodeID,           // next node with empty string part 2
    label: String               // a label to display
};

// ID of NFA node. -1 is invalid value.
type NodeID = unbox struct {
    val: I64
};

impl NodeID: ToString {
    to_string = |a| a.@val.to_string;
}

impl NodeID: Eq {
    eq = |a, b| a.@val == b.@val;
}

namespace NFANode {
    // An invalid node ID.
    _INVALID_NODE_ID: NodeID;
    _INVALID_NODE_ID = NodeID { val: -1 };

    // An empty node
    empty: NFANode;
    empty = NFANode {
        id: _INVALID_NODE_ID,
        action: sa_none(),
        output_on_action: _INVALID_NODE_ID,
        output: _INVALID_NODE_ID,
        output2: _INVALID_NODE_ID,
        label: ""
    };
}

impl NFANode: ToString {
    to_string = |node| (
        "("
        + node.@id.to_string + ":"
        + node.@action.to_string + ":"
        + node.@output_on_action.to_string + ","
        + node.@output.to_string + ","
        + node.@output2.to_string + ":"
        + node.@label
        + ")"
    );
}


// NFA Fragment
type NFAFrag = unbox struct {
    input: NodeID,                 // node id of input of this fragment
    set_output: NodeID -> NFA -> NFA,  // a function to set node id of output
                                    // of this fragment
    label: String               // a label to display
};

namespace NFAFrag {

    // `nfa.compile_pattern(pattern)` compiles a pattern to a fragment.
    compile_pattern: Pattern -> NFA -> (NFA, NFAFrag);
    compile_pattern = |pat, nfa| (
        if pat.is_pclass {
            let action = sa_char_match (pat.as_pclass);
            nfa._compile_action(action)
        };
        if pat.is_psequence {
            let patterns = pat.as_psequence;
            if patterns.get_size == 0 {
                nfa._compile_null_sequence
            };
            if patterns.get_size == 1 {
                nfa.compile_pattern(patterns.@(0))
            };
            let (nfa, frag1) = nfa.compile_pattern(
                psequence $ patterns.pop_back);
            let (nfa, frag2) = nfa.compile_pattern(
                patterns.get_last.as_some);
            nfa._compile_seq(frag1, frag2)
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa.compile_pattern(pat2);
            nfa._compile_either(frag1, frag2)
        };
        if pat.is_pquant {
            let (pat1, min, max) = pat.as_pquant;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            if (min == 0 && max == 1) {
                nfa._compile_zero_or_once(frag1)
            };
            if (min == 0 && max == I64::maximum) {
                nfa._compile_zero_or_more(frag1)
            };
            if (min == 1 && max == I64::maximum) {
                nfa._compile_one_or_more(frag1)
            };
            if (min >= 2) {
                let (nfa, frag2) = nfa.compile_pattern(pquant $
                        (pat1, min - 1,
                            if max == I64::maximum { max } else { max - 1}
                        )
                );
                // TODO: frag1 の中にグループがあったら？
                nfa._compile_seq(frag1, frag2)
            };
            eval assert (|_|"invalid quantifier: min=" + min.to_string, false);
            (nfa, frag1)
        };
        if pat.is_pgroup {
            let (n, pat1) = pat.as_pgroup;
            let (nfa, frag0) = nfa._compile_action(sa_group_begin(n));
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa._compile_action(sa_group_end(n));
            let (nfa, frag) = nfa._compile_seq(frag0, frag1);
            let (nfa, frag) = nfa._compile_seq(frag, frag2);
            (nfa, frag)
        };
        if pat.is_passert {
            nfa._compile_action(sa_assert(pat.as_passert))
        };
        eval assert (|_|"invalid pattern:" + pat.to_string, false);
        nfa._compile_action(sa_none())
    );

    // Compiles an action to a fragment.
    _compile_action: NFANodeAction -> NFA -> (NFA, NFAFrag);
    _compile_action = |action, nfa| (
        let (nfa, id) = nfa.new_node;
        let nfa = nfa.mod_node(id, set_action(action));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_node(id, set_output_on_action(out))
            ),
            label: action.to_string
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)
    );

    // Compiles null sequence (``) to a fragment.
    _compile_null_sequence: NFA -> (NFA, NFAFrag);
    _compile_null_sequence = |nfa| (
        let (nfa, id) = nfa.new_node;
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_node(id, set_output(out))
            ),
            label: "``"
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)
    );

    // Compiles a sequence of two fragments (`e1 e2`) to a fragment.
    _compile_seq: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_seq = |frag1, frag2, nfa| (
        let nfa = nfa.set_frag_output(frag1, frag2.@input);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag2, out)
            ),
            label: frag1.@label + frag2.@label
        };
        (nfa, frag)
    );

    // Compiles an alternative of two fragments (`e1|e2`) to a fragment.
    _compile_either: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_either = |frag1, frag2, nfa| (
        let (nfa, id) = nfa.new_node;
        let nfa = nfa.mod_node(id, set_output(frag1.@input));
        let nfa = nfa.mod_node(id, set_output2(frag2.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag1, out)
                   .set_frag_output(frag2, out)
            ),
            label: frag1.@label + "|" + frag2.@label
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)

    );

    // Compiles zero or once occurrence (`e?`) to a fragment.
    _compile_zero_or_once: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_once = |frag1, nfa| (
        let (nfa, id) = nfa.new_node;
        let nfa = nfa.mod_node(id, set_output(frag1.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                let nfa = nfa.set_frag_output(frag1, out);
                nfa.mod_node(id, set_output2(out))
            ),
            label: frag1.@label + "?"
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)
    );

    // Compiles zero or more occurrence (`e*`) to a fragment.
    _compile_zero_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_node;
        let nfa = nfa.mod_node(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_node(id,set_output2(out))
            ),
            label: frag1.@label + "*"
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)
    );

    // Compiles one or more occurrence (`e+`) to a fragment.
    _compile_one_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_one_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_node;
        let nfa = nfa.mod_node(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.mod_node(id, set_output2(out))
            ),
            label: frag1.@label + "+"
        };
        let nfa = nfa.mod_node(id, set_label(frag.@label));
        (nfa, frag)
    );
}

// NFA Node set, used for NFA node transition
type NFANodeSet = unbox struct {
    ordered: Array (NodeID, Groups),   // array of node id and groups
    mask: Array Bool                    // mask whether id is contained or not
};

namespace NFANodeSet {

    // `NFANodeSet::empty(node_count)` creates an empty node set.
    // `node_count` is number of NFA nodes.
    empty: I64 -> NFANodeSet;
    empty = |node_count| NFANodeSet {
        ordered: Array::empty(node_count),
        mask:  Array::fill(node_count, false)
    };

    // Checks whether the node set is empty.
    is_empty: NFANodeSet -> Bool;
    is_empty = |node_set| (
        node_set.@ordered.is_empty
    );

    // Checks whether the node set contains a node.
    contains: NodeID -> NFANodeSet -> Bool;
    contains = |id, node_set| (
        node_set.@mask.@(id.@val)
    );

    // Adds a node to the node set.
    add: (NodeID, Groups) -> NFANodeSet -> NFANodeSet;
    add = |(id, groups), node_set| (
        if node_set.contains(id) { node_set };
        let node_set = node_set.mod_ordered(push_back((id, groups)));
        let node_set = node_set.mod_mask(set(id.@val, true));
        node_set
    );

    get_groups: NodeID -> NFANodeSet -> Option Groups;
    get_groups = |id, node_set| (
        node_set.@ordered.to_iter.filter(|(id1,_)| id1 == id)
        .get_first
        .map(|(id, groups)| groups)
    );
}

// The NFA executor
type NFAExecutor = unbox struct {
    stream: Stream,                     // stream of characters
    nfa: NFA,                           // NFA
    empty_node_set: NFANodeSet,       // an empty node set
    node_set: NFANodeSet,             // current node set
    stack: Iterator (NodeID, Groups)   // temporary stack for transition
};

namespace NFAExecutor {
    // Creates an executor.
    make: Stream -> NFA -> NFAExecutor;
    make = |stream, nfa| (
        let empty_node_set = NFANodeSet::empty(nfa.@nodes.get_size);
        let groups: Groups = Array::fill(nfa.@group_count, (-1, -1));
        let node_set = empty_node_set.add((nfa.@initial_node, groups));
        NFAExecutor {
            stream: stream,
            nfa: nfa,
            empty_node_set: empty_node_set,
            node_set: node_set,
            stack: Iterator::empty
        }
    );

    execute: NFAExecutor -> Option Groups;
    execute = |executor| (
        loop(
            executor, |executor|
            let executor = executor.transition_with_empty_string;
            if executor.@node_set.contains(executor.@nfa.@accepting_node) {
                let opt = executor.@node_set.get_groups(executor.@nfa.@accepting_node);
                eval assert (|_|"not found groups", opt.is_some);
                break $ some $ opt.as_some   // match success
                // TODO: 現状では受理状態になったらループを抜けるため、最短一致になる。
            };
            executor.@stream.advance.map_or(
                break $ none(),  // failed to match
                |(c, stream)|
                let executor = executor.transition_with_char(c);
                let executor = executor.set_stream(stream);
                eval debug_println("stream position="+stream.@position.to_string);
                continue $ executor
            )
        )
    );

    // Applies transitions with an empty string.
    transition_with_empty_string: NFAExecutor -> NFAExecutor;
    transition_with_empty_string = |executor| (
        let executor = executor._init_transition;
        loop(
            executor, |executor|
            let opt = executor._pop_stack;
            if opt.is_none {
                break $ executor
            };
            let ((id, groups), executor) = opt.as_some;
            let node = executor.@nfa.get_node(id);
            let executor = executor._transition(node.@output, groups);
            let executor = executor._transition(node.@output2, groups);
            let executor = executor._transition_on_action(node, node.@output_on_action, groups);
            continue $ executor
        )
    );

    _init_transition: NFAExecutor -> NFAExecutor;
    _init_transition = |executor| (
        executor.set_stack(executor.@node_set.@ordered.to_iter)
    );

    _pop_stack: NFAExecutor -> Option ((NodeID, Groups), NFAExecutor);
    _pop_stack = |executor| (
        executor.@stack.advance.map(|(id_groups, next)|
            (id_groups, executor.set_stack(next))
        )
    );

    // Adds node id to the node set, then pushes id to the stack.
    _transition: NodeID -> Groups -> NFAExecutor -> NFAExecutor;
    _transition = |id, groups, executor| (
        if id == _INVALID_NODE_ID {
            executor
        };
        if executor.@node_set.contains(id) {
            executor
        };
        eval debug_eprintln("transition " + id.to_string + " groups="+groups.to_string);
        executor
            .mod_node_set(add((id, groups)))
            .mod_stack(push_front((id, groups)))
    );

    // Applies transitions on an action with empty string.
    _transition_on_action: NFANode -> NodeID -> Groups -> NFAExecutor -> NFAExecutor;
    _transition_on_action = |node, id, groups, executor| (
        let action = node.@action;
        if action.is_sa_assert {
            let pa = action.as_sa_assert;
            if pa.is_pa_begin && executor.@stream.@position == 0 {
                executor._transition(id, groups)
            };
            if pa.is_pa_end && executor.@stream.@iter.is_empty {
                executor._transition(id, groups)
            };
            executor
        };
        if action.is_sa_group_begin {
            let group_idx = action.as_sa_group_begin;
            let begin = executor.@stream.@position;
            let groups = groups.set(group_idx, (begin, -1));
            executor._transition(id, groups)
        };
        if action.is_sa_group_end {
            let group_idx = action.as_sa_group_end;
            let (begin, _) = groups.@(group_idx);
            let end = executor.@stream.@position;
            let groups = groups.set(group_idx, (begin, end));
            executor._transition(id, groups)
        };
        executor
    );

    // Applies transitions with a string of one character.
    transition_with_char: U8 -> NFAExecutor -> NFAExecutor;
    transition_with_char = |char, executor| (
        let old_nodes = executor.@node_set.@ordered.to_iter;
        let executor = old_nodes.fold(
            // Clear new node set
            executor.set_node_set(executor.@empty_node_set),
            |executor, (id, groups)|
            // For each old node:
            let node = executor.@nfa.get_node(id);
            let action = node.@action;
            if !action.is_sa_char_match {
                executor
            };
            if !action.as_sa_char_match.contains(char) {
                executor
            };

            // note: stack is not used
            executor._transition(node.@output_on_action, groups)
        );
        let executor = executor.set_stack(Iterator::empty);
        executor
    );
}
