module Main;

import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.State;
import Minilib.Monad.IO;
import Minilib.Terminal.Ncurses;
import Minilib.Trait.Traversable;
import Minilib.Text.StringEx;
import Minilib.Text.Unicode;

type SIO s = StateT s IOFail;

type App = unbox struct {
    window: Window,
    rainbow: Rainbow,
    loadavg: Array F64,
    time: I64,
    status: String,
};

namespace App {
    make: [m: MonadIOFail] Window -> m App;
    make = |win| (
        let (w, h) = *win.get_window_size;
        let rainbow = *Rainbow::make;
        pure $ App {
            window: win,
            rainbow: rainbow,
            loadavg: [],
            time: 0,
            status: "",
        }
    );

    read_loadavg: [m: MonadIOFail] m F64;
    read_loadavg = (
        lift_iofail $
        with_file("/proc/loadavg", "r", |handle|
            let line = *read_line(handle);
            let fields = line.split(" ").to_array;
            let loadavg1: F64 = *fields.@(0).from_string.from_result;
            let loadavg5: F64 = *fields.@(1).from_string.from_result;
            let loadavg15: F64 = *fields.@(2).from_string.from_result;
            pure $ loadavg1
        )
    );

    collect_loadavg: I64 -> SIO App ();
    collect_loadavg = |count| (
        let value = *read_loadavg.lift_iofail;
        mod_state_(|app|
            app.mod_loadavg(|values|
                let values = values.push_back(value);
                if values.get_size <= count { values };
                values.get_sub(values.get_size - count, values.get_size)
            )
            .mod_time(add(1))
        )
    );

    render: SIO App ();
    render = (
        let app = *get_state;
        let window = app.@window;
        let (w, h) = *window.get_window_size.lift_iofail;
        let max_samples = w - 10;
        let max_bar_size = h - 3;
        collect_loadavg(max_samples);;
        let loadavg = app.@loadavg;
        let time = app.@time;
        do {
            window.clear;;
            range(0, loadavg.get_size).fold_m(
                (), |x, _|
                let xt = x + (time - loadavg.get_size);
                let color_pairs = app.@rainbow.@color_pairs;
                let cp = color_pairs.@(xt % color_pairs.get_size);
                window.set_attr(make_attr(cp, bold));;
                let sample = loadavg.@(x);
                let blocks = "▁▂▃▄▅▆▇█".to_utf32_string;
                let scale = 0.4;
                let bar_size_f = sample * scale * (max_bar_size * 8).to_F64;
                let bar_size = bar_size_f.to_I64.max(0).min(max_bar_size*8-1);
                let bar_top = bar_size % 8;
                let bar_size = (bar_size - bar_top) / 8;
                range(0, bar_size).fold_m(
                    (), |y, _|
                    window.move_add_wstr(x, h - 2 - y, "█")     // U+2588	█	FULL BLOCK
                );;
                window.move_add_str(x, h - 2 - bar_size, blocks.get_sub(bar_top, bar_top+1).to_string)
            );;
            window.set_attr(color_pair(cp_white));;
            let num = loadavg.get_last.as_some_or(0.0).to_string_precision(2_U8);
            window.move_add_str(5, 0, "loadavg: " + num);;
            window.move_add_str(5, h-1, app.@status);;
            window.refresh
        }.lift_iofail
    );
}

type Rainbow = unbox struct {
    color_pairs: Array ColorPair,
};

namespace Rainbow {
    make: [m: MonadIOFail] m Rainbow;
    make = (
        if ! *has_colors { make_rainbow_default };
        if ! *can_change_color { make_rainbow_xterm256color };
        make_rainbow_custom
    );

    make_rainbow_default: [m: MonadIOFail] m Rainbow;
    make_rainbow_default = (
        pure $ Rainbow {
            color_pairs: [ cp_white ]
        }
    );

    make_rainbow_xterm256color: [m: MonadIOFail] m Rainbow;
    make_rainbow_xterm256color = (
        let diffs = [
            (0, 1, 0),
            (-1, 0, 0),
            (0, 0, 1),
            (0, -1, 0),
            (1, 0, 0),
            (0, 0, -1),
        ];
        let diffs = diffs.to_iter.flat_map(|diff| Iterator::from_map(|_| diff).take(5));
        let (rgbs, rgb) = diffs.fold(
            ([], (5, 0, 0)), |(dr, dg, db), (rgbs, (r, g, b))|
            let rgbs = rgbs.push_back((r, g, b));
            let rgb = (r + dr, g + dg, b + db);
            (rgbs, rgb)
        );
        // xterm256color = basic 16 colors + RGB 6x6x6 colors + grayscale 24 colors,
        // so we use RGB 6x6x6 colors
        let color_pairs = rgbs.to_iter.map(|(r, g, b)|
            16 + (r * 36 + g * 6 + b)
        ).to_array;
        color_pairs.to_iter.foreach_m(|color|
            init_color_pair(color, color.to_I16, black)
        );;
        pure $ Rainbow {
            color_pairs: color_pairs
        }
    );

    make_rainbow_custom: [m: MonadIOFail] m Rainbow;
    make_rainbow_custom = (
        let custom_color_range = (16, 16 + 6 * 5);
        let (begin, end) = custom_color_range;
        range(begin, end).foreach_m(|color|
            let hue = 360.0 * (color - begin).to_F64 / (end - begin).to_F64;
            let (r, g, b) = hsv_to_rgb((hue, 1.0, 1.0));
            let to_i = |v| max(0, min(1000, (v * 1000.0).to_I64));
            init_color(color.to_I16, r.to_i, g.to_i, b.to_i);;
            init_color_pair(color, color.to_I16, black);;
            pure()
        );;
        pure $ Rainbow {
            color_pairs: range(begin, end).to_array
        }
    );

    // Converts HSV to RGB.
    //
    // # Parameters
    // * `h`: a hue (0.0 .. 360.0)
    // * `s`: a saturation (0.0 .. 1.0)
    // * `v`: a value (0.0 .. 1.0)
    // # Returns
    // `(r, g, b)`: a tuple of red/green/blue component (0.0 .. 1.0)
    hsv_to_rgb: (F64, F64, F64) -> (F64, F64, F64);
    hsv_to_rgb = |(h, s, v)| (
        let modulo = |x: F64, m: F64| (
            let x = x - (x / m).to_I64.to_F64 * m;
            if x < 0.0 { x + m } else { x }
        );
        let h = modulo(h, 360.0);
        let h = h / 60.0;
        let hf = (modulo(h, 2.0) - 1.0).abs;
        let v0 = v;
        let v1 = v * (1.0 - s * hf);
        let v2 = v * (1.0 - s);
        if h < 1.0 {
            (v0, v1, v2)
        } else if h < 2.0 {
            (v1, v0, v2)
        } else if h < 3.0 {
            (v2, v0, v1)
        } else if h < 4.0 {
            (v2, v1, v0)
        } else if h < 5.0 {
            (v1, v2, v0)
        } else {
            (v0, v2, v1)
        }
    );
}


main: IO ();
main = do {
    Ncurses::run $ |win| (
        let app = *App::make(win);
        let key_input_timeout = 100; // milliseconds
        app.@window.timeout(key_input_timeout);;
        loop_m(
            (), |_|
            App::render;;
            let key = *app.@window.get_key;
            if key == "q" || key == "^[" { break_m $ () };
            mod_state_(|app| app.set_status("key=" + key.to_string));;
            continue_m $ ()
        ).eval_state_t(app)
    )
}.try(eprintln);
