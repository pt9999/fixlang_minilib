module Minilib.Functor.EitherT;

import Minilib.Trait.Traversable;
import Minilib.Trait.Eq1;

type [f: * -> *, g: * -> *] EitherT f g a = unbox union {
    left: f a,
    right: g a,
};

// [f a: Eq, g a: Eq] というトレイト制約は書けない
impl [a: Eq, f: Eq1, g: Eq1] EitherT f g a: Eq {
    eq = |ea1, ea2| (
        match ea1 {
            left(fa1) => match ea2 {
                left(fa2) => eq1(fa1, fa2),
                right(ga2) => false,
            },
            right(ga1) => match ea2 {
                left(fa2) => false,
                right(ga2) => eq1(ga1, ga2),
            }, 
        }
    );
}

impl [f: Eq1, g: Eq1] EitherT f g: Eq1 {
    eq1 = |ea1, ea2| (
        match ea1 {
            left(fa1) => match ea2 {
                left(fa2) => eq1(fa1, fa2),
                right(ga2) => false,
            },
            right(ga1) => match ea2 {
                left(fa2) => false,
                right(ga2) => eq1(ga1, ga2),
            }, 
        }
    );
}

// TODO: impl EitherT f g a: ToString
// TODO: impl EitherT f g: ToString1

impl [f: Functor, g: Functor] EitherT f g: Functor {
    map = |h, ea| (
        match ea {
            left(fa) => left(fa.map(h)),
            right(ga) => right(ga.map(h)),
        }
    );
}

impl [f: Traversable, g: Traversable] EitherT f g: Traversable {
    sequence = |ema| (
        match ema {
            left(fma) => fma.sequence.bind(left >> pure),
            right(gma) => gma.sequence.bind(right >> pure),
        }
    );
}

/*
impl [m: Monad, n: Monad, m: Traversable, n: Traversable] EitherT m n: Monad {
    // pure(a) becomes right
    pure = |a| right(pure(a));

    bind = |f, ea| (
        match ea {
            left(ma) => left(ma.bind(f)),       // type error: ma.bind(f), since f: a -> EitherT m n b, not a -> m b
            right(na) => right(na.bind(f)),
        }
    );
}
*/
