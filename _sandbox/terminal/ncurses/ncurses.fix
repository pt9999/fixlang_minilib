module Minilib.Terminal.Ncurses;

import Minilib.Monad.IO;
import Minilib.Text.Unicode;

// Ncurses アプリケーション全体を表すオブジェクト。(ライブラリ内部で利用)
type Ncurses = unbox struct {
    dtor: Destructor ()
};

namespace Ncurses {
    // スクリーンを初期化してアプリケーションのメインルーチンを実行し、スクリーンを元の状態に戻す。
    //
    // # Parameters
    // * `runner`: 標準ウィンドウを引数に取り、アプリケーションのメインルーチンを実行する関数
    run: (Window -> IOFail ()) -> IOFail ();
    run = |runner| (
        FFI_CALL_IO[() minilib_ncurses_initialize()].lift;;
        let ncurses = Ncurses {
            dtor: *Destructor::make((), |_|
                FFI_CALL_IO[() minilib_ncurses_finialize()];;
                println("finalize done");;
                pure()
            ).lift
        };
        let win = *ncurses._get_standard_window;
        runner(win);;
        eval ncurses;
        pure()
    );

    // スクリーン全体を表す標準ウィンドウを取得する。
    _get_standard_window: [m: MonadIOFail] Ncurses -> m Window;
    _get_standard_window = |ncurses| lift_iofail $ do {
        let p_win = *FFI_CALL_IO[Ptr minilib_ncurses_get_standard_window()].lift;
        pure $ Window {
            dtor: *Destructor::make(p_win, |p_win| pure $ nullptr).lift
        }
    };

    // An error value.
    error: CInt;
    error = FFI_CALL[CInt minilib_ncurses_err()];

}

type Window = unbox struct {
    dtor: Destructor Ptr
};

namespace Window {
    // Refreshes curses windows and lines.
    // This function must be called to get actual output to the terminal, as other routines merely manipulate data structures.
    // For details, see [wrefresh(3) - Linux man page](https://linux.die.net/man/3/wrefresh).
    refresh: [m: MonadIOFail] Window -> m ();
    refresh = |win| lift_iofail $ do {
        win._check_err("refresh") $ |p_win|
        FFI_CALL_IO[CInt wrefresh(Ptr), p_win]
    };

    // Makes a sub window:
    //
    // # Parameters
    // * `x`: the left position on the screen.
    // * `y`: the top position on the screen.
    // * `w`: the number of columns.
    // * `h`: the number of lines.
    // * `parent`: the parent window.
    make_sub_window: [m: MonadIOFail] I64 -> I64 -> I64 -> I64 -> Window -> m Window;
    make_sub_window = |x, y, w, h, parent| lift_iofail $ do {
        let p_win = *parent.@dtor.borrow_io(|p_parent|
            FFI_CALL_IO[Ptr subwin(Ptr, CInt, CInt, CInt, CInt), p_parent, h.to_CInt, w.to_CInt, y.to_CInt, x.to_CInt]
        ).lift;
        let win = Window {
            dtor: *Destructor::make(p_win, |p_win|
                FFI_CALL_IO[() delwin(Ptr), p_win].when(p_win != nullptr);;
                pure $ nullptr
            ).lift
        };
        do {
            win._check_err("keypad") $ |p_win|
            FFI_CALL_IO[CInt keypad(Ptr, CInt), p_win, 1.to_CInt]
        };;
        pure $ win
    };

    get_window_size: [m: MonadIOFail] Window -> m (I64, I64);
    get_window_size = |win| lift_iofail $ do {
        let ret = *win.@dtor.borrow_io(|p_win|
            FFI_CALL_IO[CInt minilib_ncurses_get_window_size(Ptr), p_win]
        ).lift;
        let w = ret.to_I64.shift_right(16).bit_and(0xffff);
        let h = ret.to_I64.bit_and(0xffff);
        pure $ (w, h)
    };

    _check_err_i: [m: MonadIOFail] String -> Window -> (Ptr -> IO CInt) -> m CInt;
    _check_err_i = |name, win, ffi_call_io| lift_iofail $ do {
        let ret = *win.@dtor.borrow_io(|p_win| ffi_call_io(p_win)).lift;
        if ret == Ncurses::error { throw $ name + " failed!" };
        pure $ ret
    };

    _check_err: [m: MonadIOFail] String -> Window -> (Ptr -> IO CInt) -> m ();
    _check_err = |name, win, ffi_call_io| (
        let ret = *_check_err_i(name, win, ffi_call_io);
        pure() // ignore ret
    );

    clear: [m: MonadIOFail] Window -> m ();
    clear = |win| (
        win._check_err("clear") $ |p_win|
        FFI_CALL_IO[CInt erase(Ptr), p_win]
    );

    draw_border: [m: MonadIOFail] Window -> m ();
    draw_border = |win| (
        win._check_err("draw_border") $ |p_win|
        FFI_CALL_IO[CInt minilib_ncurses_draw_border(Ptr), p_win]
    );

    set_attr: [m: MonadIOFail] ChType -> Window -> m ();
    set_attr = |chtype, win| (
        win._check_err("set_attr") $ |p_win|
        FFI_CALL_IO[CInt wattrset(Ptr, U32), p_win, chtype]
    );

    set_color_pair: [m: MonadIOFail] ColorPair -> Attr -> Window -> m ();
    set_color_pair = |color_pair, attr, win| (
        win._check_err("set_color_pair") $ |p_win|
        FFI_CALL_IO[CInt wattr_set(Ptr, U32, U16, Ptr), p_win, attr, color_pair.to_U16, nullptr]
    );

    move_to: [m: MonadIOFail] I64 -> I64 -> Window -> m ();
    move_to = |x, y, win| (
        win._check_err("move_to") $ |p_win|
        FFI_CALL_IO[CInt wmove(Ptr, CInt, CInt), p_win, y.to_CInt, x.to_CInt]
    );

    add_str: [m: MonadIOFail] String -> Window -> m ();
    add_str = |str, win| (
        win._check_err("add_str") $ |p_win|
        str.borrow_c_str_io(|p_str|
            FFI_CALL_IO[CInt waddstr(Ptr, Ptr), p_win, p_str]
        )
    );

    // Moves the cursor to `(x,y)`, then write the ASCII string.
    move_add_str: [m: MonadIOFail] I64 -> I64 -> String -> Window -> m ();
    move_add_str = |x, y, str, win| (
        win._check_err("move_add_str") $ |p_win|
        str.borrow_c_str_io(|p_str|
            FFI_CALL_IO[CInt mvwaddstr(Ptr, CInt, CInt, Ptr), p_win, y.to_CInt, x.to_CInt, p_str]
        )
    );

    // Moves the cursor to `(x,y)`, then write the Unicode string.
    move_add_wstr: [m: MonadIOFail] I64 -> I64 -> String -> Window -> m ();
    move_add_wstr = |x, y, str, win| (
        win._check_err("move_add_wstr") $ |p_win|
        let wchars = utf8_to_utf32(str.get_bytes.pop_back, []).push_back(0_U32);
        wchars.borrow_boxed_io(|p_wstr|
            FFI_CALL_IO[CInt mvwaddwstr(Ptr, CInt, CInt, Ptr), p_win, y.to_CInt, x.to_CInt, p_wstr]
        )
    );

    // Reads a character from the window.
    // If any error occurs, this function returns `Ncurses::error.to_I64`.
    // For details, see [wgetch(3) - Linux man page](https://linux.die.net/man/3/wgetch).
    getch: [m: MonadIO] Window -> m I64;
    getch = |win| lift_io $ do {
        win.@dtor.borrow_io(|p_win|
            FFI_CALL_IO[CInt wgetch(Ptr), p_win]
        ).map(to_I64)
    };

    // Reads a character from the window, then convert it to a keyname.
    // For details, see [wgetch(3) - Linux man page](https://linux.die.net/man/3/wgetch) and
    // [keyname(3) - Linux man page](https://linux.die.net/man/3/keyname).
    get_key: [m: MonadIOFail] Window -> m String;
    get_key = |win| (
        let ch = *win.getch;
        if ch == Ncurses::error.to_I64 { pure $ "" };
        pure $ *keyname(ch)
    );

    // Sets timeout for `getch` and `get_key`.
    // For details, see [wtimeout(3) - Linux man page](https://linux.die.net/man/3/wtimeout).
    //
    // # Parameters
    // * `delay`: If negative, blocking read is used. If `delay` is zero, non-blocking read is used.
    //            If `delay` is positive, then read blocks for `delay` milliseconds.
    // * `win`: A Window.
    timeout: [m: MonadIOFail] I64 -> Window -> m ();
    timeout = |delay, win| (
        win._check_err("getch") $ |p_win|
        FFI_CALL_IO[CInt wtimeout(Ptr, CInt), p_win, delay.to_CInt]
    );
}

type Color = I16;

namespace Color {
    has_colors: [m: MonadIO] m Bool;
    has_colors = lift_io $ do {
        FFI_CALL_IO[CChar has_colors()]
    }.map(|c| c.to_I64 != 0);

    can_change_color: [m: MonadIO] m Bool;
    can_change_color = lift_io $ do {
        FFI_CALL_IO[CChar can_change_color()]
    }.map(|c| c.to_I64 != 0);

    get_max_colors: [m: MonadIO] m I64;
    get_max_colors = lift_io $ do {
        FFI_CALL_IO[CInt minilib_ncurses_get_max_colors()]
    }.map(to_I64);

    // Changes the definition of a color.
    //
    // # Parameters
    // * `color`: a legal color value.
    // * `r`: red components (in range 0 through 1000).
    // * `g`: green components (in range 0 through 1000).
    // * `b`: blue components (in range 0 through 1000).
    init_color: [m: MonadIOFail] Color -> I64 -> I64 -> I64 -> m ();
    init_color = |color, r, g, b| lift_iofail $ do {
        let err = *FFI_CALL_IO[CInt init_color(I16, I16, I16, I16), color.to_I16, r.to_I16, g.to_I16, b.to_I16].lift;
        if err != 0.to_CInt { throw $ "init_color failed! " + (color, r, g, b, *has_colors, *can_change_color, *get_max_colors).to_string};
        pure()
    };

    black: Color;
    black = 0_I16;

    red: Color;
    red = 1_I16;

    green: Color;
    green = 2_I16;

    yellow: Color;
    yellow = 3_I16;

    blue: Color;
    blue = 4_I16;

    magenta: Color;
    magenta = 5_I16;

    cyan: Color;
    cyan = 6_I16;

    white: Color;
    white = 7_I16;
}

type ColorPair = I64;

namespace ColorPair {
    get_max_color_pairs: [m: MonadIO] m I64;
    get_max_color_pairs = lift_io $ do {
        FFI_CALL_IO[CInt minilib_ncurses_get_max_color_pairs()]
    }.map(to_I64);

    init_color_pair: [m: MonadIOFail] ColorPair -> Color -> Color -> m ();
    init_color_pair = |color_pair, fore_color, back_color| lift_iofail $ do {
        let err = *FFI_CALL_IO[CInt init_pair(I16, I16, I16), color_pair.to_I16, fore_color.to_I16, back_color.to_I16].lift;
        if err != 0.to_CInt { throw $ "init_color_pair failed! " + (color_pair, fore_color, back_color, *get_max_color_pairs).to_string };
        pure()
    };

    color_pair: ColorPair -> ChType;
    color_pair = |i| (i.bit_and(255)).to_U32.shift_left(8_U32);

    cp_red: ColorPair;
    cp_red = 1;

    cp_green: ColorPair;
    cp_green = 2;

    cp_yellow: ColorPair;
    cp_yellow = 3;

    cp_blue: ColorPair;
    cp_blue = 4;

    cp_magenta: ColorPair;
    cp_magenta = 5;

    cp_cyan: ColorPair;
    cp_cyan = 6;

    cp_white: ColorPair;
    cp_white = 7;
}

type ChType = U32;

_ncurses_bits: ChType -> ChType -> ChType;
_ncurses_bits = |shift, mask| mask.shift_left(shift + 8_U32);

type Attr = ChType;

make_attr: ColorPair -> Attr -> ChType;
make_attr = |pair, attr| (
    color_pair(pair).bit_or(attr)
);

namespace Attr {

    normal: Attr;
    normal = 0_U32;

    underline: Attr;
    underline = 1_U32._ncurses_bits(9_U32);

    reverse: Attr;
    reverse = 1_U32._ncurses_bits(10_U32);

    blink: Attr;
    blink = 1_U32._ncurses_bits(11_U32);

    dim: Attr;
    dim = 1_U32._ncurses_bits(12_U32);

    bold: Attr;
    bold = 1_U32._ncurses_bits(13_U32);
}

type Key = I64;
type KeyName = String;

namespace Key {
    keyname: [m: MonadIOFail] Key -> m KeyName;
    keyname = |key| lift_iofail $ do {
        let ptr = *FFI_CALL_IO[Ptr keyname(CInt), key.to_CInt].lift;
        if ptr == nullptr {
            throw $ "keyname failed!"
        };
        pure $ String::unsafe_from_c_str_ptr(ptr)
    };
}
