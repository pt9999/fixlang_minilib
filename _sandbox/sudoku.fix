// 数独の問題を解くプログラム。
//
// 数独の問題は以下のような9行9列の文字列として表現する。
// 各マスは数字('1'から'9')または空き('.')とする。他の文字は無視される。
// ```
// 53..7....
// 6..195...
// .98....6.
// 8...6....
// 4..8.3..1
// 7...2...6
// .6....28.
// ...419..5
// ....8..79
// ```
module Main;

import Debug;
import Random;

import Minilib.Math.RandomEx;
import Minilib.Text.StringEx;

// ------------------------------------------------------------
// ヘルパー定義
// ------------------------------------------------------------

// デバッグメッセージを出力する
debug_lazy: Lazy String -> ();
debug_lazy = |lazy_str| (
    if false { debug_println(lazy_str()) }
    else { () }
);

debug_lazy2: Lazy String -> ();
debug_lazy2 = |lazy_str| (
    if true { debug_println(lazy_str()) }
    else { () }
);

// バイト配列を文字列に変換する
bytes_to_string: Array U8 -> String;
bytes_to_string = |bytes| bytes.push_back(0_U8)._unsafe_from_c_str;

// 文字列に含まれる文字のうち、指定した条件を満たす文字だけを残す
filter_chars: (U8 -> Bool) -> String -> String;
filter_chars = |f, str| (
    str.get_bytes.pop_back.to_iter.filter(f).to_array.bytes_to_string
);

// ------------------------------------------------------------
//  盤面の管理
// ------------------------------------------------------------

// 数字 (1 から 9)
type Digit = U8;

// 盤面 (9 x 9 マス)
type Board = unbox struct {
    data: Array (Option Digit)      // 9 x 9
};

namespace Board {
    // 初期状態の盤面
    empty: Board;
    empty = Board {
        data: Array::fill(9 * 9, none())
    };

    // 指定したマスの数字を取得する
    get_digit: I64 -> I64 -> Board -> Option Digit;
    get_digit = |row, col, board| board.@data.@(row * 9 + col);

    // 指定したマスの数字を設定する
    set_digit: I64 -> I64 -> Option Digit -> Board -> Board;
    set_digit = |row, col, digit, board| board.mod_data(set(row * 9 + col, digit));

    // 数字が配置されたマスの数を数える
    get_digit_count: Board -> I64;
    get_digit_count = |board| (
        board.@data.to_iter.map(|digit| if digit.is_some { 1 } else { 0 })
        .fold(0, add)
    );

    // 数字が配置されていないマスのイテレータを返す
    get_empty_cells: Board -> Iterator (I64, I64);
    get_empty_cells = |board| (
        let row = *Iterator::range(0, 9);
        let col = *Iterator::range(0, 9);
        if board.get_digit(row, col).is_some { Iterator::empty };
        pure $ (row, col)
    );
}

// 数独の問題を表す文字列から盤面を読み込む。
impl Board: FromString {
    from_string = |problem| (
        let board = Board::empty;
        // 問題を行に分割し、数字(1から9)と空き('.')以外の文字を除去する。空行も除去する。
        let lines = problem.split("\n").map(
            filter_chars(|c| ('1' <= c && c <= '9') || c == '.')
        ).filter(|s| s != "").to_array;
        // 9行9列であることを確認する。
        if lines.get_size != 9 { err $ "invalid row size" };
        let _ = *lines.to_iter.fold_m(
            (), |_, line|
            if line.get_size != 9 { err $ "invalid col size" };
            ok()
        );
        Iterator::range(0, 9).fold_m(board, |board, row|
            Iterator::range(0, 9).fold_m(board, |board, col|
                let line = lines.@(row);
                let c = line.get_bytes.@(col);
                let digit = if '1' <= c && c <= '9' { some(c - '1' + 1_U8) } else { none() };
                let board = board.set_digit(row, col, digit);
                pure $ board
            )
        )
    );
}

impl Board: ToString {
    to_string = |board| (
        Iterator::range(0, 9).map(|row|
            Iterator::range(0, 9).map(|col|
                let digit = board.get_digit(row, col);
                if digit.is_none { '.' } else { digit.as_some - 1_U8 + '1' }
            ).to_array.bytes_to_string
        ).join("\n")
    );
}

// ------------------------------------------------------------
//  配置可能候補の管理
// ------------------------------------------------------------

// 特定のマスに数字を置けるかどうかを表わすビットベクトル。
// bit i の意味は次のいずれか。(i = 1..9)
// 1: 配置可能、0: 配置不可
type BitVec = U16;

namespace BitVec {
    // すべての数字が配置可能であるビットベクトル。
    full: BitVec;
    full = 0b1111111110_U16;    //  bit 1..9

    // すべての数字が配置できないビットベクトル。
    empty: BitVec;
    empty = 0_U16;

    // i 番目のビットを取得する。
    get_bit: I64 -> BitVec -> Bool;
    get_bit = |i, vec| vec.bit_and(1_U16.shift_left(i.to_U16)) != 0_U16;

    // i 番目のビットを設定する。
    set_bit: I64 -> Bool -> BitVec -> BitVec;
    set_bit = |i, b, vec| (
        if b { vec.bit_or(1_U16.shift_left(i.to_U16)) }
        else { vec.bit_and(U16::maximum - 1_U16.shift_left(i.to_U16)) }
    );

    // 1 (配置可能) の数を数える。
    count_ones: BitVec -> I64;
    count_ones = |vec| (
        let vec = vec.bit_and(0xaaaa_U16).shift_right(1_U16) + vec.bit_and(0x5555_U16);
        let vec = vec.bit_and(0xcccc_U16).shift_right(2_U16) + vec.bit_and(0x3333_U16);
        let vec = vec.bit_and(0xf0f0_U16).shift_right(4_U16) + vec.bit_and(0x0f0f_U16);
        let vec = vec.bit_and(0xff00_U16).shift_right(8_U16) + vec.bit_and(0x00ff_U16);
        vec.to_I64
    );

    // 配置可能な数字のイテレータを返す。
    to_iter: BitVec -> Iterator I64;
    to_iter = |vec| (
        Iterator::range(1, 9 + 1).filter(|digit| vec.get_bit(digit))
    );
}

// 9 x 9 マスの配置可能候補を管理する
type Candidates = unbox struct {
    data: Array BitVec  // 9 x 9
};

namespace Candidates {
    //  初期状態(すべての数字を配置可能)
    full: Candidates;
    full = Candidates {
        data: Array::fill(9 * 9, BitVec::full)
    };

    // 指定したセルの配置可能候補を取得する
    get: I64 -> I64 -> Candidates -> BitVec;
    get = |row, col, cand| cand.@data.@(row * 9 + col);

    // 指定したセルの配置可能候補を更新する
    mod: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod = |row, col, f, cand| (
        let cand = cand.mod_data(mod(row * 9 + col, f));
        cand
    );

    // 指定した行全体の配置可能候補を更新する
    mod_row: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_row = |row, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, col| cand.mod(row, col, f)
    );

    // 指定した列全体の配置可能候補を更新する
    mod_col: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_col = |col, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, row| cand.mod(row, col, f)
    );

    // 指定したマスを含むブロックの配置可能候補を更新する
    mod_block: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_block = |row, col, f, cand| (
        let top = row / 3 * 3;
        let left = col / 3 * 3;
        Iterator::range(0, 9).fold(
            cand, |cand, i| cand.mod(top + i / 3, left + i % 3, f)
        )
    );

    // 指定したマスを含む行、列、ブロックの配置可能候補を更新する
    mod_all: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_all = |row, col, f, cand| (
        cand.mod_row(row, f)
        .mod_col(col, f)
        .mod_block(row, col, f)
    );

    // 盤面をもとに配置可能候補を初期化する
    init_with_board: Board -> Candidates;
    init_with_board = |board| (
        let cand = Candidates::full;
        Iterator::range(0, 9).fold(cand, |cand, row|
            Iterator::range(0, 9).fold(cand, |cand, col|
                let digit = board.get_digit(row, col);
                if digit.is_none { cand };
                cand.mod_all(row, col, set_bit(digit.as_some.to_I64, false))
            )
        )
    );

    // まだ数値が配置されていないマスのうち、候補数が最も少ないマスを求める。
    // 成功時は `some(候補数, 行, 列)` が返る。
    // 候補数は0の場合もある。(そのマスにはどの数字も配置できないことを意味する)
    // 全てのマスに数字が配置されているときは `none()` が返る。
    find_best_cell: Board -> Candidates -> Option (I64, I64, I64);
    find_best_cell = |board, cand| (
        let best: Option (I64, I64, I64) = none();
        Iterator::range(0, 9).fold(best, |best, row|
            Iterator::range(0, 9).fold(best, |best, col|
                let digit = board.get_digit(row, col);
                if digit.is_some { best };
                let bitvec = cand.get(row, col);
                let num_cand = bitvec.count_ones;
                let best = if best.is_none || best.as_some.@0 > num_cand {
                    some $ (num_cand, row, col)
                } else { best };
                best
            )
        )
    );
}

// ------------------------------------------------------------
//  数独を解く
// ------------------------------------------------------------

// 盤面と配置可能候補の状態
type BoardState = unbox struct {
    board: Board,
    candidates: Candidates,
    digit_count: I64                       // 配置済みの数字の数
};

namespace BoardState {
    // 空の盤面状態
    empty: BoardState;
    empty = BoardState {
        board: Board::empty,
        candidates: Candidates::full,
        digit_count: 0
    };

    // 問題を読み込む。
    load_problem: String -> Result ErrMsg BoardState;
    load_problem = |problem| (
        let board: Board = *from_string(problem);
        pure $ BoardState::init_with_board(board)
    );

    // 盤面をもとに状態を初期化する。
    init_with_board: Board -> BoardState;
    init_with_board = |board| (
        let candidates = Candidates::init_with_board(board);
        let digit_count = board.get_digit_count;
        BoardState {
            board: board,
            candidates: candidates,
            digit_count: digit_count
        }
    );

    // 指定したセルに数字を配置する。
    place_digit: I64 -> I64 -> I64 -> BoardState -> BoardState;
    place_digit = |row, col, digit, state| (
        eval assert(|_| "digit is already set", state.@board.get_digit(row, col).is_none);
        eval debug_lazy(|_| [state.@digit_count, digit, row, col].format("{}: place {} at ({}, {})"));
        let state = state.mod_board(set_digit(row, col, some(digit.to_U8)));
        let state = state.mod_candidates(mod_all(row, col, set_bit(digit, false)));
        let state = state.mod_digit_count(add(1));
        state
    );
}

impl BoardState: ToString {
    to_string = |state| state.@board.to_string;
}

namespace Solver {
    // 数独の問題を解く。
    solve: BoardState -> Result ErrMsg (Array BoardState);
    solve = |state| (
        let solutions = [];
        let stack = [state];
        _solve_inner(stack, 0, solutions)
    );

    _solve_inner: Array BoardState -> I64 -> Array BoardState -> Result ErrMsg (Array BoardState);
    _solve_inner = |stack, step, solutions| (
        let step = step + 1;
        if step >= 100000 { err $ "too may steps" };
        if solutions.get_size >= 10 { err $ "too may solutions" };
        if stack.is_empty { ok $ solutions };
        let state = stack.get_last.as_some;
        let stack = stack.pop_back;
        eval debug_lazy(|_| [state.@digit_count, stack.get_size].format("{}: _solve_inner: stack size={}"));
        if state.@digit_count >= 9 * 9 {
            // success
            eval debug_lazy(|_| "found a solution");
            let solutions = solutions.push_back(state);
            _solve_inner(stack, step, solutions)
        };
        let best = state.@candidates.find_best_cell(state.@board);
        if best.is_none {
            // failed
            eval debug_lazy(|_| [state.@digit_count].format("{}: no candidates"));
            _solve_inner(stack, step, solutions)
        };
        let (num_cand, row, col) = best.as_some;
        if num_cand == 0 {
            // failed
            eval debug_lazy(|_| (state.@digit_count, row, col).format("{}: no candidates at ({}, {})"));
            _solve_inner(stack, step, solutions)
        };

        let bitvec = state.@candidates.get(row, col);
        eval debug_lazy(|_| (state.@digit_count, num_cand, (row, col), bitvec).format("{}: find {} candidates at {} = {}"));
        let stack = Iterator::range(0, 9).fold(stack, |stack, digit|
            let digit = digit + 1;
            if bitvec.get_bit(digit) == false { stack };
            let stack = stack.push_back(state.place_digit(row, col, digit));
            stack
        );
        _solve_inner(stack, step, solutions)
    );
}

type Generator = unbox struct {
    num_digits_to_place: I64,
    state: BoardState,
    problem: Option BoardState,
    random: Random,
    step: I64
};

namespace Generator {
    generate_problem: I64 -> Random -> Result ErrMsg (BoardState, Random);
    generate_problem = |num_digits_to_place, random| (
        let gen = Generator {
            num_digits_to_place: num_digits_to_place,
            state: BoardState::empty,
            problem: none(),
            random: random,
            step: 0
        };
        let gen = *gen._generate_loop;
        if gen.@problem.is_none {
            err $ "Could not generate problem"
        };
        ok $ (gen.@problem.as_some, gen.@random)
    );

    _generate_loop: Generator -> Result ErrMsg Generator;
    _generate_loop = |gen| (
        loop_m(
            gen, |gen|
            let gen = gen.mod_step(add(1));
            if gen.@step >= 100000 { err $ "too many steps" };
            let state = gen.@state;
            let cells_to_place = gen.@num_digits_to_place - state.@digit_count;
            eval debug_lazy2(|_| [state.@digit_count, cells_to_place].format(
                "{}: _generate_loop: cells_to_place={}"));
            if cells_to_place <= 0 {
                eval debug_lazy2(|_| [state.@digit_count].format("{}: solving..."));
                let res = Solver::solve(state);
                if res.is_err {
                    eval debug_lazy2(|_| (state.@digit_count, res.as_err).format("{}: solving: err={}"));
                    // not found solution
                    let gen = gen.set_state(BoardState::empty); // restart
                    continue_m $ gen
                };
                let solutions = res.as_ok;
                eval debug_lazy2(|_| [state.@digit_count, solutions.get_size].format("{}: solving: solution count={}"));
                if solutions.get_size != 1 {
                    // not found solution or too many solutions
                    let gen = gen.set_state(BoardState::empty); // restart
                    continue_m $ gen
                };
                // found problem with one solution
                let gen = gen.set_problem(some(state));
                break_m $ gen
            };
            let random = gen.@random;
            let (res, random) = random._place_random_digit(state);
            let gen = gen.set_random(random);
            if res.is_err {
                let gen = gen.set_state(BoardState::empty); // restart
                continue_m $ gen
            };
            let state = res.as_ok;
            let gen = gen.set_state(state);
            continue_m $ gen
        )
    );

    _place_random_digit: BoardState -> Random -> (Result ErrMsg BoardState, Random);
    _place_random_digit = |state, random| (
        eval assert(|_| "board is full", state.@digit_count < 9 * 9);
        let empty_cells = state.@board.get_empty_cells;
        let empty_cells = empty_cells.map(|(row, col)|
            let bitvec = state.@candidates.get(row, col);
            (bitvec, row, col)
        );
        let empty_cells = empty_cells.filter(|(bitvec, row, col)|
            bitvec != BitVec::empty
        );
        let empty_cells = empty_cells.to_array;
        if empty_cells.get_size == 0 {
            eval debug_lazy2(|_| [state.@digit_count].format("{}: cannot place any digit"));
            (err $ "cannot place any digit", random)
        };

        let (i, random) = random.generate_I64_range(0, empty_cells.get_size);
        let (bitvec, row, col) = empty_cells.@(i);
        let cands = bitvec.to_iter.to_array;
        eval assert (|_| "no cands", cands.get_size > 0);
        let (i, random) = random.generate_I64_range(0, cands.get_size);
        let digit = cands.@(i);
        eval debug_lazy2(|_| (state.@digit_count, digit, (row, col)).format("{}: place digit {} at {}"));
        let state = state.place_digit(row, col, digit);
        (ok $ state, random)
    );
}

// ------------------------------------------------------------
//  テストケース
// ------------------------------------------------------------

problem1: String;
problem1 = "
    53..7....
    6..195...
    .98....6.
    8...6....
    4..8.3..1
    7...2...6
    .6....28.
    ...419..5
    ....8..79
";

test1: IO ();
test1 = do {
    let state = *BoardState::load_problem(problem1).from_result;
    let solutions = *Solver::solve(state).from_result;
    let _ = *println([solutions.get_size].format("Found {} solutions:")).lift;
    solutions.to_iter.fold_m(
        (), |_, state|
        println("\n" + state.to_string).lift
    )
}.try(eprintln);

test2: IO ();
test2 = do {
    let _ = *pure();
    //let time = CALL_C[I32 time(Ptr), nullptr];
    let time = 123;
    let random = Random::init_by_seed(time.to_U64);
    let num_digits_to_place = 60;
    let (state, random) = *Generator::generate_problem(num_digits_to_place, random).from_result;
    let _ = *println("Problem:\n" + state.to_string).lift;
    let solutions = *Solver::solve(state).from_result;
    let _ = *println([solutions.get_size].format("Found {} solutions:")).lift;
    solutions.to_iter.fold_m(
        (), |_, state|
        println("\n" + state.to_string).lift
    )
}.try(eprintln);

main: IO ();
main = test2;
