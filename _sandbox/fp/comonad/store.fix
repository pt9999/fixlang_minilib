module Minilib.Comonad.Store;

import Minilib.Comonad.IdentityC;
import Minilib.Trait.Comonad;

// A trait for the interface of store comonads.
trait ComonadStore = Comonad + ComonadStoreIF;

// A trait for the store comonads.
//
// Minimum definition: `PositionType`, `pos`, `peek`
trait [sw: * -> *] sw: ComonadStoreIF {
    // The type of the position.
    type PositionType sw;

    // Gets the current position.
    pos: sw a -> PositionType sw;

    // Peeks the value at the specified position.
    peek: PositionType sw -> sw a -> a;

    // Peeks the value at the position relative to the current position.
    peeks: (PositionType sw -> PositionType sw) -> sw a -> a;

    // Seeks the current position to the specified position.
    seek: PositionType sw -> sw a -> sw a;

    // Seeks the current position with the specified function.
    seeks: (PositionType sw -> PositionType sw) -> sw a -> sw a;

    // Takes measurements at various positions.
    experiment: [f: Functor] (PositionType sw -> f (PositionType sw)) -> sw a -> f a;
}

namespace ComonadStore {
    namespace Default {
        // default implementation of `peeks`.
        default_peeks: [sw: ComonadStore] (PositionType sw -> PositionType sw) -> sw a -> a;
        default_peeks = |f, store| (
            let p = store.pos;
            store.peek(f(p))
        );

        // default implementation of `seek`.
        default_seek: [sw: ComonadStore] PositionType sw -> sw a -> sw a;
        default_seek =  |p, store| store.duplicate.peek(p);

        // default implementation of `seeks`.
        default_seeks: [sw: ComonadStore] (PositionType sw -> PositionType sw) -> sw a -> sw a;
        default_seeks =  |f, store| store.duplicate.peek(f(store.pos));

        // default implementation of `experiment`.
        default_experiment: [f: Functor, sw: ComonadStore] (PositionType sw -> f (PositionType sw)) -> sw a -> f a;
        default_experiment = |g, store| g(store.pos).map(|p| store.peek(p));
    }
}

// StoreT comonad.
type [w: * -> *] StoreT p w a = unbox struct {
    data: (p, w (p -> a))
};

// Store comonad.
type Store p a = StoreT p IdentityC a;

// Creates a store from a position and a comonad of a value function.
//
// # Parameters
// - `pair`: a position and a comonad of a value function.
store_t: [w: * -> *] (p, w (p -> a)) -> StoreT p w a;
store_t = |data| StoreT { data: data };

// Creates a store from a position and a value function.
//
// # Parameters
// - `pair`: a position and a value function.
store: (p, (p -> a)) -> Store p a;
store = |(p, f)| store_t $ (p, IdentityC::make(f));

// Runs a StoreT comonad.
run_store_t: [w: * -> *] StoreT p w a -> (p, w (p -> a));
run_store_t = |store| store.@data;

// Runs a Store comonad.
run_store: Store p a -> (p, p -> a);
run_store = |store| (
    let (p, wf) = store.@data;
    (p, wf.extract)
);

// Gets the current position and the value.
get: [w: Comonad] StoreT p w a -> (p, a);
get = |store| (store.pos, store.extract);

impl [w: Functor] StoreT p w: Functor {
    map = |g, swa| (
        let (p, wf) = swa.run_store_t;
        store_t $ (p, wf.map(map(g)))
    );
}

impl [w: Comonad] StoreT p w: Comonad {
    extract = |store| (
        let (p, wf) = store.run_store_t;
        (wf.extract)(p)
    );
    extend = |g, store| (
        let (p, wfb) = store.run_store_t;
        let wfa = wfb.extend(|wfb|
            |pos| g $ store_t $ (pos, wfb)
        );
        store_t $ (p, wfa)
    );
}

impl [w: Comonad] StoreT p w: ComonadStoreIF {
    type PositionType (StoreT p w) = p;

    pos = |store| (
        let (p, wf) = store.run_store_t;
        p
    );
    peek = |p, store| (
        let (_, wf) = store.run_store_t;
        (wf.extract)(p)
    );
    peeks = ComonadStore::Default::default_peeks;
    seek = ComonadStore::Default::default_seek;
    seeks = ComonadStore::Default::default_seeks;
    experiment = ComonadStore::Default::default_experiment;
}
