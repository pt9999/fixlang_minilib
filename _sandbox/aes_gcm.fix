// AES-GCM
// NIST Special Publication 800-38D
// Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC
// https://doi.org/10.6028/NIST.SP.800-38D
module Main;

import Debug;
import Random;

import Minilib.Encoding.Binary;
import Minilib.Crypto.AES;
import Minilib.Math.RandomEx;
import Minilib.Text.Hex;

import Sandbox.Cipher;
//import Sandbox.StateT;


// a 128bit block.
type Block = unbox struct {
  hi: U64,
  lo: U64
};

impl Block: ToStringHex {
    to_string_hex = |block| block.@hi.to_string_hex + block.@lo.to_string_hex;
}

namespace Block {
    // `Block::make(hi, lo)` creates a 128bit block.
    make: U64 -> U64 -> Block;
    make = |hi, lo| (
        Block { hi: hi, lo: lo }
    );

    get_block_be: I64 -> Array U8 -> Block;
    get_block_be = |i, array| (
        let hi = array.get_u64_be(i);
        let lo = array.get_u64_be(i + 8);
        Block { hi: hi, lo: lo }
    );

    set_block_be: I64 -> Block -> Array U8 -> Array U8;
    set_block_be = |i, block, array| (
        array.set_u64_be(i, block.@hi)
             .set_u64_be(i + 8, block.@lo)
    );

    // 6.1 Basic operation and functions
    _zero: Block;
    _zero = Block { hi: 0_U64, lo: 0_U64 };

    _xor: Block -> Block -> Block;
    _xor = |x, y| (
        Block {
            hi: x.@hi.bit_xor(y.@hi),
            lo: x.@lo.bit_xor(y.@lo)
        }
    );

    _shift_right_1: Block -> Block;
    _shift_right_1 = |x| (
        let hi = x.@hi.shift_right(1_U64);
        let lo = x.@lo.shift_right(1_U64);
        let lo = if x.@hi.bit_and(1_U64) == 0_U64 { lo } else { lo.bit_or(1_U64.shift_left(31_U64)) };
        Block { hi: hi, lo: lo }
    );

    _is_bit_set: I64 -> Block -> Bool;
    _is_bit_set = |i, x| (
        if i < 64 { x.@hi.bit_and(1_U64.shift_left((63 - i).to_U64)) != 0_U64 };
        if i < 128 { x.@lo.bit_and(1_U64.shift_left((127 - i).to_U64)) != 0_U64 };
        false
    );

    // 6.3 Multiplication operation of Blocks
    _mul: Block -> Block -> Block;
    _mul = |x, y| (
        let z = _zero;
        let v = y;
        loop(
            (z, v, 0), |(z, v, i)|
            if i > 127 { break $ z };
            let z = if x._is_bit_set(i) { z._xor(v) } else { z };
            let v = if v._is_bit_set(127) { v._shift_right_1._xor(_R) } else { v._shift_right_1 };
            continue $ (z, v, i + 1)
        )
    );

    _R: Block;
    _R = Block { hi: 0b11100001_U64.shift_left(56_U64), lo: 0_U64 };

    // 6.4 GHASH function
    _GHASH: Block -> Iterator Block -> Block;
    _GHASH = |h, xs| (
        xs.fold(_zero, |y, x| y._xor(x)._mul(h))
    );

    // 6.5 GCTR function
    //_GCTR: [bc: BlockCipher] bc ->
}

test_ghash: IO ();
test_ghash = (
    let h = Block::make(0x112233_U64, 0x223344_U64);
    let xs = [
        Block::make(0x123123_U64, 0x234234_U64),
        Block::make(0x123124_U64, 0x234235_U64)
    ].to_iter;
    let hash = _GHASH(h, xs);
    println(hash.to_string_hex)
);


// Carryless Multiplication
// NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB

_clmul_u8_u8_table: Array U16;
_clmul_u8_u8_table = Array::from_map(256 * 256, |pos|
    let a = pos.shift_left(0).bit_and(0xff00).to_U16;
    let b = pos.shift_left(8).bit_and(0xff00).to_U16;
    let c = 0_U16;
    loop(
        (c, a, 0), |(c, a, i)|
        if i >= 8 { break $ c };
        let c = if b.shift_right((15 - i).to_U16).bit_and(1_U16) != 0_U16 {
            c.bit_xor(a)
        } else { c };
        let a = a.shift_right(1_U16);
        continue $ (c, a, i + 1)
    )
);

_clmul_u8_u8: U8 -> U8 -> U16;
_clmul_u8_u8 = |a, b| (
    let pos = a.to_I64.shift_left(8).bit_or(b.to_I64);
    _clmul_u8_u8_table.@(pos)
);

_clmul_u16_u16: U16 -> U16 -> U32;
_clmul_u16_u16 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U8;
    let x0 = x.shift_right(8_U16).to_U8;
    let y1 = y.to_U8;
    let y0 = y.shift_right(8_U16).to_U8;
    let z2 = _clmul_u8_u8(x1, y1);
    let z0 = _clmul_u8_u8(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u8_u8(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U32.bit_xor(z1.to_U32.shift_left(8_U32)).bit_xor(z0.to_U32.shift_left(16_U32));
    z
);

_clmul_u32_u32: U32 -> U32 -> U64;
_clmul_u32_u32 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U16;
    let x0 = x.shift_right(16_U32).to_U16;
    let y1 = y.to_U16;
    let y0 = y.shift_right(16_U32).to_U16;
    let z2 = _clmul_u16_u16(x1, y1);
    let z0 = _clmul_u16_u16(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u16_u16(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U64.bit_xor(z1.to_U64.shift_left(16_U64)).bit_xor(z0.to_U64.shift_left(32_U64));
    z
);


test_clmul_u8_u8: IO ();
test_clmul_u8_u8 = (
    let print_row = |a:I64| println $ do {
        let b = *Iterator::range(0, 16);
        let c = _clmul_u8_u8(a.to_U8, b.to_U8);
        pure $ c.to_string_hex
    }.join(" ");
    Iterator::range(0, 16).fold_m(
        (), |_, a|
        print_row(a)
    )
);

test_clmul_u32_u32_1: Random -> IO Random;
test_clmul_u32_u32_1 = |random| (
    let trace_mul = |a, b| (
        let c = _clmul_u32_u32(a, b);
        eval *println(a.to_string_hex + " * " + b.to_string_hex + " = " + c.to_string_hex);
        pure $ c
    );
    let (a1, random) = random.generate_U32;
    let (b1, random) = random.generate_U32;
    let (a2, random) = random.generate_U32;
    let (b2, random) = random.generate_U32;
    let c11 = *trace_mul(a1, b1);
    let c12 = *trace_mul(a1, b2);
    let c21 = *trace_mul(a2, b1);
    let c22 = *trace_mul(a2, b2);
    let expected = c11.bit_xor(c12).bit_xor(c21).bit_xor(c22);
    let actual = *trace_mul(a1.bit_xor(a2), b1.bit_xor(b2));
    eval assert_eq(|_|
        "mismatch: " + [a1, b2, a2, b2].map(to_string_hex).to_string,
        expected, actual);
    pure $ random
);

test_clmul_u32_u32: IO ();
test_clmul_u32_u32 = (
    let random = Random::init_by_seed(123_U64);
    let random = *Iterator::range(0, 16).fold_m(
        random, |random, i|
        test_clmul_u32_u32_1(random)
    );
    pure()
);

main: IO ();
//main = test_clmul_u32_u32;
main = test_ghash;


