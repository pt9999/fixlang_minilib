module Minilib.Crypto.Cert.X509Signature;

import Debug;
import HashMap;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.Pem;
import Minilib.Crypto.Cert.OID;
import Minilib.Crypto.Cert.Pkcs1;
import Minilib.Crypto.ECDSA;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
//import Minilib.Thread.Time;
//import Minilib.Testing.UnitTest;

validate_signature: SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature = |public_key, certificate| (
    let signature_algorithm: AlgorithmIdentifier = certificate.@signature_algorithm;
    let options = signature_algorithm._find_emsa_pkcs1_options;
    if options.is_some {
        validate_signature_pkcs1_v1_5(options.as_some, public_key, certificate)
    };
    let ecdsa_scheme = signature_algorithm._find_ecdsa_scheme;
    if ecdsa_scheme.is_some {
        validate_signature_ecdsa(ecdsa_scheme.as_some, public_key, certificate)
    };

    err $ "Not supported signature algorithm: " + certificate.@signature_algorithm.to_string
);

_find_emsa_pkcs1_options: AlgorithmIdentifier -> Option EmsaPkcs1Options;
_find_emsa_pkcs1_options = |signature_algorithm| (
    if signature_algorithm.match_name("sha-1WithRSAEncryption") {
        some $ Pkcs1::emsa_pkcs1_options_sha1
    };
    if signature_algorithm.match_name("sha256WithRSAEncryption") {
        some $ Pkcs1::emsa_pkcs1_options_sha256
    };
    if signature_algorithm.match_name("sha384WithRSAEncryption") {
        some $ Pkcs1::emsa_pkcs1_options_sha384
    };
    if signature_algorithm.match_name("sha512WithRSAEncryption") {
        some $ Pkcs1::emsa_pkcs1_options_sha512
    };
    none()
);

_find_ecdsa_scheme: AlgorithmIdentifier -> Option ECDSAScheme;
_find_ecdsa_scheme = |signature_algorithm| (
    if signature_algorithm.match_name("ecdsa-with-SHA256") {
        some $ ECDSAScheme::ecdsa_secp256r1_sha256
    };
    if signature_algorithm.match_name("ecdsa-with-SHA384") {
        some $ ECDSAScheme::ecdsa_secp384r1_sha384
    };
    none()
);

validate_signature_pkcs1_v1_5: EmsaPkcs1Options -> SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature_pkcs1_v1_5 = |options, public_key, certificate| (
    let (n, e) = *public_key.get_rsa_public_key;
    let message = certificate.@tbs_certificate_bytes;
    let signature = certificate.@signature_value.@data;
    Pkcs1::rsassa_pkcs1_v1_5_verify((n, e), message, signature, options)
);


validate_signature_ecdsa: ECDSAScheme -> SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature_ecdsa = |ecdsa_scheme, public_key, certificate| (
    let (ecdsa_scheme, ec_point) = *get_ec_point_from_public_key(ecdsa_scheme, public_key);
    // Validate signature
    let message = certificate.@tbs_certificate_bytes;
    let sig_value: EcdsaSigValue = *decode_der_from_bytes(certificate.@signature_value.@data);
    //eval debug_eprintln("sig_value="+ sig_value.to_string);
    let signature: ECDSASignature = ECDSASignature { r: sig_value.@r, s: sig_value.@s };
    ecdsa_scheme.verify(ec_point, signature, message)
);

get_ec_point_from_public_key: ECDSAScheme -> SubjectPublicKeyInfo -> Result ErrMsg (ECDSAScheme, ECPoint);
get_ec_point_from_public_key = |ecdsa_scheme, public_key| (
    let pubkey_algorithm: AlgorithmIdentifier = public_key.@algorithm;
    if !pubkey_algorithm.match_name("id-ecPublicKey") {
        err $ "Public_key algorithm does not match `id-ecPublicKey`: " + pubkey_algorithm.to_string
    };

    // Check for named curve matches
    let named_curve: ObjectIdentifier = *decode_der_from_bytes(pubkey_algorithm.@parameters);
    //eval debug_eprintln("named_curve="+ named_curve.to_string_with_name);
    let ecdsa_scheme = *if named_curve.match_name(ecdsa_scheme.@ec.@id) { pure $ ecdsa_scheme }
    else {
        // Some certificates uses ecdsa-with-SHA256 but its public key uses secp384r1,
        // so let's change the named curve.
        // I don't know whether it is OK, but that cerficate passes the validation.
        let name = named_curve.get_name.as_some_or("");
        let ec = _find_ec_param(name);
        if ec.is_none { err $ "Named curve not found: " + name };
        //eval debug_eprintln("changing ecdsa_scheme to use " + name);
        pure $ ecdsa_scheme.set_ec(ec.as_some)
    };
    let ec = ecdsa_scheme.@ec;

    // Decode ec_point
    let ec_point: Array U8 = public_key.@subject_public_key.@data;
    //eval debug_eprintln("ec_point="+ ec_point.to_string_hex);
    let ec_point: ECPoint = *from_bytes_ec(ec, ec_point);

    pure $ (ecdsa_scheme, ec_point)
);

_find_ec_param: String -> Option ECParam;
_find_ec_param = |name| (
    if name == "secp256r1" { some $ ECParam::secp256r1 };
    if name == "secp384r1" { some $ ECParam::secp384r1 };
    none()
);

