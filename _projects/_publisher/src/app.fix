module Publisher.App;

import Minilib.App.Clap;
import Minilib.Monad.Reader;

import Publisher.Env;
import Publisher.AppEnv;
import Publisher.Logger;
import Publisher.Publish;

// TODO: move to Minilib.App.Clap
namespace ClapEx {
    namespace Command {
        empty: Command;
        empty = Command::new("");
    }
    type CommandRunner = ArgMatches -> IOFail ();

    get_flag: String -> ArgMatches -> Bool;
    get_flag = |name, matches| (
        matches.get_one(name) == some("true")
    );

    handle_subcommands: Array (Command, CommandRunner) -> CommandRunner;
    handle_subcommands = |subcommand_runners, matches| (
        let (name, submatches) = matches.subcommand.as_some_or(("", ArgMatches::empty));
        match subcommand_runners.to_iter.filter(|(command, runner)| command.@name == name).get_first {
            some((command, runner)) => runner(submatches),
            none() => throw $ "invalid subcommand: " + name
        }
    );
}

to_publish_args: ArgMatches -> PublishArgs;
to_publish_args = |matches| (
    PublishArgs::empty
    .set_project_dir(matches.get_one("DIR").as_some)
    .set_new_version(matches.get_one("new_version"))
    .set_release(matches.get_flag("release"))
    .set_confirm(matches.get_flag("confirm"))
    .set_test(matches.get_flag("test"))
    .set_commit(matches.get_flag("commit"))
    .set_push(matches.get_flag("push"))
    .set_tag(matches.get_flag("tag"))
    .set_update_document(matches.get_flag("update_document"))
    .set_check_branch(matches.get_flag("check_branch"))
);

run_command_publish: ArgMatches -> IOFail ();
run_command_publish = |matches| (
    let env: AppEnv = *make_empty_env;
    let args = matches.to_publish_args;
    do_publish(args).run_reader_t(env)
);

command_publish: Command;
command_publish = (
    Command::new("publish")
    .display_name("publish")
    .about("Make a release for a Fix project")
    .arg(Arg::new("DIR").help("the project directory").takes_value.default_value("."))
    .arg(Arg::new("check_branch").long("check-branch").help("check if the current branch is main").default_value("true"))
    .arg(Arg::new("test").long("test").help("run tests").default_value("true"))
    .arg(Arg::new("update_document").long("update-document").help("update documents").default_value("true"))
    .arg(Arg::new("new_version").long("new-version").help("the new version").takes_value)
    .arg(Arg::new("release").long("release").help("remove prerelease if exists").default_value("false"))
    .arg(Arg::new("confirm").long("confirm").help("confirm when version up").default_value("true"))
    .arg(Arg::new("commit").long("commit").help("commit the project file, lock files, documents").default_value("true"))
    .arg(Arg::new("push").long("push").help("push to the remote repository").default_value("true"))
    .arg(Arg::new("tag").long("tag").help("make the version tag and the latest tag").default_value("true"))
);

run_command_project_show: ArgMatches -> IOFail ();
run_command_project_show = |matches| (
    let env: AppEnv = *make_empty_env;
    let env = env.set_logger_api(NullLogger::api);
    let args = ProjectArgs::empty
        .set_project_dir(matches.get_one("DIR").as_some);
    do_project_show(args).run_reader_t(env)
);

command_project_show: Command;
command_project_show = (
    Command::new("show")
    .display_name("show")
    .about("Shows a project file contents")
    .arg(Arg::new("DIR").help("the project directory").takes_value.default_value("."))
);

command_project: Command;
command_project = (
    Command::new("project")
    .display_name("project")
    .about("Manages a project file")
    .subcommand(command_project_show)
);

run_command_project: ArgMatches -> IOFail ();
run_command_project = handle_subcommands([
        (command_project_show, run_command_project_show),
        (Command::empty, run_command_project_show),
]);

command_main: Command;
command_main = (
    Command::new("publisher.out")
    .version("0.1.0")
    .about("Publish tool for subprojects")
    .subcommand(command_publish)
    .subcommand(command_project)
);

run_command_main: ArgMatches -> IOFail ();
run_command_main = handle_subcommands([
    (command_publish, run_command_publish),
    (command_project, run_command_project),
]);

main: IO ();
main = (
    do {
        let args = *IO::get_args.lift;
        let matches = *command_main.get_matches_from(args).from_result;
        run_command_main(matches);;
        IO::exit(0).lift
    }.try(|errmsg|
        eprintln("\nError: " + errmsg);;
        IO::exit(1)
    )
);
