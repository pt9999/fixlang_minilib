module Minilib.Crypto.Cert.X509Signature;

import Debug;
import HashMap;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1.Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.Pem;
import Minilib.Crypto.Cert.OID;
import Minilib.Crypto.Cert.Pkcs1;
import Minilib.Crypto.ECDSA;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
//import Minilib.Thread.Time;
//import Minilib.Testing.UnitTest;

validate_signature: SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature = |public_key, certificate| (
    let hashspec = _find_pkcs1_v1_5_hashspec(certificate);
    if hashspec.is_some {
        validate_signature_pkcs1_v1_5(hashspec.as_some, public_key, certificate)
    };
    let ecdsa_scheme = _find_ecdsa_scheme(certificate);
    if ecdsa_scheme.is_some {
        validate_signature_ecdsa(ecdsa_scheme.as_some, public_key, certificate)
    };

    err $ "Not supported signature algorithm: " + certificate.@signature_algorithm.to_string
);

_find_pkcs1_v1_5_hashspec: Certificate -> Option Pkcs1::HashSpec;
_find_pkcs1_v1_5_hashspec = |certificate| (
    let signature_algorithm: AlgorithmIdentifier = certificate.@signature_algorithm;
    if signature_algorithm.match_name("sha-1WithRSAEncryption") {
        some $ Pkcs1::hashspec_sha1
    };
    if signature_algorithm.match_name("sha256WithRSAEncryption") {
        some $ Pkcs1::hashspec_sha256
    };
    if signature_algorithm.match_name("sha384WithRSAEncryption") {
        some $ Pkcs1::hashspec_sha384
    };
    if signature_algorithm.match_name("sha512WithRSAEncryption") {
        some $ Pkcs1::hashspec_sha512
    };
    none()
);

_find_ecdsa_scheme: Certificate -> Option ECDSAScheme;
_find_ecdsa_scheme = |certificate| (
    let signature_algorithm: AlgorithmIdentifier = certificate.@signature_algorithm;
    if signature_algorithm.match_name("ecdsa-with-SHA256") {
        some $ ECDSAScheme::ecdsa_secp256r1_sha256
    };
    if signature_algorithm.match_name("ecdsa-with-SHA384") {
        some $ ECDSAScheme::ecdsa_secp384r1_sha384
    };
    none()
);

validate_signature_pkcs1_v1_5: Pkcs1::HashSpec -> SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature_pkcs1_v1_5 = |hashspec, public_key, certificate| (
    let pubkey_algorithm: AlgorithmIdentifier = public_key.@algorithm;
    if !pubkey_algorithm.match_name("rsaEncryption") {
        err $ "Public_key algorithm does not match `rsaEncryption`: " + pubkey_algorithm.to_string
    };
    let rsa_pubkey: RSAPublicKey = *decode_der_from_bytes(public_key.@subject_public_key.@data);
    let n = rsa_pubkey.@modulus;
    let e = rsa_pubkey.@public_exponent;
    let message = certificate.@tbs_certificate_bytes;
    let signature = certificate.@signature_value.@data;
    Pkcs1::rsassa_pkcs1_v1_5_verify((n, e), message, signature, hashspec)
);


validate_signature_ecdsa: ECDSAScheme -> SubjectPublicKeyInfo -> Certificate -> Result ErrMsg ();
validate_signature_ecdsa = |ecdsa_scheme, public_key, certificate| (
    let pubkey_algorithm: AlgorithmIdentifier = public_key.@algorithm;
    if !pubkey_algorithm.match_name("id-ecPublicKey") {
        err $ "Public_key algorithm does not match `id-ecPublicKey`: " + pubkey_algorithm.to_string
    };

    // Check for named curve matches
    let named_curve: ObjectIdentifier = *decode_der_from_bytes(pubkey_algorithm.@parameters);
    //eval debug_eprintln("named_curve="+ named_curve.to_string_with_name);
    let ecdsa_scheme = *if named_curve.match_name(ecdsa_scheme.@ec.@id) { pure $ ecdsa_scheme }
    else {
        // Some certificates uses ecdsa-with-SHA256 but its public key uses secp384r1,
        // so let's change the named curve.
        // I don't know whether it is OK, but that cerficate passes the validation.
        let name = named_curve.get_name.as_some_or("");
        let ec = _find_ec_param(name);
        if ec.is_none { err $ "Named curve not found: " + name };
        //eval debug_eprintln("changing ecdsa_scheme to use " + name);
        pure $ ecdsa_scheme.set_ec(ec.as_some)
    };
    let ec = ecdsa_scheme.@ec;

    // Decode ecpoint
    let ecpoint: Array U8 = public_key.@subject_public_key.@data;
    //eval debug_eprintln("ecpoint="+ ecpoint.to_string_hex);
    let ecpoint: ECPoint = *from_bytes_ec(ec, ecpoint);

    // Validate signature
    let message = certificate.@tbs_certificate_bytes;
    let sig_value: EcdsaSigValue = *decode_der_from_bytes(certificate.@signature_value.@data);
    //eval debug_eprintln("sig_value="+ sig_value.to_string);
    let signature: ECDSASignature = ECDSASignature { r: sig_value.@r, s: sig_value.@s };
    ecdsa_scheme.verify(ecpoint, signature, message)
);

_find_ec_param: String -> Option ECParam;
_find_ec_param = |name| (
    if name == "secp256r1" { some $ ECParam::secp256r1 };
    if name == "secp384r1" { some $ ECParam::secp384r1 };
    none()
);