module Minilib.Crypto.Tls13.Handshake;

import AsyncTask;
import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Crypto.Tls13.ECDHE;
import Minilib.Crypto.Tls13.ECDSA;
import Minilib.Crypto.Tls13.KeyShare;
import Minilib.Crypto.Tls13.Extensions;
import Minilib.Crypto.Tls13.Connection;
import Minilib.Crypto.Tls13.HandshakeProtocol;
import Minilib.Crypto.Tls13.RecordProtocol;
//import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type ClientHelloState = unbox struct {
    client_hello: ClientHello,
    ecdhe: ECDHE,
};

namespace ClientHelloState {
    make: [m: MonadRandGen] String -> m ClientHelloState;
    make = |server_name| (
        let hello = ClientHello::empty;
        let hello = hello.init_random(*randgen_bytes(32));
        // init server_name
        let hello = hello.add_extension(Extension::server_name $
            ServerNameList::make([
                ServerName::make(server_name)
            ])
        );
        // init key_share
        let ecdhe = *ECDHE::make(ECParam::secp256r1);
        let ks: KeyShare = ks_client_hello $ KeyShareClientHello::make $ [
            ecdhe.to_key_share_entry
        ];
        let hello = hello.add_extension(Extension::key_share $ ks);
        eval debug_println("client_hello: extensions=" + hello.@extensions.to_string);
        pure $ ClientHelloState {
            client_hello: hello,
            ecdhe: ecdhe
        }
    );

    send: [m: TLSConnection] ClientHelloState -> m ();
    send = |client_hello_state| (
        let handshake: Handshake = Handshake::client_hello $ client_hello_state.@client_hello;
        let handshake_bytes: Array U8 = marshal_to_bytes(handshake);
        let plaintexts: Array TLSPlaintext = TLSPlaintext::split_fragments(ContentType::handshake(), handshake_bytes);
        TLSPlaintext::send_plaintexts(plaintexts)
    );
}

type ServerHelloState = unbox struct {
    server_hello: ServerHello,
    ecdhe: ECDHE,
};

namespace ServerHelloState {
    recv: [m: TLSConnection, ErrorType m = ErrMsg] ClientHelloState -> m ServerHelloState;
    recv = |client_hello_state| (
        let plaintext: TLSPlaintext = *TLSPlaintext::recv_plaintext;
        if !plaintext.@type_.is_handshake {
            error $ "unexpected content type"
        };
        let fragment = plaintext.@fragment;
        let handshake: Handshake = *unmarshal_from_bytes(fragment).from_result_t;
        if !handshake.is_server_hello {
            error $ "unexpected handshake type"
        };
        let hello: ServerHello = handshake.as_server_hello;
        pure $ ServerHelloState {
            server_hello: hello,
            ecdhe: client_hello_state.@ecdhe
        }
    );
}


type HandshakeState = unbox union {
    empty: (),
    client_hello_sent: ClientHelloState,
    server_hello_received: ServerHelloState,
};

namespace HandshakeState {
}

