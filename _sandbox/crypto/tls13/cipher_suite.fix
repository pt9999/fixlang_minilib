module Minilib.Crypto.Tls13.CipherSuite;

import Minilib.Encoding.Binary;

// B.4. Cipher Suites

type CipherSuite = unbox union {
    _TLS_AES_128_GCM_SHA256,
    _TLS_AES_256_GCM_SHA384,
    _TLS_CHACHA20_POLY1305_SHA256,
    _TLS_AES_128_CCM_SHA256,
    _TLS_AES_128_CCM_8_SHA256,
};

impl CipherSuite: Marshal {
    marshal = |obj, buf| (
        let val: U16 = (
            if obj.is__TLS_AES_128_GCM_SHA256 { 0x1301_U16 };
            if obj.is__TLS_AES_256_GCM_SHA384 { 0x1302_U16 };
            if obj.is__TLS_CHACHA20_POLY1305_SHA256 { 0x1303_U16 };
            if obj.is__TLS_AES_128_CCM_SHA256 { 0x1304_U16 };
            if obj.is__TLS_AES_128_CCM_8_SHA256 { 0x1305_U16 };
            0_U16        // invalid
        );
        buf.marshal(val)
    );
}

impl ContentType: Unmarshal {
    unmarshal = |buf| (
        let (val: U16, buf) = *buf.unmarshal;
        let obj = *(
            if val == 0x1301_U16 { ok $ _TLS_AES_128_GCM_SHA256() };
            if val == 0x1302_U16 { ok $ _TLS_AES_256_GCM_SHA384() };
            if val == 0x1303_U16 { ok $ _TLS_CHACHA20_POLY1305_SHA256() };
            if val == 0x1304_U16 { ok $ _TLS_AES_128_CCM_SHA256() };
            if val == 0x1305_U16 { ok $ _TLS_AES_128_CCM_8_SHA256() };
            err $ "invalid"
        );
        pure $ (obj, buf)
    );
}

