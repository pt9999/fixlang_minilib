// Command line argument parser.  (partial port of `clap` crate)
// https://docs.rs/clap/3.2.0/clap/index.html

module Main;

import HashMap;

import StringEx;

//----------------------------------------------
//  ArgAction
//----------------------------------------------
namespace ArgAction {
    type ArgAction = unbox union {
        set: (),        // set next argument to the single value
        append: (),     // append next argument to the values
        set_true: (),   // set "true" as the single value
        set_false: (),  // set "false" as the single value
        help: (),
        version: ()
    };
}

//----------------------------------------------
//  Arg
//----------------------------------------------
type Arg = unbox struct {
    id: String,
    short: U8,
    long: String,
    required: Bool,
    takes_value: Bool, // TODO
    multiple_values: Bool,
    default_value: Option String,
    value_name: String,
    help: String,
    action: ArgAction
};

namespace Arg {
    new: String -> Arg;
    new = |id| (
        Arg {
            id: id,
            short: 0_U8,
            long: "",
            required: false,
            takes_value: false,
            multiple_values: false,
            default_value: none(),
            value_name: "VALUE",
            help: "",
            action: ArgAction::set_true()
        }
    );

    // short(), long() .. please use set_short(), set_long() etc.

    is_positional: Arg -> Bool;
    is_positional = |arg| (
        arg.@short == 0_U8 && arg.@long == ""
    );
}

impl Arg: ToString {
    to_string = |arg| (
        if arg.@short != 0_U8 {
            Array::empty(3).push_back('-').push_back(arg.@short)._unsafe_to_string
        };
        if arg.@long != "" {
            "--" + arg.@long
        };
        if arg.@required { 
            "<" + arg.@id + ">"
        } else {
            "[" + arg.@id + "]"
        }
    );
}

// ---------------------------------
//  Command
// ---------------------------------
type Command = unbox struct {
    name: String,
    bin_name: String,
    display_name: String,
    version: String,
    author: String,
    about: String,
    args: Array Arg,
    help_template: HelpTemplate,
    version_template: HelpTemplate
};

type App = Command;

namespace Command {
    new: String -> Command;
    new = |name| (
        Command {
            name: name,
            bin_name: name,
            display_name: name,
            version: "",
            author: "",
            about: "",
            args: _default_args,
            help_template: HelpTemplate::default_help,
            version_template: HelpTemplate::default_version
        }
    );
    
    // about(), version() .. please use set_about(), set_version() etc.

    arg: Arg -> Command -> Command;
    arg = |arg, command| (
        command.mod_args(|args| args.push_back(arg))
    );

    render_help: Command -> String;
    render_help = |command| (
        command.@help_template.format(command)
    );

    render_version: Command -> String;
    render_version = |command| (
        command.@version_template.format(command)
    );

    _default_args: Array Arg;
    _default_args = (
        Array::empty(100)
        .push_back(Arg::new("help")
            .set_short('h').set_long("help")
            .set_help("Print help information")
            .set_action(ArgAction::help())
        )
        .push_back(Arg::new("version")
            .set_short('V').set_long("version")
            .set_help("Print version information")
            .set_action(ArgAction::version())
        )
    );

    get_matches: Command -> IOFail ArgMatches;
    get_matches = |command| (
        let raw_args = *IO::get_args;
        command.get_matches_from(raw_args).from_result
    );

    get_matches_from: Array String -> Command -> Result ErrMsg ArgMatches;
    get_matches_from = |raw_args, command| (
        err $ "Not impl yet"
    );
}

// ---------------------------------
//  ArgParser
// ---------------------------------
namespace ArgParser
{
    type ArgParser = unbox struct {
        command: Command,
        args: Array Arg,
        matches: ArgMatches,
        raw_args: Array String,
        current_index: I64,
        positional_only: Bool
    };

    make: Array String -> Command -> ArgParser;
    make = |raw_args, command| (
        ArgParser {
            command: command,
            args: command.@args,
            matches: ArgMatches::empty,
            raw_args: raw_args,
            current_index: 1,
            positional_only: false
        }
    );

    // 実際のコマンドライン引数の配列を解析し、Argの値を設定する。
    _parse_args : ArgParser -> Result ErrMsg ArgParser;
    _parse_args = |parser| (
        loop_m(
            parser, |parser|
            if parser.@current_index >= parser.@raw_args.get_size {
                break_m $ parser
            };
            let raw_arg = raw_args.@(parser.@current_index);
            if parser.positional_only {
                continue_m $ *parser._process_positional_arg
            };
            if raw_arg == "--" {
                let parser = parser.set_positional_only(true);
                let parser = parser.mut_current_index(|i| i + 1);
                continue_m $ parser
            };
            if raw_arg.get_sub_ex(0,1) == "-" {
                continue_m $ *parser._process_option_arg
            };
            continue_m $ *parser._process_positional_arg
        )
    );
    
    _get_sub_ex: I64 -> I64 -> String -> String;
    _get_sub_ex = |s, e, str| (
        let size = str.get_size;
        let s = max(0, s);
        let e = max(s, min(size, e));
        if s == 0 && e == size { str };
        str.get_sub(s,e)
    );

    // 現在のコマンドライン引数をオプションと見なして処理する。
    _process_option_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_option_arg = |parser| (
        let raw_arg = raw_args.@(parser.@current_index);
        let parser = parser.mut_current_index(|i| i + 1);
        let i = parser.@args.find_by(|arg| arg.to_string == raw_arg);
        if i.is_none {
            err $ "Found argument '" + raw_arg + "' which wasn't expected, or isn't valid in this context"
        };
        let arg = parser.@args.@(i.as_some);
        let parser = parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser 
    );

    // 現在のコマンドライン引数をポジショナルと見なして処理する。
    _process_positional_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_positional_arg = |parser| (
        let raw_arg = raw_args.@(parser.@current_index);
        //let parser = parser.mut_current_index(|i| i + 1);
        let args = parser.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        if args.get_size == 0 {
            err $ "Found argument '" + raw_arg + "' which wasn't expected, or isn't valid in this context"
        };
        let arg = args.@(0);
        let parser = parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser
    ); 

    // parser.@args から arg を除去する。
    _remove_arg: Arg -> ArgParser -> ArgParser;
    _remove_arg = |arg, parser| (
        parser.mut_args(|args| args.filter(|a| a.@id != arg.@id))
    );

    // Arg に設定されたアクションを遂行する。
    _perform_action: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _perform_action = |arg, parser| (
        let action = parser.@action;
        if action.is_help {
            err $ parser.@command.render_help
        };
        if action.is_version {
            err $ parser.@command.render_version
        };
        if action.is_set_true || action.is_set_false {
            let value = if action.is_set_true { "true" } else { "false" };
            let values = Array::empty(1).push_back(value);
            let parser = parser.mut_matches(|matches|
                matches.set_values(args.@id, values)
            );
            ok $ parser
        };
        if action.is_set || action.is_append {
            parser._set_or_append_value(arg)
        };
        eval assert(|_| "unknown action: arg="+arg.to_string, false);
        err $ "error"
    );

    // 次のコマンドライン引数を値と見なし, set or append アクションを実行する。
    _set_or_append_value: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _set_or_append_value = |arg, parser| (
        if parser.@current_index >= parser.@raw_args.get_size {
            err $ "The argument '" + arg.to_string + "' requires a value but none was supplied"
        };
        let value = parser.@raw_args.@(parser.current_index);
        let parser = parser.mut_current_index(|i| i + 1);
        let parser = parser.mut_matches(|matches|
            matches.mut_values(args.@id, |values|
                if arg.@action.is_set {
                    Array::empty(1).push_back(value)
                };
                if arg.@action.is_append {
                    values.push_back(value)
                };
                eval assert(|_| "arg.@action is not set nor append", false);
                values
            )
        );
        ok $ parser
    );

    _check_required_args_present: ArgMatches -> Command -> Result ErrMsg ();
    _check_required_args_present = |matches, command| (
        let missing_args: Array Arg = command.@args.to_iter
            .filter(|arg| arg.@required)
            .filter(|arg| !matches.@map.contains_key(arg.@id))
            .to_array;
        if missing_args.get_size == 0 {
            ok()
        };
        err $ "The following required arguments were not provided:\n" +
        missing_args.map(|arg| "    " + arg.to_string + "\n")
        .to_iter.concat_iter
    );

    _set_default_if_not_present: ArgMatches -> Command -> ArgMatches;
    _set_default_if_not_present = |matches, command| (
        command.@args.fold(
            matches,
            |matches, arg|
            if arg.default_value.is_none {
                matches
            };
            if matches.@map.contains_key(arg.@id) {
                matches
            };
            let values = Array::empty(1).push_back(arg.default_value.as_some);
            matches.mod_map(|map|
                map.insert(arg.@id, values)
            )
        )
    );
}

// ---------------------------------
//  ArgMatches
// ---------------------------------

type ArgMatches = unbox struct {
    map: HashMap String (Array String)
};

namespace ArgMatches {
    empty: ArgMatches;
    empty = ArgMatches { map: HashMap::empty(0) };

    get_many: String -> ArgMatches -> Option (Array String);
    get_many = |id, matches| (
        matches.@map.find(id)
    );
    get_one: String -> ArgMatches -> Option String;
    get_one = |id, matches| (
        let array = *matches.get_many(id);
        if array.get_size == 0 { none };
        some(array.@(0))
    );

    mut_many: String -> (Array String -> Array String) -> ArgMatches -> ArgMatches;
    mut_many = |id, f, matches| (
        let values = matches.@map.find(id).or(Array::empty(0));
        let values = f(values);
        matches.mut_map(|map| map.insert(id, values))
    );

    set_many: String -> Array String -> ArgMatches -> ArgMatches;
    set_many = |id, values, matches| (
        matches.mut_many(id, |_| values)
    );
}

// ---------------------------------
//  HelpTemplate
// ---------------------------------

type HelpTemplate = unbox struct { 
    data: String 
};
namespace HelpTemplate {
    new: String -> HelpTemplate;
    new = |str| HelpTemplate { data: str };

    default_help: HelpTemplate;
    default_help = HelpTemplate { 
        data: (
            "{name} {version}\n" +
            "{author-with-newline}" +
            "{about-with-newline}" +
            "\n" + 
            "{usage}\n" +
            "{all-args}\n"
        )
    };

    default_version: HelpTemplate;
    default_version = HelpTemplate {
        data: (
            "{name} {version}\n"
        )
    };

    format: Command -> HelpTemplate -> String;
    format = |command, help_template| (
        let help = help_template.@data;
        let help = help.replace_all("{name}", command.@display_name);
        let help = help.replace_all("{version}", command.@version);
        let help = help.replace_all("{author-with-newline}", 
            if command.@author == "" { "" } else { command.@author + "\n" }
        );
        let help = help.replace_all("{about-with-newline}", 
            if command.@about == "" { "" } else { command.@about + "\n" }
        );
        let help = help.replace_all("{usage}", 
            help_template._format_usage(command)
        );
        let help = help.replace_all("{all-args}", 
            help_template._format_all_args(command)
        );
        help
    );

    _format_usage: Command -> HelpTemplate -> String;
    _format_usage = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg.is_positional).to_array;
        let usage = "USAGE:\n";
        let usage = usage + (
            "    " + command.@bin_name + "[EXE]"
        );
        let usage = usage + (
            if args.get_size == 0 { "" } else {
                args.to_iter.map(|arg| " " + arg.to_string).concat_iter
            }
        );
        let usage = usage + (
            if options.get_size == 0 { "" } else { " [OPTIONS]" }
        );
        usage + "\n"
    );

    _format_all_args: Command -> HelpTemplate -> String;
    _format_all_args = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg.is_positional).to_array;

        let args_text = if args.get_size == 0 { "" } else {
            "ARGS:\n" +
            args.to_iter.map(_format_arg).concat_iter
        };
        let options_text = if options.get_size == 0 { "" } else {
            "OPTIONS:\n" +
            options.to_iter.map(_format_option).concat_iter
        };
        args_text + options_text
    );

    _format_arg: Arg -> String;
    _format_arg = |arg| (
        let line = "    " + arg.to_string;
        let line = if line.get_size >= 15 { line } else {
            line + Array::fill(15 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );

    _format_option: Arg -> String;
    _format_option = |arg| (
        let line = "    ";
        let line = line + (
            if arg.@short == 0_U8 { "    " } else {
                arg.to_string + (
                    if arg.@long == "" { "  " } else { ", " }
                )
            }
        );
        let line = line + (
            if arg.@long == "" { " " } else {
                "--" + arg.@long + " "
            }
        );
        let line = line + (
            if !arg.@takes_value { "" } else {
                "<" + arg.@value_name + ">"
            }
        );
        let line = if line.get_size >= 32 { line } else {
            line + Array::fill(32 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );
}

// ---------------------------------


main: IO ();
main = (
    let command = (
        Command::new("nice-tool")
        .set_display_name("MyNiceTool")
        .set_version("0.0.1")
        .set_about("A nice tool")
        .arg(Arg::new("count").set_short('n').set_long("count").set_help("How many times to iterate"))
        .arg(Arg::new("output").set_short('o').set_long("output").set_help("An output file"))
        .arg(Arg::new("FILE").set_help("An input file"))
    );
    let _ = *println(command.render_help);
    let raw_args = ["nice-tool", "hoge"];
    let matches = command.get_matches_from(raw_args);
    let _ = *println("matches="+matches.to_string);
    pure()
);
