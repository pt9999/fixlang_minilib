module Main;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.Secret;
import Minilib.Crypto.Tls13.CipherSuite;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

parse_hex: String -> IOFail (Array U8);
parse_hex = |str| str.from_string_hex.from_result;

// RFC 8448: Example Handshake Traces for TLS 1.3
// 3.  Simple 1-RTT Handshake

// {server}  extract secret "early":
test_early_secret: TestCase;
test_early_secret = (
    make_test("test_early_secret") $ |_|
    let cipher_suite: CipherSuite = _TLS_AES_128_GCM_SHA256();
    let hkdf = *HKDF::from_cipher_suite(cipher_suite).from_result;
    let secret = *hkdf.calc_early_secret_0.from_result;
    let expected = "33ad0a1c607ec03b09e6cd9893680ce210adf300aa1f2660e1b22e10f170f92a";
    let actual = secret.to_string_hex;
    assert_equal("eq", expected, actual)
);

// {server}  derive secret for handshake "tls13 derived":
// {server}  extract secret "handshake":
test_handshake_secret: TestCase;
test_handshake_secret = (
    make_test("test_handshake_secret") $ |_|
    let cipher_suite: CipherSuite = _TLS_AES_128_GCM_SHA256();
    let hkdf = *HKDF::from_cipher_suite(cipher_suite).from_result;
    let early_secret = *parse_hex("33ad0a1c607ec03b09e6cd9893680ce210adf300aa1f2660e1b22e10f170f92a"); // PRK
    let dhe = *parse_hex("8bd4054fb55b9d63fdfbacf9f04b9f0d35e6d63f537563efd46272900f89492d"); // ikm
    let secret = *hkdf.calc_handshake_secret(early_secret, dhe).from_result;
    let expected = "1dc826e93606aa6fdc0aadc12f741b01046aa6b99f691ed221a9f0ca043fbeac";
    let actual = secret.to_string_hex;
    assert_equal("eq", expected, actual)
);

main: IO ();
main = (
    [
        test_early_secret,
        test_handshake_secret,
    ]
    .run_test_driver
);
