module Publisher.Publish;

import Minilib.IO.Errno;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;

import Publisher.Common;
import Publisher.ProcessRunner;
import Publisher.ConsoleUi;
import Publisher.Fs;
import Publisher.ProjectFile;

log_message: [m: MonadIO] String -> m ();
log_message = |str| eprintln(str).lift_io;

namespace GitTask {

    // Checks if the current directory is the root of a Git working tree.
    check_git_working_tree: [m: MonadFs, m: MonadError] m ();
    check_git_working_tree = (
        // `.git` is a directory in a standalone Git repository.
        // `.git` is a file in a submodule of a Git repository, or a worktree.
        let git_dir = DirName::git;
        check_if_directory_exists(git_dir).catch(|errmsg|
            check_if_file_exists(git_dir)
        )
    );

    check_branch_name: [m: MonadRunProcess, m: MonadError] String -> m ();
    check_branch_name = |expected| (
        log_message((expected,).format("### Checking if the current branch name is `{}`"));;
        let (stdout, stderr) = *run_process_quietly(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
        let actual = stdout.strip_spaces;
        if actual != expected {
            error $ (expected, actual).format("The current branch name is not `{}`: actual = `{}`")
        };
        pure()
    );

    check_uncommitted_files: [m: MonadRunProcess, m: MonadError] m ();
    check_uncommitted_files = (
        log_message("### Checking for uncommitted files");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only"]);
        if stdout != "" {
            error $ "Uncommitted file exists"
        };
        pure()
    );

    no_commit_since_latest:  [m: MonadRunProcess] m Bool;
    no_commit_since_latest = (
        log_message("### Checking if there is any commit from the latest release");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only", TagName::latest]);
        if stdout == "" {
            pure $ true
        };
        pure $ false
    );

    reset_fixdeps_lock:  [m: MonadRunProcess] m ();
    reset_fixdeps_lock = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        pure()
    );

    commit_fixdeps_lock: [m: MonadRunProcess] m ();
    commit_fixdeps_lock = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        if stdout == "" { pure() };
        log_message("### Commit fixdeps.lock");;
        let (stdout, stderr) = *run_process(["git", "add", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update deps", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]);
        pure()
    );

    commit_documents: [m: MonadRunProcess] m ();
    commit_documents = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", DirName::docs]);
        if stdout == "" { pure() };
        log_message("### Commit documents");;
        let (stdout, stderr) = *run_process(["git", "add", "--", DirName::docs]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update documents", "--", DirName::docs]);
        pure()
    );

    reset_documents: [m: MonadRunProcess] m ();
    reset_documents = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", DirName::docs]);
        pure()
    );

    commit_project_file: [m: MonadRunProcess] PublishArgs -> Path -> String -> m ();
    commit_project_file = |args, filepath, version| (
        log_message("### Commit the project file");;
        let (stdout, stderr) = *run_process(["git", "add", "--verbose", "--", filepath]);
        let message = "version " + version;
        let (stdout, stderr) = *run_process(["git", "commit", "--verbose", "-m", message]);
        when(args.@tag, do {
            log_message("### Make a version tag");;
            let (stdout, stderr) = *run_process(["git", "tag", version]);
            let (stdout, stderr) = *run_process(["git", "tag", TagName::latest, "-f"]);
            pure()
        });;
        when(args.@push, do {
            log_message("### Push to the remote repository");;
            let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin]);
            pure()
        });;
        when(args.@push && args.@tag, do {
            log_message("### Push tags to the remote repository");;
            let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin, version]);
            let (stdout, stderr) = *run_process(["git", "push", RemoteName::origin, TagName::latest, "-f"]);
            pure()
        });;
        pure()
    );
}

namespace ProjectTask {

    chdir_to_project_dir: [m: MonadFs] Path -> m ();
    chdir_to_project_dir = |project_dir| (
        log_message("### Chdir to `" + project_dir + "`");;
        fs_chdir(project_dir)
    );

    // Checks if the project file (fixproj.toml) exists
    check_project_file_exists: [m: MonadFs] m ();
    check_project_file_exists = (
        let project_file_path = FileName::fixproj_toml;
        check_if_file_exists(project_file_path)
    );

    check_if_file_exists: [m: MonadFs] Path -> m ();
    check_if_file_exists = |filepath| (
        if ! *fs_file_exists(filepath) {
            error $ "File not found: " + filepath
        };
        pure()
    );

    check_if_directory_exists: [m: MonadFs] Path -> m ();
    check_if_directory_exists = |dirpath| (
        if ! *fs_directory_exists(dirpath) {
            error $ "Directory not found: " + dirpath
        };
        pure()
    );

    run_fix_clean: [m: MonadRunProcess] m ();
    run_fix_clean = (
        log_message("### Clean");;
        let (stdout, stderr) = *run_process(["fix", "clean"]);
        pure()
    );

    run_fix_deps_update: [m: MonadRunProcess] m ();
    run_fix_deps_update = (
        log_message("### Update deps");;
        let (stdout, stderr) = *run_process(["fix", "deps", "update"]);
        pure()
    );

    run_fix_test: [m: MonadRunProcess] m ();
    run_fix_test = (
        log_message("### Run tests");;
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "basic"]);
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "max"]);
        pure()
    );

    run_fix_docs: [m: MonadRunProcess] m ();
    run_fix_docs = (
        log_message("### Generate documents");;
        let (stdout, stderr) = *run_process(["fix", "docs", "-o", DirName::docs]);
        pure()
    );
}


type PublishArgs = unbox struct {
    project_dir: Path,
    new_version: Option String,
    release: Bool,
    confirm: Bool,
    test: Bool,
    commit: Bool,
    push: Bool,
    tag: Bool,
    update_document: Bool,
    check_branch: Bool,
};

namespace PublishArgs {
    empty: PublishArgs;
    empty = PublishArgs {
        project_dir: "",
        new_version: none(),
        release: false,
        confirm: false,
        test: true,
        commit: false,
        push: false,
        tag: false,
        update_document: false,
        check_branch: true,
    };

    update_realpath: [m: MonadFs] PublishArgs -> m PublishArgs;
    update_realpath = |args| (
        let args = *args.act_project_dir(fs_realpath);
        pure $ args
    );
}

do_publish: [m: MonadConsoleUi, m: MonadFs, m: MonadRunProcess, m: MonadError] PublishArgs -> m ();
do_publish = |args| (
    let args = *args.update_realpath;
    
    chdir_to_project_dir(args.@project_dir);;

    check_git_working_tree;;
    check_project_file_exists;;
    check_branch_name(BranchName::main).when(args.@check_branch);;
    check_uncommitted_files;;
    if *no_commit_since_latest {
        log_message("### No commit since latest, so only run tests with the latest dependencies");;
        run_fix_clean;;
        run_fix_deps_update;;
        run_fix_test.when(args.@test);;
        run_fix_docs;;
        reset_fixdeps_lock;;
        reset_documents;;
        log_message("### No need to publish");;
        pure()
    };

    run_fix_clean;;
    run_fix_deps_update;;
    run_fix_test.when(args.@test);;
    run_fix_docs;;

    log_message("### Update the project file");;
    let project_file_path = FileName::fixproj_toml;
    let new_version = *upgrade_project_version(project_file_path, args.@new_version, args.@release, args.@confirm);

    reset_documents;;

    commit_fixdeps_lock;;

    when(args.@update_document, do {
        run_fix_docs;;
        commit_documents
    });;
    when(args.@commit && new_version != "",
        commit_project_file(args, project_file_path, new_version));;
    pure()
);

type ProjectArgs = unbox struct {
    project_dir: Path,
};

namespace ProjectArgs {
    empty: ProjectArgs;
    empty = ProjectArgs {
        project_dir: "",
    };
}

do_project_show: [m: MonadIO, m: MonadFs, m: MonadError] ProjectArgs -> m ();
do_project_show = |args| (
    chdir_to_project_dir(args.@project_dir);;
    let project_file_path = FileName::fixproj_toml;
    let project_file = *ProjectFile::from_file(project_file_path);
    let project_name = *project_file.get_project_name;
    let project_version = *project_file.get_project_version;
    mprintln(project_name + " = " + project_version)
);
