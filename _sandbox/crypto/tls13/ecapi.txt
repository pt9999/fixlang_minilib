
// ecapi.fix
module Minilib.Crypto.EC.EcApi
namespace EcApi {
    type EcCurveName = String;
    type EcHashName = String;
    type EcPublicKey = Array U8;    // UncompressedPointRepresentation
    type EcSharedSecret = Array U8;
    type EcSignature = Array U8;
    type EcMessage = Array U8;

    type EcApi = unbox struct {
        make_ecdhe: EcCurveName -> RandomGenerator -> Result ErrMsg EcdheInstance,
        make_ecdsa: EcCurveName -> EcHashName -> Result ErrMsg EcdsaInstance,
    };

    type EcdheInstance = unbox struct {
        named_group: String,
        key_exchange: EcPublicKey,
        accept_peer_key_exchange: EcPublicKey -> Result ErrMsg EcSharedSecret,
    };

    type EcdsaInstance = unbox struct {     // ECDSAScheme
         verify: EcPublicKey -> EcSignature -> EcMessage -> Result ErrMsg (),
    };

}

// ecapi_impl.fix
module Minilib.Crypto.EC.EcApiImpl

make: [m: MonadError] m EcApi;
make = (
    pure $ EcApi {
        make_ecdhe: _make_ecdhe,
        make_ecdsa: _make_ecdsa,
    }
);

_make_ecdhe: EcCurveName -> RandomGenerator -> Result ErrMsg EcdheInstance;

_make_ecdsa: EcCurveName -> EcHashName -> Result ErrMsg EcdsaInstance;

_get_ecparam: EcCurveName -> Result ErrMsg ECParam;

_get_ecdsa_scheme: EcCurveName -> EcHashName -> Result ErrMsg ECDSAScheme;

_get_public_key: EcPublicKey -> Result ErrMsg ECPoint;

----------------------------------

/*
// crypto/crypto_api.fix
trait a: CryptoApi {
    type TlsImpl a;
    type CertImpl a;
    type RsaImpl a;
    type EcImpl a;
    get_tls_api: [tls: TlsApi, TlsImpl a = tls] a -> tls;
    get_cert_api: [cert: CertApi, CertImpl a = cert] a -> cert;
    get_rsa_api: [rsa: RsaApi, RsaImpl a = rsa] a -> rsa;
    get_ec_api: [ec: EcApi, EcImpl a = ec] a -> ec;
}
*/

// crypto/tls/tls_api.fix
trait a: TlsApi {
    type CertImpl a;
    type Asn1Impl a;
    type RsaImpl a;
    type EcImpl a;
    type TlsSessionImpl a;
    get_cert_api: [cert: CertApi, TlsApi::CertImpl a = cert] a -> cert;
    get_asn1_api: [asn1: Asn1Api, TlsApi::Asn1Impl a = asn1] a -> asn1;
    get_rsa_api: [rsa: RsaApi, TlsApi::RsaImpl a = rsa] a -> rsa;
    get_ec_api: [ec: EcApi, TlsApi::EcImpl a = ec] a -> ec;
    get_tls_session_api: [s: TlsSessionApi, TlsApi::TlsSessionImpl a = s] a -> s;
};

// crypto/cert/cert_api.fix
trait a: CertApi {
    type RsaImpl a;
    type EcImpl a;
    get_rsa_api: [rsa: RsaApi, CertApi::RsaImpl a = rsa] a -> rsa;
    get_ec_api: [ec: EcApi, CertApi::EcImpl a = ec] a -> ec;
};

// crypto/asn1/asn1_api.fix

trait a: Asn1Api {
    decode_der_from_bytes: [obj: DecodeDer, m: MonadError] Array U8 -> a -> m obj;
};

// crypto/ec/ec_api.fix
module Minilib.Crypto.Ec.EcApi;

type EcCurveName = String;
type EcHashName = String;
type EcPublicKey = Array U8;    // UncompressedPointRepresentation
type EcSharedSecret = Array U8;
type EcSignature = Array U8;
type EcMessage = Array U8;

trait a: EcApi {
  type EcdheImpl a;
  type EcdsaImpl a;
  make_ecdhe: [ecdhe: EcdheApi, EcdheImpl a = ecdhe, m: MonadRandom] EcCurveName -> a -> m ecdhe;
  make_ecdsa: [ecdsa: EcdsaApi, EcdsaImpl a = ecdsa, m: MonadError] EcCurveName -> EcHashName -> a -> m ecdsa,
}

trait a: EcdheApi {
    get_curve_name: a -> EcCurveName;
    get_key_exchange: a -> EcPublicKey;
    accept_peer_key_exchange: [m: MonadError] EcPublicKey -> a -> m EcSharedSecret;
}

trait a: EcdsaApi {
    verify: [m: MonadError, asn1: Asn1Api] EcPublicKey -> EcSignature -> EcMessage -> asn1 -> a -> m ();
}

// crypto/ec/default_ec_impl.fix
module Minilib.Crypto.Ec.DefaultEcImpl;

type DefaultEcImpl = unbox struct {
    dummy: ()
};

namespace DefaultEcImpl {
    make: DefaultEcImpl;
    make = DefaultEcImpl {
        dummy: ()
    };
}

impl DefaultEcImpl: EcApi {
    type EcdheImpl DefaultEcImpl = DefaultEcdheImpl;
    type EcdsaImpl DefaultEcImpl = DefaultEcdsaImpl;

    //make_ecdhe: [ecdhe: EcdheApi, EcdheImpl a = ecdhe, m: MonadRandom] EcCurveName -> a -> m ecdhe;
    make_ecdhe = |curve_name, ec_impl| DefaultEcdheImpl::make(curve_name);

    //make_ecdsa: [ecdsa: EcdsaApi, EcdsaImpl a = ecdsa, m: MonadError] EcCurveName -> EcHashName -> a -> m ecdsa,
    make_ecdsa = |curve_name, hash_name, ec_impl| DefaultEcdsaImpl::make(curve_name, hash_name);
}

type DefaultEcdheImpl = unbox struct {
    curve_name: EcCurveName,
    ecdhe: ECDHE,
};

namespace DefaultEcdheImpl {
    make: [m: MonadRandom] EcCurveName -> m DefaultEcdheImpl;
    make = |curve_name| (
        let ec = ECParam::from_curve_name(curve_name);
        pure $ DefaultEcdheImpl {
            curve_name: curve_name,
            ecdhe: *ECDHE::make(ec),
        }
    );
}

impl DefaultEcdheImpl: EcdheApi {
    get_curve_name = @curve_name;
    get_key_exchange = @ecdhe >> get_pub_key;
    accept_peer_key_exchange = |peer_key, a| (
        a.@ecdhe.accept_server_share(peer_key).from_result_t
    );
}

type DefaultEcdsaImpl = unbox struct {
    curve_name: EcCurveName,
    hash_name: EcHashName,
    ecdsa_scheme: ECDSAScheme
};

namespace DefaultEcdsaImpl {
    make: [m: MonadError] EcCurveName -> EcHashName -> m DefaultEcdsaImpl;
    make = (
        let ecdsa_scheme = ECDSAScheme::from_curve_name_and_hash_name(curve_name, hash_name);
        pure $ DefaultEcdsaImpl {
            curve_name: curve_name,
            hash_name: hash_name,
            ecdsa_scheme: ecdsa_scheme
        }
    );
}

impl DefaultEcdsaImpl: EcdsaApi {
    //verify: [m: MonadError, asn1: Asn1Api] EcPublicKey -> EcSignature -> EcMessage -> asn1 -> a -> m ();
    verify = |pub_key, signature, message, asn1_impl, ecdsa_impl| (
        let ecdsa_scheme = ecdsa_impl.@ecdsa_scheme;
        let (ecdsa_scheme, ec_point) = *get_ec_point_from_public_key(ecdsa_scheme, public_key).from_result_t;
        let sig_value: EcdsaSigValue = *asn1_impl.decode_der_from_bytes(signature).from_result_t;         // uses Asn1Api
        let signature: ECDSASignature = ECDSASignature { r: sig_value.@r, s: sig_value.@s };
        ecdsa_scheme.verify(ec_point, signature, content).from_result_t
    );
}

// crypto/ec/mock_ec_impl.fix
module Minilib.Crypto.Ec.MockEcImpl;

type MockEcImpl = unbox struct {
    dummy: ()
};

namespace MockEcImpl {
    make: MockEcImpl;
    make = MockEcImpl {
        dummy: ()
    };
}

impl MockEcImpl: EcApi {
    type EcdheImpl MockEcImpl = MockEcdheImpl;
    type EcdsaImpl MockEcImpl = MockEcdsaImpl;

    //make_ecdhe: [ecdhe: EcdheApi, EcdheImpl a = ecdhe, m: MonadRandom] EcCurveName -> a -> m ecdhe;
    make_ecdhe = |curve_name, ec_impl| MockEcdheImpl::make(curve_name);

    //make_ecdsa: [ecdsa: EcdsaApi, EcdsaImpl a = ecdsa, m: MonadError] EcCurveName -> EcHashName -> a -> m ecdsa,
    make_ecdsa = |curve_name, hash_name, ec_impl| MockEcdsaImpl::make(curve_name, hash_name);
}

type MockEcdheImpl = unbox struct {
    curve_name: EcCurveName,
};

namespace MockEcdheImpl {
    make: [m: MonadRandom] EcCurveName -> m MockEcdheImpl;
    make = |curve_name| (
        pure $ MockEcdheImpl {
            curve_name: curve_name,
        }
    );
}

impl MockEcdheImpl: EcdheApi {
    get_curve_name = @curve_name;
    get_key_exchange = |_| Array::fill(64, 0_U8);
    accept_peer_key_exchange = |peer_key, a| pure $ Array::fill(64, 0_U8)
}

type MockEcdsaImpl = unbox struct {
    curve_name: EcCurveName,
    hash_name: EcHashName,
};

namespace MockEcdsaImpl {
    make: [m: MonadError] EcCurveName -> EcHashName -> m MockEcdsaImpl;
    make = (
        pure $ MockEcdsaImpl {
            curve_name: curve_name,
            hash_name: hash_name,
        }
    );
}

impl MockEcdsaImpl: EcdsaApi {
    //verify: [m: MonadError] EcPublicKey -> EcSignature -> EcMessage -> a -> m ();
    verify = |pub_key, signature, message, ecdsa_impl| pure();
}
