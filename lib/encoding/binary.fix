module Binary;

type ByteOrder = unbox union {
    little_endian: (),
    big_endian: ()
};

type ByteBuffer = unbox struct {
    array: Array U8,
    byte_order: ByteOrder
};

namespace ByteBuffer {
    // `ByteBuffer::make(array, byte_order)` creates new byte buffer such that:
    // - The internal byte array is `array`
    // - The byte order is `byte_order`
    make: Array U8 -> ByteOrder -> ByteBuffer;
    make = |array, byte_order| (
        ByteBuffer { 
            array: array,
            byte_order: byte_order
        }
    );

    // `ByteBuffer::fill(size, value, byte_order)` creates new byte buffer such that:
    // - The internal byte array is initialized by size `size` and filled with `value`
    // - The byte order is `byte_order`
    fill: I64 -> U8 -> ByteOrder -> ByteBuffer;
    fill = |size, value, byte_order| (
        let array = Array::fill(size, value);
        ByteBuffer::make(array, byte_order)
    );

    // Calls a function with a pointer to the memory region where elements are stored.
    borrow_ptr : (Ptr -> b) -> ByteBuffer -> b;
    borrow_ptr = |f, buf| (
        buf.@array.borrow_ptr(f)
    );

    // Gets the byte array in the byte buffer.
    get_bytes: ByteBuffer -> Array U8;
    get_bytes = @array;

    // Gets U8 from the byte buffer at position `i`.
    get_u8: I64 -> ByteBuffer -> U8;
    get_u8 = |i, buf| (
        if buf.@byte_order.is_little_endian { 
            get_u8_le(i, buf.@array) 
        } else {
            get_u8_be(i, buf.@array) 
        }
    );

    // Gets U16 from the byte buffer at position `i`.
    get_u16: I64 -> ByteBuffer -> U16;
    get_u16 = |i, buf| (
        if buf.@byte_order.is_little_endian { 
            get_u16_le(i, buf.@array) 
        } else {
            get_u16_be(i, buf.@array) 
        }
    );

    // Gets U32 from the byte buffer at position `i`.
    get_u32: I64 -> ByteBuffer -> U32;
    get_u32 = |i, buf| (
        if buf.@byte_order.is_little_endian { 
            get_u32_le(i, buf.@array) 
        } else {
            get_u32_be(i, buf.@array) 
        }
    );

    // Gets U64 from the byte buffer at position `i`.
    get_u64: I64 -> ByteBuffer -> U64;
    get_u64 = |i, buf| (
        if buf.@byte_order.is_little_endian { 
            get_u64_le(i, buf.@array) 
        } else {
            get_u64_be(i, buf.@array) 
        }
    );

    // Sets U8 into the byte buffer at position `i`.
    set_u8: I64 -> U8 -> ByteBuffer -> ByteBuffer;
    set_u8 = |i, val, buf| (
        if buf.@byte_order.is_little_endian { 
            buf.mod_array(set_u8_le(i, val))
        } else {
            buf.mod_array(set_u8_be(i, val))
        }
    );

    // Sets U16 into the byte buffer at position `i`.
    set_u16: I64 -> U16 -> ByteBuffer -> ByteBuffer;
    set_u16 = |i, val, buf| (
        if buf.@byte_order.is_little_endian { 
            buf.mod_array(set_u16_le(i, val))
        } else {
            buf.mod_array(set_u16_be(i, val))
        }
    );
    
    // Sets U32 into the byte buffer at position `i`.
    set_u32: I64 -> U32 -> ByteBuffer -> ByteBuffer;
    set_u32 = |i, val, buf| (
        if buf.@byte_order.is_little_endian { 
            buf.mod_array(set_u32_le(i, val))
        } else {
            buf.mod_array(set_u32_be(i, val))
        }
    );

    // Sets U64 into the byte buffer at position `i`.
    set_u64: I64 -> U64 -> ByteBuffer -> ByteBuffer;
    set_u64 = |i, val, buf| (
        if buf.@byte_order.is_little_endian { 
            buf.mod_array(set_u64_le(i, val))
        } else {
            buf.mod_array(set_u64_be(i, val))
        }
    );
}

//-----------------------------------------------------------
// little endian
//-----------------------------------------------------------

// Decodes U8 from `array` at position `i` with little endian.
get_u8_le: I64 -> Array U8 -> U8;
get_u8_le = |i, array| (
    array.@(i)
);

// Decodes U16 from `array` at position `i` with little endian.
get_u16_le: I64 -> Array U8 -> U16;
get_u16_le = |i, array| (
    array.get_u8_le(i).to_U16.bit_or(
        array.get_u8_le(i + 1).to_U16.shift_left(8_U16)
    )
);

// Decodes U32 from `array` at position `i` with little endian.
get_u32_le: I64 -> Array U8 -> U32;
get_u32_le = |i, array| (
    array.get_u16_le(i).to_U32.bit_or(
        array.get_u16_le(i + 2).to_U32.shift_left(16_U32)
    )
);

// Decodes U64 from `array` at position `i` with little endian.
get_u64_le: I64 -> Array U8 -> U64;
get_u64_le = |i, array| (
    array.get_u32_le(i).to_U64.bit_or(
        array.get_u32_le(i + 4).to_U64.shift_left(32_U64)
    )
);

// Encodes U8 into `array` at position `i` with little endian.
set_u8_le: I64 -> U8 -> Array U8 -> Array U8;
set_u8_le = |i, val, array| (
    array.set(i, val)
);

// Encodes U16 into `array` at position `i` with little endian.
set_u16_le: I64 -> U16 -> Array U8 -> Array U8;
set_u16_le = |i, val, array| (
    array.set_u8_le(i, val.to_U8)
         .set_u8_le(i + 1, val.shift_right(8_U16).to_U8)
);

// Encodes U32 into `array` at position `i` with little endian.
set_u32_le: I64 -> U32 -> Array U8 -> Array U8;
set_u32_le = |i, val, array| (
    array.set_u16_le(i, val.to_U16)
         .set_u16_le(i + 2, val.shift_right(16_U32).to_U16)
);

// Encodes U64 into `array` at position `i` with little endian.
set_u64_le: I64 -> U64 -> Array U8 -> Array U8;
set_u64_le = |i, val, array| (
    array.set_u32_le(i, val.to_U32)
         .set_u32_le(i + 4, val.shift_right(32_U64).to_U32)
);

//-----------------------------------------------------------
// big endian
//-----------------------------------------------------------

// Decodes U8 from `array` at position `i` with big endian.
get_u8_be: I64 -> Array U8 -> U8;
get_u8_be = |i, array| (
    array.@(i)
);

// Decodes U16 from `array` at position `i` with big endian.
get_u16_be: I64 -> Array U8 -> U16;
get_u16_be = |i, array| (
    array.get_u8_be(i).to_U16.shift_left(8_U16).bit_or(
        array.get_u8_be(i + 1).to_U16
    )
);

// Decodes U32 from `array` at position `i` with big endian.
get_u32_be: I64 -> Array U8 -> U32;
get_u32_be = |i, array| (
    array.get_u16_be(i).to_U32.shift_left(16_U32).bit_or(
        array.get_u16_be(i + 2).to_U32
    )
);

// Decodes U64 from `array` at position `i` with big endian.
get_u64_be: I64 -> Array U8 -> U64;
get_u64_be = |i, array| (
    array.get_u32_be(i).to_U64.shift_left(32_U64).bit_or(
        array.get_u32_be(i + 4).to_U64
    )
);


// Encodes U8 into `array` at position `i` with big endian.
set_u8_be: I64 -> U8 -> Array U8 -> Array U8;
set_u8_be = |i, val, array| (
    array.set(i, val)
);

// Encodes U16 into `array` at position `i` with big endian.
set_u16_be: I64 -> U16 -> Array U8 -> Array U8;
set_u16_be = |i, val, array| (
    array.set_u8_be(i, val.shift_right(8_U16).to_U8)
         .set_u8_be(i + 1, val.to_U8)
);

// Encodes U32 into `array` at position `i` with big endian.
set_u32_be: I64 -> U32 -> Array U8 -> Array U8;
set_u32_be = |i, val, array| (
    array.set_u16_be(i, val.shift_right(16_U32).to_U16)
         .set_u16_be(i + 2, val.to_U16)
);

// Encodes U64 into `array` at position `i` with big endian.
set_u64_be: I64 -> U64 -> Array U8 -> Array U8;
set_u64_be = |i, val, array| (
    array.set_u32_be(i, val.shift_right(32_U64).to_U32)
         .set_u32_be(i + 4, val.to_U32)
);

//-----------------------------------------------------------
// Endian
//-----------------------------------------------------------

trait a: Endian {
    // Gets U8 from the byte array at position `i`.
    get_u8: I64 -> Array U8 -> a -> U8;
    // Gets U16 from the byte array at position `i`.
    get_u16: I64 -> Array U8 -> a -> U16;
    // Gets U32 from the byte array at position `i`.
    get_u32: I64 -> Array U8 -> a -> U32;
    // Gets U64 from the byte array at position `i`.
    get_u64: I64 -> Array U8 -> a -> U64;
    // Sets U8 into the byte array at position `i`.
    set_u8: I64 -> U8 -> Array U8 -> a -> Array U8;
    // Sets U16 into the byte array at position `i`.
    set_u16: I64 -> U16 -> Array U8 -> a -> Array U8;
    // Sets U32 into the byte array at position `i`.
    set_u32: I64 -> U32 -> Array U8 -> a -> Array U8;
    // Sets U64 into the byte array at position `i`.
    set_u64: I64 -> U64 -> Array U8 -> a -> Array U8;
}

type LittleEndian = unbox struct {
    data: ()
};

_little_endian: LittleEndian;
_little_endian = LittleEndian { data: () };

impl LittleEndian: Endian {
    get_u8 = |i, array, le| (
        array.@(i)
    );
    get_u16 = |i, array, le| (
        le.get_u8(i, array).to_U16.bit_or(
            le.get_u8(i + 1, array).to_U16.shift_left(8_U16)
        )
    );
    get_u32 = |i, array, le| (
        le.get_u16(i, array).to_U32.bit_or(
            le.get_u16(i + 2, array).to_U32.shift_left(16_U32)
        )
    );
    get_u64 = |i, array, le| (
        le.get_u32(i, array).to_U64.bit_or(
            le.get_u32(i + 4, array).to_U64.shift_left(32_U64)
        )
    );
    set_u8 = |i, val, array, le| (
        array.set(i, val)
    );
    set_u16 = |i, val, array, le| (
        let array = le.set_u8(i, val.to_U8, array);
        le.set_u8(i + 1, val.shift_right(8_U16).to_U8, array)
    );
    set_u32 = |i, val, array, le| (
        let array = le.set_u16(i, val.to_U16, array);
        le.set_u16(i + 2, val.shift_right(16_U32).to_U16, array)
    );
    set_u64 = |i, val, array, le| (
        let array = le.set_u32(i, val.to_U32, array);
        le.set_u32(i + 4, val.shift_right(32_U64).to_U32, array)
    );
}

type BigEndian = unbox struct {
    data: ()
};

_big_endian: BigEndian;
_big_endian = BigEndian { data: () };

impl BigEndian: Endian {
    get_u8 = |i, array, be| (
        array.@(i)
    );
    get_u16 = |i, array, be| (
        be.get_u8(i, array).to_U16.shift_left(8_U16).bit_or(
            be.get_u8(i + 1, array).to_U16
        )
    );
    get_u32 = |i, array, be| (
        be.get_u16(i, array).to_U32.shift_left(16_U32).bit_or(
            be.get_u16(i + 2, array).to_U32
        )
    );
    get_u64 = |i, array, be| (
        be.get_u32(i, array).to_U64.shift_left(32_U64).bit_or(
            be.get_u32(i + 4, array).to_U64
        )
    );
    set_u8 = |i, val, array, be| (
        array.set(i, val)
    );
    set_u16 = |i, val, array, be| (
        let array = be.set_u8(i, val.shift_right(8_U16).to_U8, array);
        be.set_u8(i + 1, val.to_U8, array)
    );
    set_u32 = |i, val, array, be| (
        let array = be.set_u16(i, val.shift_right(16_U32).to_U16, array);
        be.set_u16(i + 2, val.to_U16, array)
    );
    set_u64 = |i, val, array, be| (
        let array = be.set_u32(i, val.shift_right(32_U64).to_U32, array);
        be.set_u32(i + 4, val.to_U32, array)
    );
}
