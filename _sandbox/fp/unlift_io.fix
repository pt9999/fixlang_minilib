module Minilib.Monad.UnliftIO;

import Minilib.Common.Common;
import Minilib.Monad.IO;
import Minilib.Monad.Reader;
import Minilib.Monad.Writer;
import Minilib.Monad.State;
import Minilib.Monad.Result;

trait MonadUnliftIO = Monad + MonadUnliftIOIF;
trait MonadUnliftIOFail = Monad + MonadUnliftIOIF + MonadUnliftIOFailIF;

trait [m: *->*] m: MonadUnliftIOIF {
    type UnliftedIO m a;
    with_run_in_io: ((m a -> IO (UnliftedIO m a)) -> IO (UnliftedIO m b)) -> m b;
}

trait [m: *->*] m: MonadUnliftIOFailIF {
    type UnliftedIOFail m a;
    with_run_in_iofail: ((m a -> IOFail (UnliftedIOFail m a)) -> IOFail (UnliftedIOFail m b)) -> m b;
}

impl IO: MonadUnliftIOIF {
    type UnliftedIO IO a = a;
    with_run_in_io = |body| body(id);
}

impl IOFail: MonadUnliftIOIF {
    type UnliftedIO IOFail a = Result ErrMsg a;
    with_run_in_io = |body| body(to_result).from_io_result;
}

impl IOFail: MonadUnliftIOFailIF {
    type UnliftedIOFail IOFail a = a;
    with_run_in_iofail = |body| body(id);
}

impl [m: MonadUnliftIO] ReaderT e m: MonadUnliftIOIF {
    type UnliftedIO (ReaderT e m) a = UnliftedIO m a;
    with_run_in_io = |body| (
        reader_t $ |e|
        with_run_in_io(|run|
            body(run_reader_t(e) >> run)
        )
    );
}

impl [m: MonadUnliftIOFail] ReaderT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (ReaderT e m) a = UnliftedIOFail m a;
    with_run_in_iofail = |body| (
        reader_t $ |e|
        with_run_in_iofail(|run|
            body(run_reader_t(e) >> run)
        )
    );
}

impl [m: MonadUnliftIO] WriterT e m: MonadUnliftIOIF {
    type UnliftedIO (WriterT e m) a = UnliftedIO m (e, a);
    with_run_in_io = |body| (
        writer_t $
        with_run_in_io(|run|
            body(run_writer_t >> run)
        )
    );
}

impl [m: MonadUnliftIOFail] WriterT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (WriterT e m) a = UnliftedIOFail m (e, a);
    with_run_in_iofail = |body| (
        writer_t $
        with_run_in_iofail(|run|
            body(run_writer_t >> run)
        )
    );
}

impl [m: MonadUnliftIO] StateT s m: MonadUnliftIOIF {
    type UnliftedIO (StateT s m) a = UnliftedIO m (s, a);
    with_run_in_io = |body| (
        state_t $ |s|
        with_run_in_io(|run|
            body(run_state_t(s) >> run)
        )
    );
}

impl [m: MonadUnliftIOFail] StateT s m: MonadUnliftIOFailIF {
    type UnliftedIOFail (StateT s m) a = UnliftedIOFail m (s, a);
    with_run_in_iofail = |body| (
        state_t $ |s|
        with_run_in_iofail(|run|
            body(run_state_t(s) >> run)
        )
    );
}

/*
namespace ResultT {
    from_iofail: IOFail a -> ResultT ErrMsg IO a;
    from_iofail = |iof| (
         result_t $ iof.to_result
    );

    to_iofail: ResultT ErrMsg IO a -> IOFail a;
    to_iofail = |res| (
        from_io_result $ res.run_result_t
    );
}
*/

impl [m: MonadUnliftIO] ResultT e m: MonadUnliftIOIF {
    type UnliftedIO (ResultT e m) a = UnliftedIO m (Result e a);
    with_run_in_io = |body| (
        result_t $ with_run_in_io(|run| body(run_result_t >> run))
    );
}

// TODO: can implement with only [m: MonadUnliftIO]?
impl [m: MonadUnliftIOFail] ResultT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (ResultT e m) a = UnliftedIOFail m (Result e a);
    with_run_in_iofail = |body| (
        result_t $ with_run_in_iofail(|run| body(run_result_t >> run))
    );
}
