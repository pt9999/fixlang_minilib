module Minilib.Crypto.Tls13.HandshakeState;

import AsyncTask;
import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Crypto.Tls13.ECDHE;
import Minilib.Crypto.Tls13.ECDSA;
import Minilib.Crypto.Tls13.KeyShare;
import Minilib.Crypto.Tls13.Extensions;
import Minilib.Crypto.Tls13.Connection;
import Minilib.Crypto.Tls13.Protection;
import Minilib.Crypto.Tls13.HandshakeProtocol;
import Minilib.Crypto.Tls13.RecordProtocol;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;


namespace TLSRecordHelper {
    split_handshakes: TLSInnerPlaintext -> Result ErrMsg (Array (Handshake, Array U8));
    split_handshakes = |inner_plaintext| (
        let buf = ByteBuffer::make(inner_plaintext.@content, big_endian());
        loop_m(
            ([], buf), |(output, buf)|
            if buf.get_position >= buf.get_size { break_m $ output };
            let start = buf.get_position;
            let (handshake: Handshake, buf) = *buf.unmarshal;
            let end = buf.get_position;
            let handshake_bytes = buf.@array.subarray(start, end);
            let output = output.push_back((handshake, handshake_bytes));
            continue_m $ (output, buf)
        )
    );
}

type HandshakeState = unbox union {
    before_client_hello: BeforeClientHello,
    after_client_hello: AfterClientHello,
    after_server_hello: AfterServerHello,
    after_finished: AfterFinished,
};

impl HandshakeState: ToString {
    to_string = |hstate| (
        if hstate.is_before_client_hello { hstate.as_before_client_hello.to_string };
        if hstate.is_after_client_hello { hstate.as_after_client_hello.to_string };
        if hstate.is_after_server_hello { hstate.as_after_server_hello.to_string };
        if hstate.is_after_finished { hstate.as_after_finished.to_string };
        ""
    );
}

namespace HandshakeState {
    make: [m: Monad] m HandshakeState;
    make = pure $ before_client_hello $ BeforeClientHello { dummy: () };

    start_handshake: [m: MonadRandGen, m: MonadError] String -> HandshakeState -> m HandshakeState;
    start_handshake = |server_name, hstate| (
        if hstate.is_before_client_hello { hstate.as_before_client_hello.start_handshake(server_name) };
        error $ "start_handshake: wrong hstate"
    );

    send_records: [m: TLSConnection] HandshakeState -> m HandshakeState;
    send_records = |hstate| (
        let (records, hstate) = *hstate.pop_records_to_send;
        eval *TLSRecord::send_records(records);
        pure $ hstate
    );

    pop_records_to_send: [m: MonadError] HandshakeState -> m (Array TLSRecord, HandshakeState);
    pop_records_to_send = |hstate| (
        if hstate.is_after_client_hello {
            hstate.as_after_client_hello.pop_records_to_send
        };
        if hstate.is_after_finished {
            hstate.as_after_finished.pop_records_to_send
        };
        pure $ ([], hstate)
    );

    pop_appdata_received: [m: MonadError] HandshakeState -> m (Array U8, HandshakeState);
    pop_appdata_received = |hstate| (
        if hstate.is_after_finished {
            hstate.as_after_finished.pop_appdata_received
        };
        pure $ ([], hstate)
    );

    recv_record: [m: TLSConnection] HandshakeState -> m HandshakeState;
    recv_record = |hstate| (
        let record: TLSRecord = *TLSRecord::recv_record;
        hstate.on_recv_record(record)
    );

    try_recv_record: [m: TLSConnection] HandshakeState -> m (Option HandshakeState);
    try_recv_record = |hstate| (
        let opt: Option TLSRecord = *TLSRecord::try_recv_record;
        if opt.is_none { pure $ none() };
        let record = opt.as_some;
        hstate.on_recv_record(record)
    );

    on_recv_record: [m: MonadError] TLSRecord -> HandshakeState -> m HandshakeState;
    on_recv_record = |record, hstate| (
        if record.@content_type.is_alert {
            error $ "received alert: " + record.@fragment.to_string_hex
        };
        if record.@content_type.is_change_cipher_spec {
            eval debug_println("received change_cipher_spec");
            pure $ hstate
        };
        if hstate.is_after_client_hello {
            hstate.as_after_client_hello.on_recv_record(record)
        };
        if hstate.is_after_server_hello {
            hstate.as_after_server_hello.on_recv_record(record)
        };
        if hstate.is_after_finished {
            hstate.as_after_finished.on_recv_record(record)
        };
        pure $ hstate
    );
}

type BeforeClientHello = unbox struct {
    dummy: ()
};

impl BeforeClientHello: ToString {
    to_string = |obj| "BeforeClientHello {}";
}

namespace BeforeClientHello {
    start_handshake: [m: MonadRandGen] String -> BeforeClientHello -> m HandshakeState;
    start_handshake = |server_name, _| (
        let hello = ClientHello::empty;
        let hello = hello.init_random(*randgen_bytes(32));
        // init server_name
        let hello = hello.add_extension(Extension::server_name $
            ServerNameList::make([
                ServerName::make(server_name)
            ])
        );
        // init key_share
        // TODO: support other key agreement type
        let key_agreement = *ECDHE::make(ECParam::secp256r1);
        let ks: KeyShare = ks_client_hello $ KeyShareClientHello::make $ [
            key_agreement.to_key_share_entry
        ];
        let hello = hello.add_extension(Extension::key_share $ ks);
        // 9.2. Mandatory-to-Implement Extensions
        // TODO: cookie
        // TODO: signature_algorithms_cert

        eval debug_println("client_hello: extensions=" + hello.@extensions.to_string);
        let handshake: Handshake = Handshake::client_hello $ hello;
        let handshake_bytes: Array U8 = marshal_to_bytes(handshake);
        let client_hello_records: Array TLSRecord = TLSRecord::split_fragments(ContentType::handshake(), handshake_bytes);

        pure $ after_client_hello $ AfterClientHello {
            client_hello_records: client_hello_records,
            key_agreement: key_agreement,
            records_to_send: client_hello_records,
        }
    );
}


// TODO: support other key agreement type
type KeyAgreement = ECDHE;

type AfterClientHello = unbox struct {
    client_hello_records: Array TLSRecord,
    key_agreement: KeyAgreement,
    records_to_send: Array TLSRecord,
};

impl AfterClientHello: ToString {
    to_string = |hello| (
        "AfterClientHello {" +
        " client_hello_records=" + hello.@client_hello_records.to_string +
        " key_agreement=" + hello.@key_agreement.to_string +
        "}"
    );
}

namespace AfterClientHello {

    pop_records_to_send: [m: MonadError] AfterClientHello -> m (Array TLSRecord, HandshakeState);
    pop_records_to_send = |after_client_hello| (
        pure $ (
            after_client_hello.@records_to_send,
            HandshakeState::after_client_hello $ after_client_hello.set_records_to_send([])
        )
    );

    on_recv_record: [m: MonadError] TLSRecord -> AfterClientHello -> m HandshakeState;
    on_recv_record = |record, after_client_hello| (
        if !record.@content_type.is_handshake {
            error $ "after_client_hello: unexpected content type"
        };
        let client_hello_handshake_bytes = *after_client_hello.@client_hello_records.join_fragments;
        let server_hello_handshake_bytes = record.@fragment;
        let handshake: Handshake = *unmarshal_from_bytes(server_hello_handshake_bytes).from_result_t;
        if !handshake.is_server_hello {
            error $ "after_client_hello: unexpected handshake type"
        };
        let server_hello: ServerHello = handshake.as_server_hello;
        eval debug_println("server_hello=" + server_hello.to_string);

        // key agreement
        let key_agreement = after_client_hello.@key_agreement;
        let key_share_entry = *server_hello._find_key_share_entry;
        let shared_secret: SharedSecret = *key_agreement.accept_server_share(key_share_entry).from_result_t;
        eval debug_println("shared_secret=" + shared_secret.to_string_hex);

        // construct protection
        let cipher_suite = server_hello.@cipher_suite;
        let protection = *Protection::make(cipher_suite).from_result_t;
        let protection = protection.add_handshake_context(client_hello_handshake_bytes);
        let protection = protection.add_handshake_context(server_hello_handshake_bytes);
        let protection = *protection.init_handshake(shared_secret).from_result_t;

        pure $ after_server_hello $ AfterServerHello {
            protection: protection,
            server_hello: server_hello,
            handshakes: [],
        }
    );

    _find_key_share_entry: [m: MonadError] ServerHello -> m KeyShareEntry;
    _find_key_share_entry = |hello| (
        let opt = hello.@extensions.find(is_key_share).map(as_key_share);
        if opt.is_none { error $ "key_share not found" };
        let ks: KeyShare = opt.as_some;
        if !ks.is_ks_server_hello { error $ "not ks_server_hello" };
        let kse: KeyShareEntry = ks.as_ks_server_hello.@server_share;
        pure $ kse
    );
}

type AfterServerHello = unbox struct {
    protection: Protection,
    server_hello: ServerHello,
    handshakes: Array (Handshake, Array U8),
};

impl AfterServerHello: ToString {
    to_string = |obj| "AfterServerHello {}";
}

namespace AfterServerHello {
    on_recv_record: [m: MonadError] TLSRecord -> AfterServerHello -> m HandshakeState;
    on_recv_record = |record, after_server_hello| (
        let protection = after_server_hello.@protection;
        let inner_plaintext = *protection.decrypt_server(record.to_ciphertext).from_result_t;
        if !inner_plaintext.@content_type.is_handshake {
            error $ "after_server_hello: unexpected content type"
        };
        let handshakes = *inner_plaintext.split_handshakes.from_result_t;
        eval debug_println("received handshakes=" + handshakes.to_string);

        // concat handshakes
        let after_server_hello = after_server_hello.mod_handshakes(append(handshakes));
        let handshakes = after_server_hello.@handshakes;

        let have_finished = handshakes.map(@0).find_by(is_finished).is_some;
        if !have_finished {
            let after_server_hello = after_server_hello.mod_protection(mod_server(increment_sequence_number));
            // continue receiving
            pure $ HandshakeState::after_server_hello $ after_server_hello
        };

        // check finished
        eval *_check_handshakes_order(handshakes.map(@0));
        eval *_verify_server_finished(handshakes, protection);
        let protection = _update_handshake_context(handshakes, (0, handshakes.get_size), protection);
        let protection = protection.mod_server(increment_sequence_number);
        let server_params = ServerParams::make(after_server_hello.@server_hello, handshakes.map(@0));
        let asf: AfterFinished = *AfterFinished::make(protection, server_params);
        pure $ HandshakeState::after_finished $ asf
    );



    _check_handshakes_order: [m: MonadError] Array Handshake -> m ();
    _check_handshakes_order = |handshakes| (
        let size = handshakes.get_size;
        let get_count: (Handshake -> Bool) -> I64 = |f| handshakes.to_iter.filter(f).fold(0, |i, _| i + 1);
        let get_order: (Handshake -> Bool) -> I64 = |f| handshakes.find_by(f).as_some_or(-1);
        let or_error = |bool| if !bool { error $ "invalid handshakes order" } else { pure() };
        eval *(get_count(Handshake::is_encrypted_extensions) == 1).or_error;
        eval *(get_count(Handshake::is_certificate_request) <= 1).or_error;
        eval *(get_count(Handshake::is_certificate) == 1).or_error;
        eval *(get_count(Handshake::is_certificate_verify) == 1).or_error;
        eval *(get_count(Handshake::is_finished) == 1).or_error;
        eval *(get_order(Handshake::is_encrypted_extensions) == 0).or_error;
        eval *(get_order(Handshake::is_finished) == size - 1).or_error;
        pure()
    );

    _update_handshake_context: Array (Handshake, Array U8) -> (I64, I64) -> Protection -> Protection;
    _update_handshake_context = |handshakes, (start, end), protection| (
        handshakes.subarray(start, end).map(@1).to_iter.fold(
            protection, |protection, handshake_bytes|
            protection.add_handshake_context(handshake_bytes)
        )
    );

    _verify_server_finished:  [m: MonadError] Array (Handshake, Array U8) -> Protection -> m ();
    _verify_server_finished = |handshakes, protection| (
        let size = handshakes.get_size;
        let protection = _update_handshake_context(handshakes, (0, size - 1), protection);
        let finished = handshakes.@(size - 1).@0.as_finished;
        let verify_data = *protection.calc_finished_verify_data(true).from_result_t;
        eval debug_println("verify_data expected="+ verify_data.to_string_hex);
        eval debug_println("verify_data actual  ="+ finished.@verify_data.to_string_hex);
        if verify_data != finished.@verify_data {
            error $ "verify_data mismatch"
        };
        pure $ ()
    );
}

type ServerParams = unbox struct {
    server_hello: ServerHello,
    handshakes: Array Handshake, // EncryptedExceptions, [CertificateRequest], Certificate, CertificateVerify, Finished
};

namespace ServerParams {
    make: ServerHello -> Array Handshake -> ServerParams;
    make = |server_hello, handshakes| ServerParams {
        server_hello: server_hello,
        handshakes: handshakes
    };
}

type AfterFinished = unbox struct {
    protection: Protection,
    server_params: ServerParams,
    records_to_send: Array TLSRecord,
    appdata_received: Array U8,
};

impl AfterFinished: ToString {
    to_string = |obj| "AfterFinished {}";
}

namespace AfterFinished {
    make: [m: MonadError] Protection -> ServerParams -> m AfterFinished;
    make = |protection, server_params| (
        let ciphertext = *_make_client_finished(protection).from_result_t;
        let records_to_send = [
            ciphertext.to_record
        ];
        pure $ AfterFinished {
            protection: protection,
            server_params: server_params,
            records_to_send: records_to_send,
            appdata_received: [],
        }
    );

    _make_client_finished: Protection -> Result ErrMsg TLSCiphertext;
    _make_client_finished = |protection| (
        let verify_data = *protection.calc_finished_verify_data(true);
        let client_finished = Finished { verify_data: verify_data };
        let handshake_bytes = marshal_to_bytes(Handshake::finished $ client_finished);
        // TODO: client Certificate, CerfiticateVerify?
        let inner_plaintext = TLSInnerPlaintext::make(
            handshake_bytes,
            ContentType::handshake(),
            0
        );
        let ciphertext = *protection.encrypt_client(inner_plaintext).from_result_t;
        pure $ ciphertext
    );

    pop_records_to_send: [m: MonadError] AfterFinished -> m (Array TLSRecord, HandshakeState);
    pop_records_to_send = |after_finished| (
        pure $ (
            after_finished.@records_to_send,
            HandshakeState::after_finished $ after_finished.set_records_to_send([])
        )
    );

    pop_appdata_received: [m: MonadError] AfterFinished -> m (Array U8, HandshakeState);
    pop_appdata_received = |after_finished| (
        pure $ (
            after_finished.@appdata_received,
            HandshakeState::after_finished $ after_finished.set_appdata_received([])
        )
    );

    on_recv_record: [m: MonadError] TLSRecord -> AfterFinished -> m HandshakeState;
    on_recv_record = |record, after_finished| (
        let protection = after_finished.@protection;
        let inner_plaintext = *protection.decrypt_server(record.to_ciphertext).from_result_t;
        let after_finished = after_finished.mod_protection(mod_server(increment_sequence_number));
        if inner_plaintext.@content_type.is_handshake {
            let handshakes = *inner_plaintext.split_handshakes.from_result_t;
            eval debug_println("received handshakes=" + handshakes.to_string);
            pure $ HandshakeState::after_finished $ after_finished
        };
        if inner_plaintext.@content_type.is_application_data {
            eval debug_println("received application_data");
            let after_finished = after_finished.mod_appdata_received(
                append(inner_plaintext.@content)
            );
            pure $ HandshakeState::after_finished $ after_finished
        };

        eval debug_println("unsupported content_type: " + inner_plaintext.@content_type.to_string);
        pure $ HandshakeState::after_finished $ after_finished
    );
}
