// WARNING: This module only supports x86_64-linux-gnu.
// WARNING: IPv6 is not supported yet.

module Main;
import Debug;
import AsyncTask;

// from /usr/include/x86_64-linux-gnu/bits/
_AF_INET: I64;
_AF_INET = 2;

_SOCK_STREAM: I64;
_SOCK_STREAM = 1;

/*
type sockaddr_in = unbox struct {
    sin_family: U16;    // host byte order
    sin_port: U16;      // network byte order
    sin_addr: U32;      // network byte order
    padding1: U32;
    padding2: U32;
}
*/

_sockaddr_in_size: I64;
_sockaddr_in_size = 16;

// make IPv4 sockaddr
make_sockaddr_in: Array U8 -> U16 -> Array U8;
make_sockaddr_in = |addr, port| (
    //eval debug_eprintln("addr="+addr.to_iter.map(|x|x.to_string).join(",") + " port="+port.to_string);
    let port_h: U8 = port.shift_right(8_U16).bit_and(255_U16).to_U8;
    let port_l: U8 = port.bit_and(255_U16).to_U8;
    //eval debug_eprintln ("port_h="+port_h.to_string+" port_l="+port_l.to_string);
    let sockaddr_in = [
        2_U8, 0_U8, // sin_family = _AF_INET, host byte order
        port_h, port_l, // sin_port
        addr.@(0), addr.@(1), addr.@(2), addr.@(3), // sin_addr
        0_U8, 0_U8, 0_U8, 0_U8,
        0_U8, 0_U8, 0_U8, 0_U8
    ];
    sockaddr_in
);

sockaddr_in_to_string: Array U8 -> String;
sockaddr_in_to_string = |sockaddr| (
    let sa = sockaddr;
    let port = sa.@(2).to_U16.shift_left(8_U16).bit_or(sa.@(3).to_U16).to_string;
    let addr = sa.@(4).to_string + "." + sa.@(5).to_string + "." + 
        sa.@(6).to_string + "." + sa.@(7).to_string;
    addr + ":" + port
);

_socket: I64 -> I64 -> I64 -> I64;
_socket = |domain, type, protocol| (
    CALL_C[I32 socket(I32, I32, I32), domain.to_I32, type.to_I32, protocol.to_I32].to_I64
);

_bind: I64 -> Array U8 -> I64 -> I64;
_bind = |sockfd, addr, addrlen| (
    addr.borrow_ptr(|ptr| CALL_C[I32 bind(I32, Ptr, I32), sockfd.to_I32, ptr, addrlen.to_I32]).to_I64
);

_listen: I64 -> I64 -> I64;
_listen = |sockfd, backlog| (
    CALL_C[I32 listen(I32, I32), sockfd.to_I32, backlog.to_I32].to_I64
);

_accept: I64 -> (I64, Array U8);
_accept = |sockfd| (
    let addr: Array U8 = Array::fill(_sockaddr_in_size, 0_U8);
    let addrlen: Array U32 = Array::fill(1, 0_U32);
    let addrlen = addrlen.set(0, addr.get_size.to_U32);
    let fd = addr.borrow_ptr(|p_addr|
        addrlen.borrow_ptr(|p_addrlen|
            CALL_C[I32 accept(I32, Ptr, Ptr), sockfd.to_I32, p_addr, p_addrlen].to_I64
        )
    );
    let addr = (
        if fd == -1 { addr };
        let len = addrlen.@(0).to_I64;
        if len == addr.get_size { addr };
        addr.get_sub(0, len)
    );
    (fd, addr)
);

_connect: I64 -> Array U8 -> I64 -> I64;
_connect = |sockfd, addr, addrlen| (
    eval debug_eprintln("addr="+addr.to_iter.map(|x|x.to_string).join(","));
    addr.borrow_ptr(|ptr| CALL_C[I32 connect(I32, Ptr, I32), sockfd.to_I32, ptr, addrlen.to_I32]).to_I64
);

_send: I64 -> Array U8 -> I64 -> I64;
_send = |sockfd, buf, flags| (
    buf.borrow_ptr(|p_buf| CALL_C[I64 send(I32, Ptr, U64, I32), sockfd.to_I32, p_buf, buf.get_size.to_U64, flags.to_I32])
);

_recv: I64 -> I64 -> I64 -> (I64, Array U8);
_recv = |sockfd, bufsize, flags| (
    let buf = Array::fill(bufsize, 0_U8);
    let len = buf.borrow_ptr(|p_buf| CALL_C[I64 recv(I32, Ptr, U64, I32), sockfd.to_I32, p_buf, buf.get_size.to_U64, flags.to_I32]);
    (len, buf)
);

_close: I64 -> I64;
_close = |sockfd| (
    CALL_C[I32 close(I32), sockfd.to_I32].to_I64
);

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(I32), usec.to_I32].to_I64
);

// Parse host string (eg. "127.0.0.1" -> [127_U8, 0_U8, 0_U8, 1_U8])
// FIXME: <arpa/inet.h> の inet_addr()を使えばホスト名解決もできそう？
parse_host: String -> IOFail (Array U8);
parse_host = |host| (
    let host_split = host.split(".").to_array;
    if host_split.get_size != 4 {
        throw $ "Invalid host format: " + host
    }; 
    let addr: Array U8 = Array::fill(4, 0_U8);
    loop_m (
        (addr, 0), |(addr, i)|
        if i >= 4 {
            break_m $ addr
        };
        let res: Result ErrMsg U8 = from_string(host_split.@(i));
        if res.is_err {
            throw $ "Invalid host format: " + host + ": " + res.as_err
        };
        let addr = addr.set(i, res.as_ok);
        continue_m $ (addr, i + 1)
    )
);

/*
// FIXME: IPv6 is not supported
resolve_host: String -> IOFail (Array U8);
resolve_host = |host| (
    let hostent: Array U8 = Array::fill(256, 0_U8);    
    let buf: Array U8 = Array::fill(1024, 0_U8);
    let bufsize = buf.get_size;
    let result: Array Ptr = Array::fill(1, nullptr);
    let herrorno: Array I32 = Array::fill(1, 0_I32);
    let res = host.borrow_c_str(|host_ptr| 
        CALL_C[Ptr gethostbyname(Ptr), host_ptr]
    );
    if res == nullptr {
        throw $ "Resolving host failed: " + host
    };
    let addr: Array U8 = Array::fill(4, 0_U8);
    let addr = addr.set(0, a.shift_right(24).bit_and(255).to_U8);
    let addr = addr.set(1, a.shift_right(16).bit_and(255).to_U8);
    let addr = addr.set(2, a.shift_right(8).bit_and(255).to_U8);
    let addr = addr.set(3, a.shift_right(0).bit_and(255).to_U8);
    pure $ addr
);
*/

// Parse port string (eg. "8080" -> 8080_U16)
parse_port: String -> IOFail U16;
parse_port = |port| (
    let res: Result ErrMsg U16 = from_string(port);
    if res.is_err {
        throw $ "Invalid port: " + port + ": " + res.as_err
    };
    pure $ res.as_ok
);

parse_host_port: String -> IOFail (Array U8, U16);
parse_host_port = |host_port| (
    let split = host_port.split(":").to_array;
    if split.get_size <= 0 || split.get_size > 2 {
        throw $ "Invalid host_port format: " + host_port
    };
    let host = split.@(0);
    let port = if split.get_size == 2 { split.@(1) } else { "80" };
    pure $ (*parse_host(host), *parse_port(port))
);


listen: String -> I64 -> IOFail I64;
listen = |server_host_port, backlog| (
    let _ = *(pure());
    let (addr, port) = *parse_host_port(server_host_port);
    let sockaddr_in = make_sockaddr_in(addr, port);
    let socketfd = _socket(_AF_INET, _SOCK_STREAM, 0);
    if socketfd < 0 {
        throw $ "creating socket failed"
    };
    let ret = _bind(socketfd, sockaddr_in, sockaddr_in.get_size);
    if ret == -1 {
        let _ = _close(socketfd);
        throw $ "bind failed"
    };
    let ret = _listen(socketfd, backlog);
    if ret == -1 {
        let _ = _close(socketfd);
        throw $ "listen failed"
    };
    let _ = *(lift $ eprintln ("listening on " + server_host_port));
    pure $ socketfd
);

accept: I64 -> IOFail (I64, String);
accept = |sockfd| (
    let (fd, addr) = _accept(sockfd);
    if fd == -1 {
        throw $ "accept failed"
    };
    let addr = sockaddr_in_to_string (addr);
    pure $ (fd, addr)
);


connect: String  -> IOFail IOHandle;
connect = |host_port| (
    let _ = *(pure());
    let (addr, port) = *parse_host_port(host_port);
    let sockaddr_in = make_sockaddr_in(addr, port);
    let socketfd = _socket(_AF_INET, _SOCK_STREAM, 0);
    if socketfd < 0 {
        throw $ "creating socket failed"
    };
    let ret = _connect(socketfd, sockaddr_in, sockaddr_in.get_size);
    if ret < 0 {
        throw $ "connect failed"
    };
    let fp = "w+".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), socketfd.to_I32, mode]);
    if fp == nullptr {
        throw $ "fdopen failed"
    };
    eval CALL_C[() setbuf(Ptr, Ptr), fp, nullptr];
    pure $ IOHandle::from_file_ptr $ fp
);

http_fetch: String -> IOFail ();
http_fetch = |host_port| (
    let handle = *connect(host_port);
    eval *write_string(handle, "GET /index.html HTTP/1.0\n");
    eval *write_string(handle, "\n");
    eval *loop_m(
        (), |_| 
        let line = *read_line(handle);
        if line == "" {
            break_m $ ()
        };
        eval *(eprintln(line).lift);
        continue_m $ ()
    );
    eval *(close_file(handle).lift);
    pure()
);

client_test: IO ();
client_test = (
    let host_port = "127.0.0.1:8080";
    let host_port = "183.79.248.124:80";
    //let host_port = "www.yahoo.co.jp:80";

    http_fetch(host_port).try (
        |err| eprintln(err)
    )
);

_unsafe_perform_iofail: a -> IOFail a -> a;
_unsafe_perform_iofail = |default, iofail| (
    iofail.try(|e| 
        let _ = *(eprintln("error: " + e));
        pure $ default
    )
    ._unsafe_perform
);

recv: I64 -> I64 -> IOFail (Array U8);
recv = |fd, bufsize| (
    let (len, buf) = _recv(fd, bufsize, 0);
    if len == -1 { 
        throw $ "_recv failed"
    };
    let buf = if len == buf.get_size { buf } else { buf.get_sub(0, len) };
    pure $ buf
);


dummy: I64 -> IOFail ();
dummy = |fd| (
    let _ = *(lift $ eprintln ("dummy start: fd=" + fd.to_string));
    pure()
);

echo: I64 -> IOFail ();
echo = |fd| (
    let _ = *(lift $ eprintln ("echo start: fd=" + fd.to_string));
    loop_m(
        "", |str|
        let _ = *(lift $ eprintln ("recv start"));
        let buf = *recv(fd, 1024);
        eval _usleep(1000);
        let _ = *(lift $ eprintln ("recv end: buf.size=" + buf.get_size.to_string));
        if buf.get_size == 0 {
            break_m $ ()
        };
        let str = str + buf.push_back(0_U8)._unsafe_from_c_str;
        let str = *(loop_m(
            str, |str|
            let pos = str.find("\n", 0);
            if pos.is_none {
                break_m $ str
            };
            let pos = pos.as_some;
            let line = str.get_sub(0, pos);
            let str = str.get_sub(pos + 1, str.get_size);
            let _ = *(lift $ eprintln("> " + line));
            continue_m $ str
        ));
        continue_m $ str
    )
);

server_test: IO ();
server_test = (
    do {
        let server_host_port = "127.0.0.1:2525";
        let sockfd = *(listen(server_host_port, 10));
        loop_m(
            (), |_|
            let (fd, addr) = *(accept(sockfd));
            let _ = *(lift $ eprintln ("accepting " + addr));
            //let _ = *(echo (fd));
            let task = AsyncTask::make(|_|
                let ret: () = dummy(fd)._unsafe_perform_iofail();
                ret
            );
            let _ = *(lift $ eprintln ("sleeping"));
            eval _usleep(10 * 1000 * 1000);
            let _ = *(lift $ eprintln ("waiting"));
            let out = task.get;
            let _ = *(lift $ eprintln ("waiting done"));
            continue_m $ ()
        )
    }
    .try(|err| eprintln (err))
);

main: IO ();
//main = client_test;
main = server_test;
