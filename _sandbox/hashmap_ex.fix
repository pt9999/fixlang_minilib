module Main;

import Hash;
import HashMap;

import Minilib.Monad.Iden;
import Minilib.Testing.UnitTest;
import Minilib.Trait.Traversable;

// Inserts an element to a HashMap, or erases an element from a HashMap.
//
// Semantically, `hmap.set(key, opt_v)` is equivalent to
// `match opt_v { some(v) => hmap.insert(key, v), none() => hmap.erase(key) }`.
//
// # Parameters
// - `key`: A key
// - `opt_value`: If `some(v)`, an element is inserted. if `none()`, any element for `key` is erased.
// - `hmap`: A hashmap
set : [k : HashKey] k -> (Option v) -> HashMap k v -> HashMap k v;
set = |k, opt_v, mp| (
    let store = |action| mp.act(k, action);
    store.iset(opt_v)
);

// Modifies a hashmap by a functorial action. 
// 
// Semantically, `hmap.act(key, fun)` is equivalent to 
// `fun(hmap.find(key)).map(|opt_v| hmap.set(opt_v))`.
//
// `action` is a function which takes an `Option v` as an argument and returns an `f (Option v)`.
//  The argument of `action` is `some(old_value)` if there is an entry for the key `k`, `none()` if there is no entry.
//  `action` should return a lifted value for `f` of `some(new_value)`
//   if you want to keep the entry (with or without changing the value),
//   or return a lifted value for `f` of `none()` if you want to remove the entry.
//
// # Parameters
// - `key`: A key
// - `action`: The functorial action to be performed on the value for the key `key`.
// - `hmap`: A hashmap
act : [k : HashKey, f: Functor] k -> (Option v -> f (Option v)) -> HashMap k v -> f (HashMap k v);
act = |k, updater, mp| (
    let size = mp.get_size;
    let cap = mp.get_capacity;
    let mp = if size < cap { mp } else { mp.reserve(size+1) };
    let (table_idx, opt_bucket_idx) = mp._find_place(k);
    match opt_bucket_idx {
        some(bucket_idx) => (
            //mp.mod__table(Array::mod(table_idx, Array::set(bucket_idx, Option::some $ (k, v))))
            let opt_kv: Option (k, v) = mp[^_table][table_idx][bucket_idx].iget;
            let opt_old_value: Option v = opt_kv.map(Tuple2::@1);
            updater(opt_old_value).map(|opt_new_value|
                match opt_new_value {
                    none() => (
                        let mp = mp.mod__size(Add::add(-1));
                        mp[^_table][table_idx][bucket_idx].iset(Option::none())
                    ),
                    some(v) => (
                        mp[^_table][table_idx][bucket_idx].iset(Option::some $ (k, v))
                    )
                }
            )
        ),
        none() => (
            let opt_old_value: Option v = none();
            updater(opt_old_value).map(|opt_new_value|
                if opt_new_value.is_none { mp };
                let v = opt_new_value.as_some;
                let open_idx = mp.@_table.@(table_idx).find_by(Option::is_none);
                let mp = if open_idx.is_some {
                    let open_idx = open_idx.as_some;
                    //mp.mod__table(Array::mod(table_idx, Array::set(open_idx, Option::some $ (k, v))))
                    mp[^_table][table_idx][open_idx].iset(Option::some $ (k, v))
                } else {
                    //mp.mod__table(Array::mod(table_idx, Array::push_back(Option::some $ (k, v))))
                    mp[^_table][table_idx].imod(push_back $ Option::some $ (k, v))
                };
                mp.mod__size(Add::add(1))            
            )
        )
    }
);

test_act: TestCase;
test_act = (
    make_test("test_act") $ |_|
    let h: HashMap I64 I64 = HashMap::empty(10);
    let n = 1000;
    let count = 10;
    let h = range(0, count).fold(
        h, |_, h|
        range(0, n).fold(
            h, |i, h|
            let store = |action| h.act(i, action);
            store.imod(|opt_v| some $ opt_v.map_or(1, add(1)))
        )
    );
    assert_equal("size", n, h.get_size);;
    range(0, n).foreach_m(|i|
        let expected = some $ count;
        let actual = h.find(i);
        assert_equal("after increment i="+i.to_string, expected, actual)
    );;
    let h = range(0, count).fold(
        h, |_, h|
        range(0, n).fold(
            h, |i, h|
            let store = |action| h.act(i, action);
            store.imod(|opt_v| 
                match opt_v {
                    none() => none(),
                    some(v) => if v <= 1 { none() } else { some(v-1) }
                }
            )
        )
    );
    range(0, n).foreach_m(|i|
        let expected = none();
        let actual = h.find(i);
        assert_equal("after decrement i="+i.to_string, expected, actual)
    );;
    assert_equal("size", 0, h.get_size);;
    pure()
);

main: IO ();
main = (
    [
        test_act,
    ]
    .run_test_driver
);