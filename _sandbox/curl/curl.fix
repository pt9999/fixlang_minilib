module Minilib.Net.Curl;

import Debug;
import Minilib.Text.StringEx;

type Curl = box struct {
    dtor: Destructor Ptr
};

make: IOFail Curl;
make = (
    eval *pure();
    eval debug_eprintln("curl_glue_init");
    let glue = FFI_CALL[Ptr curl_glue_init()];
    let curl = Curl {
        dtor: Destructor::make(glue, |glue|
            eval debug_eprintln("curl_glue_cleanup");
            FFI_CALL[() curl_glue_cleanup(Ptr), glue]
        )
    };
    pure $ curl
);

_check_error: CInt -> Ptr -> IOFail ();
_check_error = |code, glue| (
    if code != 0.to_CInt {
        let errmsg = FFI_CALL[Ptr curl_glue_get_error_message(Ptr), glue];
        throw $ String::_unsafe_from_c_str_ptr(errmsg)
    };
    pure()
);

set_url: String -> Curl -> IOFail ();
set_url = |url, curl| (
    eval *pure();
    url.borrow_c_str(|p_url|
        curl.@dtor.borrow(|glue|
            glue._check_error(FFI_CALL[CInt curl_glue_set_url(Ptr, Ptr), glue, p_url])
        )
    )
);

perform: Curl -> IOFail ();
perform = |curl| (
    eval *pure();
    curl.@dtor.borrow(|glue|
        glue._check_error(FFI_CALL[CInt curl_glue_perform(Ptr), glue])
    )
);

set_boxed_value: I64 -> Boxed a -> Curl -> IOFail ();
set_boxed_value = |index, boxed, curl| (
    eval *pure();
    curl.@dtor.borrow(|glue|
        let retained_ptr = FFI::unsafe_get_retained_ptr_of_boxed_value(boxed);
        pure $ FFI_CALL[() curl_glue_set_boxed_value(Ptr, CInt, Ptr), glue, index.to_CInt, retained_ptr]
    )
);

get_boxed_value: I64 -> Curl -> IOFail (Boxed a);
get_boxed_value = |index, curl| (
    eval *pure();
    curl.@dtor.borrow(|glue|
        pure $ _get_boxed_value(index, glue)
    )
);

_get_boxed_value: I64 -> Ptr -> Boxed a;
_get_boxed_value = |index, glue| (
    let retained_ptr = FFI_CALL[Ptr curl_glue_get_boxed_value(Ptr, CInt), glue, index.to_CInt];
    FFI::unsafe_get_boxed_value_from_retained_ptr(retained_ptr)
);

_callback_write_function: Ptr -> CSizeT -> CSizeT -> Ptr -> CSizeT;
_callback_write_function = |ptr, size, nmemb, userdata| (
    // char* ptr, void* userdata
    eval debug_eprintln("_callback_write_function: nmemb=" + nmemb.to_string);
    let glue = userdata;
    let boxed: Boxed String = glue._get_boxed_value(1);
    let value: String = boxed.@value;
    eval debug_eprintln("value=" + value + " size=" + value.get_size.to_string);
    nmemb
);
FFI_EXPORT[_callback_write_function, _callback_write_function];

set_write_callback: Curl -> IOFail ();
set_write_callback = |curl| (
    eval *pure();
    curl.@dtor.borrow(|glue|
        glue._check_error(FFI_CALL[CInt curl_glue_set_write_callback(Ptr), glue])
    )
);
