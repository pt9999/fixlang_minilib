module Main;

import Minilib.Common.Assert;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Euclid;
import Minilib.Math.Types;
import Minilib.Text.Hex;

// https://en.wikipedia.org/wiki/Montgomery_modular_multiplication

type MontScheme = unbox struct {
    r_log_base: U64,    // r = 2 ^ (r_log_base * _log2_base)
    n: BigInt,          // the modulus
    m: BigInt,          // n * m = -1 mod r
    r2_mod_n: BigInt,         // r2_mod_n = r^2 mod n
    r3_mod_n: BigInt,         // r3_mod_n = r^3 mod n
};

namespace MontScheme {
    make: U64 -> BigInt -> MontScheme;
    make = |r_log_base, n| (
        let r: BigInt = one.shift_left(r_log_base * _log2_base);
        let (x, y, d) = extended_euclid(r, n);
        assert_lazy(|_| "R and N are not coprime", d == one) $ |_|
        // R * x + _N * y = 1
        // _N * (-y) = -1 mod R
        let m = (-y) % r;
        let m = if m.is_negative { m + r } else { m };

        // r^2 mod n
        let r2: BigInt = one.shift_left(r_log_base * _log2_base * 2_U64);
        let r2_mod_n = r2 % n;

        // r^3 mod n
        let r3: BigInt = one.shift_left(r_log_base * _log2_base * 3_U64);
        let r3_mod_n = r3 % n;

        MontScheme {
            r_log_base: r_log_base,
            n: n,
            m: m,
            r2_mod_n: r2_mod_n,
            r3_mod_n: r3_mod_n,
        }
    );

    mul_R: MontScheme -> BigInt -> BigInt;
    mul_R = |s, a| (
        BigInt::make(a.@sign, Array::fill(s.@r_log_base.to_I64, 0_U32).append(a.@nat))
    );

    mod_R: MontScheme -> BigInt -> BigInt;
    mod_R = |s, a| (
        BigInt::make(a.@sign, a.@nat.truncate(s.@r_log_base.to_I64))
    );

    div_R: MontScheme -> BigInt -> BigInt;
    div_R = |s, a| (
        BigInt::make(a.@sign, a.@nat.get_sub(s.@r_log_base.to_I64, a.@nat.get_size))
    );

    //REDC algorithm
    reduce: MontScheme -> BigInt -> BigInt;
    reduce = |s, aR| (
        let MontScheme { n:n, m:m } = s;
        let k: BigInt = (aR.mod_R(s) * m).mod_R(s);
        let a: BigInt = (aR + k * n).div_R(s);
        if a >= n {
            a - n
        } else {
            a
        }
    );
}

// Montgomery form
type Mont = unbox struct {
    aR: BigInt,                 // a * r mod n
    s: MontScheme         // the scheme
};

impl Mont: ToString {
    to_string = |mont| (
        "Mont { aR=" + mont.@aR.to_string + ", a=" + mont.to_BigInt.to_string + " }"
    );
}

namespace Mont {
    from_BigInt: BigInt -> MontScheme -> Mont;
    from_BigInt = |a, s| (
        let aR = (a * s.@r2_mod_n).reduce(s);
        Mont { aR: aR, s: s }
    );

    to_BigInt: Mont -> BigInt;
    to_BigInt = |mont| (
        let Mont { aR: aR, s: s } = mont;
        aR.reduce(s)
    );

    _inverse: Mont -> Mont;
    _inverse = |mont| (
        let Mont { aR: aR, s: s } = mont;
        let MontScheme { n:n, r3_mod_n:r3_mod_n } = s;
        let (aRinv, y, d) = extended_euclid(aR, n);
        assert_lazy(|_| "aR and N are not coprime", d == one) $ |_|
        // aR * aRinv = 1 mod n
        let inv_aR = (aRinv * r3_mod_n).reduce(s);
        Mont { aR: inv_aR, s: s }
    );
}

impl Mont: Add {
    add = |m1, m2| (
        let s = m1.@s;
        let aR = m1.@aR + m2.@aR;
        let aR = if aR >= s.@n { aR - s.@n } else { aR };
        Mont { aR: aR, s: s }
    );
}

impl Mont: Sub {
    sub = |m1, m2| (
        let s = m1.@s;
        let aR = m1.@aR - m2.@aR;
        let aR = if aR.is_negative { aR + s.@n } else { aR };
        Mont { aR: aR, s: s }
    );
}

impl Mont: Mul {
    mul = |m1, m2| (
        let s = m1.@s;
        let aR = (m1.@aR * m2.@aR).reduce(s);
        Mont { aR: aR, s: s }
    );
}

impl Mont: Div {
    div = |m1, m2| (
        m1 * m2._inverse
    );
}

type Montgomery = unbox union {
    no_mont: BigInt,
    mont: Mont
};

impl Montgomery: ToString {
    to_string = |m| (
        match m {
            no_mont(a) => "no_mont(" + a.to_string + ")",
            mont(m) => "mont(" + m.to_BigInt.to_string + ")",
        }
    );
}

namespace Montgomery {
    from_I64: I64 -> Montgomery;
    from_I64 = |i64| (
        no_mont $ BigInt::from_I64(i64)
    );

    to_BigInt: Montgomery -> BigInt;
    to_BigInt = |m| (
        match m {
            no_mont(a) => a,
            mont(m) => m.to_BigInt
        }
    );

    _map_op2: (BigInt -> BigInt -> BigInt) -> (Mont -> Mont -> Mont) -> (Montgomery -> Montgomery -> Montgomery);
    _map_op2 = |int_op, mont_op| (
        |a, b|
        match a {
            no_mont(a) => match b {
                no_mont(b) => no_mont $ int_op(a, b),
                mont(b) => mont $ mont_op(from_BigInt(a, b.@s), b)
            },
            mont(a) => match b {
                no_mont(b) => mont $ mont_op(a, from_BigInt(b, a.@s)),
                mont(b) => mont $ mont_op(a, b)
            }
        }
    );
}

impl Montgomery: Add {
    add = _map_op2(add, add);
}

impl Montgomery: Sub {
    sub = _map_op2(sub, sub);
}

impl Montgomery: Mul {
    mul = _map_op2(mul, mul);
}

impl Montgomery: Div {
    div = _map_op2(div, div);
}

namespace ECInt {
    from_string_hex: String -> Result ErrMsg BigInt;
    from_string_hex = |str| (
        let bytes: Array U8 = *FromStringHex::from_string_hex(str);
        from_bytes(bytes)
    );
}

scheme_1: MontScheme;
scheme_1 = (
    let n: BigInt = from_string("688150649").as_ok;
    let r_log_base = 1_U64;
    MontScheme::make(r_log_base, n)
);

scheme_secp256r1_p: MontScheme;
scheme_secp256r1_p = (
    //let n = ECInt::from_string_hex("FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551").as_ok;
    let p = ECInt::from_string_hex("FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF").as_ok;
    let r_log_base = 8_U64;
    MontScheme::make(r_log_base, p)
);

test_mont: IOFail ();
test_mont = (
    let s = scheme_secp256r1_p;
    let a: BigInt = from_string("12345").as_ok;
    let a: Mont = from_BigInt(a, s);
    let b: BigInt = from_string("78911").as_ok;
    let b: Mont = from_BigInt(b, s);
    println("a="+a.to_string).lift;;
    println("b="+b.to_string).lift;;
    println("a+b="+(a+b).to_string).lift;;
    println("a-b="+(a-b).to_string).lift;;
    println("a-b+b="+(a-b+b).to_string).lift;;
    println("a*b="+(a*b).to_string).lift;;
    println("a/b="+(a/b).to_string).lift;;
    println("a/b*b="+(a/b*b).to_string).lift;;
    println("a*b/b="+(a*b/b).to_string).lift;;
    pure()
);

main: IO ();
main = do {
    test_mont
}.try(eprintln);
