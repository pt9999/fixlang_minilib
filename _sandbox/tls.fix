module Main;

import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type U24 = unbox struct {
    v: U32
};

namespace U24 {
    to_U24: U32 -> U24;
    to_U24 = |v| U24 { v: v.bit_and(0xFFFFFF_U32) };

    to_U32: U24 -> U32;
    to_U32 = |u24| u24.@v.bit_and(0xFFFFFF_U32);
}

impl U24: Marshal {
    marshal = |val, buf| (
        // big-endian only
        let val = val.to_U32;
        let buf = buf.marshal(val.shift_right(16_U32).to_U8);
        let buf = buf.marshal(val.to_U16);
        buf
    );
}

impl U24: Unmarshal {
    unmarshal = |buf| (
        // big-endian only
        let (hi:U8, buf) = buf.unmarshal;
        let (lo:U16, buf) = buf.unmarshal;
        let val:U32 = hi.to_U32.shift_left(16_U32).bit_or(lo.to_U32);
        (val.to_U24, buf)
    );
}

trait a: GetByteSize {
    get_byte_size: a -> I64;
}

impl U8: GetByteSize {
    get_byte_size = |_| 1;
}

impl U16: GetByteSize {
    get_byte_size = |_| 2;
}

impl U24: GetByteSize {
    get_byte_size = |_| 3;
}

impl U32: GetByteSize {
    get_byte_size = |_| 4;
}

impl [a: GetByteSize] Array a: GetByteSize {
    get_byte_size = |arr| (
        let n = arr.get_size;
        if n == 0 { 0 } else { n * arr.@(0).get_byte_size }
    );
}

namespace Vector {
    marshal_fixed: [a: Marshal] Array a -> ByteBuffer -> ByteBuffer;
    marshal_fixed = |vector, buf| (
        let n = vector.get_size;
        loop(
            (buf, 0), |(buf, i)|
            if i >= n { break $ buf };
            let buf = buf.marshal(vector.@(i));
            continue $ (buf, i + 1)
        )
    );

    marshal_var_size: [a: Marshal, a: GetByteSize, sz: Marshal] Array a -> (I64 -> sz) -> ByteBuffer -> ByteBuffer;
    marshal_var_size = |vector, to_size, buf| (
        let size = vector.get_byte_size.to_size;
        let buf = buf.marshal(size);
        buf.marshal_fixed(vector)
    );

    unmarshal_fixed: [a: Unmarshal, a: GetByteSize] I64 -> ByteBuffer -> (Array a, ByteBuffer);
    unmarshal_fixed = |byte_size, buf| (
        if byte_size <= 0 { ([], buf) };
        loop(
            (buf, [], 0, 0), |(buf, vector, n, i)|
            if n != 0 && i >= n { break $ (vector, buf) };
            let (val, buf) = buf.unmarshal;
            let n = if n != 0 { n } else {
                byte_size / val.get_byte_size
            };
            let vector = vector.push_back(val);
            continue $ (buf, vector, n, i + 1)
        )
    );

    unmarshal_var_size: [a: Unmarshal, a: GetByteSize, sz: Unmarshal] (sz -> I64) -> ByteBuffer -> (Array a, ByteBuffer);
    unmarshal_var_size = |from_size, buf| (
        let (size, buf) = buf.unmarshal;
        let byte_size = size.from_size;
        buf.unmarshal_fixed(byte_size)
    );
}

type Handshake = unbox union {
    client_hello: ClientHello,
    server_hello: (),
    new_session_ticket: (),
    end_of_early_data: (),
    encrypted_extensions: (),
    certificate: (),
    certificate_request: (),
    certificate_verify: (),
    finished: (),
    key_update: (),
    message_hash: ()
};

type HandhshakeType = U8;

namespace Handshake {
    get_msg_type: Handshake -> HandhshakeType;
    get_msg_type = |h| (
        if h.is_client_hello { 1_U8 };
        if h.is_server_hello { 2_U8 };
        if h.is_new_session_ticket { 4_U8 };
        if h.is_end_of_early_data { 5_U8 };
        if h.is_encrypted_extensions { 8_U8 };
        if h.is_certificate { 11_U8 };
        if h.is_certificate_request { 13_U8 };
        if h.is_certificate_verify { 15_U8 };
        if h.is_finished { 20_U8 };
        if h.is_key_update { 24_U8 };
        if h.is_message_hash { 254_U8 };
        eval assert(|_| "unknown msg_type", false);
        0_U8
    );

    _marshal_body: Handshake -> ByteBuffer -> ByteBuffer;
    _marshal_body = |h, buf| (
        if h.is_client_hello { buf.marshal(h.as_client_hello) };
        buf
    );
}

impl Handshake: Marshal {
    marshal = |h, buf| (
        let buf = buf.marshal(h.get_msg_type);
        let length_pos = buf.get_position;
        let buf = buf.marshal(0_U32.to_U24);
        let buf = buf._marshal_body(h);
        let last_pos = buf.get_position;
        let buf = buf.set_position(length_pos);
        let buf = buf.marshal((last_pos - (length_pos + 3)).to_U32.to_U24);
        let buf = buf.set_position(last_pos);
        buf
    );
}


type CipherSuite = U16;

type ClientHello = unbox struct {
    legacy_version: U16,                    // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id: Array U8,            // <0..32>
    cipher_suites: Array CipherSuite,       // <2..2^16-2>
    legacy_compression_method: Array U8,    // <1..2^8-1>
    extensions: Array Extension            // <8..2^16-1>
};

namespace ClientHello {
    make: SecureRandom -> IOFail ClientHello;
    make = |secure_random| (
        let (random, _) = *secure_random.generate_bytes(32);
        let random = Array::fill(32, 0x0a_U8);
        pure $ ClientHello {
            legacy_version: 0x0303_U16,
            random: random,
            legacy_session_id: [],
            cipher_suites: [],
            legacy_compression_method: [],
            extensions: []
        }
    );
}

impl ClientHello: Marshal {
    marshal = |msg, buf| (
        let buf = buf.marshal(msg.@legacy_version);
        let buf = buf.marshal_fixed(msg.@random);
        let buf = buf.marshal_var_size(msg.@legacy_session_id, to_U8);
        let buf = buf.marshal_var_size(msg.@cipher_suites, to_U16);
        let buf = buf.marshal_var_size(msg.@legacy_compression_method, to_U8);
        let buf = buf.marshal_var_size(msg.@extensions, to_U16);
        buf
    );
}

type ServerHello = unbox struct {
    legacy_version: U16,                    // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id_echo: Array U8,       // <0..32>
    cipher_suite: CipherSuite,              //
    legacy_compression_method: U8,          // = 0
    extensions: Array Extension            // <6..2^16-1>
};

impl ServerHello: Unmarshal {
    unmarshal = |buf| (
        let (legacy_version:U16, buf) = buf.unmarshal;
        let (random:Array U8, buf) = buf.unmarshal_fixed(32);
        let (legacy_session_id_echo:Array U8, buf) = buf.unmarshal_var_size(U8::to_I64);
        let (cipher_suite, buf) = buf.unmarshal;
        let (legacy_compression_method, buf) = buf.unmarshal;
        let (extensions, buf) = buf.unmarshal_var_size(U16::to_I64);
        let msg = ServerHello {
            legacy_version: legacy_version,
            random: random,
            legacy_session_id_echo: legacy_session_id_echo,
            cipher_suite: cipher_suite,
            legacy_compression_method: legacy_compression_method,
            extensions: extensions
        };
        (msg, buf)
    );
}


type ExtensionType = U16;

type Extension = unbox struct {
    extension_type: ExtensionType,      // U16
    extension_data: Array U8
};

impl Extension: GetByteSize {
    get_byte_size = |ex| ex.@extension_type.get_byte_size + ex.@extension_data.get_byte_size;
}

impl Extension: Marshal {
    marshal = |ex, buf| (
        let buf = buf.marshal(ex.@extension_type);
        let buf = buf.marshal_var_size(ex.@extension_data, to_U16);
        buf
    );
}

impl Extension: Unmarshal {
    unmarshal = |buf| (
        let (extension_type, buf) = buf.unmarshal;
        let (extension_data, buf) = buf.unmarshal_var_size(U16::to_I64);
        let ex = Extension {
            extension_type: extension_type,
            extension_data: extension_data
        };
        (ex, buf)
    );
}

test1: IO ();
test1 = (
    do {
        let secure_random = *SecureRandom::make;
        let hello = *ClientHello::make(secure_random);
        let handshake = client_hello(hello);
        let buf = ByteBuffer::empty(0, big_endian());
        let buf = buf.marshal(handshake);
        println(buf.@array.to_string_hex).lift
    }.try(eprintln)
);

test2: IO ();
test2 = (
    do {
        let array = *from_string_hex("03030a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a001234000000").from_result;
        let buf = ByteBuffer::make(array, big_endian());
        let (hello:ServerHello, buf) = buf.unmarshal;
        println((hello.@cipher_suite, hello.@legacy_compression_method).format(
            "cipher_suite={} legacy_compression_method={}"
        )).lift
    }.try(eprintln)
);

main: IO ();
main = test2;
