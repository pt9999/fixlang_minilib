// Duality test for Free monad and Cofree comonad
module Main;

import HashMap;

import Minilib.Common.Common;
import Minilib.Comonad.Cofree;
import Minilib.Monad.IO;
import Minilib.Monad.Free;
import Minilib.Trait.Comonad;
import Minilib.Trait.Dual;


//---------------------------------------------------------
// MonadFileIO definition

trait MonadFileIO = Monad + MonadFileIOIF;

trait [m: *->*] m: MonadFileIOIF {
    read_file: Path -> m String;
    write_file: Path -> String -> m ();
}

namespace MonadFileIOTest {
    test_monad_file_io: [m: MonadFileIO] m String;
    test_monad_file_io = (
        let msg = "";
        write_file("/home/user1/test1.txt", "Hello world");;
        write_file("/home/user1/test2.txt", "Foo bar baz");;
        let data = *read_file("/home/user1/test1.txt");
        let msg = msg + "reading from test1.txt: " + data + "\n";
        let data = *read_file("/home/user1/test2.txt");
        let msg = msg + "reading from test2.txt: " + data + "\n";
        pure $ msg
    );
}

//---------------------------------------------------------
// MonadFileIO implementation using a Free Monad

type FileIORequest a = unbox union {
    req_read_file: (Path, String -> a),
    req_write_file: ((Path, String), () -> a),
};

impl FileIORequest: Functor {
    map = |f, req| match req {
        req_read_file((arg, next)) => req_read_file((arg, next.map(f))),
        req_write_file((arg, next)) => req_write_file((arg, next.map(f))),
    };
}

//type FileIO a = Free FileIORequest a;

impl Free FileIORequest: MonadFileIOIF {
    read_file = |path| req_read_file((path, id)).lift_f;
    write_file = |path, data| req_write_file(((path, data), id)).lift_f;
}

//---------------------------------------------------------
// Preparing a Cofree Comonad

type FileIOResponse b = unbox struct {
    res_read_file: Path -> (String, b),
    res_write_file: Path -> String -> b,
};

impl FileIOResponse: Functor {
    map = |f, res| FileIOResponse {
        res_read_file: res.@res_read_file.map(map(f)),
        res_write_file: res.@res_write_file.map(map(f)),
    };
}

impl FileIORequest: Dual {
    type DualOf FileIORequest = FileIOResponse;
    zap = |f, req, res| match req {
        req_read_file((path, callback)) => (
            let (data, b) = (res.@res_read_file)(path);
            let a = callback(data);
            f(a, b)
        ),
        req_write_file(((path, data), callback)) => (
            let b = (res.@res_write_file)(path, data);
            let a = callback();
            f(a, b)
        ),
    };
}

impl FileIOResponse: Dual {
    type DualOf FileIOResponse = FileIORequest;
    zap = |f, res, req| zap(f.flip, req, res);
}

type MockFileIO = unbox struct {
    files: HashMap Path String,
};

namespace MockFileIO {
    empty: MockFileIO;
    empty = MockFileIO {
        files: HashMap::empty(10),
    };

    mock_read_file: MockFileIO -> Path -> (String, MockFileIO);
    mock_read_file = |mock, path| (
        match mock.@files.find(path) {
            none() => ("", mock),
            some(data) => (data, mock),
        }
    );

    mock_write_file: MockFileIO -> Path -> String -> MockFileIO;
    mock_write_file = |mock, path, data| (
        mock.mod_files(insert(path, data))
    );

    to_response: MockFileIO -> FileIOResponse MockFileIO;
    to_response = |mock| FileIOResponse {
        res_read_file: mock.mock_read_file,
        res_write_file: mock.mock_write_file,
    };

    to_cofree: MockFileIO -> Cofree FileIOResponse MockFileIO;
    to_cofree = |mock| mock.coiter(to_response);
}

test_free_cofree_zap: IO ();
test_free_cofree_zap = (
    let free: Free FileIORequest String = test_monad_file_io;
    let cofree: Cofree FileIOResponse MockFileIO = MockFileIO::empty.to_cofree;
    let op = |a, b| (a, b);
    //let (msg, mock) = zap(op, free, cofree);
    let (mock, msg) = zap(op, cofree, free);
    println(msg)
);

main: IO ();
main = (
    test_free_cofree_zap
);
