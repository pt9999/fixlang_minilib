module Main;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.X509Path;
import Minilib.Crypto.Cert.Pem;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
import Minilib.Thread.Time;
import Minilib.Testing.UnitTest;

dump_triplets: Path -> IOFail ();
dump_triplets = |path| (
    let bytes = *read_file_bytes(path);
    let buf = ByteBuffer::make(bytes, big_endian());
    let sm: StateT ByteBuffer IOFail () = loop_m(
        (), |_|
        let buf = *get_state;
        if buf.@position >= buf.get_size { break_m $ () };
        let identifier = *decode_identifier;
        let length = *decode_length;
        if identifier.@constructed {
            eval *println(
                identifier.to_string +
                " length=" + length.to_string
            ).lift.lift_t;
            continue_m $ ()
        };
        let contents = *decode_contents(length);
        eval *println(
            identifier.to_string +
            " length=" + length.to_string +
            " contents=" + contents.to_string_hex +
            if identifier.@tag == tag_printable_string {
                " (" + contents._unsafe_to_string + ")"
            } else { "" }
        ).lift.lift_t;
        continue_m $ ()
    );
    sm.run_state_t(buf).forget
);


perf_certificates_pem: Path -> IOFail (Array Certificate);
perf_certificates_pem = |path| (
    let contents = *read_file_string(path);
    let _ = *timeit(
        "parse", |_|
        let _: Result ErrMsg () = do {
            let entries = *parse_pem_entries(contents);
            let certificates: Array Certificate = *entries.map_m(|entry|
                from_bytes(entry.@bytes)
            );
            pure()
        };
        ()
    ).lift;
    pure $ []
);


test_dump_triplets: IOFail ();
test_dump_triplets = (
    let path = Path::parse(".local/tmp.cert_0.cer").as_some;
    dump_triplets(path)
);

test_cert_path: IOFail ();
test_cert_path = (
    let certs = *Iterator::range(0, 3).to_array.map_m(|i|
        let path = Path::parse((i,).format(".local/tmp.cert_{}.cer")).as_some;
        read_certificate_from_file(path)
    );
    let ca_certs = *CACertificates::make;
    let path = *CertificatePath::make(certs, ca_certs);
    println(path.to_string).lift
);

test_read_certificates_from_file: IOFail ();
test_read_certificates_from_file = (
    let path = Path::parse(".local/tmp.cert_0.cer").as_some;
    //let path = Path::parse("/etc/ssl/certs/ca-certificates.crt").as_some;
    //let path = Path::parse("/etc/ssl/certs/Amazon_Root_CA_3.pem").as_some;
    let certificates = *read_certificates_from_file(path);
    certificates.foreach_m(|certificate|
        eval *println(certificate.to_string).lift;
        println("").lift
    )
);

main: IO ();
main = (
    do {
        //eval *test_dump_triplets;
        eval *test_cert_path;
        //eval *test_read_certificates_from_file;
        pure()
    }.try(eprintln)
);