module Main;

import AsyncTask;
import Random;

import Deque;
import StringEx;

namespace Channel {
    type Channel a = unbox struct {
        data: Var (Deque a)
    };

    make: I64 -> IO (Channel a);
    make = |size| (
        let var = *Var::make(Deque::empty(size));
        pure $ Channel { data: var }
    );

    is_empty: Channel a -> IO Bool;
    is_empty = |chan| (
        let deque = *chan.@data.get;
        pure $ deque.is_empty
    );

    send: a -> Channel a -> IO ();
    send = |a, chan| (
        chan.@data.mod(push_back(a))
    );

    recv: Channel a -> IO a;
    recv = |chan| (
        chan.@data.wait_and_lock(
            |deque| !deque.is_empty,
            |deque|
            let a = deque.get_front.as_some;
            let deque = deque.pop_front;
            let _ = *chan.@data.Var::set(deque);
            pure $ a
        )
    );

    try_recv: Channel a -> IO (Option a);
    try_recv = |chan| (
        chan.@data.lock(
            |deque|
            if deque.is_empty { pure $ none() };
            let a = deque.get_front.as_some;
            let deque = deque.pop_front;
            let _ = *chan.@data.Var::set(deque);
            pure $ some(a)
        )
    );
}

impl Var a: Eq {
    eq = |var1, var2| (
        var1.@_dtor.borrow(|handle1|
            var2.@_dtor.borrow(|handle2|
                handle1 == handle2
            )
        )
    );
}

impl Channel a: Eq {
    eq = |chan1, chan2| (
        chan1.@data == chan2.@data 
    );
}

namespace Topic {
    type Topic a = unbox struct {
        subscribers: Iterator (Channel a)
    };

    empty: Topic a;
    empty = Topic {
        subscribers: []
    };

    subscribe: Channel a -> Topic a -> Topic a;
    subscribe = |chan, topic| (
        topic.mod_subscribers(push_front(chan))
    );
    
    unsubscribe: Channel a -> Topic a -> Topic a;
    unsubscribe = |chan, topic| (
        topic.mod_subscribers(filter(|ch| ch != chan))
    );

    notify: a -> Topic a -> IO ();
    notify = |value, topic| (
        topic.@subscribers.fold_m(
            (), |_, chan|
            chan.send(value)
        )
    );
}

map_m: [m : Monad] (a -> m b) -> Array a -> m (Array b);
map_m = |f, array| array.to_iter.fold_m(
    Array::empty(array.get_size), |output, a|
    let b = *f(a);
    pure $ output.push_back(b)
);

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);


test1: IO ();
test1 = (
    let _ = *pure();
    let rand_var = *Var::make(Random::init_by_seed(123_U64));
    let sleep_random: IO () = (
        let u64 = *rand_var.lock(|rand|
            let (u64, rand) = rand.generate_U64;
            let _ = *rand_var.Var::set(rand);
            pure $ u64
        );
        eval _usleep((u64 % 100000_U64).to_I64);
        pure()
    );
    let n = 20;
    let indices = Iterator::range(0, n).to_array;
    let channels = *indices.map_m(|_| Channel::make(4));
    let channel_result = *Channel::make(4);
    let task_func = |idx| (
        let _ = *eprintln(idx.to_string + ": 1st send to " + idx.to_string);
        let _ = *channels.@(idx).send(idx);
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 1st recv from " + ((idx+n/3)%n).to_string);
        let val = *channels.@((idx+n/3)%n).recv;
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 2nd send to " + idx.to_string);
        let _ = *channels.@(idx).send(val);
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 2nd recv from " + ((idx+n*2/3)%n).to_string);
        let val = *channels.@((idx+n*2/3)%n).recv;
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": final send to " + idx.to_string);
        let _ = *channel_result.send((idx,val));
        pure()
    );
    let tasks = *indices.map_m(
        |idx|
        AsyncIOTask::make(
            TaskPolicy::run_after_destructed.bit_or(TaskPolicy::on_dedicated_thread),
            task_func(idx)
        )
    );
    let (idx, val) = *channel_result.recv;
    let _ = *tasks.map_m(get);
    let _ = *eprintln("idx=" + idx.to_string + " val="+val.to_string);
    loop_m(
        (), |_|
        let opt = *channel_result.try_recv;
        if opt.is_none { break_m $ () };
        let (idx, val) = opt.as_some;
        let _ = *eprintln("rest idx=" + idx.to_string + " val="+val.to_string);
        continue_m $ ()
    )
);

main: IO ();
main = test1;
