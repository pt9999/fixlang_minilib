module Main;

import Minilib.App.Clap;
import Minilib.IO.Errno;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;
import Publisher.ProcessRunner;

log_message: [m: MonadIO] String -> m ();
log_message = |str| println(str).lift_io;

// Constants
namespace C {
    // ファイル名: "fixproj.toml"
    fixproj_toml: String = "fixproj.toml";
    // ファイル名: "fixdeps.lock"
    fixdeps_lock: String = "fixdeps.lock";
    // ディレクトリ名: "docs"
    docs_dir: String = "docs";
    // Gitブランチ名: "main"
    main_branch: String = "main";
    // Gitタグ名: "latest"
    latest_tag: String = "latest";
}

check_if_file_exists: Path -> IOFail ();
check_if_file_exists = |filepath| (
    if ! *file_exists(filepath).lift {
        throw $ "File not found: " + filepath
    };
    pure()
);

check_if_directory_exists: Path -> IOFail ();
check_if_directory_exists = |dirpath| (
    if ! *directory_exists(dirpath).lift {
        throw $ "Directory not found: " + dirpath
    };
    pure()
);

check_branch_name: String -> IOFail ();
check_branch_name = |expected| (
    log_message((expected,).format("### Checking if the current branch name is `{}`"));;
    let (stdout, stderr) = *run_process_quietly(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
    let actual = stdout.strip_spaces;
    if actual != expected {
        throw $ (expected, actual).format("The current branch name is not `{}`: actual = `{}`")
    };
    pure()
);

check_uncommitted_files: IOFail ();
check_uncommitted_files = (
    log_message("### Checking for uncommitted files");;
    let (stdout, stderr) = *run_process(["git", "diff", "--name-only"]);
    if stdout != "" {
        throw $ "Uncommitted file exists"
    };
    pure()
);

no_commit_since_latest: IOFail Bool;
no_commit_since_latest = (
    log_message("### Checking if there is any commit from the latest release");;
    let (stdout, stderr) = *run_process(["git", "diff", "--name-only", C::latest_tag]);
    if stdout == "" {
        pure $ true
    };
    pure $ false
);

reset_fixdeps_lock: IOFail ();
reset_fixdeps_lock = (
    let (stdout, stderr) = *run_process(["git", "checkout", "--", C::fixdeps_lock]);
    pure()
);

commit_fixdeps_lock: IOFail ();
commit_fixdeps_lock = (
    let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", C::fixdeps_lock]);
    if stdout == "" { pure() };
    let (stdout, stderr) = *run_process(["git", "add", "--", C::fixdeps_lock]);
    let (stdout, stderr) = *run_process(["git", "commit", "-m", "update deps", "--", C::fixdeps_lock]);
    pure()
);

reset_docs: IOFail ();
reset_docs = (
    let (stdout, stderr) = *run_process(["git", "checkout", "--", C::docs_dir]);
    pure()
);

run_python_verup: String -> Bool -> IOFail ();
run_python_verup = |verup_py, confirm| (
    let confirm = if confirm { "--confirm" } else { "--no-confirm" };
    let args = ["python3", verup_py, "--update-document", "--commit", "--tag", "--push", confirm];
    let (stdout, stderr) = *run_process_with_options(args, ["verbose", "has_input"]);
    pure()
);

run_command_release: ArgMatches -> IOFail ();
run_command_release = |submatches| (
    let confirm = submatches.get_one("confirm").as_some == "true";
    let topdir = submatches.get_one("topdir").as_some;
    let topdir = *realpath(topdir);

    let verup_py = join_paths([topdir, "_verup.py"]);
    check_if_file_exists(verup_py);;

    let subproject_dir = submatches.get_one("dir").as_some;
    let subproject_dir = *realpath(subproject_dir);
    log_message("=== " + subproject_dir + " ===");;
    chdir(subproject_dir);;

    let git_dir = join_paths([subproject_dir, ".git"]);
    check_if_directory_exists(git_dir);;

    let fixproj_toml_path = join_paths([subproject_dir, C::fixproj_toml]);
    check_if_file_exists(fixproj_toml_path);;

    check_branch_name(C::main_branch);;
    check_uncommitted_files;;

    log_message("### Clean");;
    let (stdout, stderr) = *run_process(["fix", "clean"]);
    log_message("### Update deps");;
    let (stdout, stderr) = *run_process(["fix", "deps", "update"]);
    do {
        log_message("### Run tests");;
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "basic"]);
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "max"]);
        log_message("### Make documents for testing");;
        let (stdout, stderr) = *run_process(["fix", "docs", "-o", C::docs_dir]);
        pure()
    }
    .catch(|errmsg|
        log_message("### Caught error: " + errmsg);;
        reset_fixdeps_lock;;
        reset_docs;;
        throw $ errmsg
    );;
    if *no_commit_since_latest {
        log_message("### No need to publish");;
        reset_fixdeps_lock;;
        reset_docs;;
        pure()
    };
    reset_docs;;
    commit_fixdeps_lock;;

    run_python_verup(verup_py, confirm);;
    pure()
);

command_release: Command;
command_release = (
    Command::new("release")
    .display_name("publisher.out release")
    .about("Make a release")
    .arg(Arg::new("dir").short('d').long("dir").help("subproject directory").takes_value.required)
    .arg(Arg::new("topdir").long("topdir").help("_projects directory").takes_value.default_value(".."))
    .arg(Arg::new("confirm").long("confirm").help("confirm when version up").default_value("true"))
);

command_main: Command;
command_main = (
    Command::new("publisher.out")
    .version("0.1.0")
    .about("Release tool for subprojects")
    .subcommand(command_release)
);

run_command_main: ArgMatches -> IOFail ();
run_command_main = |matches| (
    if matches.subcommand.is_none {
        throw $ "no subcommand is specified"
    };
    let (name, submatches) = matches.subcommand.as_some;
    if name == "release" {
        run_command_release(submatches)
    } else {
        throw $ "invalid subcommand: " + name
    }
);

main: IO ();
main = (
    do {
        let args = *IO::get_args.lift;
        let matches = *command_main.get_matches_from(args).from_result;
        run_command_main(matches);;
        IO::exit(0).lift
    }.try(|errmsg| 
        eprintln("\nError: " + errmsg);;
        IO::exit(1)
    )
);
