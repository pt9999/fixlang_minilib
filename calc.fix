module Main;

import Character;
import Debug;

type Value = I64;

// box を書かないと stack overflow になる
type Expr = box union {
    ex_value: Value,
    ex_add: (Expr, Expr),
    ex_mul: (Expr, Expr)
};

skip_whitespaces: Iterator U8 -> Iterator U8;
skip_whitespaces = |itor| (
    let res = itor.advance;
    if res.is_none {
        itor
    };
    let (ch, next) = res.as_some;
    if (not(is_space(ch))) {
        itor
    };
    skip_whitespaces (next)
);


take_while: (Array a, Iterator a) -> (a -> Bool) -> (Array a, Iterator a);

take_while = |(arr, itor), filter| (
    loop((arr, itor), |(arr, itor)| (
        let next = itor.advance;
        if next.is_none {
            break $ (arr, itor)
        };
        let (a, next) = next.as_some;
        if (not (filter(a))) {
            break $ (arr, itor)
        };
        let arr = arr.push_back (a);
        continue $ (arr, next)
    ))
);

impl Array U8: ToString {
    to_string = |arr| String::from_c_str(arr.push_back(0_U8));
}

impl Iterator U8: ToString {
    to_string = |itor| itor.to_array.to_string;
}


parse_value: Iterator U8 -> Result ErrMsg (Expr, Iterator U8);
parse_value = |itor| (
    let itor = skip_whitespaces (itor);
    let (arr, itor) = take_while(([], itor), is_digit);
    let str = arr.to_string;
    // eval debug_println ("str=" + str+" itor="+itor.to_string);
    let res : Result ErrMsg I64 = from_string(str);
    if res.is_err {
        err (ErrMsg::make (res.as_err.to_string + ": `" + str + "`"))
    };
    let value : I64 = res.as_ok;
    ok((ex_value(value), itor))
);

parse_mult: Iterator U8 -> Result ErrMsg (Expr, Iterator U8);
parse_mult = |itor| (
    let (expr, itor) = *parse_value (itor);
    let itor = skip_whitespaces (itor);
    let next = itor.advance;
    if next.is_none {
        ok((expr, itor))
    };
    let (a, next) = next.as_some;
    if (a != '*') {
        ok((expr, itor))
    };
    let (expr2, itor) = *parse_mult(next);
    ok((ex_mul((expr, expr2)), itor))
);

parse_add: Iterator U8 -> Result ErrMsg (Expr, Iterator U8);
parse_add = |itor| (
    let (expr, itor) = *parse_mult (itor);
    let itor = skip_whitespaces (itor);
    let next = itor.advance;
    if next.is_none {
        ok((expr, itor))
    };
    let (a, next) = next.as_some;
    if (a != '+') {
        ok((expr, itor))
    };
    let (expr2, itor) = *parse_add(next);
    ok((ex_add((expr, expr2)), itor))
);

evaluate: Expr -> Value;
evaluate = |expr| (
    if expr.is_ex_add {
        let (a, b) = expr.as_ex_add;
        evaluate(a) + evaluate(b)
    };
    if expr.is_ex_mul {
        let (a, b) = expr.as_ex_mul;
        evaluate(a) * evaluate(b)
    };
    expr.as_ex_value
);

calc: String -> String;
calc = |line| (
    let res = parse_add (line.get_bytes.to_iter);
    //let res = err(ErrMsg::make("hoge")) : Result ErrMsg (Expr, Iterator U8);
    if res.is_err {
        "Error: " + res.as_err.to_string
    };
    let (expr, itor) = res.as_ok;
    let value = evaluate(expr);
    value.to_string
);

flush : IOHandle -> IOResult ErrMsg ();
flush = |handle| (
    IOResult::from_result (
        let res = CALL_C[I32 fflush(Ptr), handle.@_file_ptr];
        if res < 0_I32 { 
            Result::err $ ErrMsg { msg : "flush failed!: some error occurred in fflush." } 
        };
        Result::ok()
    )
);

main_loop : () -> IOResult ErrMsg ();
main_loop = |_| (
    let _ = *write_string(stdout, "Calc ver 0.00\n");
    loop_m ((), |_| 
        let _ = *write_string(stdout, ">> ");
        let _ = *flush(stdout);
        let line = *read_line(IOHandle::stdin);
        if (line == "") {
            break_m $ ()
        };
        let line = calc(line) + "\n";
        let _ = *write_string (IOHandle::stdout, line);
        continue_m $ ()
    )
);

main : IO ();
main = (
    let res = *main_loop().to_io;
    if res.is_err {
        eprintln (res.as_err.to_string)
    };
    pure()
);