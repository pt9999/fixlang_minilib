module Minilib.Type.TBool;

trait b: TBool {
    type IfElse b t f;
}

type TTrue = struct {};

impl TTrue: Zero {
    zero = TTrue {};
}

impl TTrue: ToString {
    to_string = |_| "true";
}

impl TTrue: TBool {
    type IfElse TTrue t f = t;
}

type TFalse = struct {};

impl TFalse: Zero {
    zero = TFalse {};
}

impl TFalse: ToString {
    to_string = |_| "false";
}

impl TFalse: TBool {
    type IfElse TFalse t f = f;
}

type TBoolNot b = struct {};
impl TBoolNot b: Zero { zero = TBoolNot {}; }
impl [b: ToString, b: Zero] TBoolNot b: ToString { 
    to_string = |_| "not(" + (zero:b).to_string + ")"; 
}
impl [b: TBool] TBoolNot b: TBool {
    type IfElse (TBoolNot b) t f = IfElse b f t;
}

type TBoolAnd b1 b2 = struct {};
impl TBoolAnd b1 b2: Zero { zero = TBoolAnd {}; }
impl [b1: ToString, b1: Zero, b2: ToString, b2: Zero] TBoolAnd b1 b2: ToString { 
    to_string = |_| "and(" + (zero:b1).to_string + "," + (zero:b2).to_string + ")"; 
}
impl [b1: TBool, b2: TBool] TBoolAnd b1 b2: TBool {
    type IfElse (TBoolAnd b1 b2) t f = IfElse b1 (IfElse b2 t f) f;
}

type TBoolOr b1 b2 = struct {};
impl TBoolOr b1 b2: Zero { zero = TBoolOr {}; }
impl [b1: ToString, b1: Zero, b2: ToString, b2: Zero] TBoolOr b1 b2: ToString { 
    to_string = |_| "or(" + (zero:b1).to_string + "," + (zero:b2).to_string + ")"; 
}
impl [b1: TBool, b2: TBool] TBoolOr b1 b2: TBool {
    type IfElse (TBoolOr b1 b2) t f = IfElse b1 t (IfElse b2 t f);
}
