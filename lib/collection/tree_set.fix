// A tree set that preserves the order of elements.
module TreeSet;

import RBTree;

namespace TreeSet {
    // A trait of the element. Currently `ToString` is required.
    trait TreeSetElem = ToString;

    // A type of set that preserves the order of its elements.
    type TreeSet a = unbox struct {
        root: RBNode a,
        less_than: a -> a -> Bool
    };

    // `TreeSet::make()` creates an empty `TreeSet` using default `LessThan` ordering. 
    make: [a: TreeSetElem, a: LessThan] () -> TreeSet a;
    make = |_| (
        make_lt(|x,y| x < y)
    );

    // `TreeSet::make_lt(less_than)` creates an empty `TreeSet` using `less_than` ordering. 
    make_lt: [a: TreeSetElem] (a -> a -> Bool) -> TreeSet a;
    make_lt = |less_than| (
        TreeSet {
            root: RBNode::empty(),
            less_than: less_than
        }
    );
    
    // `ts.insert(x)` inserts `x` to `ts`.
    // If `ts` already contains an element `y` equivalent to `x`, 
    // ie. `!less_than(x,y) && !less_than(y,x)` is true,
    // then `y` is replaced with `x`.
    insert: [a: TreeSetElem] a -> TreeSet a -> TreeSet a;
    insert = |x, ts| (
       ts.mod_root(insert_lt(x, ts.@less_than))
    );

    // `ts.erase(x)` removes an element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true.
    erase: [a: TreeSetElem] a -> TreeSet a -> TreeSet a;
    erase = |x, ts| (
       ts.mod_root(remove_lt(x, ts.@less_than))
    );

    is_empty: [a: TreeSetElem] TreeSet a -> Bool;
    is_empty = |ts| (
        ts.@root.is_empty
    );

    contains: [a: TreeSetElem] a -> TreeSet a -> Bool;
    contains = |x, ts| (
        ts.@root.find(x, ts.@less_than).is_some
    );

    to_iter: [a: TreeSetElem] TreeSet a -> Iterator a;
    to_iter = |ts| (
        ts.@root.to_iter
    );

    from_iter_lt: [a: TreeSetElem] (a -> a -> Bool) -> Iterator a -> TreeSet a;
    from_iter_lt = |less_than, iter| (
        TreeSet {
            root: RBNode::from_iter_lt(less_than, iter),
            less_than: less_than
        }
    );

    from_iter: [a: LessThan, a: TreeSetElem] Iterator a -> TreeSet a;
    from_iter = |iter| (
        TreeSet::from_iter_lt(RBNode::_less_than, iter) 
    );

    intersect: [a : TreeSetElem] TreeSet k -> TreeSet k -> TreeSet k;
    intersect = |ts1, ts2| (
        ts1.to_iter.fold(
            ts1, |ts1, x|
            if ts2.contains(x) {
                ts1
            } else {
                ts1.erase(x)
            }
        )
    );

    merge: [a : TreeSetElem] TreeSet k -> TreeSet k -> TreeSet k;
    merge = |ts1, ts2| (
        ts2.to_iter.fold(
            ts1, |ts1, x|
            ts1.insert(x)
        )
    );
}

impl [a: TreeSetElem] TreeSet a: ToString {
    to_string = |ts| (
        "TreeSet{" + ts.to_iter.map(to_string).join(",") + "}"
    );
}
