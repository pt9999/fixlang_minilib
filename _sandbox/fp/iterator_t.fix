module Minilib.Monad.IteratorT;

// https://hackage.haskell.org/package/list-transformer-1.1.1

import Minilib.Monad.Trans;
import Minilib.Monad.IO;
import Minilib.Monad.Error;

type [m: * -> *] IteratorT m a = box struct {
    next: m (Option (a, IteratorT m a))
};


namespace IteratorT {
    make: [m: * -> *] m (Option (a, IteratorT m a)) -> IteratorT m a;
    make = |next| IteratorT { next: next };

    advance: [m: * -> *] IteratorT m a -> m (Option (a, IteratorT m a));
    advance = @next;

    empty: [m: Monad] IteratorT m a;
    empty = IteratorT::make $ pure $ none();

    is_empty: [m: Monad] IteratorT m a -> m Bool;
    is_empty = |xs| xs.advance.bind(|opt| pure $ opt.is_none);

    get_front: [m: Monad] IteratorT m a -> m (Option a);
    get_front = |xs| xs.advance.bind(|opt| pure $ opt.map(Tuple2::@0));

    push_front: [m: Monad] a -> IteratorT m a -> IteratorT m a;
    push_front = |x, xs| IteratorT::make $ pure $ some $ (x, xs);

    push_m_front: [m: Monad] m a -> IteratorT m a -> IteratorT m a;
    push_m_front = |x, xs| IteratorT::make $ do {
        pure $ some $ (*x, xs)
    };

    from_m_iter: [m: Monad] Iterator (m a) -> IteratorT m a;
    from_m_iter = |xs| IteratorT::make $ do {
        match xs.advance {
            none() => pure $ none(),
            some((x, xs2)) => pure $ some((*x, IteratorT::from_m_iter(xs2)))
        }
    };

    from_iter: [m: Monad] Iterator a -> IteratorT m a;
    from_iter = |xs| IteratorT::make $ do {
        match xs.advance {
            none() => pure $ none(),
            some((x, xs2)) => pure $ some((x, IteratorT::from_iter(xs2)))
        }
    };

    from_array: [m: Monad] Array a -> IteratorT m a;
    from_array = |arr| IteratorT::from_iter(arr.to_iter);

    to_array_m: [m : Monad] IteratorT m a -> m (Array a);
    to_array_m = |xs| (
        xs.fold_m(
            [], |array, x|
            pure $ array.push_back(x)
        )
    );

    append: [m: Monad] IteratorT m a -> IteratorT m a -> IteratorT m a;
    append = |ys, xs| IteratorT::make $ do {
        match *xs.advance {
            none() => ys.advance,
            some((x, xs2)) => pure $ some $ (x, xs2.append(ys))
        }
    };

    fold_m: [m : Monad] b -> (b -> a -> m b) -> IteratorT m a -> m b;
    fold_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)| (
            let next = *iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let accum = *op(accum, next);
            continue_m $ (accum, iter)
        ))
    );
}

impl [m: Functor] IteratorT m: Functor {
    map = |f, xs| (
        IteratorT::make $ xs.advance.map(
            |opt| opt.map(
                |(x, xs2)| (f(x), xs2.map(f))
            )
        )
    );
}

impl [m: Monad] IteratorT m: Monad {
    pure = |x| IteratorT::make $ pure $ some $ (x, IteratorT::empty);
    bind = |f, xs| (
        IteratorT::make $ do {
            match *xs.advance {
                none() => pure $ none(),
                some((x, ys)) => f(x).append(ys.bind(f)).advance
            }
        }
    );
}

impl IteratorT: MonadTrans {
    lift_t = |ma| (
        IteratorT::empty.push_m_front(ma)
    );
}

impl [m: MonadError] IteratorT m: MonadErrorIF {
    error = lift_t << error;
    catch = |handler, xs| (
        IteratorT::make $ do {
            match *xs.advance {
                none() => pure $ none(),
                some((x, xs2)) => pure $ some $ (x, xs2.catch(handler))
            }
        }.catch(handler >> advance)
    );
}

impl [m: MonadIO] IteratorT m: MonadIOIF {
    lift_io = lift_t << lift_io;
}

impl [m: MonadIOFail] IteratorT m: MonadIOFailIF {
    lift_iofail = lift_t << lift_iofail;
}