/*
    PNG file write test
    $ fix run -f png.fix ../lib/io_ex.fix ../lib/string_ex.fix -d png -d z
*/
module Main;

import Debug;

import IOEx;

namespace PngImageIO {
    type PngImageIO = unbox struct {
        data: Array U8
    };

    empty: PngImageIO;
    empty = (
        let img = PngImageIO {
            data: Array::fill(_def_png_image.@sizeof_png_image, 0_U8)
        };
        img.set_version(1)
    );

    get_width: PngImageIO -> I64;
    get_width = |img| img.@data.decode_u32_le(_def_png_image.@offsetof_width).to_I64;

    get_height: PngImageIO -> I64;
    get_height = |img| img.@data.decode_u32_le(_def_png_image.@offsetof_height).to_I64;

    get_warning_or_error: PngImageIO -> I64;
    get_warning_or_error = |img| img.@data.decode_u32_le(_def_png_image.@offsetof_warning_or_error).to_I64;

    get_message: PngImageIO -> String;
    get_message = |img| (
        img.@data.borrow_ptr(|ptr|
            String::_unsafe_from_c_str_ptr(ptr.add_offset(_def_png_image.@offsetof_message))
        )
    );

    set_version: I64 -> PngImageIO -> PngImageIO;
    set_version = |n, img| img.mod_data(encode_u32_le(_def_png_image.@offsetof_version, n.to_U32));

    set_width: I64 -> PngImageIO -> PngImageIO;
    set_width = |n, img| img.mod_data(encode_u32_le(_def_png_image.@offsetof_width, n.to_U32));

    set_height: I64 -> PngImageIO -> PngImageIO;
    set_height = |n, img| img.mod_data(encode_u32_le(_def_png_image.@offsetof_height, n.to_U32));

    set_format: I64 -> PngImageIO -> PngImageIO;
    set_format = |n, img| img.mod_data(encode_u32_le(_def_png_image.@offsetof_format, n.to_U32));

    set_flags: I64 -> PngImageIO -> PngImageIO;
    set_flags = |n, img| img.mod_data(encode_u32_le(_def_png_image.@offsetof_flags, n.to_U32));

    write_to_file: String -> Bool -> Array U8 -> I64 -> PngImageIO -> IOFail ();
    write_to_file = |filepath, convert_to_8bit, buffer, row_stride, png_image| (
        let convert_to_8bit = if convert_to_8bit { 1_I32 } else { 0_I32 };
        let colormap = nullptr;
        let res =
            png_image.@data.borrow_ptr(|p_png_image|
              filepath.borrow_c_str(|p_filepath|
                buffer.borrow_ptr(|p_buffer|
                    CALL_C[I32 png_image_write_to_file(Ptr, Ptr, I32, Ptr, I32, Ptr),
                        p_png_image, p_filepath, convert_to_8bit, 
                        p_buffer, row_stride.to_I32, colormap]
                )
              )
            );
        let result = "PngImageIO::write_to_file: res=" + res.to_string;
        let warning_or_error = png_image.get_warning_or_error;
        let message = png_image.get_message;
        if warning_or_error == 2 {  // error
            throw $ result + " ERROR: " + message
        };
        if warning_or_error == 1 {  // warning
            eprintln(result + " WARNING: " + message).lift
        } else if res == 1_I32 {
            // png_image_write_to_file() returns 1 on success
            pure()
        } else {
            // something is wrong, but no message
            throw $ result
        }
    );

    _PNG_FORMAT_FLAG_ALPHA: I64;
    _PNG_FORMAT_FLAG_ALPHA = 1; /* format with an alpha channel */
    _PNG_FORMAT_FLAG_COLOR: I64;
    _PNG_FORMAT_FLAG_COLOR = 2; /* color format: otherwise grayscale */
    _PNG_FORMAT_FLAG_LINEAR: I64;
    _PNG_FORMAT_FLAG_LINEAR = 4; /* 2-byte channels else 1-byte */
    _PNG_FORMAT_FLAG_COLORMAP: I64;
    _PNG_FORMAT_FLAG_COLORMAP = 8; /* image data is color-mapped */
    _PNG_FORMAT_FLAG_BGR: I64;
    _PNG_FORMAT_FLAG_BGR = 16; /* BGR colors, else order is RGB */
    _PNG_FORMAT_FLAG_AFIRST: I64;
    _PNG_FORMAT_FLAG_AFIRST = 32; /* alpha channel comes first */
    _PNG_FORMAT_FLAG_ASSOCIATED_ALPHA: I64;
    _PNG_FORMAT_FLAG_ASSOCIATED_ALPHA = 64; /* alpha channel is associated */

    parse_format: String -> I64;
    parse_format = |str| (
        if str == "GRAY" { 0 };
        if str == "GA" { _PNG_FORMAT_FLAG_ALPHA };
        if str == "AG" { _PNG_FORMAT_FLAG_ALPHA.bit_or $ _PNG_FORMAT_FLAG_AFIRST };
        if str == "RGB" { _PNG_FORMAT_FLAG_COLOR };
        if str == "BGR" { _PNG_FORMAT_FLAG_COLOR.bit_or $ _PNG_FORMAT_FLAG_BGR };
        if str == "RGBA" { _PNG_FORMAT_FLAG_COLOR.bit_or $ _PNG_FORMAT_FLAG_ALPHA };
        if str == "ARGB" { _PNG_FORMAT_FLAG_COLOR.bit_or $ _PNG_FORMAT_FLAG_ALPHA.bit_or $ _PNG_FORMAT_FLAG_AFIRST };
        if str == "BGRA" { _PNG_FORMAT_FLAG_COLOR.bit_or $ _PNG_FORMAT_FLAG_BGR.bit_or $ _PNG_FORMAT_FLAG_ALPHA };
        if str == "ABGR" { _PNG_FORMAT_FLAG_COLOR.bit_or $ _PNG_FORMAT_FLAG_BGR.bit_or $ _PNG_FORMAT_FLAG_ALPHA.bit_or $ _PNG_FORMAT_FLAG_AFIRST };
        eval debug_eprintln ("invalid format: " + str);
        0
    );

    // `png_image` structure layout
    type DefPngImage = unbox struct {
        offsetof_opaque: I64,
        offsetof_version: I64,
        offsetof_width: I64,
        offsetof_height: I64,
        offsetof_format: I64,
        offsetof_flags: I64,
        offsetof_colormap_entries: I64,
        offsetof_warning_or_error: I64,
        offsetof_message: I64,
        sizeof_png_image: I64
    };

    _def_png_image: DefPngImage;
    _def_png_image = DefPngImage {
        offsetof_opaque: 0,
        offsetof_version: 8,
        offsetof_width: 12,
        offsetof_height: 16,
        offsetof_format: 20,
        offsetof_flags: 24,
        offsetof_colormap_entries: 28,
        offsetof_warning_or_error: 32,
        offsetof_message: 36,
        sizeof_png_image: 104
    };
}

namespace Image {
    type Image = unbox struct {
        width: I64,
        height: I64,
        channels: I64,
        format: String,
        data: Array U8
    };
    
    make: I64 -> I64 -> String -> Image;
    make = |width, height, format| (
        let channels = calc_channels_by_format(format);
        Image {
            width: width,
            height: height,
            channels: channels,
            format: format,
            data: Array::fill(width * height * channels, 0_U8)
        }
    );

    calc_channels_by_format: String -> I64;
    calc_channels_by_format = |format| (
        if format == "GRAY" { 1 };
        if format == "GA" || format == "AG" { 2 };
        if format == "RGB" || format == "GBR" { 3 };
        if format == "RGBA" || format == "ARGB" || format == "BGRA" || format == "ABGR" { 4 };
        eval debug_eprintln ("unknown format: " + format);
        1 
    );

    calc_index: I64 -> I64 -> I64 -> Image -> I64;
    calc_index = |x, y, c, image| (
        (y * image.@width + x) * image.@channels + c
    );

    get: I64 -> Image -> U8;
    get = |index, image| (
        image.@data.@(index)
    );

    set: I64 -> U8 -> Image -> Image;
    set = |index, value, image| (
        image.mod_data(set(i, value))
    );

    get_rgb: I64 -> Image -> (U8, U8, U8);
    get_rgb = |index, image| (
        let data = image.@data;
        (data.@(index), data.@(index + 1), data.@(index + 2))
    );

    set_rgb: I64 -> (U8, U8, U8) -> Image -> Image;
    set_rgb = |index, color, image| (
        image.mod_data(|data|
            data.set(index, color.@0)
                .set(index + 1, color.@1)
                .set(index + 2, color.@2))
    );

    write_png_file: String -> Image -> IOFail ();
    write_png_file = |filepath, image| (
        let imgio = PngImageIO::empty;
        let imgio = imgio.set_width(image.@width);
        let imgio = imgio.set_height(image.@height);
        let imgio = imgio.set_format(PngImageIO::parse_format(image.@format));
        let row_stride = image.@width * image.@channels;
        imgio.write_to_file(filepath, false, image.@data, row_stride)
    );
}


main: IO ();
main = (
    do {
        let width = 512;
        let height = 512;
        let image = Image::make(width, height, "RGB");
        let image = Iterator::range(0, height).fold(
            image, |image, y|
            Iterator::range(0, width).fold (
                image, |image, x|
                let index = image.calc_index(x, y, 0);
                image.set_rgb(index, (x.to_U8, y.to_U8, 0_U8))
            )
        );
        let filepath = "tmp.test.png";
        let _ = *image.write_png_file(filepath);
        let _ = *println("Wrote " + filepath).lift;
        pure()
    }.try(eprintln)
);

