// X.509 Certificate module
//
// RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile
// https://tex2e.github.io/rfc-translater/html/rfc5280.html
module Minilib.Crypto.X509;

import Debug;

import Minilib.Crypto.Asn1;
import Minilib.Crypto.Asn1.Der;
import Minilib.Encoding.Binary;
import Minilib.Math.BigInt;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;

// 4.1. Basic Certificate Fields

type Certificate = unbox struct {
    tbs_certificate: TBSCertificate,
    signature_algorithm:   AlgorithmIdentifier,
    signature_value: BitString,
};

impl Certificate: ToString {
    to_string = |obj| (
        "Certificate {" +
        " tbs_certificate=" + obj.@tbs_certificate.to_string +
        " signature_algorithm=" + obj.@signature_algorithm.to_string +
        " signature_value=" + obj.@signature_value.to_string +
        " }"
    );
}

impl Certificate: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let tbs_certificate = *decode_obj;
            let signature_algorithm = *decode_obj;
            let signature_value = *decode_obj;
            pure $ Certificate {
                tbs_certificate: tbs_certificate,
                signature_algorithm: signature_algorithm,
                signature_value: signature_value
            }
        }
    );
}

type TBSCertificate = unbox struct {
    version: Version,
    serial_number: CertificateSerialNumber,
    signature: AlgorithmIdentifier,
    issuer: Name,
    validity: Validity,
    subject: Name,
    subject_public_key_info: SubjectPublicKeyInfo,
    issuer_unique_id: Option UniqueIdentifier,
    subject_unique_id: Option UniqueIdentifier,
    extensions: Option Extensions,
};

impl TBSCertificate: ToString {
    to_string = |obj| (
        "TBSCertificate {" +
        " version=" + obj.@version.to_string +
        " serial_number=" + obj.@serial_number.to_string +
        " signature=" + obj.@signature.to_string +
        " issuer=" + obj.@issuer.to_string +
        " validity=" + obj.@validity.to_string +
        " subject=" + obj.@subject.to_string +
        " subject_public_key_info=" + obj.@subject_public_key_info.to_string +
        " issuer_unique_id=" + obj.@issuer_unique_id.to_string +
        " subject_unique_id=" + obj.@subject_unique_id.to_string +
        " extensions=" + obj.@extensions.to_string +
        " }"
    );
}

impl TBSCertificate: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            //let version = *with_context(0, decode_integer);
            let version = *with_context(0, decode_integer).if_exists;
            let serial_number = *decode_bigint;
            eval debug_eprintln("signature");
            let signature = *decode_obj;
            eval debug_eprintln("issuer");
            let issuer = *decode_name;
            eval debug_eprintln("validity");
            let validity = *decode_obj;
            let subject = *decode_name;
            let subject_public_key_info = *decode_obj;
            let issuer_unique_id = *with_context(1, decode_obj).if_exists;
            let subject_unique_id = *with_context(2, decode_obj).if_exists;
            //let extensions = *with_context(3, decode_obj).if_exists;
            let extensions = none();    // TODO
            pure $ TBSCertificate {
                //version: version,
                version: version.as_some_or(0),
                serial_number: serial_number,
                signature: signature,
                issuer: issuer,
                validity: validity,
                subject: subject,
                subject_public_key_info: subject_public_key_info,
                issuer_unique_id: issuer_unique_id,
                subject_unique_id: subject_unique_id,
                extensions: extensions,
            }
        }
    );
}

type Version = Asn1::Integer; // v1(0), v2(1), v3(2)

type CertificateSerialNumber = BigInt;

type Validity = unbox struct {
    not_before: Time,
    not_after: Time,
};

impl Validity: ToString {
    to_string = |obj| (
        "Validity {" +
        " not_before=" + obj.@not_before.to_string +
        " not_after=" + obj.@not_after.to_string +
        " }"
    );
}

impl Validity: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let not_before = *decode_time;
            let not_after = *decode_time;
            pure $ Validity {
                not_before: not_before,
                not_after: not_after
            }
        }
    );
}

type Time = String;

decode_time: [m: MonadReadByte] m String;
decode_time = (
    choice $ [
        decode_utc_time,
        decode_generalized_time
    ]
);


type UniqueIdentifier = Asn1::BitString;

type SubjectPublicKeyInfo = unbox struct {
    algorithm: AlgorithmIdentifier,
    subject_public_key: Asn1::BitString,
};

impl SubjectPublicKeyInfo: ToString {
    to_string = |obj| (
        "SubjectPublicKeyInfo {" +
        " algorithm=" + obj.@algorithm.to_string +
        " subject_public_key=" + obj.@subject_public_key.to_string +
        " }"
    );
}

impl SubjectPublicKeyInfo: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let algorithm = *decode_obj;
            let subject_public_key = *decode_obj;
            pure $ SubjectPublicKeyInfo {
                algorithm: algorithm,
                subject_public_key: subject_public_key
            }
        }
    );
}


// 4.1.2.4. Issuer

type Name = RDNSequence;

decode_name: [m: MonadReadByte] m Name;
decode_name = decode_RDNSequence;

type RDNSequence = Array RelativeDistinguishedName;

decode_RDNSequence: [m: MonadReadByte] m RDNSequence;
decode_RDNSequence = (
    decode_sequence_of(decode_RelativeDistinguishedName)
);

type RelativeDistinguishedName = Array AttributeTypeAndValue;

decode_RelativeDistinguishedName: [m: MonadReadByte] m RelativeDistinguishedName;
decode_RelativeDistinguishedName = (
    decode_set_of(decode_AttributeTypeAndValue)
);

type AttributeTypeAndValue = (AttributeType, AttributeValue);

decode_AttributeTypeAndValue: [m: MonadReadByte] m AttributeTypeAndValue;
decode_AttributeTypeAndValue = (
    decode_sequence $ do {
        let type_ = *decode_obj;
        let value = *decode_obj;
        pure $ (type_, value)
    }
);

type AttributeType = Asn1::ObjectIdentifier;

type AttributeValue = String;

type AlgorithmIdentifier = unbox struct {
    algorithm: Asn1::ObjectIdentifier,
    parameters: Array U8,
};

impl AlgorithmIdentifier: ToString {
    to_string = |obj| (
        "AlgorithmIdentifier {" +
        " algorithm=" + obj.@algorithm.to_string +
        " parameters=" + obj.@parameters.to_string_hex +
        " }"
    );
}

impl AlgorithmIdentifier: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let algorithm = *decode_obj;
            let parameters = [];    // TODO
            pure $ AlgorithmIdentifier {
                algorithm: algorithm,
                parameters: parameters,
            }
        }
    );
}

type Extensions = Array ();    // TODO
