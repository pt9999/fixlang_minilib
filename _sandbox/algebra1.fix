module Main;

import Debug;

import Minilib.Math.Types;
import Minilib.Text.StringEx;

//-------------------------------------------------------------
// Modular Arithmetic
// https://en.wikipedia.org/wiki/Modular_arithmetic

type Modular a = unbox struct {
    value: a,
    modulus: a          // zero if unknown
};

namespace Modular {
    make: [a: Euclid] a -> a -> Modular a;
    make = |value, modulus| (
        let value = if modulus == zero { value } else { value % modulus };
        Modular { value: value, modulus: modulus }
    );

    modulo: [a: Euclid] a -> a -> Modular a;
    modulo = make;

    _get_modulus: [a: Euclid] Modular a -> Modular a -> a;
    _get_modulus = |x, y| (
        eval if x.@modulus != y.@modulus &&
                x.@modulus != zero && 
                y.@modulus != zero {
            debug_eprintln("warning: modulus mismatch")
        } else { () };
        if x.@modulus != zero { 
            x.@modulus
        };
        y.@modulus
    );

    is_zero: [a: Euclid] Modular a -> Bool;
    is_zero = |x| x.@value == zero;

    // Extended Euclidean algorithm
    // Solve a * x + b * y = d, where d = gcd(a, b)
    // Returns (x, y, d)
    _extended_euclid: [a: Euclid] a -> a -> (a, a, a);
    _extended_euclid = |a, b| (
        if b == zero {
            (one, zero, a)
        };
        let q = a / b;
        let r = a % b;
        eval assert(|_| "division-with-remainder failed", a == q * b + r);
        let (y, z, d) = _extended_euclid(b, r);
        // b * y + r * z = d
        // b * y + (a - q * b) * z = d
        // a * z + b * (y - q * z) = d
        let x = z;
        let y = y - q * z;
        eval assert(|_| "extended euclid failed"
            // + " ((a,x),(b,y),(ans, d))=" + ((a, x), (b, y), (a * x + b * y, d)).to_string
        , a * x + b * y == d);
        (x, y, d)
    );
}

impl [a: ToString] Modular a: ToString {
    to_string = |x| x.@value.to_string;         // does not show modulus
}

impl [a: Euclid] Modular a: Eq {
    eq = |x, y| (
        if x.is_zero { y.is_zero };
        if y.is_zero { false };
        let modulus = _get_modulus(x, y);
        if modulus == zero { x.@value == y.@value };
        (x.@value - y.@value) % modulus == zero
    );
}

impl [a: Euclid] Modular a: Zero {
    zero = Modular::make(zero, zero);       // modulus is unknown
}

impl [a: Euclid] Modular a: One {
    one = Modular::make(one, zero);       // modulus is unknown
}

impl [a: Euclid] Modular a: Neg {
    neg = |x| (
        Modular::make(-x.@value, x.@modulus)
    );
}

impl [a: Euclid] Modular a: Add {
    add = |x, y| (
        if x.is_zero { y };
        if y.is_zero { x };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value + y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Sub {
    sub = |x, y| (
        if x.is_zero { -y };
        if y.is_zero { x };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value - y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Mul {
    mul = |x, y| (
        if x.is_zero { zero };
        if y.is_zero { zero };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value * y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Div {
    div = |x, y| (
        eval assert(|_| "Divide by zero", !y.is_zero);
        if x.is_zero { zero };

        let modulus = _get_modulus(x, y);
        if modulus == zero { 
            // TODO correct?
            Modular::make(x.@value / y.@value, modulus)
        };
        let (u, v, d) = _extended_euclid(y.@value, modulus);
        // y.@value * u + modulus * v = d
        eval assert(|_| "cannot inverse", u % d == zero);
        Modular::make(x.@value * (u / d), modulus)
    );
}

//-------------------------------------------------------------

// Polynomial
type Polynomial a = unbox struct {
    coeff: Array a
};

namespace Polynomial {
    make: [a: Ring] Array a -> Polynomial a;
    make = |coeff| (
        // remove last zeros
        let coeff = loop(
            coeff, |coeff|
            let n = coeff.get_size;
            if n <= 1 { break $ coeff };
            if coeff.@(n - 1) != zero { break $ coeff };
            let coeff = coeff.pop_back;
            continue $ coeff
        );
        eval assert(|_| "invalid size", coeff.get_size >= 1);
        Polynomial { coeff: coeff }
    );

    polinomial: [a: Ring] Array a -> Polynomial a;
    polinomial = make;

    of_power: [a: Ring] a -> I64 -> Polynomial a;
    of_power = |x, power| (
        eval assert(|_| "invalid power", power >= 0);
        let coeff = Array::from_map(power + 1, |i|
            if i == power { x } else { zero }
        );
        Polynomial::make(coeff)
    );

    is_zero: [a: Ring] Polynomial a -> Bool;
    is_zero = |p| p == zero;

    get: [a: Ring] I64 -> Polynomial a -> a;
    get = |i, p| (
        if i < 0 || p.@coeff.get_size <= i { zero };
        p.@coeff.@(i)
    );

    get_degree: Polynomial a -> I64;
    get_degree = |p| p.@coeff.get_size - 1;

    divmod: [a: Field] Polynomial a -> Polynomial a -> (Polynomial a, Polynomial a);
    divmod = |num, den| (
        eval assert (|_| "Divide by zero", !den.is_zero);
        let (quo, rem) = loop(
            (zero, num), |(quo, num)|
            if num.is_zero { break $ (quo, num) };
            let num_degree = num.get_degree;
            let den_degree = den.get_degree;
            if num_degree < den_degree { break $ (quo, num) };
            let n = num.get(num_degree);
            let d = den.get(den_degree);
            let q = n / d;
            let qd = q * d;
            eval assert(|_| "has remainder", n == qd);
            let q = Polynomial::of_power(n / d, num_degree - den_degree);
            let quo = quo + q;
            let rem = num - q * den;
            eval assert(|_| "has reminder !!", rem.get_degree < num.get_degree);
            continue $ (quo, rem)
        );
        (quo, rem)
    );
}

impl [a: Ring, a: ToString] Polynomial a: ToString {
    to_string = |x| (
        let degree = x.get_degree;
        Iterator::range(0, degree + 1).map(|i|
            x.get(i).to_string + "x^" + i.to_string
        ).join(" + ")
    );
}

impl [a: Ring] Polynomial a: Eq {
    eq = |x, y| (
        x.@coeff == y.@coeff
    );
}

impl [a: Ring] Polynomial a: Zero {
    zero = Polynomial::make([zero]);
}

impl [a: Ring] Polynomial a: One {
    one = Polynomial::make([one]);
}

impl [a: Ring] Polynomial a: Neg {
    neg = |x| (
        Polynomial::make(x.@coeff.map(neg))
    );
}

impl [a: Ring] Polynomial a: Add {
    add = |x, y| (
        let degree = max(x.get_degree, y.get_degree);
        let coeff = Array::from_map(degree + 1, |i| x.get(i) + y.get(i));
        Polynomial::make(coeff)
    );
}

impl [a: Ring] Polynomial a: Sub {
    sub = |x, y| (
        let degree = max(x.get_degree, y.get_degree);
        let coeff = Array::from_map(degree + 1, |i| x.get(i) - y.get(i));
        Polynomial::make(coeff)
    );
}


impl [a: Ring] Polynomial a: Mul {
    mul = |x, y| (
        let x_degree = x.get_degree;
        let y_degree = y.get_degree;
        let degree = x_degree + y_degree;
        let iter = do {
            pure $ (*Iterator::range(0, x_degree + 1), *Iterator::range(0, y_degree + 1))
        };
        let coeff = Array::fill(degree + 1, zero);
        let coeff = iter.fold(
            coeff, |coeff, (ix, iy)|
            coeff.mod(ix + iy, add(x.get(ix) * y.get(iy)))
        );
        Polynomial::make(coeff)
    );
}

impl [a: Field] Polynomial a: Div {
    div = |x, y| (
        let (quo, rem) = divmod(x, y);
        quo
    );
}

impl [a: Field] Polynomial a: Rem {
    rem = |x, y| (
        let (quo, rem) = divmod(x, y);
        rem
    );
}

//---------------------------------------

test1: IO ();
test1 = (
    let m = 31;
    let a = 3;
    let a = Modular::make(a, m);
    let one = Modular::make(1, m);
    let x = *Iterator::range(0, m).fold_m(
        one, |x, i|
        let _ = *println((a, i, x, m).format("{}^{} = {} (mod {})"));
        pure $ x * a
    );
    pure()
);

test2: IO ();
test2 = (
    let a = Polynomial::make([1, 3]);
    let one = Polynomial::make([1]);
    let x = *Iterator::range(0, 5).fold_m(
        one, |x, i|
        let _ = *println((a, i, x).format("({})^{} = {}"));
        pure $ x * a
    );
    pure()
);

test3: IO ();
test3 = (
    let table = [
        (5, 7),
        (20, 32),
        (40, 30)
    ];
    table.to_iter.fold_m(
        (), |_, (a, b)|
        let (x, y, d) = _extended_euclid(a, b);
        println([a, x, b, y, d].format("{} * {} + {} * {} = {}"))
    )
);

test4: IO ();
test4 = (
    let m = 31;
    let table = [
        (5, 7),
        (20, 12),
        (10, 3)
    ];
    table.to_iter.fold_m(
        (), |_, (a, b)|
        let a = modulo(a, m);
        let b = modulo(b, m);
        let c = a / b;
        let cc = c * b;
        let d = b / a;
        let dd = d * a;
        println([a, b, c, cc].format("a={}, b={}, a/b={}, a/b*b={}\n") +
                [a, b, d, dd].format("a={}, b={}, b/a={}, b/a*a={}\n") +
                [cc == a, dd == b].format("ok={} {}\n")
                )
    )
);

test5: IO ();
test5 = (
    let m = 3;
    let p = polinomial([ modulo(0, m), modulo(1, m) ]);
    let q = polinomial([ modulo(1, m), modulo(0, m), modulo(0, m), modulo(1, m) ]);
    let a = modulo(p, q);   // x mod x^3+1 on GF(3)
    let x = *Iterator::range(0, 27).fold_m(
        modulo(one, q), |x, i|
        let _ = *println((a, i, x).format("({})^{} = {}"));
        pure $ x * a
    );
    pure()    
);

main: IO ();
main = test5;
