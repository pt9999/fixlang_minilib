module Main;

type ScanIterator i s a = unbox struct {
    state : s,
    op : a -> s -> s,
    iter : i,
};

impl [i : Iterator, Item i = a] ScanIterator i s a : Iterator {
    type Item (ScanIterator i s a) = s;
    advance = |ScanIterator { state : s, op : op, iter : iter }| (
        match iter.advance {
            none() => none(),
            some((iter, a)) => let s = op(a, s) in
                some((ScanIterator { state: s, op: op, iter: iter }, s))
        }
    );
}

// Create an iterator that generates the inclusive scan of an iterator.
//
// Conceptually, `[a0, a1, a2, ...].to_iter.scan(s, op) = [s1, s2, ...].to_iter` such that
// `s0 = s, s1 = op(a0,s0), s2 = op(a1,s1), ...`.
//
// # Parameters
//
// * `s` - The initial state.
// * `op` - The function to be called on the pair of an element and the current state.
// * `iter` - The iterator to be scaned.
scan : [i : Iterator, Item i = a] s -> (a -> s -> s) -> i -> ScanIterator i s a;
scan = |s, op, iter| ScanIterator { state: s, op: op, iter: iter };


main: IO ();
main = (
    let a = range(0,10).map(add(1));
    let b = a.scan(0, add);
    println(b.to_array.to_string)
);
