// An implementation of simple regular expression.
//
// Currently it only supports patterns below:
// - Character classes: `[xyz]`, `[^xyz]`, `.`, `\d`, `\D`, `\w`, `\W`, `\s`,
//   `\S`, `\t`, `\r`, `\n`, `\v`, `\f`, `[\b]`, x|y
// - Assertions: `^`, `$`
// - Groups: `(x)`
// - Quantifiers: `x*`, `x+`, `x?`, `x{n}`, `x{n,}`, `x{n,m}`
//
// For details, see
// [mdn web docs: Regular expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions).
//
// LIMITATION:
//
// Currently, only single bytes can be specified in character classes. Non-ascii characters
// (U+100 or hier) cannot be specified in character classes.
//
module RegExp;

import Debug;

import StringEx;
import RegExpPattern;
import RegExpNFA;

type RegExp = unbox struct {
    pattern: Pattern,
    flags: String, // TODO: support flags
    nfa: NFA
};

namespace RegExp {

    compile: String -> String -> Result ErrMsg RegExp;
    compile = |pattern_str, flags| (
        let pattern = *Pattern::parse(pattern_str);
        let pattern = pgroup $ (0, pattern); // since whole pattern is group 0
        // add ".*" in front of pattern
        let pattern = psequence $ [*Pattern::parse(".*"), pattern];
        let nfa = NFA::compile(pattern);
        ok $ RegExp { pattern: pattern, flags: flags, nfa:nfa }
    );

    match: String -> RegExp -> Result ErrMsg (Array String);
    match = |target, regexp| (
        let executor = regexp.@nfa.execute(target);
        let states: Array NFAState = executor.@accepted_states.to_iter.to_array;
        if regexp.@flags.find_byte('g').is_some {
            let states = collect_all_non_overlapping(states);
            let groups0 = states.to_iter.map(|state| state.@groups.@(0)).to_array;
            if groups0.is_empty {
                err $ "NotMatch"
            };
            ok $ target._convert_groups_to_string(groups0)
        } else {
            let opt = collect_first_match(states);
            if opt.is_none {
                err $ "NotMatch"
            };
            let state = opt.as_some;
            let groups = state.@groups;
            ok $ target._convert_groups_to_string(groups)
        }
    );

    _convert_groups_to_string: Array Group -> String -> Array String;
    _convert_groups_to_string = |groups, target| (
        groups.to_iter.map(|(begin, end)|
            if begin < 0 || end < 0 { "" };
            target.substring(begin, end)
        ).to_array
    );


}
