module Main;

import Minilib.Crypto.Tls13.Tls13;

import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

test1: IO ();
test1 = (
    do {
        eval *println("===test1===").lift;
        let secure_random = *SecureRandom::make;
        let hello = *ClientHello::make(secure_random);
        let handshake = client_hello(hello);
        let buf = ByteBuffer::empty(0, big_endian());
        let buf = buf.marshal(handshake);
        println(buf.@array.to_string_hex).lift
        let expected = "0100002903030a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a00000001000000";
        let actual = buf.@array.to_string_hex;
        eval *println(actual).lift;
        pure()
    }.try(eprintln)
);

test2: IO ();
test2 = (
    do {
        eval *println("===test2===").lift;
        let array = *from_string_hex("03030a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a001234000000").from_result;
        let buf = ByteBuffer::make(array, big_endian());
        let (hello:ServerHello, buf) = *buf.unmarshal.from_result;
        println((hello.@cipher_suite, hello.@legacy_compression_method).format(
            "cipher_suite={} legacy_compression_method={}"
        )).lift
    }.try(eprintln)
);

test3: IO ();
test3 = (
    do {
        eval *println("===test3===").lift;
        let pt = TLSPlainText::empty.set_type(application_data()).set_fragment("abc".get_bytes);
        let buf = ByteBuffer::empty(0, big_endian());
        let buf = buf.marshal(pt);
        eval *println(buf.@array.to_string_hex).lift;
        let buf = buf.set_position(0);
        let (pt: TLSPlainText, buf) = *buf.unmarshal.from_result;
        let buf = ByteBuffer::empty(0, big_endian());
        let buf = buf.marshal(pt);
        eval *println(buf.@array.to_string_hex).lift;
        pure()
    }.try(eprintln)
);

main: IO ();
main = (
    eval *test1;
    eval *test2;
    eval *test3;
    pure()
);
