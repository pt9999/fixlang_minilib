module Main;

import Minilib.Common.IteratorEx;
import Minilib.Testing.UnitTest;

// same as `arr.to_iter.zip(arr.to_iter.pop_first)`
type AdjacentIterator a = unbox struct { arr : Array a, idx : I64 };

impl AdjacentIterator a : Iterator {
    type Item (AdjacentIterator a) = (a, a);
    advance = |AdjacentIterator { arr : arr, idx : idx }| (
        if idx + 1 >= arr.get_size { none() };
        let u = arr.@(idx);
        let v = arr.@(idx + 1);
        some((AdjacentIterator { arr: arr, idx: idx + 1 }, (u, v)))
    );
}

adjacent: Array a -> AdjacentIterator a;
adjacent = |arr| AdjacentIterator { arr: arr, idx: 0 };

test_adjacent: TestCase;
test_adjacent = (
    make_table_test("test_adjacent",
        [
            ([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]),
            ([1], []),
            ([], []),
        ],
        |(arr, expected)|
        let actual = arr.adjacent.to_array;
        let actual2 = arr.to_iter.zip(arr.to_iter.pop_first).to_array;
        println("arr=" + arr.to_string).lift;;
        println("adjacent=" + actual.to_string).lift;;
        println("actual2=" + actual2.to_string).lift;;
        assert_equal("eq", expected, actual);;
        assert_equal("eq", expected, actual2)
    )
);

get_last: [iter : Std::Iterator] iter -> Std::Option (Std::Iterator::Item iter);
get_last = |iter| (
    iter.loop_iter(
        none(), |x, opt|
        continue $ some(x)
    )
);

test_get_last: TestCase;
test_get_last = (
    make_table_test("test_get_last",
        [
            ([1, 2, 3, 4, 5], some $ 5),
            ([1], some $ 1),
            ([], none()),
        ],
        |(arr, expected)|
        let actual = arr.to_iter.get_last;
        assert_equal("eq", expected, actual)
    )
);

main: IO () = (
    [
        test_adjacent,
        test_get_last,
    ]
    .run_test_driver
);
