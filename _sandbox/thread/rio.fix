// https://github.com/commercialhaskell/rio

module Main;

import AsyncTask;  // for Var
import Minilib.Common.Common;
import Minilib.Monad.Reader;
import Minilib.Monad.Iden;
import Minilib.Monad.IO;

// RIO is a thread-safe version of State monad
type RIO e a = ReaderT (Var e) IO a;

get_env: RIO e e;
get_env = (
    let v: Var e = *ask;
    v.get.lift_io
);

put_env: e -> RIO e ();
put_env = |e| (
    let v: Var e = *ask;
    v.Var::set(e).lift_io
);

mod_env: (e -> e) -> RIO e ();
mod_env = |f| (
    let v: Var e = *ask;
    v.Var::mod(f).lift_io
);

type Logger = unbox struct {
    messages: Array String
};

trait e: HasLogger {
    lens_logger: [f: Functor] (Logger -> f Logger) -> e -> f e;
}

write_log: [e: HasLogger] String -> RIO e ();
write_log = |msg| (
    mod_env(
        |e| flip(lens_logger, e).imod(mod_messages(push_back(msg)))
    )
);

type Config = unbox struct {
    value: I64
};

trait e: HasConfig {
    lens_config: [f: Functor] (Config -> f Config) -> e -> f e;
}

type Env = box struct {
    logger: Logger,
    config: Config
};

trait e: HasEnv {
    lens_env: [f: Functor] (Env -> f Env) -> e -> f e;
}

impl Env: HasLogger {
    lens_logger = Env::act_logger;
}

impl Env: HasConfig {
    lens_config = Env::act_config;
}

impl Env: HasEnv {
    lens_env = |f| f;
}

test1: RIO Env ();
test1 = (
    write_log("hello")
);

main: IO ();
main = (
    let env = Env {
        logger: Logger { messages: [] },
        config: Config { value: 42 },
    };
    let v = *Var::make(env);
    test1.run_reader_t(v);;
    let messages = (*v.get).@logger.@messages;
    println("messages="+messages.to_string)
);

