module Minilib.Net.Curl;

import Debug;
import Minilib.Text.StringEx;

type Curl = box struct {
    dtor: Destructor Ptr
};

make: IOFail Curl;
make = (
    eval *pure();
    eval debug_eprintln("curl_glue_init");
    let glue = FFI_CALL[Ptr curl_glue_init()];
    let curl = Curl {
        dtor: Destructor::make(glue, |glue|
            eval debug_eprintln("curl_glue_cleanup");
            FFI_CALL[() curl_glue_cleanup(Ptr), glue]
        )
    };
    pure $ curl
);

_throw_error: Curl -> IOFail ();
_throw_error = |curl| (
    curl.@dtor.borrow(|glue|
        let errmsg = FFI_CALL[Ptr curl_glue_get_error_message(Ptr), glue];
        throw $ String::_unsafe_from_c_str_ptr(errmsg)
    )
);

set_url: String -> Curl -> IOFail ();
set_url = |url, curl| (
    eval *pure();
    let res = url.borrow_c_str(|p_url|
        curl.@dtor.borrow(|glue|
            FFI_CALL[CInt curl_glue_set_url(Ptr, Ptr), glue, p_url]
        )
    );
    if res != 0.to_CInt {
        _throw_error(curl)
    };
    pure()
);

perform: Curl -> IOFail ();
perform = |curl| (
    eval *pure();
    let res = curl.@dtor.borrow(|glue|
        FFI_CALL[CInt curl_glue_perform(Ptr), glue]
    );
    if res != 0.to_CInt {
        _throw_error(curl)
    };
    pure()
);

set_fix_value1: Boxed a -> Curl -> IOFail ();
set_fix_value1 = |boxed, curl| (
    eval *pure();
    eval curl.@dtor.borrow(|glue|
        let retained_ptr = FFI::unsafe_get_retained_ptr_of_boxed_value(boxed);
        FFI_CALL[() curl_glue_set_fix_value1(Ptr, Ptr), glue, retained_ptr]
    );
    pure()
);

get_fix_value1: Curl -> IOFail (Boxed a);
get_fix_value1 = |curl| (
    eval *pure();
    let boxed = curl.@dtor.borrow(|glue|
        let retained_ptr = FFI_CALL[Ptr curl_glue_get_fix_value1(Ptr), glue];
        FFI::unsafe_get_boxed_value_from_retained_ptr(retained_ptr)
    );
    pure $ boxed
);

/*

set_write_function: (Array U8 -> IOFail I64) -> Curl -> IOFail ();
set_write_function = |write_func, curl| (
    let boxed = Boxed { value: write_func };
    let res = url.borrow_c_str(|p_url|
        curl.@dtor.borrow(|glue|
            FFI_CALL[CInt curl_glue_set_write_function(Ptr, Ptr), glue, p_write_func]
        )
    );
    if res != 0.to_CInt {
        _throw_error(curl)
    };
    pure()
);

write_function: WriteFunction -> Curl -> IOFail ();
write_function = |func, curl| (
    // func: Array U8 -> IOFail I64, a fix value
    // how to get a fix value from _callback_write_function?
);


*/

_callback_write_function: Ptr -> CSizeT -> CSizeT -> Ptr -> Ptr -> ();
_callback_write_function = |ptr, size, nmemb, userdata, result| (
    // char* ptr, void* userdata, int64_t* result
    eval debug_eprintln("_callback_write_function: nmemb=" + nmemb.to_string);
    let arr = [ nmemb.to_I64 ];
    eval arr.borrow_ptr(|p_arr|
        FFI_CALL[() memcpy(Ptr, Ptr, CSizeT), result, p_arr, 8.to_CSizeT]
    );
    ()
);
FFI_EXPORT[_callback_write_function, _callback_write_function];
