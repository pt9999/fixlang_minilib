module Publisher.Tests.MockEnv;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Monad.Error;
import Minilib.Testing.UnitTest;

import Publisher.Common;
import Publisher.Publish;
import Publisher.ProcessRunner;
import Publisher.Fs;
import Publisher.ConsoleUi;
import Publisher.Tests.MockProcessRunner;
import Publisher.Tests.MockFs;
import Publisher.Tests.MockConsoleUi;

// A trait for an environment of a Reader monad.
trait e: Env {
    // Creates an empty environment.
    make_empty_env: [m: MonadIO] m e;
}

namespace Env {
    // `env.get(@field)` returns the object referenced by `@field`.
    // The type of the field should be an IORef of that object.
    get: [e: Env, m: MonadIO] (e -> IORef a) -> e -> m a;
    get = |ioref, env| env.ioref.get.lift_io;

    // `env.get(@field, f)` gets the object referenced by `@field`, then apply `f` to that object.
    gets: [e: Env, m: MonadIO, m: Functor] (e -> IORef a) -> (a -> b) -> e -> m b;
    gets = |ioref, f, env| env.get(ioref).map(f);

    // `env.set(@field, object)` sets the object referenced by `@field`.
    set: [e: Env, m: MonadIO] (e -> IORef a) -> a -> e -> m ();
    set = |ioref, a, env| env.ioref.IORef::set(a).lift_io;

    // `env.mod(@field, f)` modifies the object referenced by `@field`.
    mod: [e: Env, m: MonadIO] (e -> IORef a) -> (a -> a) -> e -> m ();
    mod = |ioref, f, env| env.ioref.mod(f).lift_io;

    // `setup` is a synonym of `mod`.
    setup: [e: Env, m: MonadIO] (e -> IORef a) -> (a -> a) -> e -> m ();
    setup = mod;

    // `make_env_test(testname) $ |env| ...` creates a TestCase which uses an Env.
    make_env_test: [e: Env] String -> (e -> IOFail ()) -> TestCase;
    make_env_test = |testname, body| (
        make_test(testname) $ |_|
        let env: e = *make_empty_env;
        body(env)
    );

    // `env.run(rio)` runs a Reader monad using an Env.
    // This is equal to `rio.run_reader_t(env)`.
    run: [e: Env] RIO e a -> e -> IOFail a;
    run = |rio, env| (
        rio.run_reader_t(env)
    );

    // `env.run_catch(rio)` runs a Reader monad using an Env, catching any error.
    // This is equal to `rio.run_reader_t(env).to_result.lift`.
    run_catch: [e: Env] RIO e a -> e -> IOFail (Result ErrMsg a);
    run_catch = |rio, env| (
        env.run(rio).to_result.lift
    );
}


type MockEnv = unbox struct {
    runner: IORef MockProcessRunner,
    fs: IORef MockFs,
    console_ui: IORef MockConsoleUi,
};

impl MockEnv: Env {
    make_empty_env = (
        pure $ MockEnv {
            runner: *IORef::make(MockProcessRunner::empty).lift_io,
            fs: *IORef::make(MockFs::empty).lift_io,
            console_ui: *IORef::make(MockConsoleUi::empty).lift_io,
        }
    );
}

namespace MockEnv {
    setup_runner: [m: MonadIO] (MockProcessRunner -> MockProcessRunner) -> MockEnv -> m ();
    setup_runner = setup(@runner);

    setup_fs: [m: MonadIO] (MockFs -> MockFs) -> MockEnv -> m ();
    setup_fs = setup(@fs);

    setup_console_ui: [m: MonadIO] (MockConsoleUi -> MockConsoleUi) -> MockEnv -> m ();
    setup_console_ui = setup(@console_ui);
}

impl MockEnv: HasProcessRunner {
    get_process_runner = |args, options| (
        let env = *ask;
        let runner = *env.get(@runner);
        let (runner, res) = runner.run(args, options);
        env.set(@runner, runner);;
        match res {
            ok((stdout, stderr)) => pure $ (stdout, stderr),
            err(errmsg) => error $ errmsg
        }
    );
}

impl MockEnv: HasFileSystemApi {
    type ApiType MockEnv = MockFs;
    get_file_system_api = @fs;
}

impl MockEnv: HasConsoleUi {
    get_ui_print = |str| (
        let env = *ask;
        uiapi_print(env.@console_ui, str)
    );
    get_ui_input_line = (
        let env = *ask;
        uiapi_input_line(env.@console_ui)
    );
}