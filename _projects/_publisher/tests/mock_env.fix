module Publisher.Tests.MockEnv;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Monad.Error;
import Minilib.Testing.UnitTest;

import Publisher.Common;
import Publisher.Publish;
import Publisher.ProcessRunner;
import Publisher.Fs;
import Publisher.ConsoleUi;
import Publisher.Tests.MockProcessRunner;
import Publisher.Tests.MockFs;
import Publisher.Tests.MockConsoleUi;

// A trait for an environment of a Reader monad.
trait e: Env {
    // Creates an empty environment.
    make_empty_env: [m: MonadIO] m e;
}

namespace Env {
    // `env.get(@field)` returns the object referenced by `env.@field`.
    // The type of the field should be an IORef of that object.
    get: [e: Env, m: MonadIO] (e -> IORef a) -> e -> m a;
    get = |@field, env| env.@field.get.lift_io;

    // `env.gets(@field, f)` gets the object referenced by `env.@field`, then apply `f` to that object.
    gets: [e: Env, m: MonadIO, m: Functor] (e -> IORef a) -> (a -> b) -> e -> m b;
    gets = |@field, f, env| env.get(@field).map(f);

    // `env.set(@field, object)` sets the object referenced by `env.@field`.
    set: [e: Env, m: MonadIO] (e -> IORef a) -> a -> e -> m ();
    set = |@field, a, env| env.@field.IORef::set(a).lift_io;

    // `env.mod(@field, f)` modifies the object referenced by `env.@field` using the function `f`.
    mod: [e: Env, m: MonadIO] (e -> IORef a) -> (a -> a) -> e -> m ();
    mod = |@field, f, env| env.@field.mod(f).lift_io;

    // `setup` is a synonym of `mod`.
    setup: [e: Env, m: MonadIO] (e -> IORef a) -> (a -> a) -> e -> m ();
    setup = mod;

    // `make_env_test(testname) $ |env| ...` creates a TestCase which uses an Env.
    make_env_test: [e: Env] String -> (e -> IOFail ()) -> TestCase;
    make_env_test = |testname, body| (
        make_test(testname) $ |_|
        let env: e = *make_empty_env;
        body(env)
    );

    // `env.run(rio)` runs a Reader monad using an Env.
    // This is equal to `rio.run_reader_t(env)`.
    run: [e: Env] RIO e a -> e -> IOFail a;
    run = |rio, env| (
        rio.run_reader_t(env)
    );

    // `env.run_catch(rio)` runs a Reader monad using an Env, catching any error.
    // This is equal to `rio.run_reader_t(env).to_result.lift`.
    run_catch: [e: Env] RIO e a -> e -> IOFail (Result ErrMsg a);
    run_catch = |rio, env| (
        env.run(rio).to_result.lift
    );
}


type MockEnv = unbox struct {
    runner: IORef MockProcessRunner,
    fs: IORef MockFs,
    console_ui: IORef MockConsoleUi,
};

impl MockEnv: Env {
    make_empty_env = (
        pure $ MockEnv {
            runner: *IORef::make(MockProcessRunner::empty).lift_io,
            fs: *IORef::make(MockFs::empty).lift_io,
            console_ui: *IORef::make(MockConsoleUi::empty).lift_io,
        }
    );
}

namespace MockEnv {
    setup_runner: [m: MonadIO] (MockProcessRunner -> MockProcessRunner) -> MockEnv -> m ();
    setup_runner = setup(@runner);

    setup_fs: [m: MonadIO] (MockFs -> MockFs) -> MockEnv -> m ();
    setup_fs = setup(@fs);

    setup_console_ui: [m: MonadIO] (MockConsoleUi -> MockConsoleUi) -> MockEnv -> m ();
    setup_console_ui = setup(@console_ui);
}

impl MockEnv: HasProcessRunnerApi {
    get_process_runner_api = |e| e.@runner.to_api;
}

impl MockEnv: HasFileSystemApi {
    get_file_system_api = |e| e.@fs.to_api;
}

impl MockEnv: HasConsoleUiApi {
    get_console_ui_api = |e| e.@console_ui.to_api;
}