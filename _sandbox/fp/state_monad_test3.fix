module Main;

import Minilib.Monad.State;
import Minilib.Monad.Writer;
import Minilib.Monad.IO;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;

type NameList = unbox struct {
    names: Array String,
    ids: Array I64,
};

type NameService = unbox struct {
    name_list: NameList,
};

type Logger = unbox struct {
    messages: Array String
};

type App = unbox struct {
    name_svc: NameService,
    logger: Logger,
};


// Looks similar to WriterT, but this is a functor against `s`, ie. the left part of Tuple2.
type [m: * -> *] StateResultT a m s = unbox struct {
    data: m (s, a)
};

namespace StateResultT {
    make: [m: * -> *] m (s, a) -> StateResultT a m s;
    make = |data| StateResultT { data: data };
}

impl [m: Monad] StateResultT a m: Functor {
    map = |f, ms| StateResultT {
        data: do {
            let (s, a) = *ms.@data;
            pure $ (f(s), a)
        }
    };
}

//with_act: [m: Monad] ([f: Functor] (s -> f s) -> (t -> f t)) -> StateT s m a -> StateT t m a;
with_act: [m: Monad] ((s -> StateResultT a m s) -> (t -> StateResultT a m t)) -> StateT s m a -> StateT t m a;
with_act = |act, sma| (
    let f: s -> m (s, a) = sma.@data;
    let f: s -> StateResultT a m s = f >> StateResultT::make;
    let f: t -> StateResultT a m t = act(f);
    let f: t -> m (t, a) = f >> StateResultT::@data;
    make_state_t_monad(f)
);


add_name: [m: Monad] String -> StateT (Array String) m I64;
add_name = |name| (
    mod_state(push_back(name));;
    pure(42)
);

add_name2: [m: Monad] String -> StateT NameList m I64;
add_name2 = |name| add_name(name).with_act(act_names);

main: IO ();
main = (
    let name_list = NameList {
        names: [],
        ids: []
    };
    let (name_list, ret) = add_name2("user").run_state(name_list);
    println((name_list.@names, ret).to_string);;
    pure()
);

