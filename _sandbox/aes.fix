// Advanced Encryption Standard (AES)
//
// cf. [NIST FIPS 197](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf)
module Main;

import Debug;

import Minilib.Encoding.Binary;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
import Minilib.Thread.Time;

type AES = unbox struct {
    key_length: I64,    // 128, 192, 256
    s: Array U8        // state 4x4 bytes = 4 words, r+4c
};

namespace AES {
    make: I64 -> AES;
    make = |key_length| (
        eval assert(|_| "unsupported key length", 
            key_length == 128 || key_length == 192 || key_length == 256);
        AES {
            key_length: key_length,
            s: Array::fill(16, 0_U8)
        }
    );
    
    // 3.4 The State 
    _get_s: I64 -> I64 -> AES -> U8;
    _get_s = |r, c, aes| (
       aes.@s.@(r + 4*c)
    );

    _copy_output: AES -> Array U8;
    _copy_output = |aes| (
        aes.@s
    );

    // 3.5 Arrays of Words 
    _get_v: I64 -> AES -> U32;
    _get_v = |i, aes| (
        eval assert(|_| "out of range", 0 <= i && i < 4);
        get_u32_le(4 * i, aes.@s)
    );

    // 5. Algorithm Specifcations
    _get_number_of_rounds: AES -> I64;
    _get_number_of_rounds = |aes| (
        if aes.@key_length == 128 { 10 };
        if aes.@key_length == 192 { 12 };
        if aes.@key_length == 256 { 14 };
        eval assert(|_| "unsupported key length", false);
        0
    );

    // 5.1 CIPHER()
    _cipher: Array U8 -> Array U32 -> AES -> Array U8;
    _cipher = |input, w, aes| (
        let nr = aes._get_number_of_rounds;
        eval assert(|_| "invalid input size", input.get_size == 16);
        let aes = aes.set_s(input);
        let aes = aes._add_round_key(w, 0);
        let aes = loop(
            (aes, 1), |(aes, round)|
            if round >= nr { break $ aes };
            let aes = aes._sub_bytes;
            let aes = aes._shift_rows;
            let aes = aes._mix_columns;
            let aes = aes._add_round_key(w, round);
            continue $ (aes, round + 1)
        );
        let aes = aes._sub_bytes;
        let aes = aes._shift_rows;
        let aes = aes._add_round_key(w, nr);
        aes.@s
    );

    // 5.1.1 SUBBYTES() 
    _sub_bytes: AES -> AES;
    _sub_bytes = |aes| (
        aes.mod_s(map(|b| _sbox_table.@(b.to_I64)))
    );

    _sbox_table: Array U8;
    _sbox_table = (
        Array::from_map(256, I64::to_U8 >> _sbox)
    );

    _sbox: U8 -> U8;
    _sbox = |b| (
        let b = if b == 0_U8 { 0_U8 } else { b._inv_gf8 };
        b.bit_xor(b._rotr(4_U8))
         .bit_xor(b._rotr(5_U8))
         .bit_xor(b._rotr(6_U8))
         .bit_xor(b._rotr(7_U8))
         .bit_xor(0x63_U8)  // c
    );    

    // rotate right
    _rotr: U8 -> U8 -> U8;
    _rotr = |n, x| (
        x.shift_right(n).bit_or(x.shift_left(8_U8 - n))
    );

    // 5.1.2 SHIFTROWS()
    _shift_rows: AES -> AES;
    _shift_rows = |aes| (
        aes.mod_s(|s|
            Array::from_map(16, |i|
                let r = i.bit_and(3);
                let c = i.shift_right(2).bit_and(3);
                let c = (c + r).bit_and(3);
                let i = c.shift_left(2).bit_or(r);
                s.@(i)
            )
        )
    );

    // 5.1.3 MIXCOLUMNS()
    _mix_columns: AES -> AES;
    _mix_columns = |aes| (
        aes.mod_s(|s|
            Array::from_map(16, |i|
                let r = i.bit_and(3);
                let c = i.shift_right(2).bit_and(3);
                let c4 = c.shift_left(2);
                let s0c = s.@((r + 0).bit_and(3) + c4);
                let s1c = s.@((r + 1).bit_and(3) + c4);
                let s2c = s.@((r + 2).bit_and(3) + c4);
                let s3c = s.@((r + 3).bit_and(3) + c4);
                s0c._mul_gf8(0x02_U8)
                ._add_gf8(s1c._mul_gf8(0x03_U8))
                ._add_gf8(s2c)
                ._add_gf8(s3c)
            )
        )
    );

    // 5.1.4 ADDROUNDKEY()
    _add_round_key: Array U32 -> I64 -> AES -> AES;
    _add_round_key = |w, round, aes| (
        aes.mod_s(|s|
            loop(
                (s, 0), |(s, c)|
                if c >= 4 { break $ s };
                let s0123c = s.get_u32_be(4 * c);
                let s0123c = s0123c.bit_xor(w.@(4 * round + c));
                let s = s.set_u32_be(4 * c, s0123c);
                continue $ (s, c + 1)
            )
        )
    );

    // 5.2 KEYEXPANSION()
    _key_expansion: Array U8 -> AES -> Array U32;
    _key_expansion = |key, aes| (
        eval assert(|_| "key length mismatch", key.get_size * 8 == aes.@key_length);
        let nk = aes.@key_length / (4 * 8);
        let nb = 4;
        let nr = aes._get_number_of_rounds;
        let w = Array::fill(4 * (nr + 1), 0_U32);
        let (w, i) = loop(
            (w, 0), |(w, i)|
            if i >= nk { break $ (w, i) };
            let w = w.set(i, key.get_u32_be(4 * i));
            continue $ (w, i + 1)
        );
        loop(
            (w, i), |(w, i)|
            if i >= 4 * nr + 4 { break $ w };
            let temp = w.@(i - 1);
            let temp = if i % nk == 0 {
                _sub_word(_rot_word(temp)).bit_xor(_rcon(i / nk))
            } else if nk > 6 && i % nk == 4 {
                _sub_word(temp)
            } else { temp };
            let w = w.set(i, w.@(i - nk).bit_xor(temp));
            continue $ (w, i + 1)
        )
    );

    _sub_word: U32 -> U32;
    _sub_word = |w| (
        loop(
            (0_U32, 0), |(out, i)|
            if i >= 4 { break $ out };
            let shift = (8 * i).to_U32;
            let b = w.shift_right(shift).bit_and(0xFF_U32).to_U8;
            let b = _sbox_table.@(b.to_I64);
            let out = out.bit_or(b.to_U32.shift_left(shift));
            continue $ (out, i + 1)
        )
    );

    _rot_word: U32 -> U32;
    _rot_word = |w| (
        w.bit_and(0x00FFFFFF_U32).shift_left(8_U32).bit_or(
            w.bit_and(0xFF000000_U32).shift_right(24_U32)
        )
    );

    _rcon: I64 -> U32;
    _rcon = |j| (
        _rcon_table.@(j - 1).to_U32.shift_left(24_U32)
    );

    _rcon_table: Array U8;
    _rcon_table = [
        0x01, 0x02, 0x04, 0x08, 0x10,
        0x20, 0x40, 0x80, 0x1b, 0x36
    ].map(to_U8);

}

// Arithmetic in GF(2^8)
// NOTE: It might be better to rename GF8 to GF256 or GF2_8, but shorter is better.
namespace GF8 {
    // 4.1 Addition in GF(2^8) 
    _add_gf8: U8 -> U8 -> U8;
    _add_gf8 = bit_xor;

    // 4.2 Multiplication in GF(2^8) 
    _mul_gf8: U8 -> U8 -> U8;
    _mul_gf8 = |a, b| (
        loop(
            (b, 0_U8, 0_U8), |(b, c, i)|
            if i >= 8_U8 { break $ c };
            let c = if a.bit_and(1_U8.shift_left(i)) == 0_U8 { c }
            else { c._add_gf8(b) };
            let b = _xtimes(b);
            continue $ (b, c, i + 1_U8) 
        )
    ); 

    _xtimes: U8 -> U8;
    _xtimes = |b| (
        if b.bit_and(0x80_U8) == 0x00_U8 { b.shift_left(1_U8) }
        else { b.shift_left(1_U8).bit_xor(0x1B_U8) }
    );
        
    // 4.3 Multiplication of Words by a Fixed Matrix
    // TODO

    // 4.4 Multiplicative Inverses in GF(2^8) 
    _inv_gf8: U8 -> U8;
    _inv_gf8 = |b| (
        b._pow_gf8(254_U8)
    );

    // `a._pow_gf8(n)` calculates `a ^ n`.
    _pow_gf8: U8 -> U8 -> U8;
    _pow_gf8 = |n, a| (
        let op = _mul_gf8;
        loop(
            (1_U8, a, n), |(x, a, n)|
            if n == 0_U8 {
                break $ x
            };
            let x = if n.bit_and(1_U8) != 0_U8 {
                op(x, a)
            } else { x };
            continue $ (x, op(a, a), n.shift_right(1_U8))
        )
    );

}

to_string_hex2: U8 -> String;
to_string_hex2 = |u8| (
    let output = Array::empty(3);
    output.push_back(u8.shift_right(4_U8).bit_and(15_U8).encode_hex_char)
          .push_back(u8.shift_right(0_U8).bit_and(15_U8).encode_hex_char)
          ._unsafe_to_string
);

test_mul_gf8: IO ();
test_mul_gf8 = (
    let xs = Iterator::range(0, 8).fold(
        ([], 1_U8), |(xs, x), _|
        (xs.push_back(x), x * 2_U8)).@0;
    println $ xs.to_iter.map(|b|
        let a = 0x57_U8;
        let c = _mul_gf8(a, b);
        [a,b,c].map(to_string_hex).format("a={} b={} c={}")
    ).join("\n")
);

test_inv_gf8: IO ();
test_inv_gf8 = (
    Iterator::range(1, 256).fold_m(
        (), |_, i|
        let a = i.to_U8;
        let b = _inv_gf8(a);
        let c = _mul_gf8(a, b);
        let _ = *println([a,b,c].map(to_string_hex).format("a={} b={} c={}"));
        eval assert(|_| "invalid c", c == 1_U8);
        pure()
    )
);

tabulate: (U8 -> String) -> String;
tabulate = |f| (
    Iterator::range(0, 16).map(|x|
        Iterator::range(0, 16).map(|y|
            let b = (x * 16 + y).to_U8;
            f(b)
        ).join(" ")
    ).join("\n")
);

test_sbox: IO ();
test_sbox = (
    println $ tabulate(|b| _sbox(b).to_string_hex)
);

byte_array_from_string_hex: String -> Array U8;
byte_array_from_string_hex = |str| (
    str.split(" ").map(from_string_hex >> as_ok >> U64::to_U8).to_array
);

// Appendix A — Key Expansion Examples
test_key_expansion: IO ();
test_key_expansion = (
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(128);
    let w = aes._key_expansion(key);
    Iterator::range(0, 44).fold_m(
        (), |_, i|
        println((i, w.@(i).to_string_hex).format("w[{}] = {}"))
    )
);

// Appendix B — Cipher Example
test_cipher: IO ();
test_cipher = (
    let input = "32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34";
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let input = input.byte_array_from_string_hex;
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(128);
    let w = aes._key_expansion(key);
    let out = *timeit("cipher", |_| aes._cipher(input, w));
    println(out.to_string_hex)
);

main: IO ();
main = test_cipher;

