// An implementation of simple regular expression.
// 
// Currently it only supports patterns below:
// - Character classes: `[xyz]`, `[^xyz]`, `.`, `\d`, `\D`, `\w`, `\W`, `\s`, 
//   `\S`, `\t`, `\r`, `\n`, `\v`, `\f`, `[\b]`, x|y
// - Assertions: `^`, `$`
// - Groups: `(x)`
// - Quantifiers: `x*`, `x+`, `x?`, `x{n}`, `x{n,}`, `x{n,m}`
//
// For details, see
// [mdn web docs: Regular expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions).
//
// LIMITATION:
//
// Currently, only single bytes can be specified in character classes. Non-ascii characters
// (U+100 or hier) cannot be specified in character classes.
//
module Main;

import Character;
import Debug;

import SimpleParser;
import StringEx;

// A type of a character class
type CharClass = unbox struct {
    // A label to be displayed
    label: String,
    // A member
    f: U8 -> Bool
};

namespace CharClass {
    // An empty character class.
    empty: CharClass;
    empty = CharClass {
        label: "",
        f: |c| false
    };

    // Creates a character class from a label and a member function.
    make: String -> (U8 -> Bool) -> CharClass;
    make = |label, f| CharClass { label:label, f:f };

    // Returns true if the character is in the class.
    contains: U8 -> CharClass -> Bool;
    contains = |c, cls| (cls.@f)(c);

    // Creates a character class that consists of only single character.
    singleton: U8 -> CharClass;
    singleton = |c| CharClass {
        label: byte_to_string(c),
        f: |c1| c1 == c 
    };

    // Creates a character class that consists of characters from start to end.
    range: U8 -> U8 -> CharClass;
    range = |start, end| CharClass { 
        label: byte_to_string(start) + "-" + byte_to_string(end),
        f: |c| start <= c && c <= end 
    };

    // Creates a character class that consists of specified string.
    consists_of: String -> CharClass;
    consists_of = |str| CharClass { 
        label: str,
        f: |c| str.find_byte(c).is_some
    };

    // Negate the member function of a character class.
    negate: CharClass -> CharClass;
    negate = |cls| (
        let label = "^" + cls.@label;
        let f = cls.@f;
        CharClass { 
            label: label,
            f: |c| !f(c) 
        }
    );

    // Creates union of two character classes.
    union: CharClass -> CharClass -> CharClass;
    union = |cls1, cls2| (
        let f = cls1.@f;
        let g = cls2.@f;
        CharClass {
            label: cls1.@label + cls2.@label,
            f: |c| f(c) || g(c) 
        }
    );

    // Adds a character to the character class.
    add: U8 -> CharClass -> CharClass;
    add = |c, cls| cls.union(singleton(c));

    // For optimization, converts a character class to a table, and create a new class
    // that refers to the table.
    to_table: CharClass -> CharClass;
    to_table = |cls| (
        let table = Iterator::count_up(0).take(256).fold(
            Array::fill(256, false), |arr, i|
            arr.set(i, cls.contains(i.to_U8))
        );
        CharClass {
            label: cls.@label,
            f: |c| table.@(c.to_I64)
        }
    );

    // A character class of `.`. (any character except newlines)
    cls_dot: CharClass;
    cls_dot = CharClass::make(".") $ |c| c != '\n' && c != '\r';

    // A character class of `\d`. (digits)
    cls_digit: CharClass;
    cls_digit = CharClass::make("\\d") $ is_digit;

    // A character class of `\D`. (non-digits)
    cls_non_digit: CharClass;
    cls_non_digit = cls_digit.negate.set_label("\\D");

    cls_word_char: CharClass;
    cls_word_char = CharClass::make("\\w") $ |c| is_alnum(c) || c == '_';

    cls_non_word_char: CharClass;
    cls_non_word_char = cls_word_char.negate.set_label("\\W");

    cls_whitespace: CharClass;
    cls_whitespace = CharClass::make("\\s") $ is_space;

    cls_non_whitespace: CharClass;
    cls_non_whitespace = cls_whitespace.negate.set_label("\\S");
}

// A type that represents Assertion Pattern.
type PAssertion = unbox union {
    pa_begin: (),       // beginning of line, ie. '^'
    pa_end: ()          // end of line,       ie. '$'
};

// Converts a pattern to a string.
impl PAssertion: ToString {
    to_string = |pa| (
        if pa.is_pa_begin { "^" };
        if pa.is_pa_end { "$" };
        eval assert(|_|"err", false);
        ""
    );
}

// A type that represents Pattern of Regular Expression.
type Pattern = box union {
    // Literal character pattern, eg. `a`
    pnormal: U8,
    // Character class pattern, eg. `[a-z]`, `\d` etc.
    pclass: CharClass,
    // Assertion pattern, eg. `^`, `$`
    passert: PAssertion,
    // Sequence of patterns, eg. `XYZ`
    psequence: Array Pattern,
    // Either pattern, eg. `X|Y`
    peither: (Pattern, Pattern),
    // Quantified pattern, eg. `X?`, `X*`, `X+`, `X{n,m}`
    pquant: (Pattern, /*min_count:*/ I64, /*max_count:*/ I64),
    // Grouped pattern, eg. `(X)`
    pgroup: (/* group_number:*/ I64, Pattern)
};

impl Pattern: ToString {
    // Converts a pattern to a string.
    to_string = |pat| (
        if pat.is_pnormal { 
            pat.as_pnormal.byte_to_string
        };
        if pat.is_pclass {
            "[" + pat.as_pclass.@label + "]"
        };
        if pat.is_passert {
            pat.as_passert.to_string
        };
        if pat.is_psequence {
            pat.as_psequence.to_iter.map(to_string).join("")
        };

        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            pat1.to_string + "|" + pat2.to_string
        };
        if pat.is_pquant {
            let (pat1, min, max) = pat.as_pquant;
            pat1.to_string + "{" + min.to_string + "," + 
                if max == I64::maximum { "" } else { max.to_string }
            + "}"
        };
        if pat.is_pgroup {
            let (n, pat_inner) = pat.as_pgroup;
            "(" + n.to_string + ":" + pat_inner.to_string + ")"
        };
        eval assert(|_|"err", false);
        ""
    );
}


namespace Pattern {

    // Parses a pattern from the stream.
    parse_pattern: Parser Pattern;
    parse_pattern = do {
        let pat = *_parse_peither;
        let _ = *match_end_of_stream;
        pure $ pat
    };

    // Parses either-pattern, ie. `X|Y`
    _parse_peither: Parser Pattern;
    _parse_peither = do {
        let pat1 = *_parse_psequence;
        let bar = *match_char_if_exists('|');
        if bar.is_some {
            let pat2 = *_parse_peither;
            pure $ peither $ (pat1, pat2)
        };
        pure $ pat1
    };

    // Parses sequence of patterns, ie. `XYZ`
    _parse_psequence: Parser Pattern;
    _parse_psequence = do {
        pure $ psequence $ *zero_or_more(
            _parse_passert.or_else $
            _parse_pquant
        )
    };

    // Parses an assertion pattern, ie. `^`, `$` etc.
    _parse_passert: Parser Pattern;
    _parse_passert = do {
        let circumflex = *match_char_if_exists('^');
        if circumflex.is_some {
            pure $ passert $ pa_begin()
        };
        let dollar = *match_char_if_exists('$');
        if dollar.is_some {
            pure $ passert $ pa_end()
        };
        // TODO word boundary support
        not_match
    };

    // Parses Quantified Pattern, ie. `X?`, `X*`, `X+`, `X{n}`, `X{n,}`, `X{n,m}`
    _parse_pquant: Parser Pattern;
    _parse_pquant = do {
        let pat = *_parse_quantifiable_item;
        let question = *match_char_if_exists('?');
        if question.is_some {
            pure $ pquant $ (pat, 0, 1)
        };
        let asterisk = *match_char_if_exists('*');
        if asterisk.is_some {
            // TODO: support non-greedy match
            pure $ pquant $ (pat, 0, maximum)
        };
        let plus = *match_char_if_exists('+');
        if plus.is_some {
            // TODO: support non-greedy match
            pure $ pquant $ (pat, 1, maximum)
        };
        // `X{n}`, `X{n,}`, `X{n,m}`
        let lbrace = *match_char_if_exists('{');
        if lbrace.is_some {
            let (min_count, max_count) = *_parse_pquant_n_m_inner;
            let _ = *match_char('}').or_error("'}' is missing");
            pure $ pquant $ (pat, min_count, max_count)
        };
        pure $ pat
    };

    // Parses inner of `X{n}`, `X{n,}`, `X{n,m}`
    _parse_pquant_n_m_inner: Parser (I64, I64);
    _parse_pquant_n_m_inner = do {
        let min_count = *match_integer;
        let comma = *match_char_if_exists(',');
        if comma.is_none {
            pure $ (min_count, min_count)
        };
        let max_count = *match_integer.map(some).or_else(pure $ none());
        if max_count.is_some {
            pure $ (min_count, max_count.as_some)
        };
        pure $ (min_count, maximum)
    };

    // Parses quantifiable item.
    _parse_quantifiable_item: Parser Pattern;
    _parse_quantifiable_item = do {
        _parse_pgroup.or_else $
        _parse_pclass
    };

    // TODO: support backreferences, ie. `\\1`, `\\2` etc.

    // Parses Group Pattern, ie. `(X)`
    _parse_pgroup: Parser Pattern;
    _parse_pgroup = do {
        let lparen = *match_char('(');
        let pat = *_parse_peither;
        let rparen = *match_char(')').or_error("')' is missing");
        let group_idx = 0;  // have to assign group index later
        pure $ pgroup $ (group_idx, pat)
    };

    // A table of normal characters, ie. not a meta character.
    _normal_chars: CharClass;
    _normal_chars = (
        CharClass::consists_of(
            ".?*+^$|[](){}\\"
        ).negate.to_table
    );

    // Parses character class pattern, ie. `.`, `[a-z]`, `\w` etc.
    _parse_pclass: Parser Pattern;
    _parse_pclass = do {
        let c = *match_any_char;
        if _normal_chars.contains(c) {
            pure $ pclass(CharClass::singleton(c))
        };
        if c == '.' {
            pure $ pclass(CharClass::cls_dot)
        };
        if c == '[' {
            pure $ pclass(*_parse_pclass_bracket)
        };
        if c == '\\' {
            pure $ pclass(*_parse_backslash_char_class(false))
        };
        not_match
    };

    // Parses a character class that begins with '['.
    // The `[` itself is parsed already.
    _parse_pclass_bracket: Parser CharClass;
    _parse_pclass_bracket = do {
        let circumflex = *match_char_if_exists('^');
        let start_hyphen = *match_char_if_exists('-');
        let components = *repeat(_parse_bracket_component);
        let end_hyphen = *match_char_if_exists('-');
        let _ = *match_char(']').or_error("']' is missing");

        let cls = components.to_iter.fold(
            CharClass::empty, union
        );
        let cls = if start_hyphen.is_some || end_hyphen.is_some { cls.add('-') } else { cls };
        let cls = if circumflex.is_some { cls.negate } else { cls };
        pure $ cls.to_table
    };

    // Parses each component in a bracket.
    _parse_bracket_component: Parser CharClass;
    _parse_bracket_component = do {
        let _ = *match_char('\\');
        _parse_backslash_char_class(true)
    }.or_else $ do {
        let start = *match_any_char.filter(|c| c != ']' && c != '\\');
        let _ = *match_char('-');
        let end = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::range(start, end)
    }.or_else $ do {
        let c = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::singleton(c)
    };

    // Parses the char class that begins with a backslash.
    // The backslash itself is parsed already.
    _parse_backslash_char_class: Bool -> Parser CharClass;
    _parse_backslash_char_class = |in_bracket| do {
        let c = *match_any_char;
        if c == 'd' { pure $ CharClass::cls_digit };
        if c == 'D' { pure $ CharClass::cls_non_digit };
        if c == 'w' { pure $ CharClass::cls_word_char };
        if c == 'W' { pure $ CharClass::cls_non_word_char };
        if c == 's' { pure $ CharClass::cls_whitespace };
        if c == 'S' { pure $ CharClass::cls_non_whitespace };
        if c == 't' { pure $ CharClass::singleton('\t') };
        if c == 'r' { pure $ CharClass::singleton('\r') };
        if c == 'n' { pure $ CharClass::singleton('\n') };
        if c == 'v' { pure $ CharClass::singleton(11_U8) };
        if c == 'f' { pure $ CharClass::singleton(12_U8) };
        if c == 'b' && in_bracket { pure $ CharClass::singleton(8_U8) };
        // TODO: support for \xhh, \uhhhh
        
        // other character is treated as itself, ie. `\\`, `\+`, `\*` etc.
        pure $ CharClass::singleton(c)
    };

    // `pat._assign_group_number(n)` assigns group number for each group.
    // The first group number becomes `n + 1`. 
    // It returns the translated pattern along with maximum group number.
    _assign_group_number: I64 -> Pattern -> (I64, Pattern);
    _assign_group_number = |n, pat| (
        if pat.is_pnormal || pat.is_pclass || pat.is_passert { 
            (n, pat) 
        };
        if pat.is_psequence {
            let input: Array Pattern = pat.as_psequence;
            let output: Array Pattern = Array::empty(input.get_size);
            let (n, output) = input.to_iter.fold(
                (n, output), |(n, output), pat_inner|
                let (n, pat_inner) = pat_inner._assign_group_number(n);
                let output = output.push_back(pat_inner);
                (n, output)
            );
            let pat = psequence $ output;
            (n, pat)
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            let (n, pat1) = pat1._assign_group_number(n);
            let (n, pat2) = pat2._assign_group_number(n);
            let pat = peither $ (pat1, pat2);
            (n, pat)
        };
        if pat.is_pquant {
            let (pat_inner, min, max) = pat.as_pquant;
            let (n, pat_inner) = pat_inner._assign_group_number(n);
            let pat = pquant $ (pat_inner, min, max);
            (n, pat)
        };
        if pat.is_pgroup {
            let (_, pat_inner) = pat.as_pgroup;
            let gn = n + 1;
            let (n, pat_inner) = pat_inner._assign_group_number(gn);
            let pat = pgroup $ (gn, pat_inner);
            (n, pat)
        };
        eval assert(|_|"err", false);
        (n, pat)
    );


}

// Matched group
type Group = unbox struct {
    text: String,       // text of the group
    start: I64,         // position of the start of the group
    end: I64            // position of the end of the group
};

// The array of matched groups
type GroupArray = Array (Option Group);

impl Group: ToString {
    to_string = |group| (
        "Group{"
        + "text:\"" + group.@text + "\""
        + ", start:" + group.@start.to_string
        + ", end:" + group.@end.to_string
        + "}"
    ) ;
}

// The matching state
type MatchState = unbox struct {
    stream: Stream,             // The stream that contains current matching position
    groups: GroupArray          // The matched groups
};

type MatchStateIter = Iterator MatchState;

impl MatchState: ToString {
    to_string = |state| (
        "MatchState{"
        + "stream:" + state.@stream.to_string
        + ", groups:" + state.@groups.map(|g| /*"\n        " +*/ g.to_string).to_string
        + "}"
    );
}

namespace MatchState {
    // Creates new MatchState. The stream has to be at the position of zero.
    make: Stream -> RegExp -> MatchState;
    make = |stream, regexp| (
        eval assert (|_| "stream position is nonzero", stream.@position == 0);
        let n = regexp.@group_count;
        MatchState {
            stream: stream,
            groups: Array::fill(n + 1, none())
        }
    );        
            
    // Matches a pattern to the current position. Returns new positions at the end of pattern.
    // If two or more matching paths exist, returns them all.
    _match_pattern: Pattern -> MatchState -> Iterator MatchState;
    _match_pattern = |pattern, state| (
        if pattern.is_pnormal {
            state._match_pattern_pnormal(pattern.as_pnormal)
        };
        if pattern.is_pclass {
            state._match_pattern_pclass(pattern.as_pclass)
        };
        if pattern.is_passert {
            state._match_pattern_passert(pattern.as_passert)
        };
        if pattern.is_psequence {
            state._match_pattern_psequence(pattern.as_psequence.to_iter)
        };
        if pattern.is_peither {
            state._match_pattern_peither(pattern.as_peither)
        };
        if pattern.is_pquant {
            state._match_pattern_pquant(pattern.as_pquant)
        };
        if pattern.is_pgroup {
            state._match_pattern_pgroup(pattern.as_pgroup)
        };
        eval assert (|_| "err", false);
        Iterator::empty
    );

    _match_pattern_pnormal: U8 -> MatchState -> Iterator MatchState;
    _match_pattern_pnormal = |c, state| (
        state.@stream.advance.map_or(
            Iterator::empty,
            |(c1, next)|
            if c != c1 { Iterator::empty };
            pure $ state.set_stream(next)
        )    
    );
    
    _match_pattern_pclass: CharClass -> MatchState -> Iterator MatchState;
    _match_pattern_pclass = |cls, state| (
        state.@stream.advance.map_or(
            Iterator::empty,
            |(c, next)|
            if !cls.contains(c) { Iterator::empty };
            pure $ state.set_stream(next)
        )    
    );
    
    _match_pattern_passert: PAssertion -> MatchState -> Iterator MatchState;
    _match_pattern_passert = |pa, state| (
        if pa.is_pa_begin {
            if state.@stream.@position == 0 { pure $ state };
            Iterator::empty
        };
        if pa.is_pa_end {
            if state.@stream.advance.is_none { pure $ state };
            Iterator::empty
        };
        eval assert(|_|"err", false);
        Iterator::empty
    );
    
    _match_pattern_psequence: Iterator Pattern -> MatchState -> Iterator MatchState;
    _match_pattern_psequence = |patterns, state| (
        patterns.fold(
            pure $ state, |current, pattern|
            current.bind(|state| state._match_pattern(pattern))
        )
    );

    _match_pattern_peither: (Pattern, Pattern) -> MatchState -> Iterator MatchState;
    _match_pattern_peither = |(pat1, pat2), state| (
        let res = state._match_pattern(pat1).append $
                  state._match_pattern(pat2);
        //eval debug_println("peither: state=" +state.to_string + " res="+ res.map(|s| "\n    " + s.to_string).concat_iter);
        res
    );

    _match_pattern_pquant: (Pattern, I64, I64) -> MatchState -> Iterator MatchState;
    /*_match_pattern_pquant = |(pattern, min_count, max_count), state| (
        let result: Iterator MatchState = Iterator::empty;
        let current: Iterator MatchState = pure $ state;

        loop(
            (result, current, 0), |(result, current, i)|
            if current.is_empty {
                break $ result
            };
            if max_count < i {
                break $ result
            };
            let result = if min_count <= i && i <= max_count {
                result.append(current)
            } else {
                result
            };
            let current = current.bind(|state| state._match_pattern(pattern));
            continue $ (result, current, i + 1)
        )
    );
    */
    _match_pattern_pquant = |(pattern, min_count, max_count), state| (
        // lazy evaluation
        let states_of_each_iteration: Iterator (Iterator MatchState) = Iterator::generate(
            pure $ state,
            |states| 
            let states: Iterator MatchState = states;   // to avoid type ambiguity
            if states.is_empty { none() };
            let states: Iterator MatchState = states.bind(|state| state._match_pattern(pattern));
//            eval debug_eprintln("states=" + states.to_array.map(|s| "\n  " + s.to_string).to_string);
            if states.is_empty { none() };
            some $ (states, states)
        ).push_front(pure $ state);
        // TODO: greedy match の場合、マッチ回数が多いものから試す必要がある。
        // しかし、patternが0文字にマッチする場合、無限回マッチしてしまう。eg. `()*`
        // pattern は複数のマッチ経路が存在する可能性がある。eg. `(abc|)*`
        // 単純に進んだ文字数で降順にソートするべきかもしれないが、グループのキャプチャが変わってくる可能性はないか。
        // マッチ回数が多いものから試す以上、lazy にしてもあまり意味はない。
        // 現状ではバックトラックのため Iterator から Iterator を作っているため試行回数が爆発する。
        // 例えば `.*.*.*` を `abcde` にマッチさせると分岐がたくさんできる。
        // 重複削除、または taboo list が必要。
        // その場合、すでにチェックした (pattern, state) の組を HashSet に登録し、すでにチェック済みの場合はスキップする。
        // しかし、MatchState は hashkey にできるが、Pattern はできない。(CharClassがあるため)
        states_of_each_iteration.take(max_count).__skip(min_count).flatten
    );

    _drop_if_no_advance: MatchState -> Iterator MatchState -> Iterator MatchState;
    _drop_if_no_advance = |state, next_states| (
        let start_position = state.@stream.@position;
        next_states.filter(|s| s.@stream.@posision - start_position > 0)
    );

    __skip: I64 -> Iterator a -> Iterator a;
    __skip = |n, iter| (
        if n <= 0 { iter };
        let opt = iter.advance;
        if opt.is_none { Iterator::empty };
        let (_, next) = opt.as_some;
        next.__skip(n - 1)
    );

    _match_pattern_pgroup: (I64, Pattern) -> MatchState -> Iterator MatchState;
    _match_pattern_pgroup = |(group_number, pattern), state| (
        let stream_start = state.@stream;
        let start = state.@stream.@position;
        state._match_pattern(pattern).map(|state|
            let end = state.@stream.@position;
            let text = stream_start.read_string(max(0, end - start));
            let group = Group { text: text, start: start, end: end };
            let state = state.mod_groups(set(group_number, some(group)));
            state
        )
    );
    
    _select_longest_match: Iterator MatchState -> Option MatchState;
    _select_longest_match = |states| (
        states.fold(
            none(), |state1_opt, state2|
            state1_opt.map_or(
                some(state2),
                |state1|
                if state1.@stream.@position >= state2.@stream.@position {
                    some(state1)
                } else {
                    some(state2)
                }
            )
        )
    );


}

type RegExp = unbox struct {
    pattern: Pattern,
    flags: String, // TODO: support flags
    group_count: I64
};

namespace RegExp {

    compile: String -> String -> Result ErrMsg RegExp;
    compile = |pattern, flags| (
        let pattern = *parse_pattern.run_parser_str(pattern).map(|(p,_)| p);
        let pattern = pgroup $ (0, pattern); // since whole pattern is group 0
        let (n, pattern) = pattern._assign_group_number(-1);
        ok $ RegExp { pattern: pattern, flags: flags, group_count: n }
    );

    exec: String -> RegExp -> Result ErrMsg GroupArray;
    exec = |target, regexp| (
        let stream: Stream = *from_string(target);
        let state = MatchState::make(stream, regexp);
        let states = state._match_pattern(regexp.@pattern);
        let state = *states._select_longest_match.map_or(
            err $ _NotMatch,
            |state| ok $ state
        );
        ok $ state.@groups
    );
}

main1: IO ();
main1 = (
    do {
        let p = parse_pattern;
        let res = *p.run_parser_str("([abc]+|d{3}e{4,}f{3,5}|)h?i*").from_result;
        let (pat, s) = res;
        let _ = println(s.to_string);
        println(pat.to_string).lift
    }
    .try(eprintln)
);

check_regexp: String -> String -> Array String -> IO ();
check_regexp = |pattern, target, expected| (
    let _ = *println("===============================================");
    let _ = *println("pattern=" + pattern);
    let _ = *println("target=" + target);

    let res = do {
        let regexp = *RegExp::compile(pattern, "");
        //let res: Result ErrMsg (Array String) = regexp.exec(target);
        let groups: GroupArray = *regexp.exec(target);
        let lines = groups.to_iter.zip(Iterator::count_up(0)).map(
            |(group, i)| "group[" + i.to_string + "]=" + group.to_string + "\n"
        ).concat_iter;
        let actual = groups.map(map_or("", |g| g.@text));
        let lines = if expected != actual {
            lines + "ERROR: expected="+expected.to_string+" actual="+actual.to_string + "\n"
        } else { lines };
        pure $ lines
    };
    if res.is_ok {
        println(res.as_ok)
    } else {
        println("ERROR: " + res.as_err)
    }
);

main: IO ();
main = (
    let _ = *main1;
    let _ = *check_regexp(".*", "abcdef", ["abcdef"]);
    let _ = *check_regexp(".*([ade])+", "abcdef", ["abcde", "e"]);
    let _ = *check_regexp(".*([ade]+)", "abcdef", ["abcde", "de"]);
    let _ = *check_regexp("\\w+", "abcd,efg", ["abcd"]);
    let _ = *check_regexp("\\s*(\\w+)\\s*", "  abc d,e fg ", ["  abc ", "abc"]);
    let _ = *check_regexp(".*(bc|c*df*e)", "abcccdef", ["abcccde", "de"]);
    pure()
);
