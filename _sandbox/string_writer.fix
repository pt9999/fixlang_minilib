module Main;

import StringEx;

//-------------------------------------------------------
// State Monad
//-------------------------------------------------------

type State s a = unbox struct { _data: s -> (a, s) };

namespace State {
    make_state_monad: (s -> (a, s)) -> State s a;
    make_state_monad = |f| State { _data: f };

    run_state: s -> State s a -> (a, s);
    run_state = |s, ma| (ma.@_data) (s);

    get_state: State s s;
    get_state = make_state_monad $ |s| (s, s);

    put_state: s -> State s ();
    put_state = |s| make_state_monad $ |_| ((), s);
}

impl State s: Monad {
    pure = |a| make_state_monad $ |s| (a, s);
    bind = |f, ma| make_state_monad $ |s|
        let (a, ss) = ma.run_state(s);
        let mb = f(a);
        mb.run_state(ss) 
    ;
}
//---------------------------------
// StringWriter
//---------------------------------

type StringWriter = State String ();

namespace StringWriter {
    write: [a: ToString] a -> StringWriter;
    write = |a| (
        put_state(*get_state + a.to_string)
    );

    collect_string: StringWriter -> String;
    collect_string = |w| (
        let (_, str) = w.run_state("");
        str
    );
}

namespace Tuple2 {
    concat_str: [a: ToString, b: ToString] (a,b) -> String;
    concat_str = |(a,b)| a.to_string + b.to_string;
}

namespace Tuple3 {
    concat_str: [a: ToString, b: ToString, c:ToString] (a,b,c) -> String;
    concat_str = |(a,b,c)| a.to_string + b.to_string + c.to_string;
}

namespace Tuple4 {
    concat_str: [a: ToString, b: ToString, c:ToString, d:ToString] (a,b,c,d) -> String;
    concat_str = |(a,b,c,d)| a.to_string + b.to_string + c.to_string + d.to_string;
}


test_string_writer: IO ();
test_string_writer = (
    let text = collect_string $ do {
        let _ = *write("hello ");
        let _ = *write("world");
        let _ = *write(((" ", 1).concat_str, " ", 2.2, "\n").concat_str);
        pure()
    };
    println (text)
);


//---------------------------------
// Format
//---------------------------------

// `array.formatv(str)` replaces each occurence of `{}` in the format string `str`
// with each element of `array`.
// Currently only supports `{}`.
formatv: String -> Array String -> String;
formatv = |str, args| (
    let from = "{}";
    let output = Array::empty(args.get_size * 2);
    let (output, tail) = args.to_iter.loop_iter(
        (output, 0), |(output, find_start), to|
        let pos = str.find(from, find_start);
        if pos.is_none {
            break $ (output, find_start)
        };
        let pos = pos.as_some;
        let output = output
            .push_back(str.substring(find_start, pos))
            .push_back(to)
        ;
        let find_start = pos + from.get_size;
        continue $ (output, find_start)
    );
    let output = output
        .push_back(str.substring(tail, str.get_size));
    output.to_iter.concat_iter
);

namespace Array {
    // `array.format(str)` replaces each occurence of `{}` in the format string `str`
    // with each element of `array`.
    // Currently only supports `{}`.
    format: [a: ToString] String -> Array a -> String;
    format = |str, arr| arr.map(to_string).formatv(str);
}

namespace Tuple2 {
    // `(a, b).format(str)` replaces each occurence of `{}` in the format string `str`
    // with `a`, `b`.
    format: [a: ToString, b: ToString] String -> (a,b) -> String;
    format = |str, (a,b)| [a.to_string, b.to_string].formatv(str);
}

namespace Tuple3 {
    // `(a, b, c).format(str)` replaces each occurence of `{}` in the format string `str`
    // with `a`, `b`, `c`.
    format: [a: ToString, b: ToString, c:ToString] String -> (a,b,c) -> String;
    format = |str, (a,b,c)| [a.to_string, b.to_string, c.to_string].formatv(str);
}

namespace Tuple4 {
    // `(a, b, c, d).format(str)` replaces each occurence of `{}` in the format string `str`
    // with `a`, `b`, `c`, `d`.
    format: [a: ToString, b: ToString, c:ToString, d:ToString] String -> (a,b,c,d) -> String;
    format = |str, (a,b,c,d)| [a.to_string, b.to_string, c.to_string, d.to_string].formatv(str);
}

main: IO ();
main = (
    let _ = *println([1].format("hello {}"));
    let _ = *println([1, 2].format("hello {} {} {} world"));
    let _ = *println(["foo"].format("hello {}"));
    let _ = *println((1, 2.2).format("hello {} world {} end"));
    let _ = *println((1, 2.2, 3_U16).format("hello {} world {} {}"));
    let _ = *println((1, 2.2, 3_U16, ("foo", "bar")).format("{} hello world {} {} {} end"));
    pure()
);
