module Minilib.Crypto.Tls13.RandGen;

import Random;
import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Math.RandomEx;
import Minilib.Monad.State;
import Minilib.Monad.Trans;

trait RandGen = Functor + Monad + RandGenIF;

trait [m: * -> *] m: RandGenIF {
    randgen_bytes: I64 -> m (Array U8);
}

impl StateT SecureRandom IOFail: RandGenIF {
    randgen_bytes = |size| (
        let secure_random = *get_state;
        let (bytes, secure_random) = *secure_random.generate_bytes(size).lift_t;
        eval *put_state(secure_random);
        pure $ bytes
    );
}

impl [m: Monad] StateT Random m: RandGenIF {
    randgen_bytes = |size| (
        let random = *get_state;
        let (bytes, random) = random.generate_array(size, generate_U8);
        eval *put_state(random);
        pure $ bytes
    );
}

// Constant RandGen
impl [m: Monad] StateT U8 m: RandGenIF {
    randgen_bytes = |size| (
        let u8 = *get_state;
        pure $ Array::fill(size, u8)
    );
}
