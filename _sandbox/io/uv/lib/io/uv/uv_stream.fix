module Minilib.IO.Uv.UvStream;

import Minilib.IO.Uv;
import Minilib.Monad.IO;


//-----------------------------------------------------------------
// UvStream
//-----------------------------------------------------------------

type UvStreamTag = unbox struct {};
trait tag: IsUvStreamTag {}
impl UvStreamTag: IsUvStreamTag {}

type UvStream = UvHandle UvStreamTag;

namespace UvStream {
    // read のコールバック
    // # Parameters
    // * stream: ストリーム(uv_stream_t*)
    // * nread: 読み込んだバイト数。0未満ならエラー。ただし Uv::eof の場合は EOFを表す。
    // * bytes: 読み込んだデータ
    type UvReadCallback = UvStream -> I64 -> Array U8 -> IO ();

    read_start: [t: IsUvStreamTag, m: MonadIOFail] UvReadCallback -> UvHandle t -> m ();
    read_start = |cb, stream| lift_iofail $ do {
        stream.borrow_ptr_m(|p_stream|
            let ret = *FFI_CALL_IO[CInt minilib_uv_is_started(Ptr), p_stream].lift;
            if ret != 0.to_CInt {
                throw $ "reading already started"
            };
            stream.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する(retain)
            FFI_CALL_IO[CInt minilib_uv_read_start(Ptr), p_stream]
            ._check_err
        )
    };
    minilib_uv_read_callback : Ptr -> I64 -> Ptr -> ();
    minilib_uv_read_callback = |p_stream, nread, p_buf| (
        eval log_debug("minilib_uv_read_callback: p_stream=" + p_stream.to_string);
        let stream: UvStream = *from_ptr(p_stream);
        let cb: UvReadCallback = *stream.get_user_callback;     // ユーザが用意したコールバック関数を取得する(release)
        stream.set_user_callback(cb);;     // ユーザが用意したコールバック関数を設定する(retain)
        let bytes = *if nread <= 0 { pure $ [] }
        else {
            let bytes = Array::fill(nread, 0_U8);
            let (bytes, ()) = *bytes.mutate_boxed_io(|p_bytes|
                FFI_CALL_IO[() memcpy(Ptr, Ptr, CSizeT), p_bytes, p_buf, nread.to_CSizeT]
            );
            pure $ bytes
        };
        cb(stream, nread, bytes)
    ).unsafe_perform;
    FFI_EXPORT[minilib_uv_read_callback, minilib_uv_read_callback];

    read_stop: [t: IsUvStreamTag, m: MonadIOFail] UvHandle t -> m ();
    read_stop = |stream| lift_iofail $ do {
        let ret = *stream.borrow_ptr_m(|p_stream|
            FFI_CALL_IO[CInt minilib_uv_is_started(Ptr), p_stream]
        ).lift;
        if ret == 0.to_CInt {
            pure()
        };
        let err = *stream.borrow_ptr_m(|p_stream|
            FFI_CALL_IO[CInt minilib_uv_read_stop(Ptr), p_stream]
        ).lift;
        let cb: UvReadCallback = *stream.get_user_callback.lift;     // ユーザが用意したコールバック関数を取得する(release)
        pure(err)._check_err
    };
}

//-----------------------------------------------------------------
// UvWrite
//-----------------------------------------------------------------

type UvWriteTag = unbox struct {};

type UvWrite = UvReq UvWriteTag;

namespace UvWrite {

    // write のコールバック
    // # Parameters
    // * req: リクエスト(uv_write_t*)
    // * status: ステータス。0未満ならエラー
    type UvWriteCallback = UvWrite -> CInt -> IO ();

    write: [t: IsUvStreamTag, m: MonadIOFail] Array U8 -> UvWriteCallback -> UvHandle t -> m UvWrite;
    write = |buf, cb, stream| lift_iofail $ do {
        let p_req = *FFI_CALL_IO[Ptr minilib_uv_write_init()].lift;
        let req = *from_ptr(p_req).lift;
        req.retain.lift;;    // リクエスト発生のためリテインする
        req.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する
        req.borrow_ptr_m(|p_req|
            stream.borrow_ptr_m(|p_handle|
                let bufsize = buf.get_size.to_CSizeT;
                buf.borrow_boxed_m(|p_buf|
                    FFI_CALL_IO[CInt minilib_uv_write(Ptr, Ptr, Ptr, CSizeT), p_req, p_handle, p_buf, bufsize]
                    ._check_err
                )
            )
        );;
        pure $ req
    };
    minilib_uv_write_callback : Ptr -> CInt -> ();
    minilib_uv_write_callback = |p_req, status| (
        eval log_debug("minilib_uv_write_callback: p_req=" + p_req.to_string);
        let req: UvWrite = *from_ptr(p_req);
        let cb: UvWriteCallback = *req.get_user_callback;
        cb(req, status);;
        req.release  // release on callback end
    ).unsafe_perform;
    FFI_EXPORT[minilib_uv_write_callback, minilib_uv_write_callback];

    get_stream: [m: MonadIO] UvWrite -> m UvStream;
    get_stream = |write| lift_io $ do {
        let p_stream = *write.borrow_ptr_m(|p_write_req|
            FFI_CALL_IO[Ptr minilib_uv_write_get_stream(Ptr), p_write_req]
        );
        from_ptr(p_stream)
    };
}

