module Main;

import Minilib.Monad.Error;
import Minilib.Monad.Random;

// crypto/tls/tls_api.fix
trait a: TlsApi {
    type CertImpl a;
    type Asn1Impl a;
    type RsaImpl a;
    type EcImpl a;
    type TlsSessionImpl a;
    get_cert_api: [cert: CertApi, TlsApi::CertImpl a = cert] a -> cert;
    get_asn1_api: [asn1: Asn1Api, TlsApi::Asn1Impl a = asn1] a -> asn1;
    get_rsa_api: [rsa: RsaApi, TlsApi::RsaImpl a = rsa] a -> rsa;
    get_ec_api: [ec: EcApi, TlsApi::EcImpl a = ec] a -> ec;
    get_tls_session_api: [sess: TlsSessionApi, TlsApi::TlsSessionImpl a = sess] a -> sess;
}

trait a: TlsSessionApi {
    make_session: String -> IOFail a;
}

// crypto/cert/cert_api.fix
trait a: CertApi {
    type RsaImpl a;
    type EcImpl a;
    get_rsa_api: [rsa: RsaApi, CertApi::RsaImpl a = rsa] a -> rsa;
    get_ec_api: [ec: EcApi, CertApi::EcImpl a = ec] a -> ec;
}

// crypto/asn1/asn1_api.fix

trait a: Asn1Api {
    decode_der_from_bytes: [obj: DecodeDer, m: MonadError] Array U8 -> a -> m obj;
}

trait a: DecodeDer {
    decode_der: a -> ();
}

trait a: RsaApi {
    dummy_rsa: a -> ();
}

// crypto/ec/ec_api.fix
type EcCurveName = String;
type EcHashName = String;
type EcPublicKey = Array U8;    // UncompressedPointRepresentation
type EcSharedSecret = Array U8;
type EcSignature = Array U8;
type EcMessage = Array U8;

trait a: EcApi {
    type EcdheImpl a;
    type EcdsaImpl a;
    make_ecdhe: [ecdhe: EcdheApi, EcApi::EcdheImpl a = ecdhe, m: MonadRandom] EcCurveName -> a -> m ecdhe;
    make_ecdsa: [ecdsa: EcdsaApi, EcApi::EcdsaImpl a = ecdsa, m: MonadError] EcCurveName -> EcHashName -> a -> m ecdsa;
}

trait a: EcdheApi {
    get_curve_name: a -> EcCurveName;
    get_key_exchange: a -> EcPublicKey;
    accept_peer_key_exchange: [m: MonadError] EcPublicKey -> a -> m EcSharedSecret;
}

trait a: EcdsaApi {
    verify: [m: MonadError, asn1: Asn1Api] EcPublicKey -> EcSignature -> EcMessage -> asn1 -> a -> m ();
}

// crypto/ec/mock_ec_impl.fix
type MockEcImpl = unbox struct {
    dummy: ()
};

namespace MockEcImpl {
    make: MockEcImpl;
    make = MockEcImpl {
        dummy: ()
    };
}

impl MockEcImpl: EcApi {
    type EcdheImpl MockEcImpl = MockEcdheImpl;
    type EcdsaImpl MockEcImpl = MockEcdsaImpl;

    // make_ecdhe: [ecdhe: EcdheApi, EcApi::EcdheImpl a = ecdhe, m: MonadRandom] EcCurveName -> a -> m ecdhe;
    make_ecdhe = |curve_name, ec_impl| MockEcdheImpl::make(curve_name);

    // make_ecdsa: [ecdsa: EcdsaApi, EcApi::EcdsaImpl a = ecdsa, m: MonadError] EcCurveName -> EcHashName -> a -> m ecdsa;
    make_ecdsa = |curve_name, hash_name, ec_impl| MockEcdsaImpl::make(curve_name, hash_name);
}

type MockEcdheImpl = unbox struct {
    curve_name: EcCurveName,
};

namespace MockEcdheImpl {
    make: [m: MonadRandom] EcCurveName -> m MockEcdheImpl;
    make = |curve_name| (
        pure $ MockEcdheImpl {
            curve_name: curve_name,
        }
    );
}

impl MockEcdheImpl: EcdheApi {
    get_curve_name = @curve_name;
    get_key_exchange = |_| Array::fill(64, 0_U8);
    accept_peer_key_exchange = |peer_key, a| pure $ Array::fill(64, 0_U8);
}

type MockEcdsaImpl = unbox struct {
    curve_name: EcCurveName,
    hash_name: EcHashName,
};

namespace MockEcdsaImpl {
    make: [m: MonadError] EcCurveName -> EcHashName -> m MockEcdsaImpl;
    make = (
        pure $ MockEcdsaImpl {
            curve_name: curve_name,
            hash_name: hash_name,
        }
    );
}

impl MockEcdsaImpl: EcdsaApi {
    //verify: [m: MonadError] EcPublicKey -> EcSignature -> EcMessage -> a -> m ();
    verify = |pub_key, signature, message, ecdsa_impl| pure();
}

main: IO ();
main = pure();
