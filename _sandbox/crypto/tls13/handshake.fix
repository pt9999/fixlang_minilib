module Minilib.Crypto.Tls13.Handshake;

import AsyncTask;
import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Crypto.Tls13.ECDHE;
import Minilib.Crypto.Tls13.ECDSA;
import Minilib.Crypto.Tls13.KeyShare;
import Minilib.Crypto.Tls13.Extensions;
import Minilib.Crypto.Tls13.Connection;
import Minilib.Crypto.Tls13.Protection;
import Minilib.Crypto.Tls13.HandshakeProtocol;
import Minilib.Crypto.Tls13.RecordProtocol;
//import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type HandshakeState = unbox union {
    before_client_hello: BeforeClientHello,
    after_client_hello: AfterClientHello,
    after_server_hello: AfterServerHello,
};

namespace HandshakeState {
    start_handshake: [m: MonadRandGen] String -> BeforeClientHello -> m HandshakeState;
    start_handshake = |server_name| (
        BeforeClientHello::make_client_hello(server_name)
    );

    send_records: [m: TLSConnection] HandshakeState -> m ();
    send_records = |state| (
        let records = state.get_records_to_send;
        TLSPlaintext::send_plaintexts(records)
    );

    get_records_to_send: HandshakeState -> m (Array TLSPlaintext);
    get_records_to_send = |state| (
        if state.is_after_client_hello {
            pure $ state.as_after_client_hello.@client_hello_records
        };
        pure $ []
    );

    recv_record: [m: TLSConnection, ErrorType m = ErrMsg] HandshakeState -> m HandshakeState;
    recv_record = |state| (
        let plaintext: TLSPlaintext = *TLSPlaintext::recv_plaintext;
        state.on_recv_record(plaintext)
    );

    on_recv_record: [m: MonadError, ErrorType m = ErrMsg] TLSPlaintext -> HandshakeState -> m HandshakeState;
    on_recv_record = |plaintext, state| (
        if state.is_after_client_hello {
            state.as_after_client_hello.on_recv_record(plaintext)
        };
        pure $ state
    );
}

type BeforeClientHello = unbox struct {
    dummy: ()
};

namespace BeforeClientHello {
    make_client_hello: [m: MonadRandGen] String -> BeforeClientHello -> m HandshakeState;
    make_client_hello = |server_name, _| (
        let hello = ClientHello::empty;
        let hello = hello.init_random(*randgen_bytes(32));
        // init server_name
        let hello = hello.add_extension(Extension::server_name $
            ServerNameList::make([
                ServerName::make(server_name)
            ])
        );
        // init key_share
        // TODO: support other key agreement type
        let key_agreement = *ECDHE::make(ECParam::secp256r1);
        let ks: KeyShare = ks_client_hello $ KeyShareClientHello::make $ [
            key_agreement.to_key_share_entry
        ];
        let hello = hello.add_extension(Extension::key_share $ ks);
        // 9.2. Mandatory-to-Implement Extensions
        // TODO: cookie
        // TODO: signature_algorithms_cert

        eval debug_println("client_hello: extensions=" + hello.@extensions.to_string);
        let handshake: Handshake = Handshake::client_hello $ hello;
        let handshake_bytes: Array U8 = marshal_to_bytes(handshake);
        let client_hello_records: Array TLSPlaintext = TLSPlaintext::split_fragments(ContentType::handshake(), handshake_bytes);

        pure $ after_client_hello $ AfterClientHello {
            client_hello_records: client_hello_records,
            key_agreement: key_agreement
        }
    );
}


// TODO: support other key agreement type
type KeyAgreement = ECDHE;

type AfterClientHello = unbox struct {
    client_hello_records: Array TLSPlaintext,
    key_agreement: KeyAgreement,
};

impl AfterClientHello: ToString {
    to_string = |hello| (
        "AfterClientHello {" +
        " client_hello_records=" + hello.@client_hello_records.to_string +
        " key_agreement=" + hello.@key_agreement.to_string +
        "}"
    );
}

namespace AfterClientHello {

    on_recv_record: [m: MonadError, ErrorType m = ErrMsg] TLSPlaintext -> AfterClientHello -> m HandshakeState;
    on_recv_record = |plaintext, after_client_hello| (
        if !plaintext.@content_type.is_handshake {
            error $ "unexpected content type"
        };
        let client_hello_handshake_bytes = *after_client_hello.@client_hello_records.join_fragments;
        let server_hello_handshake_bytes = *server_hello_records.join_fragments;
        let handshake: Handshake = *unmarshal_from_bytes(server_hello_handshake_bytes).from_result_t;
        if !handshake.is_server_hello {
            error $ "unexpected handshake type"
        };
        let server_hello: ServerHello = handshake.as_server_hello;
        eval debug_println("server_hello=" + server_hello.to_string);

        // key agreement
        let key_agreement = after_client_hello.@key_agreement;
        let key_share_entry = *server_hello._find_key_share_entry;
        let shared_secret: SharedSecret = *key_agreement.accept_server_share(key_share_entry).from_result_t;
        eval debug_println("shared_secret=" + shared_secret.to_string_hex);

        // construct protection
        let cipher_suite = server_hello.@cipher_suite;
        let protection = *Protection::make(cipher_suite).from_result_t;
        let protection = protection.add_handshake_context(client_hello_handshake_bytes);
        let protection = protection.add_handshake_context(server_hello_handshake_bytes);
        let protection = *protection.init_handshake(shared_secret).from_result_t;

        pure $ after_server_hello $ AfterServerHello {
            protection: protection,
            server_hello: server_hello,
        }
    );

    _find_key_share_entry: [m: MonadError, ErrorType m = ErrMsg] ServerHello -> m KeyShareEntry;
    _find_key_share_entry = |hello| (
        let opt = hello.@extensions.find(is_key_share).map(as_key_share);
        if opt.is_none { error $ "key_share not found" };
        let ks: KeyShare = opt.as_some;
        if !ks.is_ks_server_hello { error $ "not ks_server_hello" };
        let kse: KeyShareEntry = ks.as_ks_server_hello.@server_share;
        pure $ kse
    );
}

type AfterServerHello = unbox struct {
    protection: Protection,
    server_hello: ServerHello,
};

namespace AfterServerHello {




}

type ServerFinishedState = unbox struct {
    protection: Protection,
    server_hello: ServerHello,
};

namespace ServerFinishedState {
    make = |server_hello_state| (

    );

}


