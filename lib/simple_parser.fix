// simple parser
module SimpleParser;

import Debug;
import Character;
import StringEx;

type Char = U8;

_NEWLINE: Char;
_NEWLINE = 10_U8;

namespace Stream {
    type Stream = unbox struct {
        filename: String,
        line: I64,
        column: I64,
        position: I64,
        iter: Iterator Char
    };

    empty: Stream;
    empty = Stream{
        filename: "",
        line: 0,
        column: 0,
        position: 0,
        iter: Iterator::empty
    };
    
    advance: Stream -> Option (Char, Stream);
    advance = |s| (
        let (c, next) = *(s.@iter.advance);
        // eval debug_eprintln("advance: c="+c.to_string + " pos=" + s.@position.to_string);
        let s = s.set_iter(next);
        let s = if c == _NEWLINE {
            s.set_line(s.@line + 1).set_column(0)
        } else {
            s.set_column(s.@column + 1)
        };
        let s = s.set_position(s.@position + 1);
        pure $ (c, s)
    );

    read_all: Stream -> (Array Char, Stream);
    read_all = |s| (
        let arr = Array::empty(100);
        loop(
            (arr, s), |(arr, s)|
            let opt = s.advance;
            if opt.is_none {
                break $ (arr, s)
            };
            let (c, s) = opt.as_some;
            let arr = arr.push_back(c);
            continue $ (arr, s)
        )
    );

    error: String -> Stream -> Result ErrMsg a;
    error = |str, s| (
        let msg = 
            if s.@filename == "" { "" } else { s.@filename + " " } + 
            "line " + s.@line.to_string +
            ", column " + s.@column.to_string + 
            ": ";
        err $ msg + str
    );
}

impl Stream: FromString {
    from_string = |str| (
        pure $ Stream::empty.set_iter(str.get_bytes.pop_back.to_iter)
    );
}


type ParseResult a = Result ErrMsg (a, Stream);

impl [a: ToString] ParseResult a: ToString {
    to_string = |res| (
        if res.is_err {
            "err(" + res.as_err + ")"
        };
        let (c, s) = res.as_ok;
        "(" + c.to_string + ", pos=" + s.@position.to_string + ")"
    );
}

_NotMatch: ErrMsg;
_NotMatch = "NotMatch";


type Parser a = unbox struct { _parser: Stream -> ParseResult a };

parser: (Stream -> ParseResult a) -> Parser a;
parser = |f| Parser { _parser: f };

namespace Parser {
    run_parser: Stream -> Parser a -> ParseResult a;
    run_parser = |s, p| p.@_parser $ s;

    run_parser_str: String -> Parser a -> ParseResult a;
    run_parser_str = |str, p| 
        let s: Stream = *(from_string(str));
        p.run_parser(s);
}

impl Parser: Functor {
    map = |f, p| parser $ |s| (
        let (c, s) = *(p.run_parser(s));
        pure $ (f(c), s)
    );  
}

impl Parser: Monad {
    pure = |a| parser $ |s| ok $ (a, s);
    bind = |f, pa| parser $ |s| (
        eval debug_println("bind 1");
        let res = (pa.run_parser(s));
        eval debug_println("bind 2 " + if res.is_err { res.as_err } else { "ok" });
        let (a, s) = *res;
        eval debug_println("bind 3");
        let pb = f(a);
        eval debug_println("bind 4");
        let res = pb.run_parser(s);
        eval debug_println("bind 5");
        res
    );
}

namespace Parser {
    map_result: (a -> Result ErrMsg b) -> Parser a -> Parser b;
    map_result = |f, p| parser $ |s| (
            let (a, s) = *(p.run_parser(s));
            let res = f(a);
            if res.is_err {
                err $ res.as_err
            };
            ok $ (res.as_ok, s)
    );  

    debug_parser: (ParseResult a -> String) -> Parser a -> Parser a;
    debug_parser = |msg, p| parser $ |s| (
        let res = p.run_parser(s);
        eval debug_println(msg(res));
        res
    );
    debug: [a: ToString] String -> Parser a -> Parser a;
    debug = |msg, p| parser $ |s| (
        eval debug_println(msg + ": begin");
        let res = p.run_parser(s);
        eval debug_println(msg + ": end res=" + res.to_string);
        res
    );
    /*
    debug = |msg| (
        debug_parser $ |res| msg + ": res=" + res.to_string
    );
    */

    // Match zero-length string.
    unit: Parser ();
    unit = parser $ |s| pure $ ((), s);

    forget: Parser a -> Parser ();
    forget = |p| p.map(|_| ());

    keep_left: (a, b) -> a;
    keep_left = |(a,b)| a;

    keep_right: (a, b) -> b;
    keep_right = |(a,b)| b;

    keep_both: (a, b) -> (a, b);
    keep_both = |(a,b)| (a,b);

    drop_both: (a, b) -> ();
    drop_both = |(a,b)| ();

    // Combine two parsers. The result value is transformed by specified function.
    then: ((a, b) -> c) -> Parser b -> Parser a -> Parser c;
    then = |keep, pb, pa| parser $ |s| (
        let (a, s) = *(pa.run_parser(s));
        let (b, s) = *(pb.run_parser(s));
        pure $ (keep((a, b)), s)
    );

    // If the specified condition are not met, returns _NotMatch.
    filter: (a -> Bool) -> Parser a -> Parser a;
    filter = |f, p| parser $ |s| (
        let (c, next) = *(p.run_parser(s));
        if !f(c) {
            err $ _NotMatch
        };
        pure $ (c, next)
    );

    // if first parser (pa1) did not match (ie. not a syntax error), 
    // try second parser (pa2).
    or_else: Parser a -> Parser a -> Parser a;
    or_else = |pa2, pa1| parser $ |s| (
        let res = pa1.run_parser(s);
        if res.is_ok {
            pure $ res.as_ok
        };
        if res.as_err != _NotMatch {
            err $ res.as_err
        };
        pa2.run_parser(s)
    );

    or_error: String -> Parser a -> Parser a;
    or_error = |msg, p| parser $ |s| (
        let res = p.run_parser(s);
        if res.is_ok {
            pure $ res.as_ok
        };
        s.error(msg)
    );

    // Repeat matches as many as possible.
    repeat: Parser a -> Parser (Array a);
    repeat = |p| parser $ |s| (
        let array = Array::empty(100);
        loop(
            (array, s), |(array, s)|
            let old_position = s.@position;
            let res = p.run_parser(s);
            if res.is_err {
                break $ pure $ (array, s)
            };
            let (a, s) = res.as_ok;
            if s.@position == old_position {
                // Avoid infinite loop. (fool-proof)
                break $ pure $ (array, s)
            };
            let array = array.push_back(a);
            continue $ (array, s)
        )
    );

    zero_or_more: Parser a -> Parser (Array a);
    zero_or_more = repeat;

    one_or_more: Parser a -> Parser (Array a);
    one_or_more = |p| (
        repeat(p).filter(|array| array.get_size >= 1)
    );

    // Match zero-length string at the end of stream.
    match_end_of_stream: Parser ();
    match_end_of_stream = parser $ |s| (
        if s.advance.is_some {
            s.error("End of stream expected")
        };
        pure $ ((), s)
    );

    // Matches a character of any kind.
    any_char: Parser Char;
    any_char = parser $ |s| (
        s.advance.map_or(
            err $ _NotMatch,
            |(c, next)| pure $ (c, next)
        )
    );

    // Matches a character specified by `chr`.
    match_char: Char -> Parser Char;
    match_char = |chr| parser $ |s| (
        s.advance.map_or(
            err $ _NotMatch,
            |(c, next)| if c != chr { err $ _NotMatch } else { pure $ (c, next) }
        )
    );

    // Matches a character which is included in `str`.
    match_one_of_char: String -> Parser Char;
    match_one_of_char = |str| (
        any_char.filter(|c| str.find(c).is_some)
    );

    // Matches a string specified by `str`.
    match_str: String -> Parser String;
    match_str = |str| (
        if str.get_size == 1 { // Optimization
            let c = *(match_char(str.get_first_byte.as_some));
            pure $ [ c ]._unsafe_to_string
        };
        let parser: Parser () = str.get_bytes.pop_back.to_iter.fold(
            unit,
            |p, c|
            p.then(keep_left, match_char(c))
        );
        parser.map(|_| str)
    );

    // Matches a zero-or-more-length string. Each character should satisfy the specified condition.
    class: (Char -> Bool) -> Parser String;
    class = |f| (
        repeat(any_char.filter(f))
        .map(|array| array._unsafe_to_string)
    );

    class_whitespace: Parser String;
    class_whitespace = class(Character::is_space);
    
    class_lower: Parser String;
    class_lower = class(Character::is_lower);

    class_digit: Parser String;
    class_digit = class(Character::is_digit);

    integer: Parser I64;
    integer = (
        class_digit
        .filter(|str| str.get_size > 0)
        .map_result(|str| from_string(str))
    );
    
}

