module Main;

import AsyncTask;
import Random;

import Minilib.Collection.Deque;
import Minilib.Text.StringEx;

namespace Channel {
    type ChannelData a = unbox struct {
        deque: Deque a,
        closed: Bool
    };

    type Channel a = unbox struct {
        var: Var (ChannelData a)
    };

    // `Channel::make` creates a new channel.
    make: IO (Channel a);
    make = (
        let _ = *pure();        // make it lazy
        let chan_data = ChannelData {
            deque: Deque::empty(0),
            closed: false
        };
        let var = *Var::make(chan_data);
        pure $ Channel { var: var }
    );

    // `channel.close` closes a channel.
    close: Channel a -> IO ();
    close = |chan| (
        chan.@var.mod(set_shutdown(true))
    );

    // `channel.is_empty` checks whether the channel is closed.
    is_closed: Channel a -> IO Bool;
    is_closed = |chan| (
        let data = *chan.@var.get;
        pure $ data.@closed
    );

    // `channel.is_empty` checks whether the queue of the channel is empty.
    is_empty: Channel a -> IO Bool;
    is_empty = |chan| (
        let data = *chan.@var.get;
        pure $ data.@deque.is_empty
    );

    // `channel.send(a)` sends a data to a channel.
    // If the channel is closed, it throws `closed_error`.
    send: a -> Channel a -> IOFail ();
    send = |a, chan| (
        chan.@var.lock(
            |data|
            if data.@closed {
                pure $ err $ closed_error
            };
            let data = data.mod_deque(push_back(a));
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ ()
        ).lift.bind(from_result)
    );

    // `channel.recv` receives a data from a channel.
    // If there is no data, it waits until any data is sent, or the channel is closed.
    // If the channel is closed, it throws `closed_error`.
    recv: Channel a -> IOFail a;
    recv = |chan| (
        chan.@var.wait_and_lock(
            |data| data.@closed || !data.@deque.is_empty,
            |data|
            if data.@closed {
                pure $ err $ closed_error
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ a
        ).lift.bind(from_result)
    );

    // `channel.recv` tries to receive a data from a channel.
    // If there is no data, `none` is returned.
    // If the channel is closed, it throws `closed_error`.
    try_recv: Channel a -> IOFail (Option a);
    try_recv = |chan| (
        chan.@var.lock(
            |data|
            if data.@closed {
                pure $ err $ closed_error
            };
            if data.@deque.is_empty {
                pure $ ok $ none()
            };
            let a = data.@deque.get_front.as_some;
            let data = data.mod_deque(pop_front);
            let _ = *chan.@var.Var::set(data);
            pure $ ok $ some(a)
        ).lift.bind(from_result)
    );

    // An error message which is reported when the channel is closed.
    closed_error: ErrMsg;
    closed_error = "Closed";
}


type Future a = unbox struct {
    var: Var (Option a)
};

namespace Future {
    // `Future::make(pool, io) creates a Future.
    // `io` is performed in a task function of a TaskPool.
    make: TaskPool -> IO a -> IO (Future a);
    make = |pool, io| (
        let var = *Var::make(none());
        let io = (
            let a = *io;
            var.Var::set(some $ a)
        );
        let _ = *pool._send(io);
        pure $ Future {
            var: var
        }
    );

    // Gets the result of the Future.
    // If the `io` is not performed yet, wait until `io` is performed.
    get: Future a -> IO a;
    get = |future| (
        future.@var.wait_and_lock(
            is_some, as_some >> pure
        )
    );
}

type TaskPool = unbox struct {
    chan: Channel (IO ()),
    tasks: Array (IOTask ())
};

namespace TaskPool {

    // `TaskPool::make(task_count)` creates a TaskPool.
    make: I64 -> IO TaskPool;
    make = |task_count| (
        let chan = *Channel::make;
        let tasks = *loop_m(
            ([], 0), |(tasks, i)|
            if i >= task_count {
                break_m $ tasks 
            };
            let task = *AsyncIOTask::make(_task_func(chan));
            continue_m $ (tasks.push_back(task), i + 1)
        );
        pure $ TaskPool {
            chan: chan,
            tasks: tasks
        }
    );

    _send: IO () -> TaskPool -> IO ();
    _send = |io, pool| (
        pool.@chan.send(io)
        .try(eprintln)
    );

    // Shutdowns a taskpool.
    shutdown: TaskPool -> IO ();
    shutdown = |pool| (
        let _ = *pool.@chan.close;
        pool.@tasks.to_iter.fold_m(
            (), |_, task|
            task.get
        )
    );

    _task_func: Channel (IO ()) -> IO ();
    _task_func = |chan| (
        loop_m(
            (), |_|
            let io = *chan.recv;
            let _ = *io.lift;
            continue_m $ ()
        )
        .try(|err|
            if err == Channel::closed_error {
                pure()    
            };
            eprintln(err)
        )
    );
}


parallel_map_m: TaskPool -> (a -> IO b) -> Array a -> IO (Array b);
parallel_map_m = |pool, f, arr| (
    let tasks = *arr.to_iter.fold_m(
        [], |tasks, a|
        let task = *Future::make(pool, pure(a).bind(f));
        pure $ tasks.push_back(task)
    );
    tasks.to_iter.fold_m(
        [], |results, task|
        let result = *task.get;
        pure $ results.push_back(result)
    )
);


//---------------------------------------------------

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);

sleep_random: Var Random -> IO ();
sleep_random = |rand_var| (
    let u64 = *rand_var.lock(|rand|
        let (u64, rand) = rand.generate_U64;
        let _ = *rand_var.Var::set(rand);
        pure $ u64
    );
    eval _usleep((u64 % 500000_U64).to_I64);
    pure()
);

test1: IO ();
test1 = (
    let _ = *eprintln("start");
    let rand_var: Var Random = *Var::make(Random::init_by_seed(123_U64));
    let pool = *TaskPool::make(5);
    let arr: Array I64 = Iterator::range(0, 1000).to_array;
    let _ = *arr.parallel_map_m(pool, |i|
        let _ = *sleep_random(rand_var);
        eprintln(i.to_string)
    );
    let _ = *pool.shutdown;
    let _ = *eprintln("end");
    pure()
);

main: IO ();
main = (
    test1
);
