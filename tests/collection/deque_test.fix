module Main;

import Debug;

import Minilib.Collection.Deque;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Thread.Time;

test_get_size_ok: (Array I64, Array I64, I64) -> TestCase;
test_get_size_ok = |(front, back, expected)| (
    let testname = "test_get_size_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let actual = q.get_size;
    assert_equal("equal", expected, actual)
);

test_get_size: TestCase;
test_get_size = (
    [
        test_get_size_ok $ ([], [], 0),
        test_get_size_ok $ ([1], [], 1),
        test_get_size_ok $ ([2, 1], [], 2),
        test_get_size_ok $ ([], [3], 1),
        test_get_size_ok $ ([2, 1], [3], 3),
        TestCase::empty
    ]
    .run_tests
);

test_get_front_ok: (Array I64, Array I64, Option I64) -> TestCase;
test_get_front_ok = |(front, back, expected)| (
    let testname = "test_get_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let actual = q.get_front;
    assert_equal("equal", expected, actual)
);

test_get_front: TestCase;
test_get_front = (
    [
        test_get_front_ok $ ([], [], none()),
        test_get_front_ok $ ([1], [], some(1)),
        test_get_front_ok $ ([], [1], some(1)),
        test_get_front_ok $ ([2, 1], [], some(1)),
        test_get_front_ok $ ([], [1, 2], some(1)),
        test_get_front_ok $ ([1], [2], some(1)),
        TestCase::empty
    ]
    .run_tests
);

test_get_back_ok: (Array I64, Array I64, Option I64) -> TestCase;
test_get_back_ok = |(front, back, expected)| (
    let testname = "test_get_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let actual = q.get_back;
    assert_equal("equal", expected, actual)
);

test_get_back: TestCase;
test_get_back = (
    [
        test_get_back_ok $ ([], [], none()),
        test_get_back_ok $ ([1], [], some(1)),
        test_get_back_ok $ ([], [1], some(1)),
        test_get_back_ok $ ([2, 1], [], some(2)),
        test_get_back_ok $ ([], [1, 2], some(2)),
        test_get_back_ok $ ([1], [2], some(2)),
        TestCase::empty
    ]
    .run_tests
);

test_push_front_ok: ((Array I64, Array I64), I64, (Array I64, Array I64)) -> TestCase;
test_push_front_ok = |((front, back), value, (expected_front, expected_back))| (
    let testname = "test_push_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.push_front(value);
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_push_front: TestCase;
test_push_front = (
    [
        test_push_front_ok $ (([], []), 1, ([1], [])),
        test_push_front_ok $ (([2], []), 1, ([2, 1], [])),
        test_push_front_ok $ (([], [2]), 1, ([1], [2])),
        test_push_front_ok $ (([2], [3]), 1, ([2, 1], [3])),
        test_push_front_ok $ (([], [2, 3]), 1, ([1], [2, 3])),
        TestCase::empty
    ]
    .run_tests
);

test_push_front_many: TestCase;
test_push_front_many = (
    make_table_test("test_push_front_many",
        [
            (([], []), [], ([], [])),
            (([], []), [1, 2, 3], ([3, 2, 1], [])),
            (([4], []), [1, 2, 3], ([4, 3, 2, 1], [])),
            (([], [4]), [1, 2, 3], ([3, 2, 1], [4])),
            (([5, 4, 3], [6, 7]), [1, 2], ([5, 4, 3, 2, 1], [6, 7])),
        ],
        |((front, back), value, (expected_front, expected_back))|
        let q = Deque { front: front, back: back };
        let q = q.push_front_many(value);
        let _ = *assert_equal("front", expected_front, q.@front);
        let _ = *assert_equal("back", expected_back, q.@back);
        pure()
    )
);

test_push_back_ok: ((Array I64, Array I64), I64, (Array I64, Array I64)) -> TestCase;
test_push_back_ok = |((front, back), value, (expected_front, expected_back))| (
    let testname = "test_push_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.push_back(value);
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_push_back: TestCase;
test_push_back = (
    [
        test_push_back_ok $ (([], []), 1, ([], [1])),
        test_push_back_ok $ (([1], []), 2, ([1], [2])),
        test_push_back_ok $ (([], [1]), 2, ([], [1, 2])),
        test_push_back_ok $ (([1], [2]), 3, ([1], [2, 3])),
        test_push_back_ok $ (([], [1, 2]), 3, ([], [1, 2, 3])),
        TestCase::empty
    ]
    .run_tests
);

test_push_back_many: TestCase;
test_push_back_many = (
    make_table_test("test_push_back_many",
        [
            (([], []), [], ([], [])),
            (([], []), [1, 2, 3], ([], [1, 2, 3])),
            (([2, 1], []), [3, 4, 5], ([2, 1], [3, 4, 5])),
            (([], [1, 2]), [3, 4, 5], ([], [1, 2, 3, 4, 5])),
            (([3, 2, 1], [4, 5]), [6, 7], ([3, 2, 1], [4, 5, 6, 7])),
        ],
        |((front, back), value, (expected_front, expected_back))|
        let q = Deque { front: front, back: back };
        let q = q.push_back_many(value);
        let _ = *assert_equal("front", expected_front, q.@front);
        let _ = *assert_equal("back", expected_back, q.@back);
        pure()
    )
);


test_pop_front_ok: ((Array I64, Array I64), (Array I64, Array I64)) -> TestCase;
test_pop_front_ok = |((front, back), (expected_front, expected_back))| (
    let testname = "test_pop_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.pop_front;
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_pop_front: TestCase;
test_pop_front = (
    [
        test_pop_front_ok $ (([], []), ([], [])),
        test_pop_front_ok $ (([1], []), ([], [])),
        test_pop_front_ok $ (([], [1]), ([], [])),
        test_pop_front_ok $ (([2, 1], []), ([2], [])),
        test_pop_front_ok $ (([1], [2]), ([], [2])),
        test_pop_front_ok $ (([], [1, 2]), ([2], [])),
        test_pop_front_ok $ (([3, 2, 1], []), ([3, 2], [])),
        test_pop_front_ok $ (([2, 1], [3]), ([2], [3])),
        test_pop_front_ok $ (([1], [2, 3]), ([], [2, 3])),
        test_pop_front_ok $ (([], [1, 2, 3]), ([3, 2], [])),
        TestCase::empty
    ]
    .run_tests
);

test_pop_back_ok: ((Array I64, Array I64), (Array I64, Array I64)) -> TestCase;
test_pop_back_ok = |((front, back), (expected_front, expected_back))| (
    let testname = "test_pop_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.pop_back;
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_pop_front_many: TestCase;
test_pop_front_many = (
    make_table_test("test_pop_front_many",
        [
            (0, ([], []), ([], [], [])),
            (1, ([], []), ([], [], [])),
            (0, ([1], []), ([1], [], [])),
            (1, ([1], []), ([], [], [1])),
            (2, ([1], []), ([], [], [1])),
            (0, ([2, 1], []), ([2, 1], [], [])),
            (1, ([2, 1], []), ([2], [], [1])),
            (2, ([2, 1], []), ([], [], [1, 2])),
            (0, ([], [1]), ([], [1], [])),
            (1, ([], [1]), ([], [], [1])),
            (2, ([], [1]), ([], [], [1])),
            (0, ([], [1, 2]), ([], [1, 2], [])),
            (1, ([], [1, 2]), ([2], [], [1])),
            (2, ([], [1, 2]), ([], [], [1, 2])),
            (0, ([2, 1], [3, 4]), ([2, 1], [3, 4], [])),
            (1, ([2, 1], [3, 4]), ([2], [3, 4], [1])),
            (2, ([2, 1], [3, 4]), ([], [3, 4], [1, 2])),
            (3, ([2, 1], [3, 4]), ([4], [], [1, 2, 3])),
            (1, ([3, 2, 1], [4, 5]), ([3, 2], [4, 5], [1])),
            (2, ([3, 2, 1], [4, 5]), ([3], [4, 5], [1, 2])),
            (3, ([3, 2, 1], [4, 5]), ([], [4, 5], [1, 2, 3])),
            (4, ([3, 2, 1], [4, 5]), ([5], [], [1, 2, 3, 4])),
            (5, ([3, 2, 1], [4, 5]), ([], [], [1, 2, 3, 4, 5])),
            (6, ([3, 2, 1], [4, 5]), ([], [], [1, 2, 3, 4, 5])),
        ],
        |(max_count, (front, back), (expected_front, expected_back, expected_output))|
        let q = Deque { front: front, back: back };
        let (q, output) = q.pop_front_many(max_count);
        eval *assert_equal("front", expected_front, q.@front);
        eval *assert_equal("back", expected_back, q.@back);
        eval *assert_equal("output", expected_output, output);
        pure()
    )
);


test_pop_back: TestCase;
test_pop_back = (
    [
        test_pop_back_ok $ (([], []), ([], [])),
        test_pop_back_ok $ (([1], []), ([], [])),
        test_pop_back_ok $ (([], [1]), ([], [])),
        test_pop_back_ok $ (([2, 1], []), ([], [1])),
        test_pop_back_ok $ (([1], [2]), ([1], [])),
        test_pop_back_ok $ (([], [1, 2]), ([], [1])),
        test_pop_back_ok $ (([3, 2, 1], []), ([], [1, 2])),
        test_pop_back_ok $ (([2, 1], [3]), ([2, 1], [])),
        test_pop_back_ok $ (([1], [2, 3]), ([1], [2])),
        test_pop_back_ok $ (([], [1, 2, 3]), ([], [1, 2])),

        test_pop_front_ok $ (([], []), ([], [])),
        test_pop_front_ok $ (([1], []), ([], [])),
        test_pop_front_ok $ (([], [1]), ([], [])),
        test_pop_front_ok $ (([2, 1], []), ([2], [])),
        test_pop_front_ok $ (([1], [2]), ([], [2])),
        test_pop_front_ok $ (([], [1, 2]), ([2], [])),
        test_pop_front_ok $ (([3, 2, 1], []), ([3, 2], [])),
        test_pop_front_ok $ (([1], [2, 3]), ([], [2, 3])),
        test_pop_front_ok $ (([], [1, 2, 3]), ([3, 2], [])),
        TestCase::empty
    ]
    .run_tests
);

test_pop_back_many: TestCase;
test_pop_back_many = (
    make_table_test("test_pop_back_many",
        [
            (0, ([], []), ([], [], [])),
            (1, ([], []), ([], [], [])),
            (0, ([1], []), ([1], [], [])),
            (1, ([1], []), ([], [], [1])),
            (2, ([1], []), ([], [], [1])),
            (0, ([2, 1], []), ([2, 1], [], [])),
            (1, ([2, 1], []), ([], [1], [2])),
            (2, ([2, 1], []), ([], [], [1, 2])),
            (0, ([], [1]), ([], [1], [])),
            (1, ([], [1]), ([], [], [1])),
            (2, ([], [1]), ([], [], [1])),
            (0, ([], [1, 2]), ([], [1, 2], [])),
            (1, ([], [1, 2]), ([], [1], [2])),
            (2, ([], [1, 2]), ([], [], [1, 2])),
            (0, ([2, 1], [3, 4]), ([2, 1], [3, 4], [])),
            (1, ([2, 1], [3, 4]), ([2, 1], [3], [4])),
            (2, ([2, 1], [3, 4]), ([2, 1], [], [3, 4])),
            (3, ([2, 1], [3, 4]), ([], [1], [2, 3, 4])),
            (1, ([3, 2, 1], [4, 5]), ([3, 2, 1], [4], [5])),
            (2, ([3, 2, 1], [4, 5]), ([3, 2, 1], [], [4, 5])),
            (3, ([3, 2, 1], [4, 5]), ([], [1, 2], [3, 4, 5])),
            (4, ([3, 2, 1], [4, 5]), ([], [1], [2, 3, 4, 5])),
            (5, ([3, 2, 1], [4, 5]), ([], [], [1, 2, 3, 4, 5])),
            (6, ([3, 2, 1], [4, 5]), ([], [], [1, 2, 3, 4, 5])),
        ],
        |(max_count, (front, back), (expected_front, expected_back, expected_output))|
        let q = Deque { front: front, back: back };
        let (q, output) = q.pop_back_many(max_count);
        eval *assert_equal("front", expected_front, q.@front);
        eval *assert_equal("back", expected_back, q.@back);
        eval *assert_equal("output", expected_output, output);
        pure()
    )
);

test_reverse_array_ok: (Array I64, Array I64) -> TestCase;
test_reverse_array_ok = |(arr, expected)| (
    let testname = "test_reverse_array_ok (" + arr.to_string + ")";
    make_test(testname) $ |_|
    let actual = arr._reverse_array;
    assert_equal("equal", expected, actual)
);

test_reverse_array: TestCase;
test_reverse_array = (
    [
        test_reverse_array_ok $ ([], []),
        test_reverse_array_ok $ ([1], [1]),
        test_reverse_array_ok $ ([1, 2], [2, 1]),
        test_reverse_array_ok $ ([1, 2, 3], [3, 2, 1]),
        TestCase::empty
    ]
    .run_tests
);

test_perf_reverse_array: TestCase;
test_perf_reverse_array = (
    make_test("test_perf_push_pop_many") $ |_|
    let n = 1024 * 1024;
    let array = Array::from_map(n, |i| i.to_U8);
    let res = *timeit("_reverse_array", |_|
        let array = array._reverse_array;
        ()
    ).lift;
    pure()
);

test_move_back_elements_reversed: TestCase;
test_move_back_elements_reversed = (
    make_test("test_move_back_elements_reversed") $ |_|
    let n = 1024 * 1024;
    let array = Array::from_map(n, |i| i.to_U8);
    let res = *timeit("test_move_back_elements_reversed", |_|
        let (count, array, output) = _move_back_elements_reversed(n, array, Array::empty(n));
        ()
    ).lift;
    pure()
);


test_perf_push_pop_many: TestCase;
test_perf_push_pop_many = (
    make_test("test_perf_push_pop_many") $ |_|
    let n = 1024 * 1024;
    let array = Array::from_map(n, |i| i.to_U8);
    let res = *timeit_io(
        "n=" + n.to_string,
        do {
            eval *pure();
            let q = Deque::empty(n);
            let q = q.push_back_many(array);
        eval debug_eprintln("front=" + q.@front.get_size.to_string + " back=" + q.@back.get_size.to_string + " max_count=" + n.to_string);
            let (q, output) = q.pop_front_many(n);
        eval debug_eprintln("front=" + q.@front.get_size.to_string + " back=" + q.@back.get_size.to_string + " output=" + output.get_size.to_string);
            pure()
        }.to_result
    ).lift;
    pure()
);

main: IO ();
main = (
    [
        test_get_size,
        test_get_front,
        test_get_back,
        test_push_front,
        test_push_front_many,
        test_push_back,
        test_push_back_many,
        test_pop_front,
        test_pop_front_many,
        test_pop_back,
        test_pop_back_many,
        test_reverse_array,
        test_perf_push_pop_many,
        test_perf_reverse_array,
        test_move_back_elements_reversed,
        TestCase::empty
    ]
    .run_test_driver
);
