module Minilib.Crypto.Tls13.RandGen;

import Random;
import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Math.RandomEx;
import Minilib.Monad.State;
import Minilib.Monad.Trans;

trait RandGen = Functor + Monad + RandGenIF;

trait [m: * -> *] m: RandGenIF {
    randgen_bytes: I64 -> m (Array U8);
}

trait a: GetSetSecureRandom {
    get_secure_random: a -> SecureRandom;
    set_secure_random: SecureRandom -> a -> a;
}

impl [s: GetSetSecureRandom] StateT s IOFail: RandGenIF {
    randgen_bytes = |size| (
        let secure_random = *get_state.map(get_secure_random);
        let (bytes, secure_random) = *secure_random.generate_bytes(size).lift_t;
        eval *mod_state(set_secure_random(secure_random));
        pure $ bytes
    );
}

impl [m: Monad] StateT Random m: RandGenIF {
    randgen_bytes = |size| (
        let random = *get_state;
        let (bytes, random) = random.generate_array(size, generate_U8);
        eval *put_state(random);
        pure $ bytes
    );
}

// Constant RandGen
impl [m: Monad] StateT U8 m: RandGenIF {
    randgen_bytes = |size| (
        let u8 = *get_state;
        pure $ Array::fill(size, u8)
    );
}
