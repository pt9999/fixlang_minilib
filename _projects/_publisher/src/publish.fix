module Publisher.Publish;

import Minilib.IO.Errno;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;

import Publisher.Common;
import Publisher.ProcessRunner;
import Publisher.ConsoleUi;
import Publisher.Fs;
import Publisher.ProjectFile;

log_message: [m: MonadIO] String -> m ();
log_message = |str| println(str).lift_io;

namespace GitTask {

    check_branch_name: [m: MonadRunProcess, m: MonadError] String -> m ();
    check_branch_name = |expected| (
        log_message((expected,).format("### Checking if the current branch name is `{}`"));;
        let (stdout, stderr) = *run_process_quietly(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
        let actual = stdout.strip_spaces;
        if actual != expected {
            error $ (expected, actual).format("The current branch name is not `{}`: actual = `{}`")
        };
        pure()
    );

    check_uncommitted_files: [m: MonadRunProcess, m: MonadError] m ();
    check_uncommitted_files = (
        log_message("### Checking for uncommitted files");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only"]);
        if stdout != "" {
            error $ "Uncommitted file exists"
        };
        pure()
    );

    no_commit_since_latest:  [m: MonadRunProcess] m Bool;
    no_commit_since_latest = (
        log_message("### Checking if there is any commit from the latest release");;
        let (stdout, stderr) = *run_process(["git", "diff", "--name-only", C::tag_latest]);
        if stdout == "" {
            pure $ true
        };
        pure $ false
    );

    reset_fixdeps_lock:  [m: MonadRunProcess] m ();
    reset_fixdeps_lock = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", C::fixdeps_lock]);
        pure()
    );

    commit_fixdeps_lock: [m: MonadRunProcess] m ();
    commit_fixdeps_lock = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", C::fixdeps_lock]);
        if stdout == "" { pure() };
        log_message("### Commit fixdeps.lock");;
        let (stdout, stderr) = *run_process(["git", "add", "--", C::fixdeps_lock]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update deps", "--", C::fixdeps_lock]);
        pure()
    );

    commit_documents: [m: MonadRunProcess] m ();
    commit_documents = (
        let (stdout, stderr) = *run_process_quietly(["git", "diff", "--name-only", "--", C::dir_docs]);
        if stdout == "" { pure() };
        log_message("### Commit documents");;
        let (stdout, stderr) = *run_process(["git", "add", "--", C::dir_docs]);
        let (stdout, stderr) = *run_process(["git", "commit", "-m", "update documents", "--", C::dir_docs]);
        pure()
    );

    reset_documents: [m: MonadRunProcess] m ();
    reset_documents = (
        let (stdout, stderr) = *run_process(["git", "checkout", "--", C::dir_docs]);
        pure()
    );

    commit_fixproj_toml: [m: MonadRunProcess] PublishArgs -> Path -> String -> m ();
    commit_fixproj_toml = |args, filepath, version| (
        log_message("### Commit the project file");;
        let (stdout, stderr) = *run_process(["git", "add", "--verbose", "--", filepath]);
        let message = "version " + version;
        let (stdout, stderr) = *run_process(["git", "commit", "--verbose", "-m", message]);
        when(args.@tag, do {
            log_message("### Make a version tag");;
            let (stdout, stderr) = *run_process(["git", "tag", version]);
            let (stdout, stderr) = *run_process(["git", "tag", C::tag_latest, "-f"]);
            pure()
        });;
        when(args.@push, do {
            log_message("### Push to the remote repository");;
            let (stdout, stderr) = *run_process(["git", "push", C::remote_origin]);
            pure()
        });;
        when(args.@push && args.@tag, do {
            log_message("### Push tags to the remote repository");;
            let (stdout, stderr) = *run_process(["git", "push", C::remote_origin, version]);
            let (stdout, stderr) = *run_process(["git", "push", C::remote_origin, C::tag_latest, "-f"]);
            pure()
        });;
        pure()
    );
}

namespace ProjectTask {
    check_if_file_exists: [m: MonadFs] Path -> m ();
    check_if_file_exists = |filepath| (
        if ! *fs_file_exists(filepath) {
            error $ "File not found: " + filepath
        };
        pure()
    );

    check_if_directory_exists: [m: MonadFs] Path -> m ();
    check_if_directory_exists = |dirpath| (
        if ! *fs_directory_exists(dirpath) {
            error $ "Directory not found: " + dirpath
        };
        pure()
    );

    run_fix_clean: [m: MonadRunProcess] m ();
    run_fix_clean = (
        log_message("### Clean");;
        let (stdout, stderr) = *run_process(["fix", "clean"]);
        pure()
    );

    run_fix_deps_update: [m: MonadRunProcess] m ();
    run_fix_deps_update = (
        log_message("### Update deps");;
        let (stdout, stderr) = *run_process(["fix", "deps", "update"]);
        pure()
    );

    run_fix_test: [m: MonadRunProcess] m ();
    run_fix_test = (
        log_message("### Run tests");;
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "basic"]);
        let (stdout, stderr) = *run_process(["fix", "test", "-O", "max"]);
        pure()
    );

    run_fix_docs: [m: MonadRunProcess] m ();
    run_fix_docs = (
        log_message("### Generate documents");;
        let (stdout, stderr) = *run_process(["fix", "docs", "-o", C::dir_docs]);
        pure()
    );
}


type PublishArgs = unbox struct {
    subproject_dir: Path,
    new_version: Option String,
    confirm: Bool,
    commit: Bool,
    push: Bool,
    tag: Bool,
    update_documents: Bool,
};

namespace PublishArgs {
    empty: PublishArgs;
    empty = PublishArgs {
        subproject_dir: "",
        new_version: none(),
        confirm: false,
        commit: false,
        push: false,
        tag: false,
        update_documents: false,
    };

    update_realpath: [m: MonadFs] PublishArgs -> m PublishArgs;
    update_realpath = |args| (
        let args = *args.act_subproject_dir(fs_realpath);
        pure $ args
    );
}

do_publish: [m: MonadConsoleUi, m: MonadFs, m: MonadRunProcess, m: MonadError] PublishArgs -> m ();
do_publish = |args| (
    let args = *args.update_realpath;
    
    let subproject_dir = args.@subproject_dir;
    log_message("### Chdir to `" + subproject_dir + "`");;
    fs_chdir(subproject_dir);;

    // `.git` is a directory in a standalone Git repository.
    // `.git` is a file in a submodule of a Git repository.
    let git_dir = C::dir_git;
    check_if_directory_exists(git_dir).catch(|errmsg|
        check_if_file_exists(git_dir)
    );;

    let project_file_path = C::fixproj_toml;
    check_if_file_exists(project_file_path);;

    check_branch_name(C::branch_main);;
    check_uncommitted_files;;
    if *no_commit_since_latest {
        log_message("### No commit since latest, so only run tests with the latest dependencies");;
        run_fix_clean;;
        run_fix_deps_update;;
        run_fix_test;;
        run_fix_docs;;
        reset_fixdeps_lock;;
        reset_documents;;
        log_message("### No need to publish");;
        pure()
    };

    run_fix_clean;;
    run_fix_deps_update;;
    run_fix_test;;
    run_fix_docs;;
    reset_documents;;

    log_message("### Update the project file");;
    let new_version = *upgrade_project_version(project_file_path, args.@new_version, args.@confirm);

    commit_fixdeps_lock;;

    when(args.@update_documents, do {
        run_fix_docs;;
        commit_documents
    });;
    when(args.@commit && new_version != "",
        commit_fixproj_toml(args, project_file_path, new_version));;
    pure()
);

