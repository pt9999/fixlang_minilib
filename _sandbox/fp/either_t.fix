module Minilib.Functor.EitherT;

import Minilib.Trait.Traversable;

type [f: * -> *, g: * -> *] EitherT f g a = unbox union {
    left: f a,
    right: g a,
};

impl [f: Functor, g: Functor] EitherT f g: Functor {
    map = |h, ea| (
        match ea {
            left(fa) => left(fa.map(h)),
            right(ga) => right(ga.map(h)),
        }
    );
}

impl [f: Traversable, g: Traversable] EitherT f g: Traversable {
    sequence = |ema| (
        match ema {
            left(fma) => fma.sequence.bind(left >> pure),
            right(gma) => gma.sequence.bind(right >> pure),
        }
    );
}

/*
impl [m: Monad, n: Monad, m: Traversable, n: Traversable] EitherT m n: Monad {
    // pure(a) becomes right
    pure = |a| right(pure(a));

    bind = |f, ea| (
        match ea {
            left(ma) => left(ma.bind(f)),       // type error: ma.bind(f), since f: a -> EitherT m n b, not a -> m b
            right(na) => right(na.bind(f)),
        }
    );
}
*/
