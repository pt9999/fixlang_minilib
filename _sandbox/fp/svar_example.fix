module Main;

import Minilib.Monad.State;
import Minilib.Monad.IO;
import Minilib.Trait.Traversable;

//--------------------------
type Z = unbox struct {
    d: Array I64,
    q: Array I64,
};

type SIO = StateT Z IO;

test_svar: IO ();
test_svar = (
    println("=== test_svar ===");;
    let inf = 1e18;
    let n = 30;
    let z = Z {
        d: Array::fill(n, inf),
        q: []
    };
    z.eval_state_t $ do {
        //let d: Array (SVar Z SIO I64) = Array::from_map(n, |i| SVar::make(|z: Z| z[^d][i]));
        //let q: SVar Z SIO (Array I64) = SVar::make(|z: Z| z[^q]);
        let d = Array::from_map(n, |i| SVar::make(|z| z[^d][i]));
        let q = SVar::make(|z| z[^q]);
        let bfs = |f, q| loop_m(
            (), |_|
            match (*q.get).get_last {
                none() => break_m(),
                some(v) => q.mod(pop_back);; f(v).map(continue)
            }
        );
        d.@(0).SVar::set(0);;
        q.mod(push_back(0));;
        q.bfs(|v|
            let u = v + 1;
            when(u < n) $ do {
                let dv = *d.@(v).get;
                d.@(u).mod(min(dv + 1));;
                q.mod(push_back(u))
            }
        );;
        println((*d.map_m(get)).to_string).lift_io;;
        pure()
    }
);

/*
//------------------------------------------------------
// インデックス構文を使うためのhack. あまり綺麗じゃない

type SStore c a = ((a -> Result a a) -> Result a c);

type SAct s c a = unbox struct {
    svar_c: SVar s c,
    act_a: c -> SStore c a
};

impl [c: Indexable] SVar s c : Indexable {
    type Elem (SVar s c) = SAct s c (Elem c);
    type Index (SVar s c) = Index c;
//    act_at_index : [f : Functor] Index c -> (Elem c -> f (Elem c)) -> c -> f c;
    act_at_index = |idx, f, svar_c| (
        let sa = SAct {
            svar_c: svar_c,
            act_a: |c, f| c[idx].iact(f)
        };

        let fsa = f(sa);
        fsa.map(|sa|
            svar_c
        )
    );
}

namespace SStore {

//     sget: [c:Indexable, Elem c = a, m: MonadState, StateType m = s]
//         SStore (SVar s c) (SAct s c a) -> m a;
//     sget = |store_sa| (
//         let s = *get_state;
//         let sa: SAct s c a = store_sa(|sa| err(sa)).as_err;
//         let SAct { svar_c: svar_c, act_a: act_a } = sa;
//         let act_c: s -> SStore s c = svar_c.@data;
//         let store_c = act_c(s);
//         let a = store_c(|c:c|
//             let a = act_a(c, |a:a| err(a): Result a a).as_err;
//             err(a): Result c c  // ここでは Result c c を返す必要があるが、Result a c しか返せない
//         ).as_err;
//         pure $ a
//     );

    smod: [c:Indexable, Elem c = a, m: MonadState, StateType m = s]
        (a -> a) -> SStore (SVar s c) (SAct s c a) -> m ();
    smod = |f, store_sa| (
        mod_state_(|s|
            let sa: SAct s c a = store_sa(|sa| err(sa)).as_err;
            let SAct { svar_c: svar_c, act_a: act_a } = sa;
            let act_c: s -> SStore s c = svar_c.@data;
            let store_c = act_c(s);
            let s = store_c(|c:c| 
                let c = act_a(c, |a:a| ok(f(a)): Result a a).as_ok;
                ok(c): Result c c
            ).as_ok;
            s
        )
    );

    sset: [c:Indexable, Elem c = a, m: MonadState, StateType m = s]
        a -> SStore (SVar s c) (SAct s c a) -> m ();
    sset = |a, store_sa| (
        store_sa.smod(|_| a)
    );
}

test_sidx: IO ();
test_sidx = (
    println("=== test_sidx ===");;
    let inf = 1e18;
    let n = 30;
    let z = Z {
        d: Array::fill(n, inf),
        q: []
    };
    z.eval_state_t $ do {
        let d = SVar::make(|z| z[^d]);
        let q = SVar::make(|z| z[^q]);
        let bfs = |f, q| loop_m(
            (), |_|
            match (*q.get).get_last {
                none() => break_m(),
                some(v) => q.mod(pop_back);; f(v).map(continue)
            }
        );
        d[0].sset(0);;
        q.mod(push_back(0));;
        q.bfs(|v|
            let u = v + 1;
            when(u < n) $ do {
                //let dv = *(d[v].sget);
                let dv = (*d.get).@(v);
                d[u].smod(min(dv + 1));;
                q.mod(push_back(u))
            }
        );;
        println((*d.get).to_string).lift_io;;
        pure()
    }
);
*/

main: IO () = (
    test_svar;;
    //test_sidx;;
    //main2;;
    pure()
);

type S = unbox struct { a: I64 };

main2: IO ();
main2 = (
   eval_state_t(S{ a: 123 }) $ do {
     let s = SVar::whole_state;
     println("a=" + (*s.get).@a.to_string).lift_io;;
     let v = SVar::make(|s| s[^a]);
     let a = *v.get;
     println("a=" + a.to_string).lift_io;;
     v.SVar::set(456);;
     println("a=" + (*v.get).to_string).lift_io;;
     v.mod(|a| a + 78);;
     println("a=" + (*v.get).to_string).lift_io
   }
);
