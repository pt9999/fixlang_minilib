// RFC 8017 - PKCS #1: RSA Cryptography Specifications Version 2.2
//
// https://tex2e.github.io/rfc-translater/html/rfc8017.html
// https://datatracker.ietf.org/doc/html/rfc8017
module Minilib.Crypto.Cert.Pkcs1;

import Debug;

import Minilib.Encoding.Binary;
import Minilib.Math.Modular;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Types;
import Minilib.Text.Hex;
import Minilib.Crypto.SHA1;
import Minilib.Crypto.SHA256;
import Minilib.Crypto.SHA512;

// 4. Data Conversion Primitives

// I2OSP - Integer-to-Octet-String primitive
// x: nonnegative integer to be converted
// xlen: intended length of the resulting octet string
i2osp: BigInt -> I64 -> Result ErrMsg (Array U8);
i2osp = |x, xlen| (
    if x.is_negative {
        err $ "integer is negative"
    };
    if x >= one.BigInt::shift_left((xlen * 8).to_U64) {
        err $ "integer too large"
    };
    let nat = x.@nat._remove_last_zeros;
    let u32_len = nat.get_size;
    let u8_len = xlen;
    let bytes = Array::fill(u8_len, 0_U8);
    let bytes = Iterator::range(0, u32_len).fold(
        bytes, |bytes, i|
        bytes.set_u32_be(u8_len - (i + 1) * 4, nat.@(i))    // big endian
    );
    ok $ bytes
);

// OS2IP - Octet-String-to-Integer primitive
os2ip: Array U8 -> Result ErrMsg BigInt;
os2ip = FromBytes::from_bytes;

// 5. Cryptographic Primitives

// 5.2.2. RSAVP1
// Input: (n, e) RSA public key
//        s signature representative, an integer between 0 and n - 1
// Output: m message representative, an integer between 0 and n - 1
// Error: "signature representative out of range"

rsavp1: (BigInt, BigInt) -> BigInt -> Result ErrMsg BigInt;
rsavp1 = |(n, e), s| (
    if s.is_negative || s >= n {
        err $ "signature representative out of range"
    };
    // Let m = s^e mod n.
    let m: Modular BigInt = repeat_by_BigInt(mul, one, Modular::make(s, n), e);
    let m: BigInt = m.@value;
    pure $ m
);

// 8. Signature Scheme with Appendix

// 8.1.  RSASSA-PSS
// 8.1.2.  Signature Verification Operation
// RSASSA-PSS-VERIFY ((n, e), M, S)

// Input: (n, e)  signer's RSA public key
//        M       message whose signature is to be verified, an octet string
//        S       signature to be verified, an octet string of length k,
//                  where k is the length in octets of the RSA modulus n
// Output: "valid signature" or "invalid signature"
rsassa_pss_verify: (BigInt, BigInt) -> Array U8 -> Array U8 -> EmsaPssOptions -> Result ErrMsg ();
rsassa_pss_verify = |(n, e), _M, _S, options| (
    // 1. Length checking: If the length of the signature S is not k octets, output "invalid signature" and stop.
    let k = (n.bit_length.to_I64 + 7) / 8;
    if _S.get_size != k { err $ "invalid signature" };
    // 2. RSA verification:
    //    a. Convert the signature S to an integer signature representative s (see Section 4.2):
    let s: BigInt = *os2ip(_S);
    //    b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e)
    //       and the signature representative s to produce an integer message representative m:
    let m = *rsavp1((n, e), s);
    //    c.  Convert the message representative m to an encoded message EM of length
    //        emLen = \ceil ((modBits - 1)/8) octets, where modBits is the length in bits of
    //        the RSA modulus n (see Section 4.1):
    let modBits = n.bit_length.to_I64;
    let emLen = ((modBits - 1) + 7) / 8;
    let _EM = *i2osp(m, emLen);
    eval assert(|_| "unexpected: (emLen, k, modBits)=" + (emLen, k, modBits).to_string,
            if (modbits - 1) % 8 == 0 { emLen == k - 1 } else { emLen == k });
    // 3.  EMSA-PSS verification: Apply the EMSA-PSS verification operation (Section 9.1.2)
    //     to the message M and the encoded message EM to determine whether they are consistent:
    emsa_pss_verify(_M, _EM, modBits - 1, options)
);

// 8.2. RSASSA-PKCS1-v1_5
// RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)
// Input: (n, e) signer's RSA public key
//        M message whose signature is to be verified, an octet string
//        S signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n
// Output: "valid signature" or "invalid signature"
// Errors: "message too long"; "RSA modulus too short"
rsassa_pkcs1_v1_5_verify: (BigInt, BigInt) -> Array U8 -> Array U8 -> EmsaPkcs1Options -> Result ErrMsg ();
rsassa_pkcs1_v1_5_verify = |(n, e), _M, _S, options| (
    // 1. Length checking: If the length of the signature S is not k octets, output "invalid signature" and stop.
    //let n_bytes = n.to_bytes;
    //let k = n_bytes.get_size;
    let k = (n.bit_length.to_I64 + 7) / 8;
    if _S.get_size != k { err $ "invalid signature" };
    // 2. RSA verification:
    //    a. Convert the signature S to an integer signature representative s (see Section 4.2):
    let s: BigInt = *os2ip(_S);
    //    b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e)
    //       and the signature representative s to produce an integer message representative m:
    let m = *rsavp1((n, e), s);
    //    c. Convert the message representative m to an encoded message EM of length k octets (see Section 4.1):
    let _EM = *i2osp(m, k);
    // 3. EMSA-PKCS1-v1_5 encoding:
    //    Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2)
    //    to the message M to produce a second encoded message EM' of length k octets:
    let _EM_dash = *emsa_pkcs1_v1_5_encode(_M, k, options);
    // 4. Compare the encoded message EM and the second encoded message EM'.
    //    If they are the same, output "valid signature"; otherwise, output "invalid signature".
    if _EM != _EM_dash { err $ "invalid signature" };
    ok()
);

// 9. Encoding Methods for Signatures with Appendix
// 9.1. EMSA-PSS
// 9.1.2. Verification Operation
// Options:
//  Hash hash function (hLen denotes the length in octets of the hash function output)
//  MGF mask generation function
//  sLen intended length in octets of the salt
// Input:
//  M        message to be verified, an octet string
//  EM       encoded message, an octet string of length emLen = \ceil(emBits/8)
//  emBits   maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen + 8sLen + 9
// Output:
//  "consistent" or "inconsistent"
emsa_pss_verify: Array U8 -> Array U8 -> I64 -> EmsaPssOptions -> Result ErrMsg ();
emsa_pss_verify = |_M, _EM, em_bits, options| (
    let EmsaPssOptions {
        hash: hash,
        hlen: hlen,
        mgf: mgf,
        slen: slen
    } = options;
    // TODO: check the input limitation for the hash function (2^61 - 1 octets for SHA-1)
    //if _M.get_size >= 1.shift_left(61) - 1 { err $ "inconsistent" };
    let mHash = hash(_M);
    let em_len = (em_bits + 7) / 8;
    if em_len < hlen + slen + 2 {
        err $ "inconsistent"
    };
    if _EM.get_size == 0 || _EM.@(_EM.get_size - 1) != 0xbc_U8 {
        err $ "inconsistent"
    };
    let maskedDB = _EM.subarray(0, em_len - hlen - 1);
    let _H = _EM.subarray(em_len - hlen - 1, em_len - 1);
    let k = 8 * em_len - em_bits;
    eval assert(|_| "k out of range", 0 <= k && k < 8);
    let kmask = 0xFF_U8.shift_left((8-k).to_U8);
    if _EM.@(0).bit_and(kmask) != 0_U8 {
        eval debug_eprintln("_EM.@(0)=" + _EM.@(0).to_string_hex + " k=" + k.to_string);
        err $ "inconsistent"
    };
    let dbMask = mgf(_H, em_len - h_len - 1, hash, hlen);
    eval assert(|_| "maskedDB and dbMask size unmatch", maskedDB.get_size == dbMask.get_size);
    let _DB = Array::from_map(maskedDB.get_size, |i| maskedDB.@(i).bit_xor(dbMask.@(i)));
    let _DB = _DB.mod(0, bit_and(0xFF_U8.bit_xor(kmask)));
    let is_all_zeros = Iterator::range(0, em_len - hlen - slen - 2)
                    .filter(|i| _DB.@(i) != 0_U8).is_empty;
    if !is_all_zeros {
        eval debug_eprintln("_DB=" + _DB.to_string_hex);
        err $ "inconsistent"
    };
    if _DB.@(em_len - hlen - slen - 1) != 0x01_U8 {
        err $ "inconsistent"
    };
    let salt = _DB.subarray(_DB.get_size - slen, _DB.get_size);
    let _M_dash = Array::fill(8, 0_U8).append(mHash).append(salt);
    let _H_dash = hash(_M_dash);
    if _H != _H_dash {
        err $ "inconsistent"
    };
    ok()    // consistent
);

type EmsaPssOptions = unbox struct {
    hash: Array U8 -> Array U8,     // hash function
    hlen: I64,                      // the length in octets of the hash function output
    mgf: MaskGenerationFunction,    // mask generation function
    slen: I64,                      // intended length in octets of the salt
};

emsa_pss_options_sha256: EmsaPssOptions;
emsa_pss_options_sha256 = EmsaPssOptions {
    hash: SHA256::digest,
    hlen: 32,
    mgf: mgf1,
    slen: 32,
};

emsa_pss_options_sha384: EmsaPssOptions;
emsa_pss_options_sha384 = EmsaPssOptions {
    hash: SHA384::digest,
    hlen: 48,
    mgf: mgf1,
    slen: 48,
};

emsa_pss_options_sha512: EmsaPssOptions;
emsa_pss_options_sha512 = EmsaPssOptions {
    hash: SHA512::digest,
    hlen: 64,
    mgf: mgf1,
    slen: 64,
};

// 9.2. EMSA-PKCS1-v1_5
// EMSA-PKCS1-v1_5-ENCODE (M, emLen)
// Option: Hash hash function (hLen denotes the length in octets of the hash function output)
// Input:  M        message to be encoded
//           emLen    intended length in octets of the encoded message, at
//               least tLen + 11, where tLen is the octet length of the
//               Distinguished Encoding Rules (DER) encoding T of
//               a certain value computed during the encoding operation
// Output: EM       encoded message, an octet string of length emLen
// Errors:  "message too long"; "intended encoded message length too short"
emsa_pkcs1_v1_5_encode: Array U8 -> I64 -> EmsaPkcs1Options -> Result ErrMsg (Array U8);
emsa_pkcs1_v1_5_encode = |_M, emlen, options| (
    // 1.  Apply the hash function to the message M to produce a hash value H:
    let _H: Array U8 = (options.@hash)(_M);
    // 2.  Encode the algorithm ID for the hash function and the hash
    // value into an ASN.1 value of type DigestInfo (see
    // Appendix A.2.4) with the DER
    let _T: Array U8 = options.@der_encoding.append(_H);
    let tlen = _T.get_size;
    // 3.  If emLen < tLen + 11, output "intended encoded message length too short" and stop.
    if emlen < tlen + 11 {
        err $ "intended encoded message length too short"
    };
    // 4.  Generate an octet string PS consisting of emLen - tLen - 3
    //     octets with hexadecimal value 0xff.  The length of PS will be
    //     at least 8 octets.
    let _PS = Array::fill(emlen - tlen - 3, 0xFF_U8);
    // 5.  Concatenate PS, the DER encoding T, and other padding to form
    //     the encoded message EM as
    let _EM = [0x00_U8, 0x01_U8].append(_PS).append([0x00_U8]).append(_T);
    pure $ _EM
);


type EmsaPkcs1Options = unbox struct {
    hash: Array U8 -> Array U8,
    der_encoding: Array U8,         // see "Notes 1" of "9.2. EMSA-PKCS1-v1_5"
};

emsa_pkcs1_options_sha1: EmsaPkcs1Options;
emsa_pkcs1_options_sha1 = EmsaPkcs1Options {
    hash: SHA1::digest,
    der_encoding: "30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha256: EmsaPkcs1Options;
emsa_pkcs1_options_sha256 = EmsaPkcs1Options {
    hash: SHA256::digest,
    der_encoding: "30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha384: EmsaPkcs1Options;
emsa_pkcs1_options_sha384 = EmsaPkcs1Options {
    hash: SHA384::digest,
    der_encoding: "30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha512: EmsaPkcs1Options;
emsa_pkcs1_options_sha512 = EmsaPkcs1Options {
    hash: SHA512::digest,
    der_encoding: "30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40".from_string_hex.as_ok,
};

// B.2. Mask Generation Functions
// B.2.1. MGF1

type MaskGenerationFunction = Array U8 -> I64 -> (Array U8 -> Array U8) -> I64 -> Result ErrMsg (Array U8);

mgf1: MaskGenerationFunction;
mgf1 = |mgf_seed, mask_len, hash, hlen| (
    if mask_len >= 1.shift_left(32) * hlen {
        err $ "mask too long"
    };
    let _T = Array::empty(0);
    let n = (mask_len + hlen - 1) / hlen;
    let _T = Iterator::range(0, n).fold(_T, |_T, counter|
        let _C = i2osp(BigInt::from_I64(counter), 4);
        let _T = _T.append(hash(mgf_seed.append(_C)));
        _T
    );
    ok $ _T.subarray(0, mask_len)
);
