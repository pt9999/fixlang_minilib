module Main;

type Number = U8;   // 1..9, 0=empty

namespace Number {
    empty: Number;
    empty = 0_U8;
}

type Grid = unbox struct {
    data: Array Number
};

namespace Grid {
    empty: Grid;
    empty = Grid {
        data: Array::fill(9 * 9, Number::empty)
    };

    get_num: I64 -> I64 -> Grid -> Number;
    get_num = |row, col, grid| grid.@data.@(row * 9 + col);

    set_num: I64 -> I64 -> Number -> Grid -> Grid;
    set_num = |row, col, num, grid| grid.mod_data(set(row * 9 + col, num));

    to_diag: I64 -> I64 -> Option I64;
    to_diag = |row, col| (
        if row == col { some(0) };
        if row == 8 - col { some(1) };
        none()
    );

    to_block: I64 -> I64 -> I64;
    to_block = |row, col| (
        (row / 3) * 3 + (col / 3)
    );
}

// Read a grid from a string. The format is like this:
// ```
// 1..2..3..
// .4...5..6
// ..7.8..9.
// ```
impl Grid: FromString {
    from_string = |lines| (
        let grid = Grid::empty;
        let filter_chars = |f, str| (
            str.get_bytes.pop_back.to_iter.filter(f).to_array.push_back(0_U8)._unsafe_from_c_str
        );
        let lines = lines.split("\n").map(
            filter_chars(|c| ('1' <= c && c <= '9') || c == '.')
        ).filter(|s| s != "").to_array;
        if lines.get_size != 9 { err $ "invalid row size" };
        Iterator::range(0, 9).fold_m(grid, |grid, row|
            let line = lines.@(row);
            if line.get_size != 9 { err $ "invalid col size" };
            Iterator::range(0, 9).fold_m(grid, |grid, col|
                let c = line.get_bytes.@(col);
                let num = if '1' <= c && c <= '9' { (c - '1' + 1_U8) } else { Number::empty };
                let grid = grid.set_num(row, col, num);
                pure $ grid
            )
        )
    );
}

impl Grid: ToString {
    to_string = |grid| (
        Iterator::range(0, 9).map(|row|
            Iterator::range(0, 9).map(|col|
                let num = grid.get_num(row, col);
                if num == Number::empty { '.' } else { num - 1_U8 + '1' }
            ).to_array.push_back(0_U8)._unsafe_from_c_str
        ).join("\n")
    );
}

type BitVec = U16;
namespace BitVec {
    empty: BitVec;
    empty = 0_U16;

    get: I64 -> BitVec -> Bool;
    get = |i, vec| vec.bit_and(1_U16.shift_left(i.to_U16)) != 0_U16;

    set: I64 -> Bool -> BitVec -> BitVec;
    set = |i, b, vec| (
        if b { vec.bit_or(1_U16.shift_left(i.to_U16)) }
        else { vec.bit_and(U16::maximum - 1_U16.shift_left(i.to_U16)) } 
    );
}

type Occupy = Array BitVec; // row(9), col(9), diag(2), block(9) = 29
namespace Occupy {
    empty: Occupy;
    empty = Array::fill(29, BitVec::empty);

    get_row: I64 -> Occupy -> BitVec;
    get_row = |row, oc| oc.@(row);

    mod_row: I64 -> (BitVec -> BitVec) -> Occupy -> Occupy;
    mod_row = |row, f, oc| oc.mod(row, f);

    get_col: I64 -> Occupy -> BitVec;
    get_col = |col, oc| oc.@(col + 9);

    mod_col: I64 -> (BitVec -> BitVec) -> Occupy -> Occupy;
    mod_col = |col, f, oc| oc.mod(col + 9, f);

    get_diag: I64 -> Occupy -> BitVec;
    get_diag = |diag, oc| oc.@(diag + 18);

    mod_diag: I64 -> (BitVec -> BitVec) -> Occupy -> Occupy;
    mod_diag = |diag, f, oc| oc.mod(diag + 18, f);

    get_block: I64 -> Occupy -> BitVec;
    get_block = |block, oc| oc.@(block + 20);

    mod_block: I64 -> (BitVec -> BitVec) -> Occupy -> Occupy;
    mod_block = |block, f, oc| oc.mod(block + 20, f);
}


type Board = unbox struct {
    grid: Grid,
    occupy: Occupy,    
    size: I64                 // occupied number count
};

namespace Board {
    empty: Board;
    empty = Board {
        grid: Grid::empty,
        occupy: Occupy::empty,
        size: 0
    };
}

test_grid1: String;
test_grid1 = "
    53..7....
    6..195...
    .98....6.
    8...6....
    4..8.3..1
    7...2...6
    .6....28.
    ...419..5
    ....8..79
";

test1: IO ();
test1 = do {
    let grid: Grid = *from_string(test_grid1).from_result;
    println(grid.to_string).lift
}.try(eprintln);

main: IO ();
main = test1;
