module Main;

import Minilib.Common.Common;
import Minilib.Common.IOEx;
import Minilib.Monad.Cont;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Monad.Trans;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

type [cm: * -> *] Label cm a b = box struct {
    // the argument of a jump
    arg: a,
    // current continuation of a jump
    cc: Label cm a b -> cm b
};

namespace Label {
    make: [cm: MonadCont] a -> cm (Label cm a b);
    make = |arg| (
        call_cc(|cc| pure $ Label { arg: arg, cc: cc })
    );

    jump: [cm: MonadCont] a -> Label cm a b -> cm b;
    jump = |arg, label| (
        (label.@cc)(label.set_arg(arg))
    );
}

test_label: TestCase;
test_label = (
    make_test("test_label") $ |_|
    let cont: ContT () IOFail () = do {
        let label = *Label::make(0);
        print(label.@arg.to_string + "> ").lift.lift_t;;
        let str = *read_line(IO::stdin).lift_t;
        let str = str.strip_last_newlines;
        if (str == "") { pure() };
        println(str).lift.lift_t;;
        label.jump(label.@arg + 1)
    };
    cont.run_cont_t(|_| pure())
);

// `postpone(g)` adds `g` as a postprocess function of `r`.
// Note that `postpone(f);; postpone(g)` is equivalent to `postpone(g >> f)`.
postpone: [m: Monad] (r -> r) -> ContT r m ();
postpone = |g| (
    cont_t $ |f: () -> m r| f().bind(g >> pure)
);

test_postpone: TestCase;
test_postpone = (
    make_test("test_postpone") $ |_|
    let cont: ContT (Array String) IOFail (Array String) = do {
        //postpone(reverse);;
        postpone(push_back("third"));;
        postpone(push_back("second"));;
        pure $ [ "first" ]
    };
    let arr = *cont.run_cont_t(|arr| pure $ arr);
    println(arr.to_string).lift
);

// Exits the continuation. The following part is ignored.
// The argument of `run_cont_t` is also ignored.
// Note that if you call `postpone` before `exit_cont`, the postponed functions will be executed.
exit_cont: [m: Monad] r -> ContT r m ();
exit_cont = |r| (
    cont_t $ |f: () -> m r| pure $ r
);

test_exit_cont: TestCase;
test_exit_cont = (
    make_test("test_exit_cont") $ |_|
    let cont: ContT (Array String) IOFail (Array String) = do {
        postpone(push_back("third"));;
        exit_cont $ [ "aborted" ];;
        postpone(push_back("second"));;
        pure $ [ "first" ]
    };
    let arr = *cont.run_cont_t(|arr| pure $ arr);
    println(arr.to_string).lift
);

test_loan_pattern1: TestCase;
test_loan_pattern1 = (
    make_test("test_loan_pattern1") $ |_|
    eval_cont_t $ do {
        let handle = *with_file("tmp.test.tmp", "w").cont_t;
        write_string(handle, "hello").lift_iofail
    };;
    eval_cont_t $ do {
        let handle = *with_file("tmp.test.tmp", "r").cont_t;
        let content = *read_string(handle).lift_iofail;
        assert_equal("eq", "hello", content)
    }
);

mutate_boxed_io_2: [a : Std::Boxed] (Std::Ptr -> Std::IO (a, b)) -> a -> Std::IO (a, b);
mutate_boxed_io_2 = |f, a| (
    a.mutate_boxed_io(f >> map(Tuple2::@1))
);

test_loan_pattern2: TestCase;
test_loan_pattern2 = (
    make_test("test_loan_pattern2") $ |_|
    let src = "abcde".get_bytes.pop_back;
    let dest = "-----".get_bytes.pop_back;
    let size = 5;
    let cm: ContT (Array U8, ()) IO (Array U8, ()) = do {
        let p_dest = *dest.flip(mutate_boxed_io_2).cont_t;
        let p_src = *src.flip(borrow_boxed_io).cont_t;
        FFI_CALL_IO[Ptr memcpy(Ptr, Ptr, CSizeT), p_dest, p_src, size.to_CSizeT].lift_io;;
        pure $ ([], ())
    };
    let (dest, ()) = *cm.eval_cont_t.lift;
    let dest = dest._unsafe_to_string;
    assert_equal("eq", "abcde", dest)
);

reset_t: [m: Monad] ContT r m r -> ContT rr m r;
reset_t = eval_cont_t >> lift_t;

reset: [m: Monad] Cont r r -> Cont rr r;
reset = eval_cont >> pure;

shift_t: [m: Monad] ((a -> m r) -> ContT r m r) -> ContT r m a;
shift_t = |f| (f >> eval_cont_t).cont_t;

shift: [m: Monad] ((a -> r) -> Cont r r) -> Cont r a;
shift = |f: ((a -> r) -> ContT r Iden r)| (
    let h: (a -> Iden r) -> (a -> r) = |ff, a| ff(a).Iden::get;
    let g: (a -> Iden r) -> Iden r = (h >> f >> eval_cont_t);
    g.cont_t
);

// TODO: test_reset_shift

main: IO ();
main = (
    set_unbuffered_mode(stdout);;
    [
        test_postpone,
        test_exit_cont,
        //test_label,
        test_loan_pattern1,
        test_loan_pattern2,
    ]
    .run_test_driver
);

/*
type [cm: * -> *] LabelPair cm a b = box struct {
    label0: Label cm a b,
    label1: Label cm a b,
    code: I64,
};

coroutine0: [cm: MonadCont] LabelPair cm a b -> cm (LabelPair cm a b);
coroutine0 = |lp| (
    eval debug_eprintln("coroutine0 a");
    let lp = lp.set_code(0);
    let label0 = *Label::make(lp);
    let lp = label0.@arg;
    let lp = lp.set_label0(label0);
    if lp.@code == 0 {
        pure $ lp
    };
    if lp.@code < 1 {
        lp.@label1.jump(lp)
    };
    eval debug_eprintln("coroutine0 b");
    let lp = lp.set_code(2);
    let label0 = *Label::make(lp);
    let lp = label0.@arg;
    let lp = lp.set_label0(label0);
    if lp.@code == 2 {
        pure $ lp
    };
    if lp.@code < 3 {
        lp.@label1.jump(lp)
    };
    eval debug_eprintln("coroutine0 c");
    pure $ lp
);

coroutine1: [cm: MonadCont] LabelPair cm a b -> cm (LabelPair cm a b);
coroutine1 = |lp| (
    eval debug_eprintln("coroutine1 a");
    let lp = lp.set_code(1);
    let label1 = *Label::make(lp);
    let lp = label1.@arg;
    let lp = lp.set_label1(label1);
    if lp.@code == 1 {
        pure $ lp
    };
    if lp.@code < 2 {
        lp.@label0.jump(lp)
    };
    eval debug_eprintln("coroutine1 b");
    let lp = lp.set_code(3);
    let label1 = *Label::make(lp);
    let lp = label1.@arg;
    let lp = lp.set_label1(label1);
    if lp.@code == 3 {
        pure $ lp
    };
    if lp.@code < 4 {
        lp.@label0.jump(lp)
    };
    eval debug_eprintln("coroutine1 c");
    pure $ lp
);
*/
