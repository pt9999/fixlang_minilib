module Filer.Service.DiskUsage;

import HashMap;
import AsyncTask;
import Minilib.Common.Assert;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Monad.State;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Thread.Channel;
import Minilib.Thread.TaskPool;
import Minilib.Thread.Future;
import Minilib.Trait.Traversable;

import Filer.Common;

/*
log_debug: [m: MonadIOFail] String -> m ();
log_debug = |str| lift_iofail $ do {
    with_file("disk_usage.log", "a+", |handle|
        write_string(handle, str + "\n")
    )
};
*/

namespace DiskUsageServiceApi {
    mock_api: IOFail DiskUsageServiceApi;
    mock_api = pure $ DiskUsageServiceApi {
        get_dir_size: |path| pure $ (123, 1),
        drain_errors: pure $ [],
        shutdown: pure(),
    };

    real_api: IOFail DiskUsageServiceApi;
    real_api = do {
        pure();;
        let service = *DiskUsageService::make;
        pure $ DiskUsageServiceApi {
            get_dir_size: |path| service.get_dir_size(path),
            drain_errors: service.drain_errors,
            shutdown: service.shutdown,
        }
    };
}

type DiskUsageService = unbox struct {
    task_pool: TaskPool,
    req_chan: Channel DuRequest,
    error_chan: Channel String,
    manager_task: IOTask (Result ErrMsg DuManager),
};

namespace DiskUsageService {
    make: [m: MonadIOFail] m DiskUsageService;
    make = lift_iofail $ do {
        let task_pool = *TaskPool::make(number_of_processors);
        let env = *DuManagerEnv::real_env(task_pool);
        let manager = *DuManager::make(env);
        let manager_task = *AsyncIOTask::make(manager.run).lift;
        pure $ DiskUsageService {
            task_pool: task_pool, 
            req_chan: env.@req_chan,
            error_chan: env.@error_chan, 
            manager_task: manager_task,
        }
    };

    get_dir_size: [m: MonadIOFail] Path -> DiskUsageService -> m (I64, I64);
    get_dir_size = |path, service| (
        let req = DuGetSizeRequest {
            dir_path: path,
            res_chan: *Channel::make
        };
        service.@req_chan.send(req_get_size $ req);;
        let res = *req.@res_chan.recv;
        pure $ (res.@size, res.@active)
    );

    drain_errors: [m: MonadIOFail] DiskUsageService -> m (Array String);
    drain_errors = |service| (
        loop_m(
            [], |errors|
            match *service.@error_chan.try_recv {
                none() => break_m $ errors,
                some(err) => continue_m $ errors.push_back(err)
            }
        )
    );

    shutdown: [m: MonadIOFail] DiskUsageService -> m ();
    shutdown = |service| lift_iofail $ do {
        let DiskUsageService { 
            task_pool: task_pool, 
            req_chan: req_chan,
            error_chan: error_chan, 
            manager_task: manager_task
        } = service;
        req_chan.send(req_shutdown());;
        let res: Result ErrMsg DuManager = *manager_task.get.lift_io;
        task_pool.shutdown;;
        pure()
    };
}


// directory size
type DirSize = I64;

// st_dev, st_ino
//type DevIno = (I64, I64);

type DuNodeIndex = I64;

namespace DuNodeIndex {
    invalid: DuNodeIndex;
    invalid = -1;
}

type DuNode = unbox struct {
    path: String,
    //stat: Option FileStat,
    size: DirSize,
    active: I64,    // -1:not checked 0: check complete, 1~: check in progress
    parent: DuNodeIndex,
};

namespace DuNode {
    empty: DuNode;
    empty = DuNode {
        path: "",
        //stat: none(),
        size: 0,
        active: -1,
        parent: DuNodeIndex::invalid,
    };
}

type DuNodeMap = unbox struct {
    path_to_index: HashMap String DuNodeIndex,
    nodes: Array DuNode,
};

namespace DuNodeMap {
    empty: DuNodeMap;
    empty = DuNodeMap {
        path_to_index: HashMap::empty(10),
        nodes: []
    };

    get_node: DuNodeIndex -> DuNodeMap -> DuNode;
    get_node = |index, self| (
        self[^nodes][index].iget
    );

    mod_node: DuNodeIndex -> (DuNode -> DuNode) -> DuNodeMap -> DuNodeMap;
    mod_node = |index, f, self| (
        self[^nodes][index].imod(f)
    );

    _assert_abs_path_lazy: Path -> Lazy a -> a;
    _assert_abs_path_lazy = |path, lazy| (
        assert_lazy(|_| "not an absolute path: " + path, path.starts_with("/")) $ lazy
    );

    get_node_index_by_path: Path -> DuNodeMap -> (DuNodeMap, DuNodeIndex);
    get_node_index_by_path = |path, self| (
        _assert_abs_path_lazy(path) $ |_|
        let opt = self.@path_to_index.find(path);
        if opt.is_some {
            (self, opt.as_some)
        };
        
        let parent_path = dirname(path);
        let (self, parent) = if parent_path == path { 
            (self, DuNodeIndex::invalid) 
        } else {
            self.get_node_index_by_path(parent_path) 
        };

        let node = DuNode::empty;
        let node = node.set_path(path).set_parent(parent);
        let index = self.@nodes.@size;
        let self = self[^nodes].imod(push_back(node));
        let self = self[^path_to_index].imod(insert(path, index));
        (self, index)
    );

    get_node_by_path: Path -> DuNodeMap -> (DuNodeMap, DuNode);
    get_node_by_path = |path, self| (
        let (self, index) = self.get_node_index_by_path(path);
        let node = self.get_node(index);
        (self, node)
    );

    add_size_by_path: Path -> DirSize -> DuNodeMap -> (DuNodeMap, ());
    add_size_by_path = |path, size, self| (
        let (self, index) = self.get_node_index_by_path(path);
        self.add_size_recursive(index, size)
    );

    add_size_recursive: DuNodeIndex -> DirSize -> DuNodeMap -> (DuNodeMap, ());
    add_size_recursive = |index, size, self| (
        if index == DuNodeIndex::invalid { (self, ()) };
        let self = self[^nodes][index][^size].imod(add(size));
        let parent = self[^nodes][index][^parent].iget;
        self.add_size_recursive(parent, size)
    );

    add_active_by_path: Path -> I64 -> DuNodeMap -> (DuNodeMap, ());
    add_active_by_path = |path, diff, self| (
        let (self, index) = self.get_node_index_by_path(path);
        self.add_active_recursive(index, diff)
    );

    add_active_recursive: DuNodeIndex -> I64 -> DuNodeMap -> (DuNodeMap, ());
    add_active_recursive = |index, diff, self| (
        if index == DuNodeIndex::invalid { (self, ()) };
        let old_value = self[^nodes][index][^active].iget;
        let old_value = max(0, old_value);
        let new_value = max(0, old_value + diff);
        let self = self[^nodes][index][^active].iset(new_value);
        let parent = self[^nodes][index][^parent].iget;
        if old_value == 0 && new_value > 0 { self.add_active_recursive(parent, 1) }
        else if new_value == 0 && old_value > 0 { self.add_active_recursive(parent, -1) }
        else { (self, ()) }
    );
}


type DuGetSizeRequest = unbox struct {
    dir_path: Path,
    res_chan: Channel DuGetSizeResponse,
};

type DuGetSizeResponse = unbox struct {
    size: I64,
    active: I64,
};

type DuRequest = unbox union {
    req_get_size: DuGetSizeRequest,
    req_worker_result: DuWorkerResult,
    req_shutdown: (),
};

type DuManagerEnv = unbox struct {
    req_chan: Channel DuRequest,
    error_chan: Channel String,
    start_worker: Path -> IOFail (),
};

namespace DuManagerEnv {
    real_env: [m: MonadIO] TaskPool -> m DuManagerEnv;
    real_env = |task_pool| (
        let req_chan = *Channel::make;
        let error_chan = *Channel::make;
        pure $ DuManagerEnv {
            req_chan: req_chan,
            error_chan: error_chan,
            start_worker: |path| (
                let worker = DuWorker {
                    env: DuWorkerEnv::real_env,
                    dir_path: path,
                    req_chan: req_chan,
                    error_chan: error_chan,
                };
                let future = *Future::make(task_pool, worker.run);
                pure()
            ),
        }
    );
}

type DuManager = box struct {
    env: DuManagerEnv,
    node_map: DuNodeMap,
};

namespace DuManager {
    make: [m: MonadIO] DuManagerEnv -> m DuManager;
    make = |env| (
        pure $ DuManager {
            env: env,
            node_map: DuNodeMap::empty,
        }
    );

    run: DuManager -> IO (Result ErrMsg DuManager);
    run = |self| run_loop.exec_state_t(self).to_result;

    run_loop: StateT DuManager IOFail ();
    run_loop = loop_m(
        (), |_|
        let ret = *run_step;
        if !ret { break_m() };
        continue_m()
    );

    run_step: StateT DuManager IOFail Bool;
    run_step = do {
        let env = *gets(DuManager::@env);
        let req = *env.@req_chan.recv;
        match req {
            req_shutdown() => pure $ false,
            req_get_size(req) => on_req_get_size(req);; pure $ true,
            req_worker_result(res) => on_req_worker_result(res);; pure $ true,
            _ => error $ "unknown request",
        }
    }.catch(|errmsg|
        //log_debug("err:" + errmsg);;
        let env = *gets(DuManager::@env);
        env.@error_chan.send(errmsg);;
        pure $ true
    );

    lift_node_map: (DuNodeMap -> (DuNodeMap, a)) -> StateT DuManager IOFail a;
    lift_node_map = |f| (
        lens_state_t(act_node_map) $ state_t $ f >> pure
    );

    on_req_get_size: DuGetSizeRequest -> StateT DuManager IOFail ();
    on_req_get_size = |req| (
        let env = *gets(DuManager::@env);
        let dir_path = req.@dir_path;
        start_worker_if_unchecked(dir_path);;
        let node = *lift_node_map(get_node_by_path(dir_path));
        req.@res_chan.send(DuGetSizeResponse {
            size: node.@size,
            active: node.@active,
        })
    );

    start_worker_if_unchecked: Path -> StateT DuManager IOFail ();
    start_worker_if_unchecked = |dir_path| (
        let node = *get_node_by_path(dir_path).lift_node_map;
        if node.@active >= 0 { pure() };
        //log_debug("start_worker: path=" + dir_path);;
        let env = *gets(DuManager::@env);
        (env.@start_worker)(dir_path).lift_iofail;;
        add_active_by_path(dir_path, 1).lift_node_map
    );

    on_req_worker_result: DuWorkerResult -> StateT DuManager IOFail ();
    on_req_worker_result = |res| (
        let env = *gets(DuManager::@env);
        let DuWorkerResult { dir_path: dir_path, dir_size: dir_size, subdirs: subdirs } = res;
        //log_debug("end_worker: path=" + dir_path);;
        subdirs.to_iter.foreach_m(|subdir_path|
            start_worker_if_unchecked(subdir_path)
        );;
        add_size_by_path(dir_path, dir_size).lift_node_map;;
        add_active_by_path(dir_path, -1).lift_node_map
    );
}

type DuWorkerFileStat = unbox struct {
    size: I64,
    is_directory: Bool,
};

type DuWorkerEnv = unbox struct {
    list_dir: Path -> IOFail (Array String),
    lstat: Path -> IOFail DuWorkerFileStat,
};

namespace DuWorkerEnv {
    real_env: DuWorkerEnv;
    real_env = DuWorkerEnv {
        list_dir: FileSystem::list_dir,
        lstat: |path| (
            let stat = *FileSystem::FileStat::lstat(path);
            pure $ DuWorkerFileStat {
                size: stat.st_size,
                is_directory: stat.is_dir,
            }
        ),
    };
}

type DuWorkerResult = unbox struct {
    dir_path: Path,
    dir_size: I64,
    subdirs: Array Path,
};

type DuWorker = unbox struct {
    env: DuWorkerEnv,
    dir_path: Path,
    req_chan: Channel DuRequest,
    error_chan: Channel String,
};

namespace DuWorker {
    run: DuWorker -> IO ();
    run = |self| pure();; do {
        let env = self.@env;
        let file_names = *(env.@list_dir)(self.@dir_path);
        let file_paths = file_names.map(|name| [self.@dir_path, name].join_paths);
        let file_stats = *file_paths.to_iter.map(env.@lstat).collect_m;
        let dir_size = file_stats.to_iter.map(@size).fold(0, add);
        let subdirs = file_paths.to_iter.zip(file_stats.to_iter)
        .filter(|(path, stat)| stat.@is_directory)
        .map(|(path, stat)| path)
        .to_array;
        let res = DuWorkerResult {
            dir_path: self.@dir_path,
            dir_size: dir_size,
            subdirs: subdirs,
        };
        self.@req_chan.send(req_worker_result $ res)
    }
    .try(|errmsg|
        self.@error_chan.send(errmsg).try(eprintln)
    );
}
