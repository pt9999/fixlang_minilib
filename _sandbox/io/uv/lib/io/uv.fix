module Minilib.IO.Uv;

import Minilib.Monad.IO;
import Minilib.Monad.Iden;

log_debug: String -> ();
//log_debug = |str| debug_eprintln("\u001b[035m[Minilib.IO.Uv]\u001b[m " + str);
log_debug = |str| ();

//-----------------------------------------------------------------
// MonadBorrow
//-----------------------------------------------------------------

trait MonadBorrow = Monad + MonadBorrowIF;

trait [m: * -> *] m: MonadBorrowIF {
    borrow_boxed_m: [a: Boxed] (Ptr -> m b) -> a -> m b;
    borrow_m: (a -> m b) -> Destructor a -> m b;
    borrow_c_str_m: (Ptr -> m b) -> String -> m b;
    mutate_boxed_m: [a: Boxed] (Ptr -> m b) -> a -> m (a, b);
}

impl Iden: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed(f >> Iden::get) >> Iden::make;
    borrow_m = |f| borrow(f >> Iden::get) >> Iden::make;
    borrow_c_str_m = |f| borrow_c_str(f >> Iden::get) >> Iden::make;
    mutate_boxed_m = |f| mutate_boxed(f >> Iden::get >> pure) >> Iden::make;
}

impl IO: MonadBorrowIF {
    borrow_boxed_m = borrow_boxed_io;
    borrow_m = borrow_io;
    borrow_c_str_m = borrow_c_str_io;
    mutate_boxed_m = mutate_boxed_io;
}

impl IOFail: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed_io(f >> to_result) >> from_io_result;
    borrow_m = |f| borrow_io(f >> to_result) >> from_io_result;
    borrow_c_str_m =  |f| borrow_c_str_io(f >> to_result) >> from_io_result;
    mutate_boxed_m = |f, a| (
        let (a, res_b) = *a.mutate_boxed_io(f >> to_result).lift;
        let b = *res_b.from_result; // may throw
        pure $ (a, b)
    );
}

//-----------------------------------------------------------------
// FromPtr, BorrowPtrM
//-----------------------------------------------------------------

trait a: FromPtr {
    from_ptr: [m: MonadIO] Ptr -> m a;
}

trait a: BorrowPtrM {
    borrow_ptr_m: [m: MonadBorrow] (Ptr -> m b) -> a -> m b;
}

//-----------------------------------------------------------------
// UvPtrWithOwnership
//-----------------------------------------------------------------

type UvPtrWithOwnership = unbox union {
    owned: Destructor Ptr,
    borrowed: Ptr,
};

namespace UvPtrWithOwnership {
    make_owned: Ptr -> (Ptr -> IO Ptr) -> IO UvPtrWithOwnership;
    make_owned = |ptr, dtor| (
        pure $ owned $ *Destructor::make(ptr, dtor)
    );

    make_borrowed: Ptr -> UvPtrWithOwnership;
    make_borrowed = borrowed;
}

impl UvPtrWithOwnership: Eq {
    eq = |a, b| (
        a.borrow_ptr_m(|pa|
            b.borrow_ptr_m(|pb|
                pure $ pa == pb
            )
        )
        .Iden::get
    );
}

impl UvPtrWithOwnership: BorrowPtrM {
    borrow_ptr_m = |f, wrapped_ptr| (
        match wrapped_ptr {
            owned(dtor) => dtor.borrow_m(f),
            borrowed(ptr) => f(ptr),
        }
    );
}

//-----------------------------------------------------------------
// Error Handling
//-----------------------------------------------------------------

namespace Uv {
    strerror: CInt -> String;
    strerror = |err| (
        let buflen = 65536;
        let buf = Array::fill(buflen, 0_U8);
        let (buf, ()) = buf.mutate_boxed(|buf|
            FFI_CALL_IO[() uv_strerror_r(CInt, Ptr, CSizeT), err, buf, buflen.to_CSizeT]
        );
        let errmsg: String = buf.push_back(0_U8).from_bytes.as_ok;
        errmsg
    );

    eof: CInt;
    eof = FFI_CALL[CInt minilib_uv_get_uv_eof()];
}

_check_err_i: IO CInt -> IOFail CInt;
_check_err_i = |io| (
    let err = *io.lift;
    if err >= 0.to_CInt {
        pure $ err
    };
    throw $ Uv::strerror(err)
);

_check_err: IO CInt -> IOFail ();
_check_err = |io| (
    let err = *io._check_err_i;
    pure()
);

//-----------------------------------------------------------------
// UvLoop
//-----------------------------------------------------------------

type UvLoop = unbox struct {
    wptr: UvPtrWithOwnership
};

namespace UvLoop {
    // Creates and initializes an event loop.
    make: [m: MonadIOFail] m UvLoop;
    make = lift_iofail $ do {
        let ptr = *FFI_CALL_IO[Ptr minilib_uv_loop_init()].lift;
        if ptr == nullptr { throw $ "uv_loop_init failed!" };
        pure $ UvLoop {
            wptr: *UvPtrWithOwnership::make_owned(ptr, |ptr|
                FFI_CALL_IO[() minilib_uv_loop_close(Ptr), ptr].when(ptr != nullptr);;
                pure $ nullptr
            ).lift
        }
    };

    // Gets the default event loop.
    default: [m: MonadIO] m UvLoop;
    default = lift_io $ do {
        let p_loop = *FFI_CALL_IO[Ptr uv_default_loop()];
        from_ptr(p_loop)
    };

    // Runs the event loop until there are no more active and referenced handles or requests. 
    run_default: [m: MonadIOFail] UvLoop -> m ();
    run_default = |loop| lift_iofail $ do {
        loop.borrow_ptr_m(|p_loop|
            _check_err $ FFI_CALL_IO[CInt minilib_uv_loop_run_default(Ptr), p_loop]
        )
    };

    // Stops the event loop.
    stop: [m: MonadIO] UvLoop -> m ();
    stop = |loop| lift_io $ do {
        loop.borrow_ptr_m(|p_loop|
            FFI_CALL_IO[() uv_stop(Ptr), p_loop]
        )
    };
}

impl UvLoop: Eq {
    eq = |a, b| a.@wptr == b.@wptr;
}

impl UvLoop: FromPtr{
    from_ptr = |p_loop| lift_io $ do {
        pure $ UvLoop {
            wptr: UvPtrWithOwnership::make_borrowed $ p_loop
        }
    };
}

impl UvLoop: BorrowPtrM {
    borrow_ptr_m = |f, loop| loop.@wptr.borrow_ptr_m(f);
}

//-----------------------------------------------------------------
// UvHandle
//-----------------------------------------------------------------

// t はハンドルの種類を表す任意のタグ。(Phantom type)
type UvHandle t = unbox struct {
    dtor: Destructor Ptr
};

impl UvHandle t: FromPtr {
    from_ptr = |p_handle| lift_io $ do {
        pure $ UvHandle {
            dtor: *Destructor::make(p_handle, |p_handle|
                // ハンドルはループで管理されるため、破棄しない
                pure $ nullptr
            )
        }
    };
}

impl UvHandle t: BorrowPtrM {
    borrow_ptr_m = |f, handle| handle.@dtor.borrow_m(f);
}

namespace UvHandle {
    // ハンドルをクローズする。ハンドルはループの実行前あるいは実行中に必ずクローズする必要がある。
    close: [m: MonadIO] UvHandle t -> m ();
    close = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            FFI_CALL_IO[() minilib_uv_handle_close(Ptr), p_handle]
        )
    };

    get_loop: [m: MonadIO] UvHandle t -> m UvLoop;
    get_loop = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            // TODO: should implement minilib_uv_handle_get_loop?
            let p_loop = *FFI_CALL_IO[Ptr uv_handle_get_loop(Ptr), p_handle];
            from_ptr(p_loop)
        )
    };

    is_started: [m: MonadIO] UvHandle t -> m Bool;
    is_started = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            FFI_CALL_IO[CInt minilib_uv_is_started(Ptr), p_handle]
        ).map(|ret| ret != 0.to_CInt)
    };

    // ユーザが用意したコールバック関数を設定する。型を正しく合わせる必要がある。
    set_user_callback: [m: MonadIO] cb -> UvHandle t -> m ();
    set_user_callback = |cb, handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            let box_cb: Box cb = Box::make(cb);
            let p_cb: Ptr = *box_cb.boxed_to_retained_ptr;
            eval log_debug("UvHandle::set_user_callback: p_cb=" + p_cb.to_string);
            FFI_CALL_IO[() minilib_uv_handle_set_fix_cb(Ptr, Ptr), p_handle, p_cb]
        )
    };

    // ユーザが用意したコールバック関数を取得する。型を正しく合わせる必要がある。
    get_user_callback: [m: MonadIO] UvHandle t -> m cb;
    get_user_callback = |handle| lift_io $ do {
        handle.borrow_ptr_m(|p_handle|
            let p_cb = *FFI_CALL_IO[Ptr minilib_uv_handle_get_fix_cb(Ptr), p_handle];
            eval log_debug("UvHandle::get_user_callback: p_cb=" + p_cb.to_string);
            let box_cb: Box cb = *p_cb.boxed_from_retained_ptr;
            pure $ box_cb.@value
        )
    };
}

//-----------------------------------------------------------------
// UvReq
//-----------------------------------------------------------------

// リクエスト(uv_req_t)を表す型。
// t はリクエストの種類を表す任意のタグ。(Phantom type)
type UvReq t = unbox struct {
    dtor: Destructor Ptr
};

impl UvReq t: FromPtr {
    from_ptr = |p_req| lift_io $ do {
        FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req];;
        pure $ UvReq {
            dtor: *Destructor::make(p_req, |p_req|
                FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req];;
                pure $ nullptr
            )
        }
    };
}

impl UvReq t: BorrowPtrM {
    borrow_ptr_m = |f, req| req.@dtor.borrow_m(f);
}

namespace UvReq {
    // uv_req_t* の参照カウンタを1増加する。
    retain: [m: MonadIO] UvReq t -> m ();
    retain = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req])
    };

    // uv_req_t* の参照カウンタを1減少する。参照カウンタが0になったら解放される。
    release: [m: MonadIO] UvReq t -> m ();
    release = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req])
    };

    // ユーザが用意したコールバック関数を設定し、retainする。型を正しく合わせる必要がある。
    set_user_callback: [m: MonadIO] cb -> UvReq t -> m ();
    set_user_callback = |cb, req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            let box_cb: Box cb = Box::make(cb);
            let p_cb: Ptr = *box_cb.boxed_to_retained_ptr;
            eval log_debug("UvReq::set_user_callback: p_cb=" + p_cb.to_string);
            FFI_CALL_IO[() minilib_uv_req_set_fix_cb(Ptr, Ptr), p_req, p_cb]
        )
    };

    // ユーザが用意したコールバック関数を取得し、releaseする。型を正しく合わせる必要がある。
    get_user_callback: [m: MonadIO] UvReq t -> m cb;
    get_user_callback = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            let p_cb = *FFI_CALL_IO[Ptr minilib_uv_req_get_fix_cb(Ptr), p_req];
            eval log_debug("UvReq::get_user_callback: p_cb=" + p_cb.to_string);
            let box_cb: Box cb = *p_cb.boxed_from_retained_ptr;
            pure $ box_cb.@value
        )
    };

    // 追加データを設定する。
    set_extra_data: [m: MonadIO] Ptr -> UvReq t -> m ();
    set_extra_data = |extra_data, req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            FFI_CALL_IO[() minilib_uv_req_set_extra_data(Ptr, Ptr), p_req, extra_data]
        )
    };

    // 追加データを取得する。
    get_extra_data: [m: MonadIO] UvReq t -> m Ptr;
    get_extra_data = |req| lift_io $ do {
        req.borrow_ptr_m(|p_req|
            FFI_CALL_IO[Ptr minilib_uv_req_get_extra_data(Ptr), p_req]
        )
    };
}

//-----------------------------------------------------------------
// UvFile
//-----------------------------------------------------------------

// ファイルディスクリプタ(uv_file)を表す型。
type UvFile = CInt;

namespace UvFile {
    // 標準入力
    stdin: UvFile = 0.to_CInt;
    // 標準出力
    stdout: UvFile = 1.to_CInt;
    // 標準エラー出力
    stderr: UvFile = 2.to_CInt;
}
