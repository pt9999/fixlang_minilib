// A monad that performs bytes I/O operations.
module Minilib.Monad.BytesIO;

import Debug;

import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;

__Err_EOF: ErrMsg;
__Err_EOF = "EOF";

trait MonadBytesIO = Functor + Monad + MonadErrorIF + MonadBytesIOIF;

trait [m: * -> *] m: MonadBytesIOIF {
    // `send_bytes(bytes)` sends exactly `bytes.get_size` bytes. If the data cannot be sent immediately, this function may be blocked.
    // If an error occured (such as the connection is down or the storage is full), that error will be reported.
    send_bytes: Array U8 -> m ();
    // `recv_n_bytes(n)` receives exactly `n` bytes. If the data is not available yet, this function may be blocked.
    // If an error occured (such as the connection is down or the end of stream is reached), that error will be reported.
    recv_n_bytes: I64 -> m (Array U8);
    // `try_recv_n_bytes(n)` receives upto `n` bytes. If the data is not available yet, this function will return immediately.
    // If an error occured (such as the connection is down or the end of stream is reached), that error will be reported.
    try_recv_n_bytes: I64 -> m (Option (Array U8));
}

trait a: BytesIO {
    // type IOType a: * -> *;

    // `send(bytes)` sends exactly `bytes.get_size` bytes. If the data cannot be sent immediately, this function will be blocked.
    // If an error occured (such as the connection is down or the storage is full), that error will be reported.
    send: Array U8 -> a -> IOFail ();
    // `recv(n)` receives exactly `n` bytes. If the data is not available yet, this function will be blocked.
    // If an error occured (such as the connection is down or the end of stream is reached), that error will be reported.
    recv: I64 -> a -> IOFail (Array U8);
    // `try_recv(n)` receives upto `n` bytes. If the data is not available yet, this function will return immediately.
    // If an error occured (such as the connection is down or the end of stream is reached), that error will be reported.
    try_recv: I64 -> a -> IOFail (Option (Array U8));
}

trait a: GetByteIO {
    type BytesIOType a;
    get_bytes_io: a -> BytesIOType a;
}

impl [s: GetByteIO, bio: BytesIO, BytesIOType s = bio]
    StateT s IOFail: MonadBytesIOIF {
    send_bytes = |bytes| (
        let bytes_io = (*get_state).get_bytes_io;
        bytes_io.BytesIO::send(bytes).lift_t
    );

    recv_n_bytes = |length| (
        let bytes_io = (*get_state).get_bytes_io;
        bytes_io.BytesIO::recv(length).lift_t
    );

    try_recv_n_bytes = |length| (
        let bytes_io = (*get_state).get_bytes_io;
        bytes_io.BytesIO::try_recv(length).lift_t
    );
}
