module Test;

import Minilib.Common.IORef;
import Minilib.Common.TimeEx;
import Minilib.Testing.UnitTest;

test_ioref_simple: TestCase;
test_ioref_simple = (
    make_test("test_ioref_simple") $ |_|
    let ioref = *IORef::make(42).lift;
    let ioref2 = ioref;
    assert_equal("eq", 42, *ioref.get.lift);;
    ioref.IORef::set(43).lift;;
    assert_equal("eq", 43, *ioref.get.lift);;
    assert_equal("eq", 43, *ioref2.get.lift);;
    ioref.mod(add(1)).lift;;
    assert_equal("eq", 44, *ioref.get.lift);;
    assert_equal("eq", 44, *ioref2.get.lift);;
    pure()
);

test_ioref_unboxed: TestCase;
test_ioref_unboxed = (
    make_test("test_ioref_unboxed") $ |_|
    let ioref = *IORef::make(ok(42): Result ErrMsg I64).lift;
    let ioref2 = ioref;
    assert_equal("eq", ok(42), *ioref.get.lift);;
    ioref.IORef::set(err("err")).lift;;
    assert_equal("eq", err("err"), *ioref.get.lift);;
    assert_equal("eq", err("err"), *ioref2.get.lift);;
    ioref.mod(mod_err(|e| e+"or")).lift;;
    assert_equal("eq", err("error"), *ioref.get.lift);;
    assert_equal("eq", err("error"), *ioref2.get.lift);;
    pure()
);

test_ioref_boxed: TestCase;
test_ioref_boxed = (
    make_test("test_ioref_boxed") $ |_|
    let ioref = *IORef::make(["a"]).lift;
    let ioref2 = ioref;
    assert_equal("eq", ["a"], *ioref.get.lift);;
    ioref.IORef::set(["a","b","c"]).lift;;
    assert_equal("eq", ["a","b","c"], *ioref.get.lift);;
    assert_equal("eq", ["a","b","c"], *ioref2.get.lift);;
    ioref.mod(push_back("d")).lift;;
    assert_equal("eq", ["a","b","c","d"], *ioref.get.lift);;
    assert_equal("eq", ["a","b","c","d"], *ioref2.get.lift);;
    pure()
);

// An object with `IORef I64`, which is reset to zero on destruction
type Obj = unbox struct {
    dtor: Destructor (IORef I64),
};

namespace Obj {
    make: IORef I64 -> IO Obj;
    make = |ior_i64| pure $ Obj {
        dtor: *Destructor::make(ior_i64, |ior_i64|
            let i = *ior_i64.get;
            if i == 0 { pure $ ior_i64 };
            //eprintln("destructor is called: i=" + i.to_string);;
            ior_i64.IORef::set(0);;
            pure $ ior_i64
        )
    };

    get: Obj -> IO I64;
    get = |obj| obj.@dtor.borrow_io(|ior_i64| ior_i64.get);

    get_ior: Obj -> IO (IORef I64);
    get_ior = |obj| obj.@dtor.borrow_io(|ior_i64| pure $ ior_i64);
}

test_ioref_dtor: TestCase;
test_ioref_dtor = (
    make_test("test_ioref_dtor") $ |_|
    let ior_obj = *(
        let ior_i64: IORef I64 = *IORef::make(42).lift;
        let obj = *Obj::make(ior_i64).lift;
        IORef::make(obj).lift
    );
    let obj2: Obj = *ior_obj.get.lift;
    // now ior_obj is dead, but obj2 is alive
    assert_equal("eq", 42, *obj2.get.lift);;
    let ior_i64: IORef I64 = *obj2.get_ior.lift;
    // now obj2 is dead, but ior_i64 is alive
    assert_equal("eq", 0, *ior_i64.get.lift)
);

// Copies `IORef` as an unbox struct
copy_ior: IORef a-> IOFail (IORef a);
copy_ior = |IORef{dtor:dtor}| pure $ IORef{dtor:dtor};   // dtor is a boxed object, so only the reference of dtor is copyed

// Checks the values of `obj.get` and `obj.get_ior.get`
check_ior_obj: I64 -> I64 -> IORef Obj -> IOFail ();
check_ior_obj = |expected_obj_get, expected_obj_get_ior_get, ior_obj| (
    let obj: Obj = *ior_obj.get.lift;
    assert_equal("eq", expected_obj_get, *obj.get.lift);;
    let ior_i64: IORef I64 = *obj.get_ior.lift;
    assert_equal("eq", expected_obj_get_ior_get, *ior_i64.get.lift)
);

// Checks that:
// - Copying `IORef Obj` as an unbox struct will not affect to the referenced object
// - `IORef Obj` and `Obj` are destructed when they are not referenced any more
test_ioref_dtor_multi: TestCase;
test_ioref_dtor_multi = (
    make_test("test_ioref_dtor_multi") $ |_|
    let ior_obj: IORef Obj = *(
        let ior_i64: IORef I64 = *IORef::make(42).lift;
        let obj = *Obj::make(ior_i64).lift;
        IORef::make(obj).lift
    );
    let ior_obj = *copy_ior(ior_obj);
    check_ior_obj(42, 42, ior_obj);;
    let ior_obj = *copy_ior(ior_obj);
    check_ior_obj(42, 42, ior_obj);;
    // `IORef Obj` and `Obj` are destructed when they are not referenced any more
    // (before checing the value of `IORef I64`)
    check_ior_obj(42, 0, ior_obj)
);

test_ioref_perf: TestCase;
test_ioref_perf = (
    make_test("test_ioref_perf") $ |_|
    let n = 1000;
    let ans = *timeit_io("test_ioref_perf", do {
        pure();;
        let ior = *IORef::make(0);
        range(0, n).fold_m(
            (), |i, _|
            ior.mod(add(i))
        );;
        ior.get
    }).lift;
    assert_equal("eq", ans, n * (n-1) / 2)
);

test : IO ();
test = (
    [
        test_ioref_simple,
        test_ioref_unboxed,
        test_ioref_boxed,
        test_ioref_dtor,
        test_ioref_dtor_multi,
        test_ioref_perf,
    ]
    .run_test_driver
);
