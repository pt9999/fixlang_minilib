module Minilib.Crypto.Tls13.HandshakeProtocol;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.Extensions;
import Minilib.Crypto.Tls13.CipherSuite;
import Minilib.Crypto.SecureRandom;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

// 4. Handshake Protocol

type Handshake = unbox union {
    client_hello: ClientHello,
    server_hello: (),
    new_session_ticket: (),
    end_of_early_data: (),
    encrypted_extensions: (),
    certificate: (),
    certificate_request: (),
    certificate_verify: (),
    finished: (),
    key_update: (),
    message_hash: ()
};

type HandhshakeType = U8;

namespace Handshake {
    get_msg_type: Handshake -> HandhshakeType;
    get_msg_type = |h| (
        if h.is_client_hello { 1_U8 };
        if h.is_server_hello { 2_U8 };
        if h.is_new_session_ticket { 4_U8 };
        if h.is_end_of_early_data { 5_U8 };
        if h.is_encrypted_extensions { 8_U8 };
        if h.is_certificate { 11_U8 };
        if h.is_certificate_request { 13_U8 };
        if h.is_certificate_verify { 15_U8 };
        if h.is_finished { 20_U8 };
        if h.is_key_update { 24_U8 };
        if h.is_message_hash { 254_U8 };
        eval assert(|_| "unknown msg_type", false);
        0_U8
    );

    _marshal_body: Handshake -> ByteBuffer -> ByteBuffer;
    _marshal_body = |h, buf| (
        if h.is_client_hello { buf.marshal(h.as_client_hello) };
        buf
    );
}

impl Handshake: Marshal {
    marshal = |h, buf| (
        let buf = buf.marshal(h.get_msg_type);
        let length_pos = buf.get_position;
        let buf = buf.marshal(0_U32.to_U24);
        let buf = buf._marshal_body(h);
        let last_pos = buf.get_position;
        let buf = buf.set_position(length_pos);
        let buf = buf.marshal((last_pos - (length_pos + 3)).to_U32.to_U24);
        let buf = buf.set_position(last_pos);
        buf
    );
}


// 4.1.2 ClientHello

//type CipherSuite = U16;
type ClientHello = unbox struct {
    legacy_version: ProtocolVersion,        // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id: Array U8,            // <0..32>
    cipher_suites: Array CipherSuite,       // <2..2^16-2>
    legacy_compression_method: Array U8,    // <1..2^8-1>
    extensions: Array Extension            // <8..2^16-1>
};

namespace ClientHello {
    make: SecureRandom -> IOFail ClientHello;
    make = |secure_random| (
        let (random, _) = *secure_random.generate_bytes(32);
        let random = Array::fill(32, 0x0a_U8);
        pure $ ClientHello {
            legacy_version: 0x0303_U16,
            random: random,
            legacy_session_id: [],
            cipher_suites: [],
            legacy_compression_method: [ 0_U8 ],
            extensions: []
        }
    );

    empty: ClientHello;
    empty = ClientHello {
        legacy_version: 0x0303_U16,
        random: Array::fill(32, 0x00_U8),
        legacy_session_id: [],
        cipher_suites: [],
        legacy_compression_method: [ 0_U8 ],
        extensions: []
    };

    init: SecureRandom -> ClientHello -> IOFail ClientHello;
    init = |secure_random, hello| (
        let (random, _) = *secure_random.generate_bytes(32);
        let hello = hello.set_random(random);
        let hello = hello.set_cipher_suites([
           _TLS_AES_128_GCM_SHA256() 
        ]);
        let hello = hello.set_extensions(Extension::default_extensions);
        pure $ hello
    );
}

impl ClientHello: Marshal {
    marshal = |msg, buf| (
        eval assert(|_| "invalid random size", msg.@random.get_size == 32);
        let buf = buf.marshal(msg.@legacy_version);
        let buf = buf.marshal_fixed(msg.@random);
        let buf = buf.marshal_var_size(msg.@legacy_session_id, to_U8);
        let buf = buf.marshal_var_size(msg.@cipher_suites, to_U16);
        let buf = buf.marshal_var_size(msg.@legacy_compression_method, to_U8);
        let buf = buf.marshal_var_size(msg.@extensions, to_U16);
        buf
    );
}

// 4.1.3 ServerHello

type ServerHello = unbox struct {
    legacy_version: ProtocolVersion,        // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id_echo: Array U8,       // <0..32>
    cipher_suite: CipherSuite,              //
    legacy_compression_method: U8,          // = 0
    extensions: Array Extension            // <6..2^16-1>
};

impl ServerHello: Unmarshal {
    unmarshal = |buf| (
        let (legacy_version:U16, buf) = *buf.unmarshal;
        let (random:Array U8, buf) = *buf.unmarshal_fixed(32);
        let (legacy_session_id_echo:Array U8, buf) = *buf.unmarshal_var_size(U8::to_I64);
        let (cipher_suite:CipherSuite, buf) = *buf.unmarshal;
        let (legacy_compression_method, buf) = *buf.unmarshal;
        let (extensions, buf) = *buf.unmarshal_var_size(U16::to_I64);
        let msg = ServerHello {
            legacy_version: legacy_version,
            random: random,
            legacy_session_id_echo: legacy_session_id_echo,
            cipher_suite: cipher_suite,
            legacy_compression_method: legacy_compression_method,
            extensions: extensions
        };
        pure $ (msg, buf)
    );
}

