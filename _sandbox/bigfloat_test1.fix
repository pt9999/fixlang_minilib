module Main;

import Math;
import Debug;

import Sandbox.BigFloat;
import Minilib.Math.BigInt;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
//import Minilib.Testing.Timeit;

test_bit_length: TestCase;
test_bit_length = (
    make_table_test("test_bit_length",
        [
            ([0x76543210_U32, 0x00000a98_U32], 44_U64),
            ([0x01010101_U32, 4_U32], 35_U64),
            ([0xabababab_U32, 1_U32], 33_U64),
            ([0xcdcdcdcd_U32, 0_U32], 32_U64),
            ([0_U32, 0_U32], 0_U64),
            ([1_U32], 1_U64),
            ([0_U32], 0_U64)
        ],
        |(a, expect)|
        assert_equal("eq", expect, a._bit_length)
    )
);

test_shift_left: TestCase;
test_shift_left = (
    make_table_test("test_shift_left",
        [
            ([0x1234_U32, 0xabcd_U32], 56_U64, [0_U32, 0x34000000_U32, 0xcd000012_U32, 0xab_U32]),
            ([0x1234_U32, 0xabcd_U32], 32_U64, [0_U32, 0x1234_U32, 0xabcd_U32]),
            ([0x1234_U32, 0xabcd_U32], 4_U64,  [0x12340_U32, 0xabcd0_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 1_U64, [0xeca86420_U32, 0xfdb97530_U32, 0x1_U32]),
            ([0x1234_U32, 0_U32], 36_U64, [0_U32, 0x12340_U32, 0_U32]),
            ([0x1234_U32, 0_U32], 32_U64, [0_U32, 0x1234_U32, 0_U32]),
            ([0x1234_U32, 0_U32], 4_U64, [0x12340_U32, 0_U32]),
            ([0_U32], 0_U64, [0_U32])
        ],
        |(a, shift, expect)|
        assert_equal("eq", expect, a._shift_left(shift))
    )
);

test_shift_right: TestCase;
test_shift_right = (
    make_table_test("test_shift_right",
        [
            ([0x76543210_U32, 0xfedcba98_U32], 1_U64, [0x3b2a1908_U32, 0x7f6e5d4c_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 4_U64, [0x87654321_U32, 0x0fedcba9_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 32_U64, [0xfedcba98_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 36_U64, [0x0fedcba9_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 64_U64, [0_U32]),
            ([0x76543210_U32, 0xfedcba98_U32], 65_U64, [0_U32]),
            ([0x1234_U32, 0_U32], 32_U64, [0_U32]),
            ([0x1234_U32, 0_U32], 16_U64, [0_U32]),
            ([0_U32], 0_U64, [0_U32])
        ],
        |(a, shift, expect)|
        assert_equal("eq", expect, a._shift_right(shift))
    )
);

test_divmod_by_power_of_two: TestCase;
test_divmod_by_power_of_two = (
    make_table_test("test_divmod_by_power_of_two",
        [
            ([0x76543210_U32, 0xfedcba98_U32], 0_U64,  ([0x76543210_U32, 0xfedcba98_U32], [0x00_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 8_U64,  ([0x98765432_U32, 0x00fedcba_U32], [0x10_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 16_U64, ([0xba987654_U32, 0x0000fedc_U32], [0x3210_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 32_U64, ([0xfedcba98_U32], [0x76543210_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 36_U64, ([0x0fedcba9_U32], [0x76543210_U32, 0x08_U32])),
            ([0x76543210_U32, 0xfedcba98_U32, 0x4321_U32], 36_U64, ([0x1fedcba9_U32, 0x432_U32], [0x76543210_U32, 0x08_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 64_U64, ([0_U32], [0x76543210_U32, 0xfedcba98_U32])),
            ([0x76543210_U32, 0xfedcba98_U32], 65_U64, ([0_U32], [0x76543210_U32, 0xfedcba98_U32])),
            ([0xfedcba98_U32], 16_U64, ([0xfedc_U32], [0xba98_U32])),
            ([0x1234_U32, 0_U32], 32_U64, ([0_U32], [0x1234_U32])),
            ([0_U32], 0_U64, ([0_U32], [0_U32]))
        ],
        |(a, exp, expect)|
        assert_equal("eq", expect, _divmod_by_power_of_two(a, exp))
    )
);

test_get_prec: TestCase;
test_get_prec = (
    make_table_test("test_get_prec",
        [
            ([0x76543210_U32, 0xfedcba98_U32], -1, 5, 64),
            ([0x76543210_U32, 0_U32], 1, 3, 64),
            ([0x76543210_U32], -1, 123, 32),
            ([0_U32], 1, 111, 32)
        ],
        |(nat, sign, exp, expect)|
        let a = BigFloat::make(BigInt::make(sign, nat), exp);
        let a = a.mod_int(set_nat(nat)); // to avoid _remove_last_zeros
        assert_equal("eq", expect, a.get_prec)
    )
);

test_set_prec: TestCase;
test_set_prec = (
    make_table_test("test_set_prec",
        [
            (([0x76543210_U32, 0xfedcba98_U32], 5), 65, ([0x00000000_U32, 0x76543210_U32, 0xfedcba98_U32], 5 - 32)),
            (([0x76543210_U32, 0xfedcba98_U32], 7), 64, ([0x76543210_U32, 0xfedcba98_U32], 7)),
            (([0x7fffffff_U32, 0xfedcba98_U32], 9), 32, ([0xfedcba98_U32], 9 + 32)),
            (([0x80000000_U32, 0xfedcba98_U32], 9), 32, ([0xfedcba99_U32], 9 + 32)),
            (([0x7fffffff_U32, 0xfedcba98_U32], 9), 0, ([0xfedcba98_U32], 9 + 32)),
            (([0x0000fedc_U32], 11), 96, ([0x00000000_U32, 0x00000000_U32, 0xfedc0000_U32], 11 - 64 - 16)),
            (([0_U32], 0), 32, ([0_U32], 0))
        ],
        |((nat, exp), prec, (ex_nat, ex_exp))|
        let sign = 1;
        let a = BigFloat::make(BigInt::make(sign, nat), exp);
        let a = a.mod_int(set_nat(nat)); // to avoid _remove_last_zeros
        let a = a.set_prec(prec);
        let _ = *assert_equal("nat", ex_nat, a.@int.@nat);
        assert_equal("exp", ex_exp, a.@exp)
    )
);

test_to_string_precision: TestCase;
test_to_string_precision = (
    make_table_test("to_string_precision",
        [
            (([0xB82A0B09_U32, 0x587E6997_U32, 0xc_U32], -64), 0, "12"),
            (([0xB82A0B09_U32, 0x587E6997_U32, 0xc_U32], -64), 1, "12.3"),
            (([0xB82A0B09_U32, 0x587E6997_U32, 0xc_U32], -64), 2, "12.35"),
            (([0xB82A0B09_U32, 0x587E6997_U32, 0xc_U32], -64), 5, "12.34568"),
            (([0xB82A0B09_U32, 0x587E6997_U32, 0xc_U32], -64), 12, "12.345678901234"),
            (([0x94395810_U32, 0xD_U32], -32), 0, "14"),
            (([0x94395810_U32, 0xD_U32], -32), 1, "13.6"),
            (([0x94395810_U32, 0xD_U32], -32), 2, "13.58"),
            (([0x94395810_U32, 0xD_U32], -32), 3, "13.579"),
            (([3_U32], 4), 5, "48.00000"),
            (([3_U32], -1), 5, "1.50000"),
            (([0_U32], 0), 0, "0")
        ],
        |((nat, exp), prec, expect)|
        let sign = 1;
        let a = BigFloat::make(BigInt::make(sign, nat), exp);
        let a = a.mod_int(set_nat(nat)); // to avoid _remove_last_zeros
        assert_equal("to_string_precision", expect, a.to_string_precision(prec))
    )
);

test_eq_lt_le: TestCase;
test_eq_lt_le = (
    make_table_test("test_eq_lt_le",
        [
            (12.345, 12.345, (true, false, true)),
            (12.345, 12.3456, (false, true, true)),
            (12.3456, 12.345, (false, false, false)),
            (0.056789, 0.056789, (true, false, true)),
            (0.056789, 0.0567891, (false, true, true)),
            (0.0567892, 0.056789, (false, false, false)),
            (0.0, 0.0, (true, false, true))
        ],
        |(a, b, expect)|
        let a = BigFloat::from_F64(a);
        let b = BigFloat::from_F64(b).set_prec(96);
        let actual = (a == b, a < b, a <= b);
        let _ = *assert_equal("eq", expect.@0, actual.@0);
        let _ = *assert_equal("lt", expect.@1, actual.@1);
        let _ = *assert_equal("le", expect.@2, actual.@2);
        pure()
    )
);

main: IO ();
main = (
    let _ = *(
        let _ = *eprintln("--- test_sqrt");
        let prec10 = 20;
        let a = BigFloat::from_F64(1234567890.0).set_prec10(prec10);
        let x = a.sqrt;
        let _ = *eprintln("a  =" + a._to_string_rep);
        let _ = *eprintln("a  =" + a.to_string);
        let _ = *eprintln("x  =" + x.to_string);
        let _ = *eprintln("x*x=" + (x * x).to_string);
        pure()
    );
    if true { pure() };
    let _ = *(
        let _ = *eprintln("--- test_misc");
        let a = BigFloat::from_F64(1024.0).set_prec(256) / BigFloat::from_F64(1000.0);
        let b = BigFloat::from_F64(64.0).set_prec(256)  / BigFloat::from_F64(10.0);
        let _ = *eprintln("a="+a.to_string);
        let _ = *eprintln("a="+a.to_string_precision(20));
        let _ = *eprintln("b="+b.to_string);
        let _ = *eprintln("b="+b.to_string_precision(20));
        let c = a * b;
        let _ = *eprintln("c="+c.to_string);
        let _ = *eprintln("c="+c.to_string_precision(20));
        let _ = *eprintln("c.to_F64="+c.to_F64.to_string);
        let d = c / a;
        let _ = *eprintln("d="+d.to_string);
        let _ = *eprintln("d.to_F64="+d.to_F64.to_string);
        pure()
    );
    [
        test_bit_length,
        test_shift_left,
        test_shift_right,
        test_divmod_by_power_of_two,
        test_get_prec,
        test_set_prec,
        test_to_string_precision,
        test_eq_lt_le,
        TestCase::empty
    ]
    .run_test_driver
);
