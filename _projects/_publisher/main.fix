module Main;

import Minilib.App.Clap;
import Minilib.IO.Errno;
import Minilib.IO.FileSystem;
import Minilib.IO.Path;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;
import Publisher.ProcessRunner;

log_message: [m: MonadIO] String -> m ();
log_message = |str| println(str).lift_io;

chdir: Path -> IOFail ();
chdir = |dir| (
    let res = *dir.borrow_c_str_io(|p_dir|
        FFI_CALL_IO[CInt chdir(Ptr), p_dir]
    ).lift;
    if res < 0.to_CInt {
        throw $ "chdir failed: " + *get_last_error.lift
    };
    pure()
);

check_if_file_exists: Path -> IOFail ();
check_if_file_exists = |filepath| (
    if ! *file_exists(filepath).lift {
        throw $ "File not found: " + filepath
    };
    pure()
);

check_if_directory_exists: Path -> IOFail ();
check_if_directory_exists = |dirpath| (
    if ! *directory_exists(dirpath).lift {
        throw $ "Directory not found: " + dirpath
    };
    pure()
);

check_branch_name: String -> IOFail ();
check_branch_name = |expected| (
    log_message((expected,).format("### Checking if the current branch name is `{}`"));;
    let (stdout, stderr) = *run_process(["git", "rev-parse", "--abbrev-ref", "HEAD"]);
    let actual = stdout.strip_spaces;
    if actual != expected {
        throw $ (expected, actual).format("The current branch name is not `{}`: actual = `{}`")
    };
    pure()
);

check_uncommitted_files: IOFail ();
check_uncommitted_files = (
    log_message("### Checking for uncommitted files");;
    let (stdout, stderr) = *run_process(["git", "diff", "--name-only"]);
    if stdout != "" {
        throw $ "Uncommitted file exists"
    };
    pure()
);

is_there_any_commit_since_latest: IOFail Bool;
is_there_any_commit_since_latest = (
    log_message("### Checking if there is any commit from the latest release");;
    let (stdout, stderr) = *run_process(["git", "diff", "--name-only", "latest"]);
    if stdout == "" {
        pure $ false
    };
    pure $ true
);

run_command_release: ArgMatches -> IOFail ();
run_command_release = |submatches| (
    let topdir = submatches.get_one("topdir").as_some;
    let topdir = *realpath(topdir);

    let verup_py = join_paths([topdir, "_verup.py"]);
    check_if_file_exists(verup_py);;

    let subproject_dir = submatches.get_one("dir").as_some;
    let subproject_dir = *realpath(subproject_dir);
    log_message("=== " + subproject_dir + " ===");;
    chdir(subproject_dir);;

    let git_dir = join_paths([subproject_dir, ".git"]);
    check_if_directory_exists(git_dir);;

    let fixproj_toml = join_paths([subproject_dir, "fixproj.toml"]);
    check_if_file_exists(fixproj_toml);;

    check_branch_name("main");;
    check_uncommitted_files;;
    if ! *is_there_any_commit_since_latest {
        log_message("### No need to publish");;
        pure()
    };

    pure()
);

command_release: Command;
command_release = (
    Command::new("release")
    .display_name("publisher.out release")
    .about("Make a release")
    .arg(Arg::new("dir").short('d').long("dir").help("subproject directory").takes_value.required)
    .arg(Arg::new("topdir").long("topdir").help("_projects directory").takes_value.default_value(".."))
);

command_main: Command;
command_main = (
    Command::new("publisher.out")
    .version("0.1.0")
    .about("Release tool for subprojects")
    .subcommand(command_release)
);

run_command_main: ArgMatches -> IOFail ();
run_command_main = |matches| (
    if matches.subcommand.is_none {
        throw $ "no subcommand is specified"
    };
    let (name, submatches) = matches.subcommand.as_some;
    if name == "release" {
        run_command_release(submatches)
    } else {
        throw $ "invalid subcommand: " + name
    }
);

main: IO ();
main = do {
    let args = *IO::get_args.lift;
    let matches = *command_main.get_matches_from(args).from_result;
    run_command_main(matches)
}.try(|errmsg| eprintln("\nError: " + errmsg));
