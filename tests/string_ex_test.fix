module Main;

import Debug;

import HashMap;
import StringEx;
import UnitTest;


test_tostring_ok: [a: ToString] (a, String) -> TestCase;
test_tostring_ok = |(x, expected)| (
    let testname = "test_tostring_ok (" + expected + ")";
    make_test(testname) $ |_|
    let actual = x.to_string;
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_tostring: TestCase;
test_tostring = (
    [
        test_tostring_ok $ ((), "()"),
        test_tostring_ok $ ((1, 2), "(1, 2)"),
        test_tostring_ok $ ((1, 2, "abc"), "(1, 2, abc)"),
        test_tostring_ok $ ((1, 2, 3, (4, 5)), "(1, 2, 3, (4, 5))"),
        test_tostring_ok $ (some(1), "some(1)"),
        test_tostring_ok $ (let n: Option I64 = none(); (n, "none()")),
        test_tostring_ok $ (let res: Result ErrMsg I64 = ok(3); (res, "ok(3)")),
        test_tostring_ok $ (let res: Result ErrMsg I64 = err("ERR"); (res, "err(ERR)")),
        test_tostring_ok $ (let h: HashMap I64 I64 = HashMap::empty(0); (h, "{}")),
        test_tostring_ok $ (HashMap::empty(0).insert("a","b"), "{a:b}"),
        test_tostring_ok $ (HashMap::empty(2).insert(0,2).insert(1,3), "{0:2,1:3}"),
        test_tostring_ok $ (let a: Array I64 = []; (a, "[]")),
        test_tostring_ok $ ([1], "[1]"),
        test_tostring_ok $ ([1,2], "[1,2]"),
        TestCase::empty
    ].run_tests
);

test__unsafe_to_string: TestCase;
test__unsafe_to_string = (
    let testname = "test__unsafe_to_string";
    make_test(testname) $ |_|
    let array = [ 'a', 'b', 'c' ];
    let expected = "abc";
    let actual = array._unsafe_to_string;
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_find_byte_ok: (String, U8, Option I64) -> TestCase;
test_find_byte_ok = |(str, byte, expected)| (
    let testname = "test_find_byte_ok (" + str + "," + byte.to_string + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    let actual = str.find_byte(byte);
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_find_byte: TestCase;
test_find_byte = (
    [
        test_find_byte_ok $ ("", 'a', none()),
        test_find_byte_ok $ ("a", 'a', some(0)),
        test_find_byte_ok $ ("a", 'b', none()),
        test_find_byte_ok $ ("abab", 'a', some(0)),
        test_find_byte_ok $ ("abab", 'b', some(1)),
        test_find_byte_ok $ ("abab", 'c', none()),
        TestCase::empty
    ].run_tests
);

test_replace_all_ok: (String, String, String, String) -> TestCase;
test_replace_all_ok = |(str, from, to, expected)| (
    let testname = "test_replace_all_ok (" + str + "," + from + "," + to + "," + expected + ")";
    make_test(testname) $ |_|
    let actual = str.replace_all(from, to);
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_replace_all: TestCase;
test_replace_all = (
    [
        // if `str` is empty, return empty.
        test_replace_all_ok $ ("", "abc", "xyz", ""),
        // if `from` is empty, return `str`.
        test_replace_all_ok $ ("abc", "", "xyz", "abc"),
        // if `from` is not found, return `str`.
        test_replace_all_ok $ ("abc", "uvw", "xyz", "abc"),
        // `from` can be entire `str`
        test_replace_all_ok $ ("abc", "abc", "xyz", "xyz"),
        // `from` may be a single character
        test_replace_all_ok $ ("a", "a", "b", "b"),
        // replacement is not recursive
        test_replace_all_ok $ ("aaabca", "a", "aa", "aaaaaabcaa"),
        test_replace_all_ok $ ("aaaa", "aa", "bc", "bcbc"),
        // `to` can be empty
        test_replace_all_ok $ ("abcdabcd", "bc", "", "adad"),
        // `to` can be longer than `from`
        test_replace_all_ok $ ("abcdabcd", "bc", "xyz", "axyzdaxyzd"),
        TestCase::empty
    ].run_tests
);

test_substring_ok: (String, I64, I64, String) -> TestCase;
test_substring_ok = |(str,s,e,expected)| (
    let testname = "test_substring_ok (" + str + "," + s.to_string + "," + e.to_string + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    let actual = str.substring(s,e);
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_substring: TestCase;
test_substring = (
    [
        test_substring_ok $ ("", 0, 0, ""),
        test_substring_ok $ ("", -1, 1, ""),
        test_substring_ok $ ("abc", 0, 3, "abc"),
        test_substring_ok $ ("abc", 0, 0, ""),
        test_substring_ok $ ("abc", 0, 1, "a"),
        test_substring_ok $ ("abc", 1, 2, "b"),
        test_substring_ok $ ("abc", 2, 1, ""),
        test_substring_ok $ ("abc", 3, 3, ""),
        test_substring_ok $ ("abc", -1, 1, "a"),
        test_substring_ok $ ("abc", 2, 4, "c"),
        test_substring_ok $ ("abc", 5, 6, ""),
        TestCase::empty
    ].run_tests
);

test_string_less_than_ok : (String, String, Bool) -> TestCase;
test_string_less_than_ok = |(str1,str2,expected)| (
    let testname = "test_string_less_than_ok (" + str1 + "," + str2 + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    //let actual = string_less_than $ (str1, str2);
    let actual = str1 < str2;
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_string_less_than: TestCase;
test_string_less_than = (
    [
        test_string_less_than_ok $ ("", "", false),
        test_string_less_than_ok $ ("", "a", true),
        test_string_less_than_ok $ ("a", "", false),
        test_string_less_than_ok $ ("a", "a", false),
        test_string_less_than_ok $ ("a", "aa", true),
        test_string_less_than_ok $ ("aa", "a", false),
        test_string_less_than_ok $ ("ab", "abc", true),
        test_string_less_than_ok $ ("abc", "ab", false),
        test_string_less_than_ok $ ("a", "A", false),
        test_string_less_than_ok $ ("A", "a", true),
        TestCase::empty
    ].run_tests
);

test_to_string_hex_ok: (U64, String) -> TestCase;
test_to_string_hex_ok = |(u64,expected)| (
    let testname = "test_to_string_hex_ok (" + u64.to_string + "," + expected + ")";
    make_test(testname) $ |_|
    let actual = u64.to_string_hex;
    let _ = *(assert_equal("eq", expected, actual));
    pure()
);

test_to_string_hex: TestCase;
test_to_string_hex = (
    [
        test_to_string_hex_ok $ (0_U64, "0"),
        test_to_string_hex_ok $ (42_U64, "2A"),
        test_to_string_hex_ok $ (3735928559_U64, "DEADBEEF"),
        test_to_string_hex_ok $ (18446744073709551615_U64, "FFFFFFFFFFFFFFFF"),
        TestCase::empty
    ].run_tests
);

test_from_string_hex_ok: (String, Result ErrMsg U64) -> TestCase;
test_from_string_hex_ok = |(str,expected)| (
    let testname = "test_from_string_hex_ok (" + str + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    let actual: Result ErrMsg U64 = from_string_hex (str);
    // Result e a does not implement Eq...
    if expected.is_err {
        let _ = *(assert_true("err", actual.is_err));
        let _ = *(assert_equal("eq", expected.as_err, actual.as_err));
        pure()
    } else {
        let _ = *(assert_true("ok", actual.is_ok));
        let _ = *(assert_equal("eq", expected.as_ok, actual.as_ok));
        pure()
    }
);

test_from_string_hex: TestCase;
test_from_string_hex = (
    [
        test_from_string_hex_ok $ ("0", ok $ 0_U64),
        test_from_string_hex_ok $ ("2a", ok $ 42_U64),
        test_from_string_hex_ok $ ("DeadBeef", ok $ 3735928559_U64),
        test_from_string_hex_ok $ ("FFFFFFFFFFFFFFFF", ok $ 18446744073709551615_U64),
        test_from_string_hex_ok $ ("Dead.beef", err $ "Not a hexadecimal character: '.'"),
        test_from_string_hex_ok $ ("", err $ "Empty string"),
        TestCase::empty
    ].run_tests
);

main: IO ();
main = (
    [
        test_tostring,
        test__unsafe_to_string,
        test_find_byte,
        test_replace_all,
        test_substring,
        test_string_less_than,
        test_to_string_hex,
        test_from_string_hex,
        TestCase::empty
    ]
    .run_test_driver
);
