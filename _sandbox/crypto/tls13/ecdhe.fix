module Minilib.Crypto.Tls13.ECDHE;

import Character;
import Debug;

import Minilib.Crypto.Tls13.ECDSA;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Monad.Error;
/*
import Minilib.Crypto.SecureRandom;
import Minilib.Crypto.SHA256;
import Minilib.Encoding.Binary;
import Minilib.Math.Modular;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Types;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;
*/

type ECDHE = unbox struct {
    ec: ECParam,
    local_key_pair: ECKeyPair,
};

namespace ECDHE {
    make: [m: RandGen] ECParam -> m ECDHE;
    make = |ec| (
        let local_key_pair = *generate_keypair(ec);
        pure $ ECDHE {
            ec: ec,
            local_key_pair: local_key_pair
        }
    );

    get_pub_key: ECDHE -> (Array U8, Array U8);
    get_pub_key = |ecdhe| (
        let local_key_pair = ecdhe.@local_key_pair;
        let (x, y) = local_key_pair.@q.@xy.as_some;
        (x.to_bytes, y.to_bytes)
    );

    calc_shared_secret: (Array U8, Array U8) -> ECDHE -> Result ErrMsg (Array U8);
    calc_shared_secret = |remote_pub_key, ecdhe| (
        let ec = ecdhe.@ec;
        let local_key_pair = ecdhe.@local_key_pair;
        // make uncompressed octetstring
        let bytes = [ 4_U8 ].append(remote_pub_key.@0).append(remote_pub_key.@1);
        let remote_pub_key: ECPoint = *ECPoint::from_bytes_ec(ec, bytes);
        /*
        let remote_x: ECField = ECField::make(*ECInt::from_bytes(remote_x));
        let remote_y: ECField = ECField::make(*ECInt::from_bytes(remote_y));
        let remote_pub_key: ECPoint = ECPoint::make(ec, remote_x, remote_y);
        */
        eval *remote_pub_key.validate_pubkey;
        let dQ = remote_pub_key.mul_by_ECInt(local_key_pair.@d);
        if dQ.@xy.is_none {
            err $ "cannot calculate shared secret"
        };
        let dQx: ECField = dQ.@xy.as_some.@0;
        let shared_secret = dQx.to_bytes;
        pure $ shared_secret
    );
}