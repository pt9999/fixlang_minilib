// XML handling, such as:
// - Very simple DOM model (XmlDocument, XmlElement)
// - Escape/unescape special characters
module Sandbox.Xml;

import Debug;
import Character;

import Minilib.Text.StringEx;
import Minilib.Text.Unicode;
import Minilib.Net.HTML;

// A type that represents an XML document.
type XmlDocument = unbox struct {
    document_element: XmlElement           // document element
};

namespace XmlDocument {
    // An empty XML document.
    empty: XmlDocument;
    empty = (
        XmlDocument {
            document_element: XmlElement::make("root")      // dummy
        }
    );

    make: XmlElement -> XmlDocument;
    make = |document_element| (
        XmlDocument {
            document_element: document_element
        }
    );

    // Adds a child element to document element.
    add: XmlElement -> XmlDocument -> XmlDocument;
    add = |child, doc| (
        doc.mod_document_element(add(child))
    );

    // Converts the XML document to XML string.
    _to_string: XmlDocument -> String;
    _to_string = |doc| (
        doc.@document_element._to_string
    );   
}

impl XmlDocument: ToString {
    to_string = _to_string;
}

// A type that represents an XML node.
type XmlNode = box union {
    element_node: XmlElement,      // XML element
    text_node: XmlText,            // text node
    comment_node: XmlComment,      // comment node
    cdata_section: XmlCDATASection, // cdata section
    processing_instruction: XmlProcessingInstruction    // processing instruction
};

namespace XmlNode {
    _output_string: Array String -> XmlNode -> Array String;
    _output_string = |output, node| (
        if node.is_element_node {
            node.as_element_node._output_string(output)
        } else if node.is_text_node {
            node.as_text_node._output_string(output)
        } else if node.is_comment_node {
            node.as_comment_node._output_string(output)
        } else if node.is_cdata_section {
            node.as_cdata_section._output_string(output)
        } else if node.is_processing_instruction {
            node.as_processing_instruction._output_string(output)
        } else {
            eval assert(|_|"invalid node", false);
            output
        }
    );
}

// A type that represents an XML element.
type XmlElement = unbox struct {
    tag: String,                   // tag name
    attrs: Iterator XmlAttribute,  // attributes (reversed iterator)
    children: Array XmlNode        // child nodes
};

namespace XmlElement {

    // `XmlElement::make(tag)` creates an empty element with specified tag name.
    make: String -> XmlElement;
    make = |tag| (
        XmlElement {
            tag: tag,
            attrs: Iterator::empty,
            children: Array::empty(0)
        }
    );

    // Synonym for `XmlElement::make`.
    element: String -> XmlElement;
    element = make;

    // `el.attr(name,value)` adds an attribute to `el`.
    // If an attribute of same name exists, it will be removed first.
    // NOTE: validity of attribute names are not checked.
    attr: String -> String -> XmlElement -> XmlElement;
    attr = |name, value, el| (
        el.mod_attrs(|attrs|
            attrs.filter(|attr| attr.@name != name)
                 .push_front(XmlAttribute::make(name,value))
        )
    );

    // `parent.add(child)` adds a child element to `parent`.
    add: XmlElement -> XmlElement -> XmlElement;
    add = |child, parent| (
        parent.mod_children(push_back(element_node(child)))
    );

    // `parent.addF $ child` adds a child element to `parent`.
    // This is a flipped version of `add`.
    addF: XmlElement -> XmlElement -> XmlElement;
    addF = |parent, child| (
        parent.mod_children(push_back(element_node(child)))
    );

    // `el.text(content)` adds a text node to `el`.
    text: String -> XmlElement -> XmlElement;
    text = |content, el| (
        el.mod_children(push_back(text_node $ XmlText::make(content)))
    );
        
    // `el._to_string` converts the element to XML string.
    _to_string: XmlElement -> String;
    _to_string = |el| (
        el._output_string(Array::empty(100)).to_iter.concat_iter
    );

    // `el._output_string` output the element as XML string.
    _output_string: Array String -> XmlElement -> Array String;
    _output_string = |output, el| (
        let output = output.push_back("<" + el.@tag);
        let output = el.@attrs.reverse._output_string(output);
        let output = output.push_back(">");
        let child_sep = if el.@children.get_size >= 1 { "\n" } else { "" };
        let output = output.push_back(child_sep);
        let output = el.@children.to_iter.fold(
            output, |output, node|
            node._output_string(output)
                .push_back(child_sep)
        );
        let output = output.push_back("</" + el.@tag + ">");
        output
    );
}

impl XmlElement: ToString {
    to_string = _to_string;
}

// A type that represents name and value of an attribute.
type XmlAttribute = unbox struct {
    name: String,
    value: String
};

namespace XmlAttribute {
    make: String -> String -> XmlAttribute;
    make = |name, value| (
        XmlAttribute { name: name, value: value }
    );

    // `attrs._output_string` output the attributes as XML string.
    _output_string: Array String -> Iterator XmlAttribute -> Array String;
    _output_string = |output, attrs| (
        attrs.fold(
            output, |output, attr|
            output
            .push_back(" ")
            .push_back(escape_special(attr.@name))  // TODO needed?
            .push_back("=\"")
            .push_back(escape_special(attr.@value))
            .push_back("\"")
        )
    );
}

impl XmlAttribute: Eq {
    eq = |a, b| a.@name == b.@name && a.@value == b.@value;
}

type XmlText = unbox struct {
    content: String
};

namespace XmlText {
    make: String -> XmlText;
    make = |content| XmlText { content: content };

    _output_string: Array String -> XmlText -> Array String;
    _output_string = |output, text| (
        output.push_back(escape_special(text.@content))
    );
}

type XmlCDATASection = unbox struct {
    content: String
};

namespace XmlCDATASection {
    make: String -> XmlCDATASection;
    make = |content| XmlCDATASection { content: content };

    _output_string: Array String -> XmlCDATASection -> Array String;
    _output_string = |output, cdata_section| (
        output
        .push_back("<![CDATA[")
        .push_back(cdata_section.@content)
        .push_back("]]>")
    );
}

type XmlComment = unbox struct {
    content: String
};

namespace XmlComment {
    make: String -> XmlComment;
    make = |content| XmlComment { content: content };

    _output_string: Array String -> XmlComment -> Array String;
    _output_string = |output, comment| (
        output.push_back("<!--")
        .push_back(comment.@content)
        .push_back("-->")
    );
}

type XmlProcessingInstruction = unbox struct {
    content: String
};

namespace XmlProcessingInstruction {
    make: String -> XmlProcessingInstruction;
    make = |content| XmlProcessingInstruction { content: content };

    _output_string: Array String -> XmlProcessingInstruction -> Array String;
    _output_string = |output, pi| (
        output.push_back("<?")
        .push_back(pi.@content)
        .push_back("?>")
    );
}

namespace XmlHelpers {
    // Escapes XML special characters.
    // eg. `&` -> `&amp;`, `<` -> `&lt;`, `>` -> `&gt;`, `\"` -> `&quot;`, `'` -> `&#039;`
    escape_special: String -> String;
    escape_special = escape_html;

    // Unescapes XML special characters.
    // eg. `&amp;` -> `&`, `&lt;` -> `<`, `&gt;` -> `>`, `&quot;` -> `\"`, `&#039;` -> `'`.
    // NOTE: Other character references is also converted.
    unescape_special: String -> String;
    unescape_special = unescape_html;
}
