// Red-Black Tree.
// (This is an internal module of `TreeMap` and `TreeSet`.)
//
// Ported from Japanese translation of the book below:
//
// "Purely functional data structures" by Chris Okasaki, Cambridge University Press, 1998, ISBN 0-521-66350-4
//
// And for removal algorithm, ported from web site below.
// http://wwwa.pikara.ne.jp/okojisan/rb-tree/index.html#Delete
//
// NOTE: `less_than()` function must meet following conditions.
// - Irreflexivity: for all `x`, `less_than(x,x)` must be false.
// - Asymmetry:     for all `x, y`, if `less_than(x,y)` is true, then `less_than(y,x)` must be false.
// - Transitivity:  for all `x, y, z`, if `less_than(x,y)` is true and `less_than(y,z)` is true,
//                  then `less_than(x,z)` must be true.
//
module Minilib.Collection.RBTree;

// 上記の和訳:
//
// 下記の日本語版の書籍の「3.3 赤黒木」のサンプルコードを移植した。
//
// 「純粋関数型データ構造」
// Chris Okasaki 著
// 稲葉一浩、遠藤侑介 訳
// ISBN：978-4-04-893056-7
//
// また、削除アルゴリズムについては下記のサイトを参考にした。
// http://wwwa.pikara.ne.jp/okojisan/rb-tree/index.html#Delete
//
// 注: `less_than()` 関数は以下の条件を満たしている必要があります。
// - 非反射性: 任意の `x` について、`less_than(x,x)` は false でなければならない。
// - 非対称性: 任意の `x, y` について、 もし `less_than(x,y)` が true であるなら、`less_than(y,x)` は false でなければならない。
// - 推移性:   任意の `x, y, z` について、もし `less_than(x,y)` が true かつ `less_than(y,z)` が true であるなら、
//             `less_than(x,z)` は true でなければならない。

import Minilib.Common.Assert;

// A trait of the element. Currently `ToString` is required.
trait RBNodeElem = ToString;

// Default less_than function using `LessThan` trait.
_less_than: [a: LessThan, a: RBNodeElem] a -> a -> Bool;
_less_than = |x, y| x < y;

type RBColor = U8;

namespace RBColor {
    black: RBColor = 0_U8;
    red: RBColor = 1_U8;
}

// A type of a node of a red-black tree.
type RBNode a = unbox union {
    empty: (),
    free: RBNodeIndex,
    branch: RBBranch a,
};

// A type of a branch node of a red-black tree.
type RBBranch a = unbox struct {
    color: RBColor,
    left: RBNodeIndex,
    elem: a,
    right: RBNodeIndex,
};

namespace RBBranch {
    is_black: RBBranch a -> Bool;
    is_black = |branch| branch.@color == RBColor::black;

    is_red: RBBranch a -> Bool;
    is_red = |branch| branch.@color == RBColor::red;

    get_triplet: RBBranch a -> (RBNodeIndex, a, RBNodeIndex);
    get_triplet = |branch| (branch.@left, branch.@elem, branch.@right);

    get_left_right: RBBranch a -> (RBNodeIndex, RBNodeIndex);
    get_left_right = |branch| (branch.@left, branch.@right);

    set_left_right: (RBNodeIndex, RBNodeIndex) -> RBBranch a -> RBBranch a;
    set_left_right = |(left, right), branch| branch.set_left(left).set_right(right);
}

// A type of an index of the node array.
type RBNodeIndex = I64;

namespace RBNodeIndex {
    empty: RBNodeIndex = -1;
}

// A type of red-black tree.
type RBTree a = unbox struct {
    _root: RBNode,
    _free_list: Array RBNodeIndex,
    _nodes: Array (RBNode a),
};

namespace RBTree {
    // Debug flag. If set to true, a lot of debug messages will be printed and various validations will be done.
    _Debug: Bool;
    _Debug = false;

    // Prints to stderr if the debug flag is set.
    _debug_eprintln_lazy: (() -> String) -> ();
    _debug_eprintln_lazy = (
        if _Debug { |f| debug_eprintln(f()) } else { |f| () }
    );

    // Returns the level of this node (ie. the number of black nodes from this node to any leaf).
    // This function does not validate, so an unbalanced node can be specified.
    level_nonvalidate: [a: RBNodeElem] RBNodeIndex -> RBTree a -> I64;
    level_nonvalidate = |node, tree| (
        if tree.is_empty(node) { 1 };
        let branch = tree._get_branch(node);
        let this_count = if branch.is_black { 1 } else { 0 };
        let (left, right) = branch.get_left_right;
        let left_level = tree.level_nonvalidate(left);
        let right_level = tree.level_nonvalidate(right);
        max(left_level, right_level) + this_count
    );

    // Returns the level of this node (ie. the number of black nodes from this node to any leaf).
    // Panicks when the left and right nodes have different black count.
    level: [a: RBNodeElem] RBNodeIndex -> I64;
    level = |node| (
        if tree.is_empty(node) { 1 };
        let branch = tree._get_branch(node);
        let this_count = if branch.is_black { 1 } else { 0 };
        let (left, right) = branch.get_left_right;
        let left_level = tree.level(left);
        let right_level = tree.level(right);
        assert_lazy(|_| "The number of black nodes below the left and right nodes is different:"
                + " left=" + left_level.to_string
                + " right=" + right_level.to_string
                + "\nleft="+left.to_string
                + "\nright="+right.to_string,
            left_level == right_level
        ) $ |_|
        assert_lazy(|_| "Red duplicates", !(branch.is_red && (tree.is_red(left) || tree.is_red(right)))) $ |_|
        left_level + this_count
    );

    // Validates that:
    // - the left and right nodes have same black count
    // - children of a red node is not red
    // - max of left node < elem
    // - elem < min of right node
    // Returns `(level, min, max)`.
    // Panicks if validation failed.
    validate: [a: RBNodeElem] (a -> a -> Bool) -> RBNodeIndex -> RBTree a -> (I64, Option a, Option a);
    validate = |less_than, node, tree| (
        if tree.is_empty(node) { (1, none(), none()) };
        let branch = tree._get_branch(node);
        let this_count = if branch.is_black { 1 } else { 0 };
        let (left, elem, right) = branch.get_triplet;
        let (left_level, left_min, left_max) = tree.validate(less_than, left);
        let (right_level, right_min, right_max) = tree.validate(less_than, right);
        assert_lazy(|_| "The number of black nodes below the left and right nodes is different:"
                + " left=" + left_level.to_string
                + " right=" + right_level.to_string
                + "\nleft="+left.to_string
                + "\nright="+right.to_string,
            left_level == right_level
        ) $ |_|
        assert_lazy(|_| "Red duplicates", !(branch.is_red && (tree.is_red(left) || tree.is_red(right)))) $ |_|
        assert_lazy(|_| "not left_max < elem"
                + "\nleft_max="+left_max.as_some.to_string + " elem="+elem.to_string
                + "\nleft="+left.to_string
                + "\nright="+right.to_string,
            left_max.is_none || less_than(left_max.as_some, elem)) $ |_|
        assert_lazy(|_| "not elem < right_min"
                + "\nright_min="+right_min.as_some.to_string + " elem="+elem.to_string
                + "\nleft="+left.to_string
                + "\nright="+right.to_string,
            right_min.is_none || less_than(elem, right_min.as_some)) $ |_|

        let level = left_level + this_count;
        let min = if left_min.is_some { left_min } else { some(elem) };
        let max = if right_max.is_some { right_max } else { some(elem) };
        (level, min, max)
    );

    empty: RBTree a;
    empty = RBTree {
        _root: RBNodeIndex::empty,
        _free_list: [],
        _nodes: [],
    }

    _alloc_node: RBTree a -> (RBTree a, RBNodeIndex);
    _alloc_node = |tree| (
        match tree.@_free_list.get_last {
            some(node) => (
                let tree = tree.mod__free_list(pop_back);
                (tree, node)
            ),
            none() => (
                let node = tree.@_nodes.get_size;
                let tree = tree.mod__nodes(push_back(RBNode::empty()));
                (tree, node)
            )
        }
    );

    _free_node: RBNodeIndex -> RBTree a -> RBTree a;
    _free_node = |node, tree| (
        let tree = tree._set_node(node, RBNode::empty());
        let tree = tree.mod__free_list(push_back(node));
        tree
    );

    _get_node: RBNodeIndex -> RBTree a -> RBNode a;
    _get_node = |node, tree| (
        if node == RBNodeIndex::empty { RBNode::empty() };
        tree.@_nodes.@(node)
    );

    _set_node: RBNodeIndex -> RBNode a -> RBTree a -> RBTree a;
    _set_node = |node, data, tree| (
        tree.mod__nodes(set(node, data))
    );

    _mod_node: RBNodeIndex -> (RBNode a -> RBNode a) -> RBTree a -> RBTree a;
    _mod_node = |node, f, tree| (
        tree.mod__nodes(mod(node, f))
    );

    _get_branch: RBNodeIndex -> RBTree a -> RBBranch a;
    _get_branch = |node, tree| (
        tree._get_node(node).as_branch
    );

    _mod_branch: RBNodeIndex -> (RBBranch a -> RBBranch a) -> RBTree a -> RBTree a;
    _mod_branch = |node, f, tree| (
        tree.mod__nodes(mod(node, mod_branch(f)))
    );

    // Gets the number of elements.
    // The time complexity of this function is O(n).
    get_size: RBNodeIndex -> RBTree a -> I64;
    get_size = |node, tree| (
        if node.is_empty { 0 };
        let (left, elem, right) = node.get_triplet;
        left.get_size + 1 + right.get_size
    );

    get_left_right: RBNodeIndex -> RBTree a -> (RBNodeIndex, RBNodeIndex);
    get_left_right = |node, tree| (
        let branch = tree._get_node(node).as_branch;
        (branch.@left,branch.@right)
    );

    set_left_right: RBNodeIndex -> (RBNodeIndex, RBNodeIndex) -> RBTree a -> RBTree a;
    set_left_right = |node, (left, right), tree| (
        tree._mod_node(node, mod_branch(|branch| branch.set_left(left).set_right(right)))
    );

    // If the node is black or red, `node.get_triplet` returns a triplet `(left, elem, right)`.
    // If the node is empty, it will abort.
    get_triplet: RBNodeIndex -> RBTree a -> (RBNodeIndex, a, RBNodeIndex);
    get_triplet = |node, tree| (
        let branch = tree._get_node(node).as_branch;
        (branch.@left, branch.@elem, branch.@right)
    );

    set_triplet: RBNodeIndex -> (RBNodeIndex, a, RBNodeIndex) -> RBTree a -> RBTree a;
    set_triplet = |node, (left, elem, right), tree| (
        tree._mod_node(node, |branch| branch.set_left(left).set_elem(elem).set_right(right))
    );

    set_quad: RBNodeIndex -> (RBColor, RBNodeIndex, a, RBNodeIndex) -> RBTree a -> RBTree a;
    set_quad = |node, (color, left, elem, right), tree| (
        tree._mod_node(node, |branch| branch.set_color(color).set_left(left).set_elem(elem).set_right(right))
    );

    is_empty: RBNodeIndex -> RBTree a -> Bool;
    is_empty = |node, tree| tree._get_node(node).is_empty;

    is_red: RBNodeIndex -> RBTree a -> Bool;
    is_red = |node, tree| (
        let node = tree._get_node(node);
        node.is_branch && node.as_branch.is_red
    );

    is_black: RBNodeIndex -> RBTree a -> Bool;
    is_black = |node, tree| (
        let node = tree._get_node(node);
        node.is_branch && node.as_branch.is_black
    );

    get_color: RBNodeIndex -> RBTree a -> RBColor;
    get_color = |node, tree| tree._get_branch(node).@color;

    set_color: RBNodeIndex -> RBColor -> RBTree a -> RBTree a;
    set_color = |node, color, tree| tree._mod_branch(node, set_color(color));

    get_left: RBNodeIndex -> RBTree a -> RBNodeIndex;
    get_left = |node, tree| tree._get_branch(node).@left;

    get_right: RBNodeIndex -> RBTree a -> RBNodeIndex;
    get_right = |node, tree| tree._get_branch(node).@right;

    //====================================================================
    // Finding
    //====================================================================

    // `node.find(x, less_than)` finds an element `elem` that is equivalent to `x`,
    // ie. `!less_than(elem, x) && !less_than(x, elem)` is true.
    find: a -> (a -> a -> Bool) -> RBNodeIndex -> Option a;
    find = |x, less_than, node| (
        let lt_begin = |elem| less_than(elem, x);
        let lt_end   = |elem| !less_than(x, elem);
        let iter = node.find_range(lt_begin, lt_end);
        iter.get_first
    );

    // `node.find_range(lt_begin, lt_end)` finds all elements `elem`
    // such that `!elem.lt_begin && elem.lt_end` is true.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `x`, `x.lt_begin` is true then `x.lt_end` must be true.
    find_range: (a -> Bool) -> (a -> Bool) -> RBNodeIndex -> DynIterator a;
    find_range = |lt_begin, lt_end, node| (
        if node.is_empty { DynIterator::empty };
        let next = |_| (
            let (left, elem, right) = node.get_triplet;
            if elem.lt_begin {         // elem < begin
                right.find_range(lt_begin, lt_end)
            } else if elem.lt_end {    // begin <= elem && elem < end
                left.find_range(lt_begin, lt_end)
                ._fast_append(right.find_range(lt_begin, lt_end)
                        .push_front(elem).to_dyn)
            } else {                    // end <= elem
                left.find_range(lt_begin, lt_end)
            }
        ).advance;
        DynIterator { next: next }
    );

    // `node.find_range_descending(lt_begin, lt_end)` finds all elements `elem`
    // such that `!elem.lt_begin && elem.lt_end` is true, in descending order.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `x`, `x.lt_begin` is true then `x.lt_end` must be true.
    find_range_descending: (a -> Bool) -> (a -> Bool) -> RBNodeIndex -> DynIterator a;
    find_range_descending = |lt_begin, lt_end, node| (
        if node.is_empty { DynIterator::empty };
        let next = |_| (
            let (left, elem, right) = node.get_triplet;
            if elem.lt_begin {         // elem < begin
                right.find_range_descending(lt_begin, lt_end)
            } else if elem.lt_end {    // begin <= elem && elem < end
                right.find_range_descending(lt_begin, lt_end)
                ._fast_append(left.find_range_descending(lt_begin, lt_end)
                        .push_front(elem).to_dyn)
            } else {                    // end <= elem
                left.find_range_descending(lt_begin, lt_end)
            }
        ).advance;
        DynIterator { next: next }
    );

    // Same as `Iterator::append` but a little fast.
    _fast_append : DynIterator a -> DynIterator a -> DynIterator a;
    _fast_append = |rhs, lhs| (
        let next = |_| (
            let opt = lhs.advance;
            if opt.is_none { rhs.advance };
            let (lhs, e) = opt.as_some;
            some $ (lhs._fast_append(rhs), e)
        );
        DynIterator { next : next }
    );

    // Gets the first element (that is, the smallest element) of the tree.
    get_first: RBNodeIndex -> Option a;
    get_first = |node| (
        if node.is_empty { none() };
        let (left, elem, right) = node.get_triplet;
        if left.is_empty { some(elem) };
        left.get_first
    );

    // Gets the last element (that is, the largest element) of the tree.
    get_last: RBNodeIndex -> Option a;
    get_last = |node| (
        if node.is_empty { none() };
        let (left, elem, right) = node.get_triplet;
        if right.is_empty { some(elem) };
        right.get_last
    );

    //====================================================================
    // Upsert
    //====================================================================

    _balance: RBNodeIndex -> RBTree a -> (RBTree a, RBNodeIndex);
    _balance = |node, tree| (
        if tree.is_empty(node) || tree._get_branch(node).is_red { (tree, node) };
        let (left, right) = tree._get_branch(node).get_left_right;
        if !tree.is_red(left) {
            tree._balance_right(node, right)
        };
        let (left_left, left_right) = tree.get_left_right(left);
        if tree.is_red(left_left) {
            //let (left, e3, n4) = tree.get_triplet(node); //.as_black;
            //let (left_left, e2, n3) = tree.get_triplet(left); //.as_red;
            //let (n1, e1, n2) = tree.get_triplet(left_left); //.as_red;
            //let tree = tree.set_quad(node, (black, n3, e3, n4));
            //let tree = tree.set_quad(left, (red, left_left, e2, node));
            let tree = tree._mod_branch(left_left, set_color(black));
            let tree = tree._mod_branch(node, set_left(left_left));
            let tree = tree._mod_branch(left, set_left(left_left) >> set_right(node));
            (tree, left)
        }; 
        if tree.is_red(left_right) {
            //let (left, e3, n4) = node.get_triplet; //.as_black;
            //let (n1, e1, left_right) = left.get_triplet; //.as_red;
            //let (n2, e2, n3) = left_right.get_triplet; //.as_red;
            //left.set_quad((black, n1, e1, n2))
            //node.set_quad((black, n3, e3, n4))
            //left_right.set_quad((red, left, e2, node))
            let (n2, n3) = tree.get_left_right(left_right);
            let tree = tree._mod_branch(left, set_right(n2) >> set_color(black));
            let tree = tree._mod_branch(node, set_left(n3));
            let tree = tree._mod_branch(left_right, set_left(left) >> set_right(node));
            (tree, left_right)
        };
        tree._balance_right(node, right)
    );

    _balance_right: RBNodeIndex -> RBNodeIndex -> RBTree a -> (RBTree a, RBNodeIndex);
    _balance_right = |node, right, tree| (
        if !tree.is_red(right) { (tree, node) };

        let (right_left, right_right) = tree.get_left_right(right);
        if tree.is_red(right_left) {
            let (n1, e1, right) = node.as_black;
            let (right_left, e3, n4) = right.as_red;
            let (n2, e2, n3) = right_left.as_red;
            red $ (black $ (n1, e1, n2), e2, black $ (n3, e3, n4))
        };
        if tree.is_red(right_right) {
            let (n1, e1, right) = node.as_black;
            let (n2, e2, right_right) = right.as_red;
            let (n3, e3, n4) = right_right.as_red;
            red $ (black $ (n1, e1, n2), e2, black $ (n3, e3, n4))
        };
        (tree, node)
    );

    _upsert_inner: a -> (a -> a) -> (a -> a -> Bool) -> RBNodeIndex -> (I64, RBNodeIndex);
    _upsert_inner = |x, updater, less_than, node| (
        if node.is_empty {
            // if `x` is not found, insert `x`.
            let node = red $ (node, x, node);
            (1, node)
        };
        let color = if node.is_red { red } else { black }; // constructor
        let (left, elem, right) = node.get_triplet;
        if less_than(x, elem) {
            let (dsize, left) = left._upsert_inner(x, updater, less_than);
            let node = color $ (left, elem, right);
            (dsize, node._balance)
        };
        if less_than(elem, x) {
            let (dsize, right) = right._upsert_inner(x, updater, less_than);
            let node = color $ (left, elem, right);
            (dsize, node._balance)
        };
        // If neither `x < elem` nor `elem < x` holds, replace `elem` with `updater(elem)`.
        let node = color $ (left, updater(elem), right);
        (0, node)
    );

    // `node.upsert_lt(x, updater, less_than)` inserts or updates using `less_than` ordering.
    // Returns the size difference and the changed node.
    // If `node` does not contain an element equivalent to `x`, `x` is inserted.
    // If `node` already contains an element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true,
    // then `y` is updated with `updater(y)`.
    upsert_lt: [a: RBNodeElem] a -> (a -> a) -> (a -> a -> Bool) -> RBNodeIndex -> (I64, RBNodeIndex);
    upsert_lt = |x, updater, less_than, node| (
        let (dsize, inserted) = node._upsert_inner(x, updater, less_than);
        let inserted = black $ inserted.get_triplet;
        eval if _Debug { let _ = inserted.validate(less_than); () } else { () };
        (dsize, inserted)
    );

    // `node.upsert(x, updater)` inserts or updates using default `LessThan` ordering.
    // Returns the size difference and the changed node.
    // If `node` does not contain an element equivalent to `x`, `x` is inserted.
    // If `node` already contains an element `y` equivalent to `x`,
    // ie. `!(x < y) && !(y < x)` is true,
    // then `y` is updated with `updater(y)`.
    upsert: [a: LessThan, a: RBNodeElem] a -> (a -> a) -> RBNodeIndex -> (I64, RBNodeIndex);
    upsert = |x, updater, node| (
        node.upsert_lt(x, updater, _less_than)
    );

    //====================================================================
    // Insertion
    //====================================================================

    // `node.insert_lt(x, less_than)` inserts an element `x` using `less_than` ordering.
    // Returns the size difference and the changed node.
    // If `node` already contains an element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true,
    // then `y` is replaced with `x`.
    insert_lt: [a: RBNodeElem] a -> (a -> a -> Bool) -> RBNodeIndex -> (I64, RBNodeIndex);
    insert_lt = |x, less_than, node| (
        node.upsert_lt(x, |_| x, less_than)
    );

    // `node.insert(x)` inserts an element `x` using default `LessThan` ordering.
    // Returns the size difference and the changed node.
    // If `node` already contains an element `y` equivalent to `x`,
    // ie. `!(x < y) && !(y < x)` is true,
    // then `y` is replaced with `x`.
    insert: [a: LessThan, a: RBNodeElem] a -> RBNodeIndex -> (I64, RBNodeIndex);
    insert = |x, node| (
        node.insert_lt(x, _less_than)
    );


    //====================================================================
    // Removal
    //====================================================================

    // `node.remove(x)` removes any element `y` equivalent to `x`,
    // ie. `!(x < y) && !(y < x)` is true.
    // Returns the size difference and the changed node.
    remove: [a: LessThan, a: RBNodeElem] a -> RBNodeIndex -> (I64, RBNodeIndex);
    remove = |x, node| (
        node.remove_lt(x, _less_than)
    );

    // `node.remove_lt(x, less_than)` removes any element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true.
    // Returns the size difference and the changed node.
    remove_lt: [a: RBNodeElem] a -> (a -> a -> Bool) -> RBNodeIndex -> (I64, RBNodeIndex);
    remove_lt = |x, less_than, node| (
        let lt_begin = |elem| less_than(elem, x);
        let lt_end   = |elem| !less_than(x, elem);
        let (dsize, removed) = node.remove_range(lt_begin, lt_end);
        eval if _Debug { let _ = removed.validate(less_than); () } else { () };
        (dsize, removed)
    );

    // `node.remove_range(lt_begin, lt_end)` removes all elements `elem`
    // where `!elem.lt_begin && elem.lt_end` is true.
    // Returns the size difference and the changed node.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `x`, `x.lt_begin` is true then `x.lt_end` must be true.
    remove_range: [a: RBNodeElem] (a -> Bool) -> (a -> Bool) -> RBNodeIndex -> (I64, RBNodeIndex);
    remove_range = |lt_begin, lt_end, node| (
        loop(
            (0, node), |(dsize, node)|
            let opt = node._try_remove_range(lt_begin, lt_end);
            if opt.is_none { break $ (dsize, node) };
            let (active, removed) = opt.as_some;
            continue $ (dsize - 1, removed)   // repeat recursively
        )
    );

    // `node._try_remove_range(lt_begin, lt_end)` tries to remove single element `elem`
    // where `!elem.lt_begin && elem.lt_end` is true.
    // Even if there are several elements that holds the condition, only one of them
    // are removed.
    // Returns `some((active, removed))` if removal is succeeded
    // where `removed` is the node after removal,
    // and `active` is true iff `removed.level == node.level - 1`.
    // Returns `none()` if removal is failed.
    _try_remove_range: [a: RBNodeElem] (a -> Bool) -> (a -> Bool) -> RBNodeIndex -> Option (Bool, RBNodeIndex);
    _try_remove_range = |lt_begin, lt_end, node| (
        eval _debug_eprintln_lazy(|_| "_try_remove_range: node=" + node.to_string);
        let opt = node._try_remove_range_inner(lt_begin, lt_end);
        eval _debug_eprintln_lazy(|_| "_try_remove_range: result=" + opt.to_string);
        opt
    );

    _try_remove_range_inner: [a: RBNodeElem] (a -> Bool) -> (a -> Bool) -> RBNodeIndex -> Option (Bool, RBNodeIndex);
    _try_remove_range_inner = |lt_begin, lt_end, node| (
        if node.is_empty {
            none()
        };
        let (left, elem, right) = node.get_triplet;
        let left_result = if !elem.lt_begin {
            let (active, left) = *left._try_remove_range(lt_begin, lt_end);
            let node = node.set_triplet((left, elem, right));
            let (active, node) = _remove_fix_left $ (active, node);
            some $ (active, node)
        } else {
            none()
        };
        if left_result.is_some {
            left_result
        };

        let right_result = if elem.lt_end {
            let (active, right) = *right._try_remove_range(lt_begin, lt_end);
            let node = node.set_triplet((left, elem, right));
            let (active, node) = _remove_fix_right $ (active, node);
            some $ (active, node)
        } else {
            none()
        };
        if right_result.is_some {
            right_result
        };

        let this_result = if !elem.lt_begin && elem.lt_end {
            // remove this node
            eval _debug_eprintln_lazy(|_| "remove this node: node="+node.to_string);
            if !left.is_empty {
                eval _debug_eprintln_lazy(|_| "left is nonempty");
                let (active, left, max) = left._remove_max;
                eval _debug_eprintln_lazy(|_| "left nonempty _remove_max done: left=" + left.to_string + " max=" + max.to_string);
                let node = node.set_triplet((left, max, right));
                let (active, node) = _remove_fix_left $ (active, node);
                some $ (active, node)
            };
            if !right.is_empty {
                eval _debug_eprintln_lazy(|_| "right is nonempty");
                let (active, right, min) = right._remove_min;
                let node = node.set_triplet((left, min, right));
                let (active, node) = _remove_fix_right $ (active, node);
                eval _debug_eprintln_lazy(|_| "done");
                some $ (active, node)
            };
            eval _debug_eprintln_lazy(|_| "both left and right is empty");
            let node_was_black = node.is_black;
            some $ (node_was_black, empty())
        } else {
            none()
        };
        this_result
    );

    // `node._remove_max` removes an maximum element.
    // Returns `(active, removed, max)` where `removed` is the node after removal,
    // `max` is the maximum element,
    // and `active` is true iff `removed.level == node.level - 1`.
    _remove_max: [a: RBNodeElem] RBNodeIndex -> (Bool, RBNodeIndex, a);
    _remove_max = |node| (
        eval _debug_eprintln_lazy(|_| "_remove_max: node="+node.to_string);
        assert_lazy(|_| "_remove_max: !node.is_empty", !node.is_empty) $ |_|
        let (left, elem, right) = node.get_triplet;
        if !right.is_empty {
            let (active, right, max) = right._remove_max;
            let node = node.set_triplet((left, elem, right));
            let (active, node) = _remove_fix_right $ (active, node);
            (active, node, max)
        };
        // remove `node`
        let max = elem;
        let active = node.is_black;
        (active, left, max)
    );

    // `node._remove_min` removes an minimum element.
    // Returns `(active, removed, min)` where `removed` is the node after removal,
    // `min` is the minimum element,
    // and `active` is true iff `removed.level == node.level - 1`.
    _remove_min: [a: RBNodeElem] RBNodeIndex -> (Bool, RBNodeIndex, a);
    _remove_min = |node| (
        eval _debug_eprintln_lazy(|_| "_remove_min: node="+node.to_string);
        assert_lazy(|_| "_remove_min: !node.is_empty", !node.is_empty) $ |_|
        let (left, elem, right) = node.get_triplet;
        if !left.is_empty {
            let (active, left, min) = left._remove_min;
            let node = node.set_triplet((left, elem, right));
            let (active, node) = _remove_fix_left $ (active, node);
            (active, node, min)
        };
        // remove `node`
        let min = elem;
        let active = node.is_black;
        (active, right, min)
    );

    _debug_assert_level_diff: [a: RBNodeElem] String -> String -> RBNodeIndex -> String -> RBNodeIndex -> I64 -> Lazy b -> b;
    _debug_assert_level_diff = |prefix, name1, node1, name2, node2, diff, lazy| (
        if !_Debug { lazy() };
        let level1 = node1.level_nonvalidate;
        let level2 = node2.level_nonvalidate;
        if !(level1 + diff == level2) {
            undefined(prefix + ": " +
                name1 + ".level(" + level1.to_string + ") + " + diff.to_string + " != " +
                name2 + ".level(" + level2.to_string + ")\n" +
                name1 + " = " + node1.to_string + "\n" +
                name2 + " = " + node2.to_string)
        };
        lazy()
    );

    // Called when `node.left.level == node.right.level - 1`.
    // Returns `(active, fixed)` where `fixed` is the fixed node,
    // and `active` is true iff `fixed.level = node.level - 1`.
    _remove_fix_left: [a: RBNodeElem] (Bool, RBNodeIndex) -> (Bool, RBNodeIndex);
    _remove_fix_left = |(active, node)| (
        let (active, fixed) = _remove_fix_left_inner $ (active, node);
        if fixed.is_empty {
            (active, fixed)
        };
        let (left, elem, right) = node.get_triplet;
        _debug_assert_level_diff("_remove_fix_left postcheck",
            "fixed", fixed, "node", node,
            if active { 1 } else { 0 }
        ) $ |_|
        eval _debug_eprintln_lazy(|_| "_remove_fix_left done: active="+active.to_string + " fixed="+fixed.to_string);
        (active, fixed)
    );

    _remove_fix_left_inner: [a: RBNodeElem] (Bool, RBNodeIndex) -> (Bool, RBNodeIndex);
    _remove_fix_left_inner = |(active, node)| (
        // see http://wwwa.pikara.ne.jp/okojisan/rb-tree/index.html#Delete
        if !active {
            (active, node)
        };
        eval _debug_eprintln_lazy(|_| "_remove_fix_left: active="+active.to_string + " node="+node.to_string);
        let u = node;
        let u_was_black = u.is_black;
        let u_color = u.get_color;
        let (t1, u_elem, v) = u.get_triplet;
        assert_lazy(|_| "v is empty", !v.is_empty) $ |_|
        _debug_assert_level_diff("_remove_fix_left precheck", "t1", t1, "v", v, 1) $ |_|
        if v.is_black {
            if v.get_left.is_red {
                // pattern L1
                let (w, v_elem, t4) = v.get_triplet;
                let (t2, w_elem, t3) = w.get_triplet;
                _debug_assert_level_diff("L1", "t1", t1, "t2", t2, 0) $ |_|
                _debug_assert_level_diff("L1", "t3", t3, "t4", t4, 0) $ |_|
                let u = black $ (t1, u_elem, t2);
                let v = black $ (t3, v_elem, t4);
                let w = u_color $ (u, w_elem, v);
                let active = false;
                (active, w)
            } else if v.get_right.is_red {
                // pattern L2
                let (t2, v_elem, w) = v.get_triplet;
                let (t3, w_elem, t4) = w.get_triplet;
                _debug_assert_level_diff("L2", "t1", t1, "t2", t2, 0) $ |_|
                _debug_assert_level_diff("L2", "t3", t3, "t4", t4, 0) $ |_|
                let u = black $ (t1, u_elem, t2);
                let w = black $ (t3, w_elem, t4);
                let v = u_color $ (u, v_elem, w);
                let active = false;
                (active, v)
            } else {
                // pattern L3
                let (t2, v_elem, t3) = v.get_triplet;
                let v = red $ (t2, v_elem, t3);
                _debug_assert_level_diff("L3", "t1", t1, "v", v, 0) $ |_|
                let u = black $ (t1, u_elem, v);
                let active = u_was_black;
                (active, u)
            }
        } else {    // v.is_red
            // pattern L4
            assert_lazy(|_| "L4: u_was_black", u_was_black) $ |_|
            let (t2, v_elem, t3) = v.get_triplet;
            let u = red $ (t1, u_elem, t2);
            let active = true;
            let (active, u) = _remove_fix_left $ (active, u);
            _debug_assert_level_diff("L4", "u", u, "t3", t3, 0) $ |_|
            let v = black $ (u, v_elem, t3);
            (active, v)
        }
    );

    // Called when `node.right.level == node.level.level - 1`.
    // Returns `(active, fixed)` where `fixed` is the fixed node,
    // and `active` is true iff `fixed.level = node.level - 1`.
    _remove_fix_right: [a: RBNodeElem] (Bool, RBNodeIndex) -> (Bool, RBNodeIndex);
    _remove_fix_right = |(active, node)| (
        let (active, fixed) = _remove_fix_right_inner $ (active, node);
        if fixed.is_empty {
            (active, fixed)
        };
        let (left, elem, right) = node.get_triplet;
        _debug_assert_level_diff("_remove_fix_right postcheck",
            "fixed", fixed, "node", node,
            if active { 1 } else { 0 }
        ) $ |_|
        (active, fixed)
    );

    _remove_fix_right_inner: [a: RBNodeElem] (Bool, RBNodeIndex) -> (Bool, RBNodeIndex);
    _remove_fix_right_inner = |(active, node)| (
        // see http://wwwa.pikara.ne.jp/okojisan/rb-tree/index.html#Delete
        eval _debug_eprintln_lazy(|_| "_remove_fix_right: active="+active.to_string + " node="+node.to_string);
        if !active {
            (active, node)
        };
        let u = node;
        let u_was_black = u.is_black;
        let u_color = u.get_color;
        let (v, u_elem, t4) = u.get_triplet;
        assert_lazy(|_| "v is empty", !v.is_empty) $ |_|
        _debug_assert_level_diff("_remove_fix_right precheck", "v", v, "t4", t4, -1) $ |_|
        if v.is_black {
            if v.get_right.is_red {
                eval _debug_eprintln_lazy(|_| "R1");
                // pattern R1
                let (t1, v_elem, w) = v.get_triplet;
                let (t2, w_elem, t3) = w.get_triplet;
                _debug_assert_level_diff("R1", "t1", t1, "t2", t2, 0) $ |_|
                _debug_assert_level_diff("R1", "t3", t3, "t4", t4, 0) $ |_|
                let v = black $ (t1, v_elem, t2);
                let u = black $ (t3, u_elem, t4);
                let w = u_color $ (v, w_elem, u);
                let active = false;
                (active, w)
            } else if v.get_left.is_red {
                eval _debug_eprintln_lazy(|_| "R2");
                // pattern R2
                let (w, v_elem, t3) = v.get_triplet;
                let (t1, w_elem, t2) = w.get_triplet;
                _debug_assert_level_diff("R2", "t1", t1, "t2", t2, 0) $ |_|
                _debug_assert_level_diff("R2", "t3", t3, "t4", t4, 0) $ |_|
                let w = black $ (t1, w_elem, t2);
                let u = black $ (t3, u_elem, t4);
                let v = u_color $ (w, v_elem, u);
                let active = false;
                (active, v)
            } else {
                eval _debug_eprintln_lazy(|_| "R3");
                // pattern R3
                let (t1, v_elem, t2) = v.get_triplet;
                let t3 = t4;
                let v = red $ (t1, v_elem, t2);
                _debug_assert_level_diff("R3", "v", v, "t3", t3, 0) $ |_|
                let u = black $ (v, u_elem, t3);
                let active = u_was_black;
                (active, u)
            }
        } else {    // v.is_red
            eval _debug_eprintln_lazy(|_| "R4");
            // pattern R4
            assert_lazy(|_| "R4: u_was_black", u_was_black) $ |_|
            let (t1, v_elem, t2) = v.get_triplet;
            let t3 = t4;
            let u = red $ (t2, u_elem, t3);
            let active = true;
            let (active, u) = _remove_fix_right $ (active, u);
            _debug_assert_level_diff("R4", "t1", t1, "u", u, 0) $ |_|
            let v = black $ (t1, v_elem, u);
            (active, v)
        }
    );

    _to_array_inner: [a: RBNodeElem] Array a -> RBNodeIndex -> Array a;
    _to_array_inner = |arr, node| (
        if node.is_empty { arr };
        let (left, elem, right) = node.get_triplet;
        let arr = left._to_array_inner(arr);
        let arr = arr.push_back(elem);
        let arr = right._to_array_inner(arr);
        arr
    );

    to_array: [a: RBNodeElem] RBNodeIndex -> Array a;
    to_array = |node| (
        node._to_array_inner([])
    );

    to_iter: [a: RBNodeElem] RBNodeIndex -> DynIterator a;
    to_iter = |node| (
        if node.is_empty { DynIterator::empty };
        let (left, elem, right) = node.get_triplet;
        left.to_iter._fast_append(right.to_iter.push_front(elem).to_dyn)
    );

    from_iter_lt: [a: RBNodeElem, it: Iterator, Item it = a] (a -> a -> Bool) -> it -> RBNodeIndex;
    from_iter_lt = |less_than, iter| (
        iter.fold(
            empty(), |x, node|
            let (dsize, node) = node.insert_lt(x, less_than);
            node
        )
    );

    from_iter: [a: LessThan, a: RBNodeElem, it: Iterator, Item it = a] it -> RBNodeIndex;
    from_iter = |iter| (
        iter.from_iter_lt(_less_than)
    );

}

impl [a: RBNodeElem, a: ToString] RBNodeIndex: ToString {
    to_string = |node| (
        if node.is_empty { "E" };
        let level = node.level_nonvalidate;
        let color = if node.is_black { "B" } else { "R" };
        let (left, elem, right) = node.get_triplet;
        color + "(" + left.to_string + "," + elem.to_string + "," + right.to_string + ")"
    );
}
