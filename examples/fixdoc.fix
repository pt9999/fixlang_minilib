module Main;

import Character;

import StringEx;
import SimpleParser;
import Clap;

match_type: Parser String;
match_type = do {
    let _ = *match_str("type");
    let _ = *one_or_more(match_char_class(is_space));
    let chars = *one_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    pure $ chars._unsafe_to_string
};

match_impl: Parser String;
match_impl = do {
    let _ = *match_str("impl ");
    let decl = *one_or_more(match_char_class(|c| c != '{'));
    pure $ ("impl " + decl._unsafe_to_string).strip_spaces
};

match_global: Parser ();
match_global = do {
    let _ = *match_char_class(is_lower);
    let _ = *one_or_more(match_char_class(|c| c.is_lower || c == '_'));
    let _ = *zero_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    let _ = *zero_or_more(match_char_class(is_space));
    let _ = *match_char(':');
    let _ = *zero_or_more(match_char_class(|c| c != ';'));
    let _ = *match_char(';');
    pure()    
};

match_namespace: Parser String;
match_namespace = do {
    let _ = *match_str("namespace");
    let _ = *one_or_more(match_char_class(is_space));
    let chars = *one_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    pure $ chars._unsafe_to_string
};

matches: String -> Parser a -> Result ErrMsg a;
matches = |str, parser| (
    parser.run_parser_str(str).map(|(x,_)| x)
);

type State = unbox struct {
    output: IOHandle,   // output file handle
    first_decl: Bool,   // first declaration has appered
    doc: String,        // document (function comment etc.)
    type_name: String,  // name of type declaration
    typedef: String     // body of type declaration
};

namespace State {
    make: IOHandle -> State;
    make = |output| (
        State{
            output: output,
            first_decl: false,
            doc: "",
            type_name: "",
            typedef: ""
        }
    );

    print: String -> State -> IOFail ();
    print = |str, state| (
        write_string(state.@output, str)
    );

    println: String -> State -> IOFail ();
    println = |str, state| (
        state.print(str + "\n")
    );

    print_doc: State -> IOFail State;
    print_doc = |state| (
        let _ = *if state.@doc == "" {
            state.print("") 
        } else {
            state.print(state.@doc + "\n")
        };
        pure $ state.set_doc("")
    );

    print_typedef: State -> IOFail State;
    print_typedef = |state| (
        let _ = *state.println("```");
        let _ = *state.print(state.@typedef);
        let _ = *state.println("```");
        pure $ state.set_typedef("")
    );

    process_comment: String -> State -> IOFail State;
    process_comment = |line, state| (
        let after_comment = line.get_sub(2, line.get_size).strip_spaces + "\n";
        let state = state.mod_doc(|doc| doc + after_comment);
        pure $ state
    );

    process_impl: String -> State -> IOFail State;
    process_impl = |impl_, state| (
        let _ = *state.println("#### `" + impl_ + "`\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_global: String -> State -> IOFail State;
    process_global = |line, state| (
        let _ = *state.println("#### " + line + "\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_type_decl: String -> String -> Result ErrMsg String -> State -> IOFail State;
    process_type_decl = |orig_line, line, type_name, state| (
        let state = if type_name.is_ok { 
            state.set_type_name(type_name.as_ok) 
        } else { 
            state 
        };
        let state = state.mod_typedef(|t| t + orig_line + "\n");
        if state.@typedef.find(";", 0).is_none {
            pure $ state
        };
        let _ = *state.println("### type " + state.@type_name + "\n");
        let state = *state.print_doc;
        let state = *state.print_typedef;
        pure $ state
    );

    process_namespace: String -> String -> State -> IOFail State;
    process_namespace = |line, namespace_name, state| (
        let _ = *state.println("### namespace " + namespace_name + "\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_other: String -> State -> IOFail State;
    process_other = |line, state| (
        if !state.@first_decl {
            if line == "" {
                pure $ state
            };
            let state = *state.print_doc;
            let state = state.set_first_decl(true).set_doc("");
            pure $ state
        };
        let state = state.set_doc("");
        pure $ state
    );

    process_line: String -> State -> IOFail State;
    process_line = |orig_line, state| (
        let line = orig_line.strip_spaces;
        let is_comment = line.get_sub(0, 2) == "//";
        if (is_comment) {
            state.process_comment(line)
        };
        let is_impl: Result ErrMsg String = match_impl.matches(line);
        if is_impl.is_ok {
            state.process_impl(is_impl.as_ok)
        };
        let is_global: Result ErrMsg () = match_global.matches(line);
        if is_global.is_ok {
            state.process_global(line)
        };
        let type_name: Result ErrMsg String = match_type.matches(line);
        if type_name.is_ok || state.@typedef != "" {
            state.process_type_decl(orig_line, line, type_name)
        };
        let namespace_name: Result ErrMsg String = match_namespace.matches(line);
        if namespace_name.is_ok {
            state.process_namespace(line, namespace_name.as_ok)
        };
        state.process_other(line)
    );

    process_file: String -> String -> IOHandle -> IOFail ();
    process_file = |input_filepath, contents, output| (
        let input_filename = input_filepath.split_ex("/").to_array.get_last.as_some;
        let state = State::make(output);
        let _ = *state.println("## " + input_filename);
        let _ = *state.println("");
        let state = *contents.split("\n").loop_iter_m(
            state,
            |state, orig_line|
            let state = *state.process_line(orig_line);
            continue_m $ state
        );
        pure $ ()
    );
}

command: Command;
command = (
    Command::new("fixdoc")
    .version("0.1.0")
    .about("Output a reference document from a fix source file")
    .arg(Arg::new("FILE").help("Input file (*.fix)").required.takes_value)
    .arg(Arg::new("output").short('o').long("output").help("Output file").takes_value)
);

main: IO ();
main = (
    do {
        let matches = *command.get_matches;
        let input_file = matches.get_one("FILE").as_some;
        let output_file = matches.get_one("output");
        let output = *if output_file.is_some {
            open_file(Path::parse(output_file.as_some).as_some, "w")
        } else {
            pure $ IO::stdout
        };
        let contents = *read_file_string(Path::parse(input_file).as_some);
        let _ = *process_file(input_file, contents, output);
        pure()
    }
    .try(|err| eprintln (err))
);
