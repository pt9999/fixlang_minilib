// NFA (Nondeterministic Finite Automaton)
//
// For details, see web pages below.
// - https://swtch.com/~rsc/regexp/regexp1.html
// - https://zenn.dev/canalun/articles/regexp_and_automaton

module RegExpNFA;

import Character;
import Debug;

import SimpleParser;
import StringEx;

import RegExpPattern;

// NFA
type NFA = unbox struct {
    group_count: I64,           // group count
    states: Array NFAState,     // array of states
    initial_state: I64,         // initial state
    accepting_state: I64         // accepting state
};

namespace NFA {
    // An empty NFA.
    empty: NFA;
    empty = NFA {
        group_count: 0,
        states: Array::empty(0),
        initial_state: _ID_NONE,
        accepting_state: _ID_NONE
    };

    // Creates new state. Returns the new state id.
    new_state: NFA -> (NFA, I64);
    new_state = |nfa| (
        let id = nfa.@states.get_size;
        let state = NFAState::empty;
        let state = state.set_id(id);
        let nfa = nfa.mod_states(push_back(state));
        (nfa, id)
    );

    // `nfa.get_state(id)` gets the state whose @id is `id`.
    get_state: I64 -> NFA -> NFAState;
    get_state = |id, nfa| (
        nfa.@states.@(id)
    );

    // `nfa.mod_state(id, f)` modifies the state whose @id is `id`.
    mod_state: I64 -> (NFAState -> NFAState) -> NFA -> NFA;
    mod_state = |id, f, nfa| (
        nfa.mod_states(|states| states.set(id, f(states.@(id))))
    );

    // `nfa.set_frag_output(frag, out)` sets the output of the fragment to `out`.
    set_frag_output: NFAFrag -> I64 -> NFA -> NFA;
    set_frag_output = |frag, out, nfa| (
        (frag.@set_output)(out, nfa)
    );

    // `NFA::compile(pattern)` compiles a pattern to NFA.
    compile: Pattern -> NFA;
    compile = |pattern| (
        let nfa = NFA::empty;
        let (group_count, pattern) = pattern._assign_group_number(0);
        let nfa = nfa.set_group_count(group_count);
        let (nfa, frag) = nfa.compile_pattern(pattern);
        let nfa = nfa.set_initial_state(frag.@input);
        let (nfa, accept_id) = nfa.new_state;
        let nfa = nfa.set_accepting_state(accept_id);
        let nfa = nfa.set_frag_output(frag, accept_id);
        nfa
    );

    // `nfa.execute(stream)` executes matching.
    execute: Stream -> NFA -> Option GroupArray;
    execute = |stream, nfa| (
        let executor = NFAExecutor::make(stream, nfa);
        executor.execute
    );

}

impl NFA: ToString {
    to_string = |nfa| (
        "NFA { states=\n"
        + nfa.@states.to_iter.map(|s| "  " + s.to_string + "\n").concat_iter
        + "  initial_state=" + nfa.@initial_state.to_string + "\n"
        + "  accepting_state=" + nfa.@accepting_state.to_string + "\n"
        +"}"
    );
}

type NFAStateAction = unbox union {
    sa_none: (),
    sa_char_match: CharClass,
    sa_assert: PAssertion,
    sa_group_begin: I64,
    sa_group_end: I64
};

impl NFAStateAction: ToString {
    to_string = |a| (
        if a.is_sa_none { "none" };
        if a.is_sa_char_match { a.as_sa_char_match.to_string };
        if a.is_sa_assert { a.as_sa_assert.to_string };
        if a.is_sa_group_begin { "<g" + a.as_sa_group_begin.to_string + ">" };
        if a.is_sa_group_end { "</g" + a.as_sa_group_end.to_string + ">" };
        ""
    );
}

// An NFA state
type NFAState = unbox struct {
    id: I64,                    // state id
    action: NFAStateAction,     // action
    output_on_action: I64,      // next state when the action succeeded
    output: I64,                // next state with empty string
    output2: I64,               // next state with empty string part 2
    label: String               // a label to display
};

namespace NFAState {
    // An invalid state ID.
    _ID_NONE: I64;
    _ID_NONE = -1;

    // An empty state
    empty: NFAState;
    empty = NFAState {
        id: _ID_NONE,
        action: sa_none(),
        output_on_action: _ID_NONE,
        output: _ID_NONE,
        output2: _ID_NONE,
        label: ""
    };
}

impl NFAState: ToString {
    to_string = |state| (
        "("
        + state.@id.to_string + ":"
        + state.@action.to_string + ":"
        + state.@output_on_action.to_string + ","
        + state.@output.to_string + ","
        + state.@output2.to_string + ":"
        + state.@label
        + ")"
    );
}


// NFA Fragment
type NFAFrag = unbox struct {
    input: I64,                 // state id of input of this fragment
    set_output: I64 -> NFA -> NFA,  // a function to set state id of output
                                    // of this fragment
    label: String               // a label to display
};

namespace NFAFrag {

    // `nfa.compile_pattern(pattern)` compiles a pattern to a NFAFrag.
    compile_pattern: Pattern -> NFA -> (NFA, NFAFrag);
    compile_pattern = |pat, nfa| (
        if pat.is_pclass {
            let action = sa_char_match (pat.as_pclass);
            nfa._compile_action(action)
        };
        if pat.is_psequence {
            let patterns = pat.as_psequence;
            if patterns.get_size == 0 {
                nfa._compile_null_sequence
            };
            if patterns.get_size == 1 {
                nfa.compile_pattern(patterns.@(0))
            };
            let (nfa, frag1) = nfa.compile_pattern(
                psequence $ patterns.pop_back);
            let (nfa, frag2) = nfa.compile_pattern(
                patterns.get_last.as_some);
            nfa._compile_seq(frag1, frag2)
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa.compile_pattern(pat2);
            nfa._compile_either(frag1, frag2)
        };
        if pat.is_pquant {
            let (pat1, min, max) = pat.as_pquant;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            if (min == 0 && max == 1) {
                nfa._compile_zero_or_once(frag1)
            };
            if (min == 0 && max == I64::maximum) {
                nfa._compile_zero_or_more(frag1)
            };
            if (min == 1 && max == I64::maximum) {
                nfa._compile_one_or_more(frag1)
            };
            if (min >= 2) {
                let (nfa, frag2) = nfa.compile_pattern(pquant $
                        (pat1, min - 1,
                            if max == I64::maximum { max } else { max - 1}
                        )
                );
                // TODO: frag1 の中にグループがあったら？
                nfa._compile_seq(frag1, frag2)
            };
            eval assert (|_|"invalid quantifier: min=" + min.to_string, false);
            (nfa, frag1)
        };
        if pat.is_pgroup {
            let (n, pat1) = pat.as_pgroup;
            let (nfa, frag0) = nfa._compile_action(sa_group_begin(n));
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa._compile_action(sa_group_end(n));
            let (nfa, frag) = nfa._compile_seq(frag0, frag1);
            let (nfa, frag) = nfa._compile_seq(frag, frag2);
            (nfa, frag)
        };
        if pat.is_passert {
            nfa._compile_action(sa_assert(pat.as_passert))
        };
        eval assert (|_|"invalid pattern:" + pat.to_string, false);
        nfa._compile_action(sa_none())
    );

    _compile_action: NFAStateAction -> NFA -> (NFA, NFAFrag);
    _compile_action = |action, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_action(action));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output_on_action(out))
            ),
            label: action.to_string
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // ``
    _compile_null_sequence: NFA -> (NFA, NFAFrag);
    _compile_null_sequence = |nfa| (
        let (nfa, id) = nfa.new_state;
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output(out))
            ),
            label: "``"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e1 e2`
    _compile_seq: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_seq = |frag1, frag2, nfa| (
        let nfa = nfa.set_frag_output(frag1, frag2.@input);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag2, out)
            ),
            label: frag1.@label + frag2.@label
        };
        (nfa, frag)
    );

    // `e1|e2`
    _compile_either: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_either = |frag1, frag2, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.mod_state(id, set_output2(frag2.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag1, out)
                   .set_frag_output(frag2, out)
            ),
            label: frag1.@label + "|" + frag2.@label
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)

    );

    // `e?`
    _compile_zero_or_once: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_once = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                let nfa = nfa.set_frag_output(frag1, out);
                nfa.mod_state(id, set_output2(out))
            ),
            label: frag1.@label + "?"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e*`
    _compile_zero_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id,set_output2(out))
            ),
            label: frag1.@label + "*"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e+`
    _compile_one_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_one_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output2(out))
            ),
            label: frag1.@label + "+"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );
}

// Matched group
type Group = unbox struct {
    begin: I64,         // position of the start of the group
    end: I64            // position of the end of the group
};

impl Group: ToString {
    to_string = |group| (
        "Group{"
        + "begin:" + group.@begin.to_string
        + ", end:" + group.@end.to_string
        + "}"
    ) ;
}

// The array of matched groups
type GroupArray = Array (Option Group);


// NFA State set, used for NFA state transition
type NFAStateSet = unbox struct {
    ordered: Array (I64, GroupArray),   // array of state id and groups
    mask: Array Bool       // mask whether id is contained or not
};

namespace NFAStateSet {

    // `NFAStateSet::empty(n)` creates an empty state set.
    // `n` is number of NFA states.
    empty: I64 -> NFAStateSet;
    empty = |n| NFAStateSet {
        ordered: Array::empty(n),
        mask:  Array::fill(n, false)
    };

    // Checks whether the state set is empty.
    is_empty: NFAStateSet -> Bool;
    is_empty = |state_set| (
        state_set.@ordered.is_empty
    );

    // Checks whether the state set contains a state.
    contains: I64 -> NFAStateSet -> Bool;
    contains = |id, state_set| (
        state_set.@mask.@(id)
    );

    // Adds a state to the state set.
    add: (I64, GroupArray) -> NFAStateSet -> NFAStateSet;
    add = |(id, groups), state_set| (
        if state_set.contains(id) { state_set };
        let state_set = state_set.mod_ordered(push_back((id, groups)));
        let state_set = state_set.mod_mask(set(id, true));
        state_set
    );

    get_groups: I64 -> NFAStateSet -> Option GroupArray;
    get_groups = |id, state_set| (
        state_set.@ordered.to_iter.filter(|(id1,_)| id1 == id)
        .get_first
        .map(|(id, groups)| groups)
    );
}

// The NFA executor
type NFAExecutor = unbox struct {
    stream: Stream,            // stream of characters
    nfa: NFA,                       // NFA
    empty_state_set: NFAStateSet,   // an empty state set
    state_set: NFAStateSet,         // current state set
    stack: Iterator (I64, GroupArray) // temporary stack for transition
};

namespace NFAExecutor {
    // Creates an executor.
    make: Stream -> NFA -> NFAExecutor;
    make = |stream, nfa| (
        let empty_state_set = NFAStateSet::empty(nfa.@states.get_size);
        let groups: GroupArray = Array::fill(nfa.@group_count, none());
        let state_set = empty_state_set.add((nfa.@initial_state, groups));
        NFAExecutor {
            stream: stream,
            nfa: nfa,
            empty_state_set: empty_state_set,
            state_set: state_set,
            stack: Iterator::empty
        }
    );

    execute: NFAExecutor -> Option GroupArray;
    execute = |executor| (
        loop(
            executor, |executor|
            let executor = executor.transition_with_empty_string;
            if executor.@state_set.contains(executor.@nfa.@accepting_state) {
                let opt = executor.@state_set.get_groups(executor.@nfa.@accepting_state);
                eval assert (|_|"not found groups", opt.is_some);
                break $ some $ opt.as_some   // match success
                // TODO: 現状では受理状態になったらループを抜けるため、最短一致になる。
            };
            executor.@stream.advance.map_or(
                break $ none(),  // failed to match
                |(c, stream)|
                let executor = executor.transition_with_char(c);
                let executor = executor.set_stream(stream);
                eval debug_println("stream position="+stream.@position.to_string);
                continue $ executor
            )
        )
    );

    transition_with_empty_string: NFAExecutor -> NFAExecutor;
    transition_with_empty_string = |executor| (
        let executor = executor._init_transition;
        loop(
            executor, |executor|
            let opt = executor._pop_stack;
            if opt.is_none {
                break $ executor
            };
            let ((id, groups), executor) = opt.as_some;
            let state = executor.@nfa.get_state(id);
            let executor = executor._transition(state.@output, groups);
            let executor = executor._transition(state.@output2, groups);
            let executor = executor._transition_on_action(state, state.@output_on_action, groups);
            continue $ executor
        )
    );

    _init_transition: NFAExecutor -> NFAExecutor;
    _init_transition = |executor| (
        executor.set_stack(executor.@state_set.@ordered.to_iter)
    );

    _pop_stack: NFAExecutor -> Option ((I64, GroupArray), NFAExecutor);
    _pop_stack = |executor| (
        executor.@stack.advance.map(|(id_groups, next)|
            (id_groups, executor.set_stack(next))
        )
    );

    // Adds state id to the state set, then pushes id to the stack.
    _transition: I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition = |id, groups, executor| (
        if id == _ID_NONE {
            executor
        };
        if executor.@state_set.contains(id) {
            executor
        };
        eval debug_eprintln("transition " + id.to_string + " groups="+groups.to_string);
        executor
            .mod_state_set(add((id, groups)))
            .mod_stack(push_front((id, groups)))
    );
    
    _transition_on_action: NFAState -> I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition_on_action = |state, id, groups, executor| (
        let action = state.@action;
        if action.is_sa_assert {
            executor._transition_with_passert(action.as_sa_assert, id, groups)
        };
        if action.is_sa_group_begin {
            let group_idx = action.as_sa_group_begin;
            let begin = executor.@stream.@position;
            let group = Group { begin: begin, end: -1 };
            let groups = groups.set(group_idx, some(group));
            executor._transition(id, groups)
        };
        if action.is_sa_group_end {
            let group_idx = action.as_sa_group_end;
            let begin = groups.@(group_idx).map_or(-1, |group| group.@begin);
            let end = executor.@stream.@position;
            let group = Group { begin: begin, end: end };
            let groups = groups.set(group_idx, some(group));
            executor._transition(id, groups)
        };
        executor
    );

    _transition_with_passert: PAssertion -> I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition_with_passert = |pa, id, groups, executor| (
        if pa.is_pa_begin && executor.@stream.@position == 0 {
            executor._transition(id, groups)
        };
        if pa.is_pa_end && executor.@stream.@iter.is_empty {
            executor._transition(id, groups)
        };
        executor
    );

    transition_with_char: U8 -> NFAExecutor -> NFAExecutor;
    transition_with_char = |char, executor| (
        let old_states = executor.@state_set.@ordered.to_iter;
        let executor = old_states.fold(
            // Clear new state set
            executor.set_state_set(executor.@empty_state_set),
            |executor, (id, groups)|
            // For each old state:
            let state = executor.@nfa.get_state(id);
            let action = state.@action;
            if !action.is_sa_char_match {
                executor
            };
            if !action.as_sa_char_match.contains(char) {
                executor
            };

            // note: stack is not used
            executor._transition(state.@output_on_action, groups)
        );
        let executor = executor.set_stack(Iterator::empty);
        executor
    );
}
