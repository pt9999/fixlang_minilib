module Main;

import Debug;
import Random;

import Minilib.Math.BigInt;
import Minilib.Testing.Timeit;

namespace BigIntRandom {

    ipow: BigInt -> U64 -> BigInt;
    ipow = |a, n| (
        loop(
            (BigInt::from_I64(1), a, n), |(prod, a, n)|
            if n == 0_U64 {
                break $ prod
            };
            let prod = if n.bit_and(1_U64) != 0_U64 {
                prod * a
            } else { prod };
            continue $ (prod, a*a, n.shift_right(1_U64))
        )
    );

    // Calculates `a^n mod m`.
    modpow: BigInt -> BigInt -> BigInt -> BigInt;
    modpow = |a, n, m| (
        loop(
            (BigInt::one, a, n), |(prod, a, n)|
            if n == zero {
                break $ prod
            };
            let (quo, rem) = BigInt::divmod(n, BigInt::two);
            let prod = if rem != zero {
                prod * a
            } else { prod };
            let prod = prod % m;
            let a = (a * a) % m;
            continue $ (prod, a, quo)
        )
    );


    generate_range: BigInt -> BigInt -> Random -> (BigInt, Random);
    generate_range = |begin, end, random| (
        if begin > end {
            generate_range(end, begin, random)
        };
        let n = end - begin;
        eval assert(|_| "invalid range", n > zero);
        let size = n.@nat.get_size;
        let (nat, random) = loop(
            ([], 0, random), |(nat, i, random)|
            let (u64, random) = random.generate_U64;
            if i == size - 1 {
                let m = n.@nat.@(size - 1).to_U64;
                let m1 = m + 1_U64;
                if u64 >= U64::maximum / m1 * m1 {
                    continue $ (nat, i, random)     // try again
                };
                // choose 0..m uniformly
                let u32 = (u64 / (U64::maximum / m1)).to_U32;
                let nat = nat.push_back(u32);
                break $ (nat, random)
            };
            let (_, rem) = BigNat::_divmod_base(u64);
            let nat = nat.push_back(rem.to_U32);
            continue $ (nat, i + 1, random)
        );
        let r = BigInt::make(1, nat);
        if r >= n {
            generate_range(begin, end, random)      // try again
        };
        (r, random)
    );

    // Miller-Rabin primality test.
    // Returns true if `n` is probably prime.
    miller_rabin: BigInt -> Random -> (Bool, Random);
    miller_rabin = |n, random| (
        // For optimization purposes, let's check if `n` is divisible by a small prime number.
        let (_, rem) = BigInt::divmod(n, BigInt::from_I64(2*3*5*7));
        let rem = rem.to_I64;
        if rem % 2 == 0 || rem % 3 == 0 || rem % 5 == 0 || rem % 7 == 0 {
            // composite
            (false, random)
        };
        // Determine `s` and `d` such that `n - 1 == 2^s * d`.
        let n_minus_one = n - BigInt::one;
        let (s, d) = loop(
            (0, n_minus_one), |(s, d)|
            let (quo, rem) = BigInt::divmod(d, BigInt::two);
            if rem.to_I64 != 0 {
                break $ (s, d)
            };
            continue $ (s+1, quo)
        );
        // `k` is the number of rounds of testing to perform.
        // Accoding to Wikipedia, probability of false prime <= `4^(-k)`.
        let k = 50;
        loop(
            (k, random), |(k, random)|
            if k < 0 {
                // probably prime
                break $ (true, random)
            };
            let (a, random) = random.generate_range(two, n - two);
            let x = modpow(a, d, n);
            let (opt, y) = loop(
                (s, x, x), |(s, x, y)|
                if s < 0 {
                    break $ (none(), y)
                };
                let y = (x*x) % n;
                if y == one && x != one && x != n_minus_one {
                    // composite
                    break $ (some(false), y)
                }; 
                let x = y;
                continue $ (s-1, x, y)
            );
            if opt.is_some {
                break $ (opt.as_some, random)
            };
            if y != one {
                // composite
                break $ (false, random)
            }; 
            continue $ (k - 1, random) 
        )
    );
}


or_abort: Result ErrMsg a -> a;
or_abort = |res| (
    if res.is_err {
        eval debug_eprintln("error: " + res.as_err);
        abort()
    };
    res.as_ok
);

main1: IO ();
main1 = (
    let a: BigInt = *timeit("a", |_| from_string("10000000000000000000000000000000000000000000000000000000000000000000000").or_abort);
    let b: BigInt = *timeit("b", |_| from_string("7777777777777777").or_abort);
    let _ = *timeit("a==b", |_| a==b);
    let _ = *timeit("a>b", |_| a>b);
    let _ = *timeit("a>=b", |_| a>=b);
    let _ = *timeit("a+b", |_| a+b);
    let _ = *timeit("a-b", |_| a-b);
    let _ = *timeit("a*b", |_| a*b);
    let _ = *timeit("a/b", |_| a/b);
    let _ = *timeit("a%b", |_| a%b);
    let _ = *timeit("b/a", |_| b/a);
    let _ = *timeit("b%a", |_| b%a);
    let _ = *timeit("a/a", |_| a/a);
    let _ = *timeit("a%a", |_| a%a);
    let _ = *notimeit("from_U64(U64::maximum)", |_| BigInt::from_U64(U64::maximum));
    let _ = *notimeit("from_U64(U64::minimum)", |_| BigInt::from_U64(U64::minimum));
    let _ = *notimeit("from_I64(I64::maximum)", |_| BigInt::from_I64(I64::maximum));
    let _ = *notimeit("from_I64(I64::minimum)", |_| BigInt::from_I64(I64::minimum));
    let _ = *notimeit("(-1 * 0).@sign", |_| (BigInt::from_I64(-1) * BigInt::from_I64(0)).@sign);
    pure()
);

main: IO ();
main = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(time.to_U64);
    let a = ipow(two, 256_U64);
    let (b, random) = random.generate_range(zero, a);
    //let _ = *println(a.to_string);
    let _ = *loop_m(
        (b, random), |(b, random)|
        // Miller-Rabin Primality test. 2^-100
        let (ret, random) = miller_rabin(b, random);
        let _ = *println(b.to_string + ": " + if ret { "prime" } else { "composite" });
        if ret {
            break_m $ ()
        };
        continue_m $ (b + one, random)
    );
    pure()
);
