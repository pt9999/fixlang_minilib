// simple parser
module SimpleParser;

import Debug;
import Character;

type Char = U8;

_NEWLINE: Char;
_NEWLINE = 10_U8;

namespace CharArray {
    _unsafe_to_string: Array Char -> String;
    _unsafe_to_string = |a| (
        String::_unsafe_from_c_str (a.push_back(0_U8))
    );
}

namespace Stream {
    type Stream = box struct {
        filename: String,
        line: I64,
        column: I64,
        position: I64,
        iter: Iterator Char
    };

    empty: Stream;
    empty = Stream{
        filename: "",
        line: 0,
        column: 0,
        position: 0,
        iter: Iterator::empty
    };
    
    advance: Stream -> Option (Char, Stream);
    advance = |s| (
        let (c, next) = *(s.@iter.advance);
        eval debug_eprintln("advance: c="+c.to_string + " pos=" + s.@position.to_string);
        let s = s.set_iter(next);
        let s = if c == _NEWLINE {
            s.set_line(s.@line + 1).set_column(0)
        } else {
            s.set_column(s.@column + 1)
        };
        let s = s.set_position(s.@position + 1);
        pure $ (c, s)
    );

    read_all: Stream -> (Array Char, Stream);
    read_all = |s| (
        let arr = Array::empty(100);
        loop(
            (arr, s), |(arr, s)|
            let opt = s.advance;
            if opt.is_none {
                break $ (arr, s)
            };
            let (c, s) = opt.as_some;
            let arr = arr.push_back(c);
            continue $ (arr, s)
        )
    );

    error: String -> Stream -> Result ErrMsg a;
    error = |str, s| (
        let msg = 
            if s.@filename == "" { "" } else { s.@filename + " " } + 
            "line " + s.@line.to_string +
            ", column " + s.@column.to_string + 
            ": ";
        err $ msg + str
    );
}

impl Stream: FromString {
    from_string = |str| (
        pure $ Stream::empty.set_iter(str.get_bytes.pop_back.to_iter)
    );
}


type ParseResult a = Result ErrMsg (a, Stream);

impl [a: ToString] ParseResult a: ToString {
    to_string = |res| (
        if res.is_err {
            "err(" + res.as_err + ")"
        };
        let (c, s) = res.as_ok;
        "(" + c.to_string + ", pos=" + s.@position.to_string + ")"
    );
}

_Fail: ErrMsg;
_Fail = "Fail";


type Parser a = Stream -> ParseResult a;

namespace Parser {
    run_parser: Stream -> Parser a -> ParseResult a;
    run_parser = |s, p| p(s);

    run_parser_str: String -> Parser a -> ParseResult a;
    run_parser_str = |str, p| 
        let s: Stream = *(from_string(str));
        p(s);

    // Transform the parse result value.
    map: (a -> b) -> Parser a -> Parser b;
    map = |f, p| |s| (
        let (c, s) = *(p.run_parser(s));
        pure $ (f(c), s)
    );

    map_parser: (a -> b) -> Parser a -> Parser b;
    map_parser = map;

    bind_parser: (a -> Result ErrMsg b) -> Parser a -> Parser b;
    bind_parser = |f, p| |s| (
        let (c, s) = *(p.run_parser(s));
        let fc = f(c);
        if fc.is_err {
            err $ fc.as_err
        };
        pure $ (fc.as_ok, s)
    );

    debug_parser: (ParseResult a -> String) -> Parser a -> Parser a;
    debug_parser = |msg, p| |s| (
        let res = p.run_parser(s);
        eval debug_println(msg(res));
        res
    );

    // Match zero-length string.
    unit: Parser ();
    unit = |s| pure $ ((), s);

    keep_left: (a, b) -> a;
    keep_left = |(a,b)| a;

    keep_right: (a, b) -> b;
    keep_right = |(a,b)| b;

    keep_both: (a, b) -> (a, b);
    keep_both = |(a,b)| (a,b);

    drop_both: (a, b) -> ();
    drop_both = |(a,b)| ();

    then: ((a, b) -> c) -> Parser b -> Parser a -> Parser c;
    then = |keep, pb, pa| |s| (
        let (a, s) = *(pa.run_parser(s));
        let (b, s) = *(pb.run_parser(s));
        pure $ (keep((a, b)), s)
    );

    or_else: Parser a -> Parser a -> Parser a;
    or_else = |pa2, pa1| |s| (
        let res = pa1.run_parser(s);
        if res.is_ok {
            pure $ res.as_ok
        };
        pa2.run_parser(s)
    );

    or_error: String -> Parser a -> Parser a;
    or_error = |msg, p| |s| (
        let res = p.run_parser(s);
        if res.is_ok {
            pure $ res.as_ok
        };
        s.error(msg)
    );

    forget: Parser a -> Parser ();
    forget = |p| p.map(|_| ());

    repeat: Parser a -> Parser (Array a);
    repeat = |p| |s| (
        let array = Array::empty(100);
        loop(
            (array, s), |(array, s)|
            let old_position = s.@position;
            let res = p.run_parser(s);
            if res.is_err {
                break $ pure $ (array, s)
            };
            let (a, s) = res.as_ok;
            if s.@position == old_position {
                // Avoid infinite loop. (fool-proof)
                break $ pure $ (array, s)
            };
            let array = array.push_back(a);
            continue $ (array, s)
        )
    );

    zero_or_more: Parser a -> Parser (Array a);
    zero_or_more = repeat;

    one_or_more: Parser a -> Parser (Array a);
    one_or_more = |p| (
        repeat(p).filter(|array| array.get_size >= 1)
    );

    // Match zero-length string at the end of stream.
    match_end_of_stream: Parser ();
    match_end_of_stream = |s| (
        if s.advance.is_some {
            s.error("End of stream expected")
        };
        pure $ ((), s)
    );

    // Matches a character of any kind.
    any_char: Parser Char;
    any_char = |s| (
        s.advance.map_or(
            err $ _Fail,
            |(c, next)| pure $ (c, next)
        )
    );

    // Matches a character specified by `chr`, or fail.
    match_char: Char -> Parser ();
    match_char = |chr| |s| (
        s.advance.map_or(
            err $ _Fail,
            |(c, next)| if c != chr { err $ _Fail } else { pure $ ((), next) }
        )
    );

    // Matches a string specified by `str`, or fail.
    match_str: String -> Parser ();
    match_str = |str| (
        if str.get_size == 1 { // Optimization
            match_char(str.get_first_byte.as_some)
        };
        str.get_bytes.pop_back.to_iter.fold(
            unit,
            |p, c| p.then(|(a,b)| (), match_char(c))
        )
    );

    // Fail if specified condition does not met.
    filter: (a -> Bool) -> Parser a -> Parser a;
    filter = |f, p, s| (
        let (c, next) = *(p(s));
        if !f(c) {
            err $ _Fail
        };
        pure $ (c, next)
    );

    class: (Char -> Bool) -> Parser String;
    class = |f, s| (
        let arr: Array Char = Array::empty(100);
        loop(
            (arr, s), |(arr, s)|
            let opt = s.advance;
            if opt.is_none {
                break $ ok $ (arr._unsafe_to_string, s)
            };
            let (c, next) = opt.as_some;
            if !f(c) {
                break $ ok $ (arr._unsafe_to_string, s)
            };
            let arr = arr.push_back(c);
            continue $ (arr, next)
        )
    );

    class_whitespace: Parser String;
    class_whitespace = class(Character::is_space);
    
    class_lower: Parser String;
    class_lower = class(Character::is_lower);

    class_digit: Parser String;
    class_digit = class(Character::is_digit);

    integer: Parser I64;
    integer = |s| (
        let (digit, next) = *(class_digit.run_parser(s));
        if (digit.get_size == 0) {
            err $ _Fail
        };
        let n = *(from_string(digit));
        ok $ (n, next)
    );
}

/*
impl Parser: Monad {
    pure = |a| |s| ok $ (a, s);
    bind = |f, p| |s| (
        let (a, s) = *(p.run_parser(s));
        ok $ (f(a), s)
    );
}
*/