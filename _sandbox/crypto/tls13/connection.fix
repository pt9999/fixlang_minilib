module Minilib.Crypto.Tls13.Connection;

import Debug;

import Minilib.Monad.State;
import Minilib.Monad.Trans;
import Minilib.Net.Tcp;
import Minilib.Text.Hex;

trait TLSConnection = Functor + Monad + TLSConnectionIF;

trait [m: * -> *] m: TLSConnectionIF {
    send_bytes: Array U8 -> m ();
    recv_n_bytes: I64 -> m (Array U8);
}

trait a: ByteIO {
    // type IOType a: * -> *;
    send: Array U8 -> a -> IOFail ();
    recv: I64 -> a -> IOFail (Array U8);
}

impl Socket: ByteIO {
    // type IOType Socket = IOFail;
    send = |bytes, sock| (
        let expected_length = bytes.get_size;
        let actual_length = *sock.Socket::send(bytes); // TODO check size
        eval debug_eprintln("sent:" + actual_length.to_string + " bytes: " + bytes.to_string_hex);
        if actual_length < expected_length {
            throw $ "send error: expected=" + expected_length.to_string
                    + " actual=" + actual_length.to_string
        };
        pure()
    );
    recv = |length, sock| (
        let bytes = *sock.Socket::recv(length);
        pure $ bytes
    );
}

trait a: GetByteIO {
    type ByteIOType a;
    get_byte_io: a -> ByteIOType a;
}

impl [s: GetByteIO, bio: ByteIO, ByteIOType s = bio]
    StateT s IOFail: TLSConnectionIF {
    send_bytes = |bytes| (
        let byte_io = (*get_state).get_byte_io;
        byte_io.ByteIO::send(bytes).lift_t
    );

    recv_n_bytes = |length| (
        let byte_io = (*get_state).get_byte_io;
        byte_io.ByteIO::recv(length).lift_t
    );
}
