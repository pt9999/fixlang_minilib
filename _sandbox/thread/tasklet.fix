module Main;

import AsyncTask;
import Minilib.Common.TimeEx;
import Minilib.Thread.Future;
import Minilib.Thread.TaskPool;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Monad.Trans;
import Minilib.Trait.Traversable;

type RIO e a = ReaderT e IOFail a;

trait e: HasTaskPool {
    get_taskpool: e -> Var TaskPool;
}

impl Var TaskPool: HasTaskPool {
    get_taskpool = |e| e;
}

trait pool: MakeFuture {
    make_future: [m: MonadIOFail] IO a -> pool -> m (Future a);
}

impl Var TaskPool: MakeFuture {
    make_future = |io, var_pool| (
        var_pool.lock(|pool|
            Future::make(pool, io).to_result
        ).from_io_result.lift_iofail
    );
}

type Tasklet e a = unbox union {
    tl_pure: a,
    tl_rio: RIO e (Future (Result ErrMsg a))
};

namespace Tasklet {
    from_rio: RIO e (Future (Result ErrMsg a)) -> Tasklet e a;
    from_rio = Tasklet::tl_rio;

    from_iofail: [e: HasTaskPool] IOFail a -> Tasklet e a;
    from_iofail = |iof| (
        Tasklet::from_rio $ do {
            let var_pool = (*ask).get_taskpool;
            var_pool.make_future(iof.to_result)
        }
    );

    run: Tasklet e a -> RIO e (Future (Result ErrMsg a));
    run = @data;

    then: [e: HasTaskPool] (a -> Tasklet e b) -> Tasklet e a -> Tasklet e b;
    then = |f, tasklet| (
        match tasklet {
            tl_pure(a) => f(a),
            tl_rio(rio) => Tasklet::from_rio $ do {
                let var_pool =  (*ask).get_taskpool;
                let future = *rio;
                let res_a = *future.get.lift_iofail;
                match res_a {
                    err(e) => throw(e).lift_iofail, // TODO: this causes failure of RIO
                    ok(a) => (
                        let tasklet = f(a);
                        let res = *tasklet.get;
                        let iof = res.from_result;
                        var_pool.make_future(iof.to_result)
                    )
                }
            }
        }
    );

    catch: [e: HasTaskPool] (ErrMsg -> IOFail a) -> Tasklet e a -> Tasklet e a;
    catch = |f, tasklet| (
        match tasklet {
            tl_pure(a) => tl_pure(a),
            tl_rio(rio) => Tasklet::from_rio $ do {
                let var_pool =  (*ask).get_taskpool;
                let future = *rio;
                let iof = do {
                    let res_a = *future.get;
                    match res_a {
                        err(e) => f(e),
                        ok(a) => pure $ a
                    }
                };
                var_pool.make_future(iof.to_result)
            }
        }
    );

    get: [e: HasTaskPool] Tasklet e a -> RIO e (Result ErrMsg a);
    get = |tasklet| (
        match tasklet {
            tl_pure(a) => pure $ pure $ a,
            tl_rio(rio) => (
                let future = *rio;
                future.get.lift_iofail
            )
        }
    );

    get_all: [e: HasTaskPool] Array (Tasklet e a) -> RIO e (Array (Result ErrMsg a));
    get_all = |tasklets| (
        tasklets.to_iter.map(get).collect_m
    );
}

impl [e: HasTaskPool] Tasklet e: Monad {
    pure = |a| tl_pure(a);
    bind = Tasklet::then;
}

impl [e: HasTaskPool] Tasklet e: MonadIOIF {
    lift_io = lift >> lift_iofail;
}

impl [e: HasTaskPool] Tasklet e: MonadIOFailIF {
    lift_iofail = Tasklet::from_iofail;
}


test1: IO ();
test1 = do {
    println("=== test1 ===").lift;;
    let rio: RIO (Var TaskPool) () = do {
        let tasklets = range(0,8).map(|i|
            let tasklet = Tasklet::from_iofail(do {
                usleep((100 * (i+1)).to_U32);;
                //if i % 2 == 1 { throw $ "fail" + i.to_string };
                pure $ i
            });
            let tasklet = tasklet.then(|i| pure $ "success" + i.to_string);
            let tasklet = tasklet.catch(|err| pure $ "error:" + err);
            let tasklet = tasklet.then(|str| println(str).lift_io);
            tasklet
        ).to_array;
        tasklets.get_all.forget;;
        usleep(10000000_U32).lift_iofail;;
        pure()
    };
    let pool = *TaskPool::make(3).lift;
    let var_pool = *Var::make(pool).lift;
    rio.run_reader_t(var_pool)
}.try(eprintln);

main: IO () = test1;
