module Main;

import Sandbox.ECDSA;
import Minilib.Crypto.SecureRandom;
import Minilib.Text.Hex;

test1: IO ();
test1 = (
    do {
        let ec = secp256r1;
        let _ = *println("ec="+ec.to_string).lift;
        let secure_random = *SecureRandom::make;
        let (key_pair, _) = *secure_random.generate_keypair(ec);
        let _ = *println("key_pair=" + key_pair.to_string).lift;

        let _ = *println("validating public key q").lift;
        let _ = *key_pair.@q.validate_pubkey.from_result;

        let _ = *println("convert q to bytes (uncompressed)").lift;
        let q_bytes = key_pair.@q.to_bytes_uncompressed;
        let _ = *println("q_bytes=" + q_bytes.to_string_hex).lift;

        let _ = *println("convert bytes to q").lift;
        let q: ECPoint = *from_bytes_ec(ec, q_bytes).from_result;
        let _ = *println("q=" + q.to_string).lift;

        let _ = *println("convert q to byte (compressed)").lift;
        let q_bytes = key_pair.@q.to_bytes_compressed;
        let _ = *println("q_bytes=" + q_bytes.to_string_hex).lift;

        let _ = *println("convert bytes to q").lift;
        let q: ECPoint = *from_bytes_ec(ec, q_bytes).from_result;
        let _ = *println("q=" + q.to_string).lift;
        pure()
    }.try(eprintln)
);

main: IO ();
main = (
    test1
);
