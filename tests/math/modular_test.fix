module Main;

import Math;

import Minilib.Math.Modular;
import Minilib.Math.Types;
import Minilib.Testing.UnitTest;
import Minilib.Text.StringEx;

test_make: TestCase;
test_make = (
    make_table_test("test_make",
        [
            (1, 6, 1, 6),
            (7, 6, 1, 6),
            (-11, 6, -5, 6),
            (1, -6, 1, -6),
            (7, -6, 1, -6),
            (-11, -6, -5, -6),
            (1, 0, 1, 0)
        ],
        |(a, m, exp_a, exp_m)|
        let mod = Modular::make(a, m);
        let _ = *assert_equal("value", exp_a, mod.@value);
        let _ = *assert_equal("modulus", exp_m, mod.@modulus);
        pure()
    )
);

test_modulo: TestCase;
test_modulo = (
    make_table_test("test_modulo",
        [
            (1, 6, 1, 6),
            (7, 6, 1, 6),
            (-11, 6, -5, 6),
            (1, -6, 1, -6),
            (7, -6, 1, -6),
            (-11, -6, -5, -6),
            (1, 0, 1, 0)
        ],
        |(a, m, exp_a, exp_m)|
        let mod = modulo(a, m);
        let _ = *assert_equal("value", exp_a, mod.@value);
        let _ = *assert_equal("modulus", exp_m, mod.@modulus);
        pure()
    )
);

test_get_modulus: TestCase;
test_get_modulus = (
    make_table_test("test_get_modulus",
        [
            ((1,6), (2,6), 6),
            ((1,6), (2,0), 6),
            ((1,0), (2,6), 6),
            ((1,0), (2,0), 0)
        ],
        |(a, b, m)|
        let ma = Modular::make(a.@0, a.@1);
        let mb = Modular::make(b.@0, b.@1);
        let actual = _get_modulus(ma,mb);
        assert_equal("eq", m, actual)
    )
);

test_nonneg: TestCase;
test_nonneg = (
    make_table_test("test_nonneg",
        [
            ((1,6), (1,6)),
            ((14,6), (2,6)),
            ((-1,6), (5,6)),
            ((-14,6), (4,6)),
            ((1,-6), (1,6)),
            ((14,-6), (2,6)),
            ((-1,-6), (5,6)),
            ((-14,-6), (4,6)),
            ((1,0), (1,0)),
            ((-1,0), (-1,0))
        ],
        |(a, expected)|
        let ma = Modular::make(a.@0, a.@1);
        let ma = ma.nonneg;
        let _ = *assert_equal("value", expected.@0, ma.@value);
        let _ = *assert_equal("modulus", expected.@1, ma.@modulus);
        pure()
    )
);

test_to_string: TestCase;
test_to_string = (
    make_table_test("test_to_string",
        [
            ((1,6), "1"),
            ((14,6), "2"),
            ((-1,6), "-1"),
            ((-14,6), "-2"),
            ((0,0), "0")
        ],
        |(a, expected)|
        let ma = Modular::make(a.@0, a.@1);
        assert_equal("to_string", expected, ma.to_string)
    )
);

test_eq: TestCase;
test_eq = (
    make_table_test("test_eq",
        [
            ((1,6), (1,6), true),
            ((14,6), (2,6), true),
            ((14,6), (3,6), false),
            ((14,0), (2,6), true),
            ((-1,6), (5,6), true),
            ((-14,6), (-8,6), true),
            ((7,6), (1,0), true),
            ((4,6), (1,0), false),
            ((1,0), (0,0), false),
            ((0,0), (0,0), true)
        ],
        |(a, b, expected)|
        let ma = Modular::make(a.@0, a.@1);
        let mb = Modular::make(b.@0, b.@1);
        assert_equal("eq", expected, ma == mb)
    )
);

// TODO: add tests

main: IO ();
main = (
    [
        test_make,
        test_modulo,
        test_get_modulus,
        test_nonneg,
        test_to_string,
        test_eq,
        TestCase::empty
    ]
    .run_test_driver
);

