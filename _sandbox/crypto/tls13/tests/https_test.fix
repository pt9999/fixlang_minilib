module Main;

//import AsyncTask;
import Debug;

import Minilib.Crypto.Tls13.TLSSession;
import Minilib.Net.Tcp;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Text.Hex;

https_fetch: () -> IOFail ();
https_fetch = |_| (
    let host = "localhost";
    //let host = "www.google.co.jp";
    //let host = "github.com";
    //let host = "ja.wikipedia.org";
    let host_port = host + ":443";
    let path = "/";
    let socket: Socket = *connect_to_tcp_server(host_port);
    let session: TLSSession = *TLSSession::make(socket);
    let sm: StateT TLSSession IOFail () = do {
        eval *send_client_hello(host);
        eval *recv_server_hello;
        eval *recv_server_params;
        let request = "GET " + path + " HTTP/1.1\nHost: " + host + "\nUser-Agent: fixlang_minilib\n\n";
        eval *send_appdata(request.get_bytes.pop_back);
        loop_m (
            (), |_|
            let appdata = *recv_appdata;
            //eval debug_eprintln("appdata=" + appdata.to_string_hex);
            eval debug_eprintln("appdata(text)=" + appdata.push_back(0_U8)._unsafe_from_c_str);
            // NOTE: should exit when the body specified by Content-Length has been read
            continue_m $ ()
        ).catch(|err|
            if err == "EOF" { pure () } else { error $ err }
        )
    };
    sm.run_state_t(session).map(@0)
);

main: IO ();
main = do {
    https_fetch()
}.try(eprintln);
