module Minilib.Crypto.Tls13.MemConnection;

import Debug;

import Minilib.Crypto.Tls13.Connection;
import Minilib.IO.Channel;
import Minilib.Monad.State;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;

type MemConnection = unbox struct {
    input: Channel U8,
    output: Channel U8
};

namespace MemConnection {
    make: IO MemConnection;
    make = (
        let input = *Channel::make;
        let output = *Channel::make;
        pure $ MemConnection {
            input: input,
            output: output
        }
    );

    swap: MemConnection -> MemConnection;
    swap = |conn| MemConnection {
        input: conn.@output,
        output: conn.@input
    };

    pipe: IO (MemConnection, MemConnection);
    pipe = (
        let local_conn = *MemConnection::make;
        let remote_conn = local_conn.swap;
        pure $ (local_conn, remote_conn)
    );
}

impl MemConnection: ByteIO {
    send = |bytes, conn| (
        let output = conn.@output;
        bytes.foreach_m(|b| output.send(b))
    );
    recv = |length, conn| (
        let input = conn.@input;
        Array::fill(length, input.recv).map_m(|x| x)
    );

    try_recv = |length, conn| (
        let input = conn.@input;
        if *input.is_empty.lift { pure $ none() };
        Array::fill(length, input.recv).map_m(|x| x).map(some)
    );
}

impl MemConnection: GetByteIO {
    type ByteIOType MemConnection = MemConnection;
    get_byte_io = |a| a;
}
