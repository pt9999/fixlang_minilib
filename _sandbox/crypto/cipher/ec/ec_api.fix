module Minilib.Crypto.Cipher.Ec.EcApi;

import Minilib.Monad.Random;

type EcCurveName = String;
type EcHashName = String;
type EcPublicKey = Array U8;    // UncompressedPointRepresentation
type EcSharedSecret = Array U8;
type EcSignature = Array U8;
type EcSigMessage = Array U8;

type [m: * -> *] EcApi m = unbox struct {
    make_ecdhe: EcCurveName -> m (FreeRandom (EcdheApi m)),
    make_ecdsa: EcCurveName -> EcHashName -> m (EcdsaApi m),
};

type [m: * -> *] EcdheApi m = unbox struct {
    curve_name: EcCurveName,
    key_exchange: EcPublicKey,
    accept_peer_key_exchange: EcPublicKey -> m EcSharedSecret,
};

type [m: * -> *] EcdsaApi m = unbox struct {
    curve_name: EcCurveName,
    hash_name: EcHashName,
    verify: EcPublicKey -> EcSignature -> EcSigMessage -> m (),
};
