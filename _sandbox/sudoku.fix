// 数独の問題を解くプログラム。
//
// 数独の問題は以下のような9行9列の文字列として表現する。
// 各マスは数字('1'から'9')または空き('.')とする。他の文字は無視される。
// ```
// 53..7....
// 6..195...
// .98....6.
// 8...6....
// 4..8.3..1
// 7...2...6
// .6....28.
// ...419..5
// ....8..79
// ```
module Main;

import Debug;
import Random;
import AsyncTask;

import Minilib.Math.RandomEx;
import Minilib.Text.StringEx;

// ------------------------------------------------------------
// ヘルパー定義
// ------------------------------------------------------------

// デバッグメッセージを出力する
debug_lazy: Lazy String -> ();
debug_lazy = |lazy_str| (
    if false { debug_println(lazy_str()) }
    else { () }
);

debug_lazy2: Lazy String -> ();
debug_lazy2 = |lazy_str| (
    if true { debug_println(lazy_str()) }
    else { () }
);

// バイト配列を文字列に変換する
bytes_to_string: Array U8 -> String;
bytes_to_string = |bytes| bytes.push_back(0_U8)._unsafe_from_c_str;

// 文字列に含まれる文字のうち、指定した条件を満たす文字だけを残す
filter_chars: (U8 -> Bool) -> String -> String;
filter_chars = |f, str| (
    str.get_bytes.pop_back.to_iter.filter(f).to_array.bytes_to_string
);

// ------------------------------------------------------------
//  盤面の管理
// ------------------------------------------------------------

// 数字 (1 から 9)
type Digit = U8;

// 盤面 (9 x 9 マス)
type Board = unbox struct {
    data: Array (Option Digit)      // 9 x 9
};

namespace Board {
    // 初期状態の盤面
    empty: Board;
    empty = Board {
        data: Array::fill(9 * 9, none())
    };

    // 指定したマスの数字を取得する
    get_digit: I64 -> I64 -> Board -> Option Digit;
    get_digit = |row, col, board| board.@data.@(row * 9 + col);

    // 指定したマスの数字を設定する
    set_digit: I64 -> I64 -> Option Digit -> Board -> Board;
    set_digit = |row, col, digit, board| board.mod_data(set(row * 9 + col, digit));

    // 数字が配置されたマスの数を数える
    get_digit_count: Board -> I64;
    get_digit_count = |board| (
        board.@data.to_iter.map(|digit| if digit.is_some { 1 } else { 0 })
        .fold(0, add)
    );

    // 数字が配置されていないマスのイテレータを返す
    get_empty_cells: Board -> Iterator (I64, I64);
    get_empty_cells = |board| (
        let row = *Iterator::range(0, 9);
        let col = *Iterator::range(0, 9);
        if board.get_digit(row, col).is_some { Iterator::empty };
        pure $ (row, col)
    );
}

// 数独の問題を表す文字列から盤面を読み込む。
impl Board: FromString {
    from_string = |problem| (
        // 問題を行に分割する。
        let lines = problem.split("\n");
        // 数字(1から9)と空き('.')以外の文字を除去する。
        let lines = lines.map(
            filter_chars(|c| ('1' <= c && c <= '9') || c == '.')
        );
        // 空行を除去する。
        let lines = lines.filter(|s| s != "");
        // イテレータから配列に変換する。
        let lines = lines.to_array;
        // 9行9列であることを確認する。
        if lines.get_size != 9 { err $ "invalid row size" };
        let _ = *lines.to_iter.fold_m(
            (), |_, line|
            if line.get_size != 9 { err $ "invalid col size" };
            ok()
        );
        // 盤面の各マスを読み込む。
        let board = Board::empty;
        Iterator::range(0, 9).fold_m(board, |board, row|
            Iterator::range(0, 9).fold_m(board, |board, col|
                let line = lines.@(row);
                let c = line.get_bytes.@(col);
                let digit = if '1' <= c && c <= '9' { some(c - '1' + 1_U8) } else { none() };
                let board = board.set_digit(row, col, digit);
                pure $ board
            )
        )
    );
}

impl Board: ToString {
    to_string = |board| (
        Iterator::range(0, 9).map(|row|
            Iterator::range(0, 9).map(|col|
                let digit = board.get_digit(row, col);
                if digit.is_none { '.' } else { digit.as_some - 1_U8 + '1' }
            ).to_array.bytes_to_string
        ).join("\n")
    );
}

// ------------------------------------------------------------
//  配置可能候補の管理
// ------------------------------------------------------------

// 特定のマスに数字を置けるかどうかを表わすビットベクトル。
// i 番目のビットは数字 i が配置可能(1)または配置不可(0)であることを表す。(i = 1..9)
type BitVec = U16;

namespace BitVec {
    // すべての数字が配置可能であるビットベクトル。
    full: BitVec;
    full = 0b1111111110_U16;    //  bit 1..9

    // すべての数字が配置不可であるビットベクトル。
    empty: BitVec;
    empty = 0_U16;

    // i 番目のビットを取得する。
    get_bit: I64 -> BitVec -> Bool;
    get_bit = |i, vec| vec.bit_and(1_U16.shift_left(i.to_U16)) != 0_U16;

    // i 番目のビットを設定する。
    set_bit: I64 -> Bool -> BitVec -> BitVec;
    set_bit = |i, b, vec| (
        if b { vec.bit_or(1_U16.shift_left(i.to_U16)) }
        else { vec.bit_and(U16::maximum - 1_U16.shift_left(i.to_U16)) }
    );

    // 1 (配置可能) の数を数える。
    count_ones: BitVec -> I64;
    count_ones = |vec| (
        let vec = vec.bit_and(0xaaaa_U16).shift_right(1_U16) + vec.bit_and(0x5555_U16);
        let vec = vec.bit_and(0xcccc_U16).shift_right(2_U16) + vec.bit_and(0x3333_U16);
        let vec = vec.bit_and(0xf0f0_U16).shift_right(4_U16) + vec.bit_and(0x0f0f_U16);
        let vec = vec.bit_and(0xff00_U16).shift_right(8_U16) + vec.bit_and(0x00ff_U16);
        vec.to_I64
    );

    // 配置可能な数字のイテレータを返す。
    to_iter: BitVec -> Iterator I64;
    to_iter = |vec| (
        Iterator::range(1, 9 + 1).filter(|digit| vec.get_bit(digit))
    );
}

// 9 x 9 マスの配置可能候補を管理する
type Candidates = unbox struct {
    data: Array BitVec  // 9 x 9
};

namespace Candidates {
    //  初期状態(すべての数字を配置可能)
    full: Candidates;
    full = Candidates {
        data: Array::fill(9 * 9, BitVec::full)
    };

    // 指定したマスの配置可能候補を取得する
    get_bitvec: I64 -> I64 -> Candidates -> BitVec;
    get_bitvec = |row, col, cand| cand.@data.@(row * 9 + col);

    // 指定したマスの配置可能候補を更新する
    mod_bitvec: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_bitvec = |row, col, f, cand| (
        let cand = cand.mod_data(mod(row * 9 + col, f));
        cand
    );

    // 指定した行全体の配置可能候補を更新する
    mod_row: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_row = |row, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, col| cand.mod_bitvec(row, col, f)
    );

    // 指定した列全体の配置可能候補を更新する
    mod_col: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_col = |col, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, row| cand.mod_bitvec(row, col, f)
    );

    // 指定したマスを含むブロックの配置可能候補を更新する
    mod_block: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_block = |row, col, f, cand| (
        let top = row / 3 * 3;
        let left = col / 3 * 3;
        Iterator::range(0, 9).fold(
            cand, |cand, i| cand.mod_bitvec(top + i / 3, left + i % 3, f)
        )
    );

    // 指定したマスを含む行、列、ブロックの配置可能候補を更新する
    mod_all: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_all = |row, col, f, cand| (
        cand.mod_row(row, f)
        .mod_col(col, f)
        .mod_block(row, col, f)
    );

    // 盤面をもとに配置可能候補を初期化する
    init_with_board: Board -> Candidates;
    init_with_board = |board| (
        let cand = Candidates::full;
        Iterator::range(0, 9).fold(cand, |cand, row|
            Iterator::range(0, 9).fold(cand, |cand, col|
                let digit = board.get_digit(row, col);
                if digit.is_none { cand };
                cand.mod_all(row, col, set_bit(digit.as_some.to_I64, false))
            )
        )
    );

    // 空のマスのうち、候補数が最も少ないマスを求める。
    // 成功時は `some(候補数, 行, 列)` が返る。
    // 候補数は0の場合もある。(そのマスにはどの数字も配置できないことを意味する)
    // 空のマスがないときは `none()` が返る。
    find_best_cell: Board -> Candidates -> Option (I64, I64, I64);
    find_best_cell = |board, cand| (
        let best: Option (I64, I64, I64) = none();
        board.get_empty_cells.fold(best, |best, (row, col)|
            let bitvec = cand.get_bitvec(row, col);
            let num_cand = bitvec.count_ones;
            if best.is_none || best.as_some.@0 > num_cand {
                some $ (num_cand, row, col)
            } else { best }
        )
    );
}

// ------------------------------------------------------------
//  数独を解く
// ------------------------------------------------------------

// 盤面と配置可能候補の状態
type BoardState = unbox struct {
    board: Board,                   //  盤面
    candidates: Candidates,         //  配置可能候補
    digit_count: I64                //  配置済みの数字の数
};

namespace BoardState {
    // 空の盤面状態
    empty: BoardState;
    empty = BoardState {
        board: Board::empty,
        candidates: Candidates::full,
        digit_count: 0
    };

    // 問題を読み込む。
    load_problem: String -> Result ErrMsg BoardState;
    load_problem = |problem| (
        let board: Board = *from_string(problem);
        pure $ BoardState::init_with_board(board)
    );

    // 盤面をもとに状態を初期化する。
    init_with_board: Board -> BoardState;
    init_with_board = |board| (
        let candidates = Candidates::init_with_board(board);
        let digit_count = board.get_digit_count;
        BoardState {
            board: board,
            candidates: candidates,
            digit_count: digit_count
        }
    );

    // 指定したマスに数字を配置する。
    place_digit: I64 -> I64 -> I64 -> BoardState -> BoardState;
    place_digit = |row, col, digit, state| (
        eval assert(|_| "digit is already set", state.@board.get_digit(row, col).is_none);
        state.mod_board(set_digit(row, col, some(digit.to_U8)))
             .mod_candidates(mod_all(row, col, set_bit(digit, false)))
             .mod_digit_count(add(1))
    );
}

impl BoardState: ToString {
    to_string = |state| state.@board.to_string;
}

namespace Solver {
    // 数独の問題を解く。
    solve: BoardState -> Result ErrMsg (Array BoardState, I64);
    solve = |state| (
        let solutions = [];
        let stack = [state];
        _solve_inner(stack, 0, solutions)
    );

    // スタックから盤面状態を1つ取り出し、数字の配置を試みる。
    _solve_inner: Array BoardState -> I64 -> Array BoardState -> Result ErrMsg (Array BoardState, I64);
    _solve_inner = |stack, step, solutions| (
        let step = step + 1;
        if step >= 100000 { err $ "too may steps" };
        if solutions.get_size >= 10 { err $ "too may solutions" };

        //  スタックが空になった(探索する盤面が尽きた)場合、見つかった解を返す
        if stack.is_empty {
            ok $ (solutions, step)
        };

        //  スタックから盤面状態を1つ取り出す。
        let state = stack.get_last.as_some;
        let stack = stack.pop_back;
        eval debug_lazy(|_| [state.@digit_count, stack.get_size].format("{}: _solve_inner: stack size={}"));

        //  9 x 9 個のマスがすべて埋まったら解を記録する。
        if state.@digit_count >= 9 * 9 {
            eval debug_lazy(|_| "found a solution");
            let solutions = solutions.push_back(state);
            _solve_inner(stack, step, solutions)
        };

        // 空のマスのうち、候補数が最も少ないマスを検索する。
        let best = state.@candidates.find_best_cell(state.@board);
        if best.is_none {
            // 空のマスがない
            eval debug_lazy(|_| [state.@digit_count].format("{}: no candidates"));
            _solve_inner(stack, step, solutions)
        };
        let (num_cand, row, col) = best.as_some;
        if num_cand == 0 {
            // 候補数が0のマスにはどの数字も配置できないため、その盤面は解にならない。
            eval debug_lazy(|_| (state.@digit_count, row, col).format("{}: no candidates at ({}, {})"));
            _solve_inner(stack, step, solutions)
        };

        //  候補の各々について、その数字を配置した盤面を生成し、スタックに積む。
        eval debug_lazy(|_| (state.@digit_count, num_cand, (row, col)).format("{}: find {} candidates at {}"));
        let bitvec = state.@candidates.get_bitvec(row, col);
        let stack = bitvec.to_iter.fold(stack, |stack, digit|
            eval debug_lazy(|_| [state.@digit_count, digit, row, col].format("{}: place {} at ({}, {})"));
            stack.push_back(state.place_digit(row, col, digit))
        );
        _solve_inner(stack, step, solutions)
    );
}

// ------------------------------------------------------------
//  数独の問題を作成する
// ------------------------------------------------------------

// 問題作成器
type Generator = unbox struct {
    max_retry: I64,                 //  問題作成の最大試行回数
    num_digits_to_place: I64,       //  数字を配置する数
    var_random: Var Random,         //  Random の変数
    retry: I64                      //  現在の試行回数
};

namespace Generator {
    //  問題作成器を構築する。
    make: I64 -> I64 -> Var Random -> Generator;
    make = |max_retry, num_digits_to_place, var_random| (
        Generator {
            max_retry: max_retry,
            num_digits_to_place: num_digits_to_place,
            var_random: var_random,
            retry: 0
        }
    );

    // 数独の問題を作成し、唯一解を持つことを検証する。
    generate_and_validate: Generator -> IOFail BoardState;
    generate_and_validate = |gen| (
        loop_m(
            gen, |gen|
            let gen = gen.mod_retry(add(1));
            if gen.@retry > gen.@max_retry { throw $ "Max retry count reached" };
            let res = *gen._generate_problem.to_result.lift;
            if res.is_err {
                eval debug_lazy2(|_| (gen.@retry, res.as_err).format("{}: 問題作成失敗: err={}"));
                continue_m $ gen
            };
            let state = res.as_ok;
            let res = *gen._validate_solution(state).to_result.lift;
            if res.is_err {
                eval debug_lazy2(|_| (gen.@retry, res.as_err).format("{}: 検証失敗: err={}"));
                continue_m $ gen
            };
            break_m $ state
        )
    );

    // 数独の問題が唯一解を持つことを検証する。
    _validate_solution: BoardState -> Generator -> IOFail BoardState;
    _validate_solution = |state, gen| (
        eval debug_lazy2(|_| [gen.@retry].format("{}: 作成した問題を検証します"));
        let res = Solver::solve(state);
        if res.is_err {
            throw $ res.as_err
        };
        let (solutions, solve_step) = res.as_ok;
        eval debug_lazy2(|_| [gen.@retry, solutions.get_size, solve_step].format("{}: 検証結果: 解の数={} ステップ数={}"));
        if solutions.get_size == 0 {
            throw $ "解なし"
        };
        if solutions.get_size > 1 {
            throw $ "複数解あり"
        };
        pure $ state
    );

    //  数独の問題を生成する。
    _generate_problem: Generator -> IOFail BoardState;
    _generate_problem = |gen| (
        eval debug_lazy2(|_| [gen.@retry].format("{}: 問題を作成します"));
        loop_m(
            BoardState::empty, |state|
            //  数字の数が指定値を超えたらループを抜ける。
            if state.@digit_count >= gen.@num_digits_to_place {
                break_m $ state
            };
            //  数字をランダムに配置する。
            let state = *gen._place_random_digit(state);
            continue_m $ state
        )
    );

    // var_random を用いて乱数を生成する。
    // f は乱数を生成する関数。
    _with_random: (Random -> (a, Random)) -> Generator -> IOFail a;
    _with_random = |f, gen| (
        gen.@var_random.lock(|random|
            let (a, random) = f(random);
            let _ = *gen.@var_random.Var::set(random);
            pure $ a
        ).lift
    );

    // 数字をランダムに配置する。
    _place_random_digit: BoardState -> Generator -> IOFail BoardState;
    _place_random_digit = |state, gen| (
        let empty_cells = state.@board.get_empty_cells.to_array;
        if empty_cells.get_size == 0 {
            throw $ "空のマスが存在しません"
        };
        if empty_cells.find_by(|(row, col)|
            state.@candidates.get_bitvec(row, col) == BitVec::empty
        ).is_some {
            throw $ "数字を配置できないマスが存在します"
        };

        let i = *gen._with_random(generate_I64_range(0, empty_cells.get_size));
        let (row, col) = empty_cells.@(i);
        let bitvec = state.@candidates.get_bitvec(row, col);
        let digits = bitvec.to_iter.to_array;
        eval assert (|_| "候補の数字がありません", digits.get_size > 0);
        //eval debug_lazy2(|_| (gen.@retry, state.@digit_count, (row, col), digits.get_size).format("{}: {}: {} には {} 種類の数字を配置可能"));
        let i = *gen._with_random(generate_I64_range(0, digits.get_size));
        let digit = digits.@(i);
        //eval debug_lazy2(|_| (gen.@retry, state.@digit_count, (row, col), digit).format("{}: {}: {} に {} を配置します"));
        let state = state.place_digit(row, col, digit);
        pure $ state
    );
}

// ------------------------------------------------------------
//  テストケース
// ------------------------------------------------------------

problem1: String;   // 54 steps
problem1 = "
    53..7....
    6..195...
    .98....6.
    8...6....
    4..8.3..1
    7...2...6
    .6....28.
    ...419..5
    ....8..79
";

problem2: String;   // 67 steps ... easy?
problem2 = "
..35...79
..8...24.
.15.....6
26.....9.
.5..8....
..13.4...
.........
.4.16..5.
..9....32
";

problem3: String;   // 799 steps ... hard?
problem3 = "
.5.7..1..
....24...
..2......
3.......6
.....8.1.
19.3...7.
.....5.21
.7...18.3
2.6.8.9..
";

problem4: String;  // 188 steps
problem4 = "
.145...2.
..31..7..
....79...
..6...49.
....645..
........3
6.8..2..9
...4.....
3.7.1..5.
";

test1: IO ();
test1 = do {
    let state = *BoardState::load_problem(problem1).from_result;
    let (solutions, step) = *Solver::solve(state).from_result;
    let _ = *println([solutions.get_size, step].format("Found {} solutions in {} steps:")).lift;
    solutions.to_iter.fold_m(
        (), |_, state|
        println("\n" + state.to_string).lift
    )
}.try(eprintln);

test2: IO ();
test2 = do {
    let _ = *pure();
    let time = CALL_C[I32 time(Ptr), nullptr];
    //let time = 12345;
    let random = Random::init_by_seed(time.to_U64);
    let var_random = *Var::make(random).lift;
    let max_retry = 1000;
    let num_digits_to_place = 25;
    let gen = Generator::make(max_retry, num_digits_to_place, var_random);
    let state = *gen.generate_and_validate;
    let _ = *println("\n問題:\n" + state.to_string + "\n").lift;
    let (solutions, step) = *Solver::solve(state).from_result;
    let _ = *println([solutions.get_size, step].format("{}個の解が見つかりました (ステップ数:{})")).lift;
    solutions.to_iter.fold_m(
        (), |_, state|
        println("\n" + state.to_string).lift
    )
}.try(eprintln);

main: IO ();
main = test2;
