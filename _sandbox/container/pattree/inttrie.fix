/*
Simple Integer Trie
*/
module Minilib.Collection.IntTrie;

type Key = U64;

rbits: U64;
rbits = 8_U64;

rmask: U64;
rmask = 1_U64.shift_left(rbits) - 1_U64;

rlevels: U64;
rlevels = (64_U64 + rbits - 1_U64) / rbits;

// A type of combining function that resolves collisions.
// `combine(old_value, new_value)` returns a combined value.
type Combine a = a -> a -> a;

overwrite: Combine a = |old_value, new_value| new_value;

type RNode a = unbox union {
    empty: (),
    leaf: a,
    branch: Array (RNode a),
};

_empty_branch: RNode a;
_empty_branch = branch(Array::fill((rmask + 1_U64).to_I64, empty()));

impl [a: ToString] RNode a: ToString {
    to_string = |node| node._node_to_string(0);
}

_node_to_string: [a: ToString] I64 -> RNode a -> String;
_node_to_string = |indent, node| (
    let indent_str: String = Array::fill(indent, ' ').push_back('\0').from_bytes.as_ok;
    match node {
        empty() => indent_str + "empty()",
        leaf(value) => indent_str + "leaf(" + value.to_string + ")",
        branch(children) => 
            children.to_iter.fold(
                indent_str + "branch()", |child, s|
                s + "\n" + child._node_to_string(indent + 1)
            )
    }
);

_empty: RNode a;
_empty = empty();

find: Key -> RNode a -> Option a;
find = |key, node| (
    node._lookup(rbits * (rlevels - 1_U64), key)
);

_lookup: U64 -> Key -> RNode a -> Option a;
_lookup = |shift, key, node| (
    match node {
        empty() => none(),
        leaf(value) => some(value),
        branch(children) => (
            let i = key.shift_right(shift).bit_and(rmask);
            children.@(i.to_I64)._lookup(shift - rbits, key)
        )
    }
);

insert: Combine a -> Key -> a -> RNode a -> RNode a;
insert = |combine, key, new_value, node| (
    node._ins(rbits * (rlevels - 1_U64), combine, key, new_value)
);

_ins: U64 -> Combine a -> Key -> a -> RNode a -> RNode a;
_ins = |shift, combine, key, new_value, node| (
    if shift.to_I64 < 0 {
        match node {
            empty() => leaf(new_value),
            leaf(old_value) => leaf(combine(old_value, new_value)),
            branch(_) => undefined("branch found in level 0"),
        }
    } else {
        let node = match node {
            empty() => _empty_branch,
            leaf(_) => undefined("leaf found in level non-0"),
            branch(_) => node,
        };
        let i = key.shift_right(shift).bit_and(rmask);
        node.mod_branch(mod(i.to_I64, _ins(shift - rbits, combine, key, new_value)))
    }
);
