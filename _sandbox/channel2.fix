module Main;

import AsyncTask;
import Random;

import Deque;

namespace Channel {
    type Channel a = unbox struct {
        data: Var (Deque a)
    };

    make: I64 -> IO (Channel a);
    make = |size| (
        let var = *Var::make(Deque::empty(size));
        pure $ Channel { data: var }
    );

    is_empty: Channel a -> IO Bool;
    is_empty = |chan| (
        let deque = *chan.@data.get;
        pure $ deque.is_empty
    );

    send: a -> Channel a -> IO ();
    send = |a, chan| (
        chan.@data.mod(push_back(a))
    );

    recv: Channel a -> IO a;
    recv = |chan| (
        chan.@data.wait_and_lock(
            |deque| !deque.is_empty,
            |deque|
            let a = deque.get_front.as_some;
            let deque = deque.pop_front;
            let _ = *chan.@data.Var::set(deque);
            pure $ a
        )
    );

    recv_any: Array (Channel a) -> IO (I64, a);
    recv_any = |channels| (
        let var = *Var::make(none());
        let tasks = *channels.to_iter.zip(Iterator::count_up(0)).fold_m(
            [], |tasks, (chan, idx)|
            let recv_fun = |deque| (
                var.lock(
                    |opt|
                    if opt.is_some { pure() };
                    let a = deque.get_front.as_some;
                    let deque = deque.pop_front;
                    let _ = *chan.@data.Var::set(deque);
                    let _ = *var.Var::set(some $ (idx, a));
                    pure()
                )
            );
            let task_fun: IO () = (
                chan.@data.wait_and_lock(
                    |deque| !deque.is_empty,
                    recv_fun
                )
            );
            let task = *AsyncIOTask::make(
                TaskPolicy::run_after_destructed.bit_or(TaskPolicy::on_dedicated_thread),
                task_fun   
            );
            pure $ tasks.push_back(task)
        );
        var.wait_and_lock(
            is_some,
            |opt| pure $ opt.as_some
        )
    );
}

map_m: [m : Monad] (a -> m b) -> Array a -> m (Array b);
map_m = |f, array| array.to_iter.fold_m(
    Array::empty(array.get_size), |output, a|
    let b = *f(a);
    pure $ output.push_back(b)
);

_usleep: I64 -> I64;
_usleep = |usec| (
    CALL_C[I32 usleep(U32), usec.to_U32].to_I64
);


test1: IO ();
test1 = (
    let _ = *pure();
    let rand_var = *Var::make(Random::init_by_seed(123_U64));
    let sleep_random: IO () = (
        let u64 = *rand_var.lock(|rand|
            let (u64, rand) = rand.generate_U64;
            let _ = *rand_var.Var::set(rand);
            pure $ u64
        );
        eval _usleep((u64 % 100000_U64).to_I64);
        pure()
    );
    let n = 20;
    let indices = Iterator::range(0, n).to_array;
    let channels = *indices.map_m(|_| Channel::make(4));
    let channels_result = *indices.map_m(|_| Channel::make(4));
    let task_func = |idx| (
        let _ = *eprintln(idx.to_string + ": 1st send to " + idx.to_string);
        let _ = *channels.@(idx).send(idx);
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 1st recv from " + ((idx+n/3)%n).to_string);
        let val = *channels.@((idx+n/3)%n).recv;
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 2nd send to " + idx.to_string);
        let _ = *channels.@(idx).send(val);
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": 2nd recv from " + ((idx+n*2/3)%n).to_string);
        let val = *channels.@((idx+n*2/3)%n).recv;
        let _ = *sleep_random;
        let _ = *eprintln(idx.to_string + ": final send to " + idx.to_string);
        let _ = *channels_result.@(idx).send(val);
        pure()
    );
    let tasks = *indices.map_m(
        |idx|
        AsyncIOTask::make(
            TaskPolicy::run_after_destructed.bit_or(TaskPolicy::on_dedicated_thread),
            task_func(idx)
        )
    );
    if true {
        let (idx, val) = *channels_result.recv_any;
        let _ = *tasks.map_m(get);
        eprintln("idx=" + idx.to_string + " val="+val.to_string)
    } else {
        let _ = *indices.map_m(
            |idx|
            let val = *channels_result.@(idx).recv;
            eprintln("final result " + idx.to_string + " = " + val.to_string)
        );
        pure()
    }
);

main: IO ();
main = test1;
