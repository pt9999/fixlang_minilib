module Filer.AppView;

import Minilib.IO.FileSystem;
import Minilib.Monad.IO;
import Minilib.Monad.State;
import Minilib.Text.Unicode;
import Minilib.Text.WideChar;
import Minilib.Terminal.Ncurses;
import Minilib.Trait.Traversable;

import Filer.AppEnv;
import Filer.Common;
import Filer.FileItem;
import Filer.FileListView;
import Filer.FileView;
import Filer.ListView;
import Filer.StatusView;

type AppView = unbox struct {
    app_env: AppEnv,
    window: Window,
    file_list_view: FileListView,
    file_view: FileView,
    status_view: StatusView,
};

namespace AppView {
    make: AppEnv -> Window -> IOFail AppView;
    make = |app_env, app_win| (
        let (app_w, app_h) = *app_win.get_window_size;
        let flv_w = app_w * 1 / 3;
        let flv_win = *app_win.make_sub_window(0, 0, flv_w, app_h - 1);
        let fv_win = *app_win.make_sub_window(flv_w, 0, app_w - flv_w, app_h - 1);
        let status_win = *app_win.make_sub_window(0, app_h - 1, app_w, 1);
        let flv = *FileListView::make(app_env, flv_win, *realpath("."));
        let flv = flv.mod_list_view(set_id(0) >> set_has_focus(true));
        let fv = *FileView::make(fv_win);
        let fv = fv.mod_list_view(set_id(1) >> set_has_focus(false));
        let status_view = *StatusView::make(status_win);
        pure $ AppView {
            app_env: app_env,
            window: app_win,
            file_list_view: flv,
            file_view: fv,
            status_view: status_view,
        }
    );

    run: StateIOF AppView ();
    run = (
        loop_m(
            (), |_|
            AppView::show;;
            let key = *AppView::get_key;
            let action = *AppView::handle_key(key);
            if action.is_action_quit {
                let app_env = *select_state(AppView::@app_env);
                (app_env.@shutdown).lift_iofail;;
                break_m $ ()
            };
            AppView::handle_action(action);;
            continue_m $ ()
        )
    );

    with_file_list_view: StateIOF FileListView a -> StateIOF AppView a;
    with_file_list_view = |sm| sm.lens_state_t(act_file_list_view);

    with_file_view: StateIOF FileView a -> StateIOF AppView a;
    with_file_view = |sm| sm.lens_state_t(act_file_view);

    with_status_view: StateIOF StatusView a -> StateIOF AppView a;
    with_status_view = |sm| sm.lens_state_t(act_status_view);

    show: StateIOF AppView ();
    show = (
        with_file_list_view(FileListView::show);;
        with_file_view(FileView::show);;
        with_status_view(StatusView::show);;
        pure()
    );

    get_focus: StateIOF AppView I64;
    get_focus = (
        if *with_file_list_view(has_focus) { pure $ 0 };
        if *with_file_view(has_focus) { pure $ 1 };
        pure $ -1
    );

    set_focus: I64 -> StateIOF AppView ();
    set_focus = |id| (
        with_file_list_view $ with_list_view $ set_focus(id == 0);;
        with_file_view $ with_list_view $ set_focus(id == 1);;
        pure()
    );

    next_focus: StateIOF AppView ();
    next_focus = (
        let focus = *get_focus;
        set_focus((focus + 1) % 2)
    );

    get_key: StateIOF AppView KeyName;
    get_key = (
        let focus = *get_focus;
        if focus == 0 { with_file_list_view $ FileListView::get_key };
        if focus == 1 { with_file_view $ FileView::get_key };
        pure $ ""
    );

    handle_key: KeyName -> StateIOF AppView Action;
    handle_key = |key| (
        let focus = *get_focus;
        let action = *(
            if focus == 0 { with_file_list_view $ FileListView::handle_key(key) }
            else if focus == 1 { with_file_view $ FileView::handle_key(key) }
            else { pure $ no_action() }
        );
        if !action.is_no_action { pure $ action };
        if key == "q" || key == "Q" || key == "KEY_ESC" || key == "^[" {
            pure $ action_quit()
        };
        if key == "h" || key == "?" {
            pure $ action_help()
        };
        if key == "^I" {
            pure $ action_next_focus()
        };
        pure $ no_action()
    );

    help_messages: StateIOF AppView (Array (String, String));
    help_messages = do {
        let focus = *get_focus;
        let help = *(
            if focus == 0 { with_file_list_view $ FileListView::help_messages }
            else if focus == 1 { with_file_view $ FileView::help_messages }
            else { pure $ [] }
        );
        pure $ [
            ("  ESC     q     ", "終了"),
            ("   ?      h     ", "ヘルプ"),
            ("  TAB         ^I", "フォーカス"),
        ] + help
    };

    handle_action: Action -> StateIOF AppView ();
    handle_action = |action| (
        with_file_list_view $ FileListView::handle_action(action);;
        with_file_view $ FileView::handle_action(action);;
        match action {
            action_next_focus() => next_focus,
            action_open_file() => (
                match *with_file_list_view(selected_item) {
                    none() => pure(),
                    some(item) => (
                        if item.@stat.is_dir {
                            with_file_list_view(FileListView::open_directory(item.@file_path))
                        };
                        if item.@stat.is_file {
                            with_file_view(FileView::open_file(item.@file_path))
                        };
                        pure()
                    )
                }
            ),
            action_help() => show_help,
            _ => pure()
        }
    );

    show_help: StateIOF AppView ();
    show_help = (
        let app_win = *select_state(AppView::@window);
        let (app_w, app_h) = *app_win.get_window_size;
        let help = *AppView::help_messages;
        let help = help.map(|(left, right)| (left.to_utf32_string, right.to_utf32_string));
        let help_w = help.to_iter.map(|(left, right)| left.get_width + 2 + right.get_width).fold(0, max);
        let help_h = help.get_size;
        let dlg_w = max(2, min(app_w - 2, help_w + 2));
        let dlg_h = max(2, min(app_h - 2, help_h + 2));
        let window = *app_win.make_sub_window((app_w - dlg_w) / 2, (app_h - dlg_h) / 2, dlg_w, dlg_h);
        window.clear;;
        window.draw_border;;
        let title = "HELP";
        window.move_add_wstr(2, 0, " " + ellipsis(dlg_w - 6, title) + " ").when(title != "");;
        range(1, dlg_h-1).foreach_m(|y|
            let i = y - 1;
            if 0 <= i && i < help.get_size {
                let (left, right) = help.@(i);
                let wstr = left + "  ".to_utf32_string + right;
                //let wstr = wstr.ellipsis(dlg_w - 5) // TODO: implement ellipsis for UTF32String 
                window.move_add_wstr(1, y, wstr)
            } else { pure() }
        );;
        let key = *window.get_key;
        pure()
    );
}
