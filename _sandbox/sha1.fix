// SHA-1
// https://csrc.nist.gov/files/pubs/fips/180-4/final/docs/fips180-4.pdf
module Main;

import Debug;

// 2.2.2 Symbols and Operations 

// bitwise complement
_bit_not: U32 -> U32;
_bit_not = |x| x.bit_xor(0xFFFFFFFF_U32);

// rotate left
_rotl: U32 -> U32 -> U32;
_rotl = |n, x| (
    x.shift_left(n).bit_or(x.shift_right(32_U32 - n))
);

// rotate right
_rotr: U32 -> U32 -> U32;
_rotr = |n, x| (
    x.shift_right(n).bit_or(x.shift_left(32_U32 - n))
);

// shift right
_shr: U32 -> U32 -> U32;
_shr = |n, x| (
    x.shift_right(n)
);

// 4.1.1 SHA-1 Functions
_f: I64 -> U32 -> U32 -> U32 -> U32;
_f = |t, x, y, z| (
    if t < 20 { // ch(x,y,z): choose y or z by x
        x.bit_and(y).bit_xor(x._bit_not.bit_and(z)) 
    };
    if t < 40 { // parity(x,y,z): calc parity of x, y, z
        x.bit_xor(y).bit_xor(z)
    };
    if t < 60 { // maj(x,y,z): majority
        x.bit_and(y).bit_xor(x.bit_and(z)).bit_xor(y.bit_and(z))
    };
    // parity
    x.bit_xor(y).bit_xor(z)
);

// 4.2.1 SHA-1 Constants 
_k: I64 -> U32;
_k = |t| (
    if t < 20 { 0x5a827999_U32 };
    if t < 40 { 0x6ed9eba1_U32 };
    if t < 60 { 0x8f1bbcdc_U32 };
    0xca62c1d6_U32
);

// 5.3 Setting the Initial Hash Value (H(0))
_init_hash: Array U32;
_init_hash = (
    Array::empty(5)
        .push_back(0x67452301_U32)
        .push_back(0xefcdab89_U32)
        .push_back(0x98badcfe_U32)
        .push_back(0x10325476_U32)
        .push_back(0xc3d2e1f0_U32)
);

// 6.1.2 SHA-1 Hash Computation
_update_hash: Array U32 -> Array U32 -> Array U32;
_update_hash = |message, hash| (
    eval assert (|_| "invalid size: message", message.get_size == 16);
    eval assert (|_| "invalid size: hash", hash.get_size == 5);

    let w = Array::empty(80);
    let w = loop(
        (w, 0), |(w, t)|
        if t >= 80 { 
            break $ w
        };
        if t < 16 { 
            let w = w.push_back(message.@(t));
            continue $ (w, t + 1)
        };
        let tmp = w.@(t-3).bit_xor(w.@(t-8)).bit_xor(w.@(t-14)).bit_xor(w.@(t-16));
        let w = w.push_back(tmp._rotl(1_U32));
        continue $ (w, t + 1)
    );
    let (a,b,c,d,e) = loop(
        (hash.@(0), hash.@(1), hash.@(2), hash.@(3), hash.@(4), 0), 
        |(a, b, c, d, e, t)|
        if t >= 80 {
            break $ (a, b, c, d, e)
        };
        let tmp = a._rotl(5_U32) + _f(t, b, c, d) + e + _k(t) + w.@(t);
        let e = d;
        let d = c;
        let c = b._rotl(30_U32);
        let b = a;
        let a = tmp;
        continue $ (a, b, c, d, e, t + 1)
    );
    let hash = hash
        .set(0, a + hash.@(0))
        .set(1, b + hash.@(1))
        .set(2, c + hash.@(2))
        .set(3, d + hash.@(3))
        .set(4, e + hash.@(4));
    hash
);

_u8_array_to_u32_array_be: Array U8 -> Array U32;
_u8_array_to_u32_array_be = |u8array| (
    let n = u8array.get_size;
    eval assert(|_| "invalid size", n.bit_and(3) == 0);
    let u32array = Array::empty(n.shift_right(2));
    loop(
        (u32array, 0), |(u32array, i)|
        if i >= n {
            break $ u32array
        };
        let x = u8array.@(i+0).to_U32.shift_left(24_U32);
        let x = u8array.@(i+1).to_U32.shift_left(16_U32).bit_or(x);
        let x = u8array.@(i+2).to_U32.shift_left( 8_U32).bit_or(x);
        let x = u8array.@(i+3).to_U32.shift_left( 0_U32).bit_or(x);
        let u32array = u32array.push_back(x);
        continue $ (u32array, i + 4)
    )
);

_u32_array_to_u8_array_be: Array U32 -> Array U8;
_u32_array_to_u8_array_be = |u32array| (
    let n = u32array.get_size;
    let u8array = Array::empty(n.shift_left(2));
    loop(
        (u8array, 0), |(u8array, i)|
        if i >= n {
            break $ u8array
        };
        let u32 = u32array.@(i);
        let u8array = u8array
            .push_back(u32.shift_right(24_U32).bit_and(255_U32).to_U8)
            .push_back(u32.shift_right(16_U32).bit_and(255_U32).to_U8)
            .push_back(u32.shift_right( 8_U32).bit_and(255_U32).to_U8)
            .push_back(u32.shift_right( 0_U32).bit_and(255_U32).to_U8);
        continue $ (u8array, i + 1)
    )
);

_u64_to_u8_array_be: U64 -> Array U8;
_u64_to_u8_array_be = |u64| (
    let u8array = Array::empty(8);
    loop(
        (u8array, 0), |(u8array, i)|
        if i >= 8 {
            break $ u8array
        };
        let u8 = u64.shift_right(((7-i)*8).to_U64).bit_and(255_U64).to_U8;
        let u8array = u8array.push_back(u8);
        continue $ (u8array, i + 1)
    )
);

type SHA1 = unbox struct {
    hash: Array U32,
    msglen: U64,
    msgbuf: Array U8
};

namespace SHA1 {
    empty: SHA1;
    empty = SHA1 {
        hash: _init_hash,
        msglen: 0_U64,
        msgbuf: Array::empty(64)
    };

    update: Array U8 -> SHA1 -> SHA1;
    update = |input, sha1| (
        sha1._update_inner(input, input.get_size.to_U64)
    );

    _update_inner: Array U8 -> U64 -> SHA1 -> SHA1;
    _update_inner = |input, msglen_inc, sha1| (
        let n_input = input.get_size;
        let n_msgbuf = 64;
        let sha1 = loop(
            (sha1, 0), |(sha1, i_input)|
            if i_input >= n_input {
                break $ sha1
            };
            let sha1 = sha1.mod_msgbuf(push_back(input.@(i_input)));
            let i_input = i_input + 1;
            if sha1.@msgbuf.get_size < n_msgbuf {
                continue $ (sha1, i_input)
            };
            //eval debug_eprintln("msgbuf="+sha1.@msgbuf.bytes_to_string_hex);
            let message = sha1.@msgbuf._u8_array_to_u32_array_be;
            let sha1 = sha1.mod_hash(_update_hash(message));
            let sha1 = sha1.mod_msgbuf(truncate(0));
            continue $ (sha1, i_input)    
        );
        let sha1 = sha1.mod_msglen(|len| len + msglen_inc);
        sha1
    );

    finalize: SHA1 -> Array U8;
    finalize = |sha1| (
        // 5.1 Padding the Message 
        let sha1 = sha1._update_inner([0x80_U8], 0_U64);
        let sha1 = loop(
            sha1, |sha1|
            if sha1.@msgbuf.get_size == 448/8 {
                break $ sha1
            };
            continue $ sha1._update_inner([0x00_U8], 0_U64)
        );
        let msglen_bits: U64 = sha1.@msglen * 8_U64;
        let sha1 = sha1._update_inner(msglen_bits._u64_to_u8_array_be, 0_U64);

        eval assert(|_| "padding failed", sha1.@msgbuf.get_size == 0);

        let digest = sha1.@hash._u32_array_to_u8_array_be;
        digest
    );

    digest: Array U8 -> Array U8;
    digest = |bytes| (
        SHA1::empty.update(bytes).finalize
    );
}

// Converts a 4bit number (0..15) to a hex character ('0'..'9', 'A'..'F').
encode_hex_char: U8 -> U8;
encode_hex_char =
    let hex_chars = "0123456789ABCDEF".get_bytes.pop_back
    in |c| hex_chars.@(c.bit_and(15_U8).to_I64);

bytes_to_string_hex: Array U8 -> String;
bytes_to_string_hex = |u8array| (
    u8array.to_iter.fold(
        [], |output, u8|
        output.push_back(u8.shift_right(4_U8).bit_and(15_U8).encode_hex_char)
              .push_back(u8.shift_right(0_U8).bit_and(15_U8).encode_hex_char)
    ).push_back(0_U8)._unsafe_from_c_str
);


main: IO ();
main = (
    //let bytes = "abcdefg".get_bytes.pop_back;
    let bytes = Array::from_map(256, |i| i.to_U8);
    //let _ = *write_file_bytes(Path::parse("tmp.dat").as_some, bytes).to_result;
    let hash = SHA1::digest(bytes);
    println(hash.bytes_to_string_hex)
);
