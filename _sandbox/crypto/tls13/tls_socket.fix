module Minilib.Crypto.Tls13.TLSSocket;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Monad.BytesIO;
import Minilib.Net.Tcp;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type TLSSocket = unbox struct {
    socket: Socket,
    debug: Bool,
};

make: Socket -> TLSSocket;
make = |socket| TLSSocket {
    socket: socket,
    debug: false
};

_debug_lazy: Lazy String -> TLSSocket -> ();
_debug_lazy = |message, sock| (
    if !sock.@debug { () };
    debug_eprintln(message())
);

impl TLSSocket: BytesIO {
    // type IOType Socket = IOFail;
    send = |bytes, sock| (
        let sent_size = *sock.@socket.Socket::send(bytes);
        eval sock._debug_lazy(|_| "sent:" + sent_size.to_string + " bytes: " +
                        bytes.subarray(0, sent_size).to_string_hex_limit(100));
        pure $ sent_size
    );
    recv = |length, sock| (
        eval sock._debug_lazy(|_| "receiving " + length.to_string + " bytes");
        let bytes = *sock.@socket.Socket::recv(length);
        eval sock._debug_lazy(|_| "received " + bytes.get_size.to_string + " bytes: " +
                        bytes.to_string_hex_limit(100));
        pure $ bytes
    );

    try_recv = |length, sock| (
        eval sock._debug_lazy(|_| "try receiving " + length.to_string + " bytes");
        let opt_bytes = *sock.@socket.Socket::try_recv(length);
        eval sock._debug_lazy(|_|
            opt_bytes.map_or(
                "data not available",
                |bytes| "received " + bytes.get_size.to_string + " bytes: " + bytes.to_string_hex
            )
        );
        pure $ opt_bytes
    );
}
