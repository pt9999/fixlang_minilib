// JSON decoder
module JsonDecoder;

import Character;
import Debug;
import HashMap;

import Json;
import SimpleParser;
import StringEx;

decode: String -> Result ErrMsg Json;
decode = |str| (
    let p = _wrap_whitespaces(_parse_value)
        .then(keep_left, match_end_of_stream);
    let (json, next) = *(p.run_parser_str(str));
    pure $ json
);

//=============================================================
// 1. Introduction
//=============================================================

// The definitions below are private, so users of this module do not
// need to worry about them.
//
// JSON file format is specified by RFC 8259.
// see: https://datatracker.ietf.org/doc/html/rfc8259

//=============================================================
// 2. JSON Grammer
//=============================================================

_begin_array: Parser String;
_begin_array = _wrap_whitespaces(match_str("["));

_begin_object: Parser String;
_begin_object = _wrap_whitespaces(match_str("{").debug("{"));

_end_array: Parser String;
_end_array = _wrap_whitespaces(match_str("]"));

_end_object: Parser String;
_end_object = _wrap_whitespaces(match_str("}"));

_name_separator: Parser String;
_name_separator = _wrap_whitespaces(match_str(":"));

_value_separator: Parser String;
_value_separator = _wrap_whitespaces(match_str(","));

_ws: Parser ();
_ws = class_whitespace.debug("ws").map(|str| ());

_wrap_whitespaces: Parser a -> Parser a;
_wrap_whitespaces = |p| (
    _ws.then(keep_right, p)
    .then(keep_left, _ws)
);

//=============================================================
// 3. Values
//=============================================================

_parse_value: Parser Json;
_parse_value = parser $ |s| (
    // Make a lazy parser, so that we can avoid stack overflow.
    let parser = (
        _parse_null.map(null)
        .or_else(_parse_bool.debug("_parse_bool").map(bool))
        .or_else(_parse_string.debug("_parse_string").map(string))
        .or_else(_parse_object.debug("_parse_obje1ct").map(object))
        .or_else(_parse_array.debug("_parse_array").map(array))
    );
    parser.run_parser(s)
);

_parse_null: Parser ();
_parse_null = match_str("null").forget;

_parse_bool: Parser Bool;
_parse_bool = (
    let parse_true = match_str("true").map(|_| true);
    let parse_false = match_str("false").map(|_| false);
    parse_true.or_else(parse_false)
);

//=============================================================
// 4. Objects
//=============================================================

_parse_object: Parser (HashMap String Json);
_parse_object = (
    let member : Parser (String, Json) = do {

        let k = *_parse_string;
        let _ = *(_name_separator.or_error("Missing ':'"));
        let v = *_parse_value;
        pure $ (k, v)
    };

    let sep_member : Parser (String, Json) = do {
        let _ = *_value_separator;
        member
    };
    let to_hashmap: Array (String, Json) -> HashMap String Json =
        |kvs| kvs.to_iter.fold(
            HashMap::empty(100),
            |h, (k, v)| h.insert(k, v)
        );
    let body : Parser (HashMap String Json) = do {
        let first = *(member.debug("first"));
        let rest = *(repeat(sep_member));
        pure $ [ first ].append(rest).to_hashmap
    };
    let body = body.or_else(
        unit.map(|_| HashMap::empty(0))
    ).debug("body");

    let begin_object = _begin_object.debug("begin_object");
    let end_object = _end_object.or_error("Missing '}'").debug("end_object");

    do {
        let _ = *begin_object;
        let hashmap = *body;
        let _ = *end_object;
        pure $ hashmap
    }
).debug("parse_obj");

_parse_object1: Parser (HashMap String Json);
_parse_object1 = (
    let member : Parser (String, Json) = do {
        let k = *_parse_string.debug("k");
        let _ = *(_name_separator.or_error("Missing ':'"));
        let v = *_parse_value;
        pure $ (k, v)
    };
    let sep_member : Parser (String, Json) = do {
        let _ = *_value_separator.debug("vs");
        member
    };
    let member = match_str("member").map(|k| (k, null())).or_error("err");
    let sep_member = match_str(",member").map(|k| (k, null()));
    let to_hashmap: Array (String, Json) -> HashMap String Json =
        |kvs| kvs.to_iter.fold(
            HashMap::empty(100),
            |h, (k, v)| h.insert(k, v)
        );
    let body : Parser (HashMap String Json) = do {
        let first = *(member.debug("fir1st"));
        let rest = *(repeat(sep_member));
        pure $ [ first ].append(rest).to_hashmap
    };
    let body : Parser (HashMap String Json) = body.or_else(
        unit.map(|_| HashMap::empty(0))
    ).debug("body");

    let begin_object = _begin_object.debug("begin_object");
    let end_object = _end_object.or_error("Missing '}'").debug("end_object");
    do {
        let _ = *begin_object;
        //let hashmap = *body;
        let _ = *end_object;
        pure $ HashMap::empty(0)
    }
).debug("parse_obj1");

//=============================================================
// 5. Arrays
//=============================================================

_parse_array: Parser (Array Json);
_parse_array = (
    let sep_value : Parser Json =
        _value_separator
        .then(keep_right, _parse_value);
    let body = (
        _parse_value
        .then(|(v, vs)| [v].append(vs), 
            repeat(sep_value))
        .or_else(unit.map(|_| Array::empty(0)))
    );

    _begin_array /* .debug_parser(|_| "_begin_array") */
    .then(keep_right, body)
    .then(keep_left, 
        _end_array.or_error("Missing ']'"))
).debug("parse_arr");

//=============================================================
// 6. Numbers
//=============================================================

_parse_number: Parser F64;
_parse_number = (
    let minus = match_str("-");
    let plus = match_str("+");
    let e = match_str("e").or_else(match_str("E"));
    err $ "not-impl"
);

//=============================================================
// 7. Strings
//=============================================================

_match_unquoted_char: Parser U8;
_match_unquoted_char = any_char.filter(|c| c != _DOUBLEQUOTE && c != _BACKSLASH);

_match_unquoted_str: Parser String;
_match_unquoted_str = (
    one_or_more(_match_unquoted_char).map(|array| array._unsafe_to_string)
);


_unhex: U8 -> U8;
_unhex = |c| (
    if /* '0' = */ 48_U8 <= c && c <= /* '9' = */ 57_U8 { c - 48_U8 };
    if /* 'A' = */ 65_U8 <= c && c <= /* 'F' = */ 70_U8 { c - 65_U8 + 10_U8 };
    if /* 'a' = */ 97_U8 <= c && c <= /* 'f' = */ 102_U8 { c - 97_U8 + 10_U8 };
    0_U8 // FIXME abort?
);

_match_quoted_str: Parser String;
_match_quoted_str = (
    let match_escaped: Parser String = (
        any_char
        .map(|c| _unescape_table.@(c.to_I64))
        //.map(|c| eval debug_println("c="+c.to_string); c)
        .filter(|c| c != 0_U8)
        .map(|c| [ c ]._unsafe_to_string)
    );
    let match_hex: Parser U8 = any_char.filter(is_xdigit).map(_unhex);
    let match_hex4: Parser U16 = 
        match_hex
        .then(keep_both, match_hex)
        .then(keep_both, match_hex)
        .then(keep_both, match_hex)
        .map( |(((a,b),c),d)| 
            let a = a.to_U16.shift_left(12_U16);
            let b = b.to_U16.shift_left(8_U16);
            let c = c.to_U16.shift_left(4_U16);
            let d = d.to_U16.shift_left(0_U16);
            a.bit_or(b).bit_or(c).bit_or(d));
    let encode_utf8: U16 -> String = |ch|
        // FIXME not implemented yet
        [ ch.to_U8 ]._unsafe_to_string;
    let match_u_hex4: Parser String = (
        match_char(_ASCII_LOWER_U)
        .then(keep_right, match_hex4)
        .map(encode_utf8)        
    );

    match_char(_BACKSLASH)
    //.debug_parser(|res| "backslash="+ res.to_string)
    .then(
        keep_right,
        match_escaped
        .or_else(match_u_hex4)
    )
);

_match_str_inner: Parser String;
_match_str_inner = (
    repeat(
        _match_quoted_str
        .or_else(_match_unquoted_str) // 1文字以上にマッチ
    ).map(
        |array| array.to_iter.concat_iter
    )
    .or_else(unit.map(|_| ""))
);

_parse_string: Parser String;
_parse_string = (
    match_char(_DOUBLEQUOTE)
    .then(keep_right, _match_str_inner)
    .then(keep_left, 
        match_char(_DOUBLEQUOTE)
        .or_error("The double quote at the end of the string is missing.")
    )
);
