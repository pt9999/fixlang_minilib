// RFC 8017 - PKCS #1: RSA Cryptography Specifications Version 2.2
//
// https://tex2e.github.io/rfc-translater/html/rfc8017.html
// https://datatracker.ietf.org/doc/html/rfc8017
module Minilib.Crypto.Cipher.Rsa.Pkcs1;


import Minilib.Crypto.SHA1;
import Minilib.Crypto.SHA256;
import Minilib.Crypto.SHA512;
import Minilib.Encoding.Binary;
import Minilib.Math.Modular;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Types;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

// 4. Data Conversion Primitives

// I2OSP - Integer-to-Octet-String primitive
// x: nonnegative integer to be converted
// xlen: intended length of the resulting octet string
i2osp: BigInt -> I64 -> Result ErrMsg (Array U8);
i2osp = |x, xlen| (
    if x.is_negative {
        err $ "integer is negative"
    };
    if x >= one.BigInt::shift_left((xlen * 8).to_U64) {
        err $ "integer too large"
    };
    let nat = x.@nat._remove_last_zeros;
    let u32_len = nat.get_size;
    let u8_len = xlen;
    let bytes = Array::fill(u8_len, 0_U8);
    let bytes = Iterator::range(0, u32_len).fold(
        bytes, |bytes, i|
        bytes.set_u32_be(u8_len - (i + 1) * 4, nat.@(i))    // big endian
    );
    ok $ bytes
);

// OS2IP - Octet-String-to-Integer primitive
os2ip: Array U8 -> Result ErrMsg BigInt;
os2ip = FromBytes::from_bytes;

// 5. Cryptographic Primitives

// 5.2.1.  RSASP1
// Input: K RSA private key, where K has one of the following forms:
//          - a pair (n, d)  (NOTE: we use this form)
//          - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
//        m message representative, an integer between 0 and n - 1
// Output: s signature representative, an integer between 0 and n - 1
// Error: "message representative out of range"
rsasp1: (BigInt, BigInt) -> BigInt -> Result ErrMsg BigInt;
rsasp1 = |(n, d), m| (
    if m.is_negative || m >= n {
        err $ "message representative out of range"
    };
    // let s = m^d mod n.
    let s: Modular BigInt = repeat_by_BigInt(mul, one, Modular::make(m, n), d);
    let s: BigInt = s.@value;
    pure $ s
);

// 5.2.2. RSAVP1
// Input: (n, e) RSA public key
//        s signature representative, an integer between 0 and n - 1
// Output: m message representative, an integer between 0 and n - 1
// Error: "signature representative out of range"

rsavp1: (BigInt, BigInt) -> BigInt -> Result ErrMsg BigInt;
rsavp1 = |(n, e), s| (
    if s.is_negative || s >= n {
        err $ "signature representative out of range"
    };
    // Let m = s^e mod n.
    let m: Modular BigInt = repeat_by_BigInt(mul, one, Modular::make(s, n), e);
    let m: BigInt = m.@value;
    pure $ m
);

// 8. Signature Scheme with Appendix

// 8.1.  RSASSA-PSS

// 8.1.1.  Signature Generation Operation
// RSASSA-PSS-SIGN (K, M)
// Input: K        signer's RSA private key (NOTE: we use (n, d) form)
//        M        message to be signed, an octet string
//        salt     a random octet string of length sLen (NOTE: we use salt generated by the calling function.)
// Output: S        signature, an octet string of length k, where k is the length in octets of the RSA modulus n
// Errors: "message too long;" "encoding error"
rsassa_pss_sign: (BigInt, BigInt) -> Array U8 -> Array U8 -> EmsaPssOptions -> Result ErrMsg (Array U8);
rsassa_pss_sign = |(n, d), _M, salt, options| (
    // 1.  EMSA-PSS encoding: Apply the EMSA-PSS encoding operation (Section 9.1.1) to the message M to produce an encoded message
    //     EM of length \ceil ((modBits - 1)/8) octets such that the bit length of the integer OS2IP (EM) (see Section 4.2) is at most
    //     modBits - 1, where modBits is the length in bits of the RSA modulus n:
    let modBits = n.bit_length.to_I64;
    let _EM = *emsa_pss_encode(_M, modBits - 1, salt, options);
    // 2.  RSA signature:
    //     a.  Convert the encoded message EM to an integer message representative m (see Section 4.2):
    let m: BigInt = *os2ip(_EM);
    //     b.  Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and
    //         the message representative m to produce an integer signature representative s:
    let s = *rsasp1((n, d), m);
    //     c.  Convert the signature representative s to a signature S of length k octets (see Section 4.1):
    let k = (n.bit_length.to_I64 + 7) / 8;
    let _S = *i2osp(s, k);
    // 3.  Output the signature S.
    ok $ _S
);

// 8.1.2.  Signature Verification Operation
// RSASSA-PSS-VERIFY ((n, e), M, S)
// Input: (n, e)  signer's RSA public key
//        M       message whose signature is to be verified, an octet string
//        S       signature to be verified, an octet string of length k,
//                  where k is the length in octets of the RSA modulus n
// Output: "valid signature" or "invalid signature"
rsassa_pss_verify: (BigInt, BigInt) -> Array U8 -> Array U8 -> EmsaPssOptions -> Result ErrMsg ();
rsassa_pss_verify = |(n, e), _M, _S, options| (
    // 1. Length checking: If the length of the signature S is not k octets, output "invalid signature" and stop.
    let k = (n.bit_length.to_I64 + 7) / 8;
    if _S.get_size != k { err $ "invalid signature" };
    // 2. RSA verification:
    //    a. Convert the signature S to an integer signature representative s (see Section 4.2):
    let s: BigInt = *os2ip(_S);
    //    b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e)
    //       and the signature representative s to produce an integer message representative m:
    let m = *rsavp1((n, e), s);
    //    c.  Convert the message representative m to an encoded message EM of length
    //        emLen = \ceil ((modBits - 1)/8) octets, where modBits is the length in bits of
    //        the RSA modulus n (see Section 4.1):
    let modBits = n.bit_length.to_I64;
    let emLen = ((modBits - 1) + 7) / 8;
    let _EM = *i2osp(m, emLen);
    eval assert(|_| "unexpected: (emLen, k, modBits)=" + (emLen, k, modBits).to_string,
            if (modBits - 1) % 8 == 0 { emLen == k - 1 } else { emLen == k });
    // 3.  EMSA-PSS verification: Apply the EMSA-PSS verification operation (Section 9.1.2)
    //     to the message M and the encoded message EM to determine whether they are consistent:
    emsa_pss_verify(_M, _EM, modBits - 1, options)
);

// 8.2.1. Signature Generation Operation
// RSASSA-PKCS1-V1_5-SIGN (K, M)
// Input: K signer's RSA private key  (NOTE: we use (n, d) form)
//        M message to be signed, an octet string
// Output: S signature, an octet string of length k, where k is the
//           length in octets of the RSA modulus n
// Errors:  "message too long"; "RSA modulus too short"
rsassa_pkcs1_v1_5_sign: (BigInt, BigInt) -> Array U8 -> EmsaPkcs1Options -> Result ErrMsg (Array U8);
rsassa_pkcs1_v1_5_sign = |(n, d), _M, options| (
    // 1.  EMSA-PKCS1-v1_5 encoding
    let k = (n.bit_length.to_I64 + 7) / 8;
    let _EM = *emsa_pkcs1_v1_5_encode(_M, k, options);
    // 2.  RSA signature:
    // a.  Convert the encoded message EM to an integer message representative m (see Section 4.2):
    let m: BigInt = *os2ip(_EM);
    // b.  Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and the message representative m to
    //     produce an integer signature representative s:
    let s = *rsasp1((n, d), m);
    // c.  Convert the signature representative s to a signature S of length k octets (see Section 4.1):
    let _S = *i2osp(s, k);
    // 3.  Output the signature S.
    ok $ _S
);

// 8.2. RSASSA-PKCS1-v1_5
// RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)
// Input: (n, e) signer's RSA public key
//        M message whose signature is to be verified, an octet string
//        S signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n
// Output: "valid signature" or "invalid signature"
// Errors: "message too long"; "RSA modulus too short"
rsassa_pkcs1_v1_5_verify: (BigInt, BigInt) -> Array U8 -> Array U8 -> EmsaPkcs1Options -> Result ErrMsg ();
rsassa_pkcs1_v1_5_verify = |(n, e), _M, _S, options| (
    // 1. Length checking: If the length of the signature S is not k octets, output "invalid signature" and stop.
    //let n_bytes = n.to_bytes;
    //let k = n_bytes.get_size;
    let k = (n.bit_length.to_I64 + 7) / 8;
    if _S.get_size != k { err $ "invalid signature" };
    // 2. RSA verification:
    //    a. Convert the signature S to an integer signature representative s (see Section 4.2):
    let s: BigInt = *os2ip(_S);
    //    b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e)
    //       and the signature representative s to produce an integer message representative m:
    let m = *rsavp1((n, e), s);
    //    c. Convert the message representative m to an encoded message EM of length k octets (see Section 4.1):
    let _EM = *i2osp(m, k);
    // 3. EMSA-PKCS1-v1_5 encoding:
    //    Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2)
    //    to the message M to produce a second encoded message EM' of length k octets:
    let _EM_dash = *emsa_pkcs1_v1_5_encode(_M, k, options);
    // 4. Compare the encoded message EM and the second encoded message EM'.
    //    If they are the same, output "valid signature"; otherwise, output "invalid signature".
    if _EM != _EM_dash { err $ "invalid signature" };
    ok()
);

// 9. Encoding Methods for Signatures with Appendix
// 9.1. EMSA-PSS

// 9.1.1. Encoding Operation
// EMSA-PSS-ENCODE (M, emBits)
// Options:
//  Hash hash function (hLen denotes the length in octets of the hash function output)
//  MGF mask generation function
//  sLen intended length in octets of the salt
// Input:
//  M message to be encoded, an octet string
//  emBits maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen + 8sLen + 9
//  salt: a random octet string of length sLen (NOTE: we use salt generated by the calling function.)
// Output:
//  EM encoded message, an octet string of length emLen = \ceil(emBits/8)
// Errors:
//  "Encoding error"; "message too long"
emsa_pss_encode: Array U8 -> I64 -> Array U8 -> EmsaPssOptions -> Result ErrMsg (Array U8);
emsa_pss_encode = |_M, emBits, salt, options| (
    let EmsaPssOptions {
        hash: hash,
        hLen: hLen,
        mgf: mgf,
        sLen: sLen,
        max_message_size: max_message_size
    } = options;
    // 1.   If the length of M is greater than the input limitation for the hash function (2^61 - 1 octets for SHA-1), output "message too long" and stop.
    if _M.get_size > options.@max_message_size { err $ "message too long" };
    // 2.   Let mHash = Hash(M), an octet string of length hLen.
    let mHash = hash(_M);
    // 3.   If emLen < hLen + sLen + 2, output "encoding error" and stop.
    let emLen = (emBits + 7) / 8;
    if emLen < hLen + sLen + 2 {
        err $ "encoding error"
    };
    // 4.   Generate a random octet string salt of length sLen; if sLen = 0, then salt is the empty string.
    // (NOTE: we use salt which is passed as an argument of this function)
    if salt.get_size != sLen { err $ "salt length mismatch" };
    // 5.   Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;
    let _M_dash = Array::fill(8, 0_U8).append(mHash).append(salt);
    // 6.   Let H = Hash(M'), an octet string of length hLen.
    let _H = hash(_M_dash);
    // 7.   Generate an octet string PS consisting of emLen - sLen - hLen - 2 zero octets.  The length of PS may be 0.
    let _PS = Array::fill(emLen - sLen - hLen - 2, 0_U8);
    // 8.   Let DB = PS || 0x01 || salt; DB is an octet string of length emLen - hLen - 1.
    let _DB = _PS.append([0x01_U8]).append(salt);
    // 9.   Let dbMask = MGF(H, emLen - hLen - 1).
    let dbMask = *mgf(_H, emLen - hLen - 1, hash, hLen);
    // 10.  Let maskedDB = DB \xor dbMask.
    let maskedDB = Array::from_map(_DB.get_size, |i| _DB.@(i).bit_xor(dbMask.@(i)));
    // 11.  Set the leftmost 8emLen - emBits bits of the leftmost octet in maskedDB to zero.
    let k = 8 * emLen - emBits;
    eval assert(|_| "k out of range", 0 <= k && k < 8);
    let kmask = 0xFF_U8.shift_left((8-k).to_U8);
    let maskedDB = maskedDB.mod(0, bit_and(kmask.bit_xor(0xFF_U8)));
    // 12.  Let EM = maskedDB || H || 0xbc.
    let _EM = maskedDB.append(_H).append([0xbc_U8]);
    // 13.  Output EM.
    ok $ _EM
);

// 9.1.2. Verification Operation
// EMSA-PSS-VERIFY (M, EM, emBits)
// Options:
//  Hash hash function (hLen denotes the length in octets of the hash function output)
//  MGF mask generation function
//  sLen intended length in octets of the salt
// Input:
//  M        message to be verified, an octet string
//  EM       encoded message, an octet string of length emLen = \ceil(emBits/8)
//  emBits   maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen + 8sLen + 9
// Output:
//  "consistent" or "inconsistent"
emsa_pss_verify: Array U8 -> Array U8 -> I64 -> EmsaPssOptions -> Result ErrMsg ();
emsa_pss_verify = |_M, _EM, emBits, options| (
    let inconsistent_error = "emsa_pss_verify: inconsistent: ";
    let EmsaPssOptions {
        hash: hash,
        hLen: hLen,
        mgf: mgf,
        sLen: sLen,
        max_message_size: max_message_size
    } = options;
    // check the input limitation for the hash function
    if _M.get_size > max_message_size { err $ "message too long" };
    let mHash = hash(_M);
    let emLen = (emBits + 7) / 8;
    //eval debug_eprintln("(emLen, hLen, sLen) ="  + (emLen, hLen, sLen).to_string);
    if emLen < hLen + sLen + 2 {
        err $ inconsistent_error + "emLen too small: " + (emLen, hLen + sLen + 2).to_string
    };
    if _EM.get_size == 0 {
        err $ inconsistent_error + "EM is empty"
    };

    if _EM.@(_EM.get_size - 1) != 0xbc_U8 {
        err $ inconsistent_error + "the last byte of EM is not 0xbc: " + _EM.@(_EM.get_size - 1).to_string_hex
    };
    let maskedDB = _EM.subarray(0, emLen - hLen - 1);
    let _H = _EM.subarray(emLen - hLen - 1, emLen - 1);
    let k = 8 * emLen - emBits;
    eval assert(|_| "k out of range", 0 <= k && k < 8);
    let kmask = 0xFF_U8.shift_left((8-k).to_U8);
    if _EM.@(0).bit_and(kmask) != 0_U8 {
        err $ inconsistent_error + "the masked first byte is not zero: @(0)=" + _EM.@(0).to_string_hex + " k=" + k.to_string
    };
    let dbMask = *mgf(_H, emLen - hLen - 1, hash, hLen);
    eval assert(|_| "maskedDB and dbMask size unmatch", maskedDB.get_size == dbMask.get_size);
    let _DB = Array::from_map(maskedDB.get_size, |i| maskedDB.@(i).bit_xor(dbMask.@(i)));
    let _DB = _DB.mod(0, bit_and(0xFF_U8.bit_xor(kmask)));

    let _DB_left = _DB.subarray(0, emLen - hLen - sLen - 2);
    let is_all_zeros = _DB_left.find_by(|u8| u8 != 0_U8).is_none;
    if !is_all_zeros {
        err $ inconsistent_error + "DB_left is not all zero: " + _DB_left.to_string_hex
    };
    // NOTE: The leftmost position is "position 1",
    //       so "position emLen - hLen - sLen - 1" is `@(emLen - hLen - sLen - 2)`.
    let _DB_middle = _DB.@(emLen - hLen - sLen - 2);
    if _DB_middle != 0x01_U8 {
        err $ inconsistent_error + "DB_middle is not one: " + _DB_middle.to_string_hex + " DB=" + _DB.to_string_hex
    };
    let salt = _DB.subarray(_DB.get_size - sLen, _DB.get_size);
    let _M_dash = Array::fill(8, 0_U8).append(mHash).append(salt);
    let _H_dash = hash(_M_dash);
    if _H != _H_dash {
        err $ inconsistent_error + "H and H_dash does not match: H=" + _H.to_string_hex + " H_dash=" + _H_dash.to_string_hex
    };
    ok()    // consistent
);

type EmsaPssOptions = unbox struct {
    hash: Array U8 -> Array U8,     // hash function
    hLen: I64,                      // the length in octets of the hash function output
    mgf: MaskGenerationFunction,    // mask generation function
    sLen: I64,                      // intended length in octets of the salt
    max_message_size: I64,          // max message size (inclusive) for the hash function. see FIPS180-4 Figure 1
};

emsa_pss_options_sha256: EmsaPssOptions;
emsa_pss_options_sha256 = EmsaPssOptions {
    hash: SHA256::digest,
    hLen: 32,
    mgf: mgf1,
    sLen: 32,
    max_message_size: 1.shift_left(61) - 1,     // 2^64 bites = 2^61 bytes
};

emsa_pss_options_sha384: EmsaPssOptions;
emsa_pss_options_sha384 = EmsaPssOptions {
    hash: SHA384::digest,
    hLen: 48,
    mgf: mgf1,
    sLen: 48,
    max_message_size: I64::maximum,             // actually 2^128 bits = 2^125 bytes
};

emsa_pss_options_sha512: EmsaPssOptions;
emsa_pss_options_sha512 = EmsaPssOptions {
    hash: SHA512::digest,
    hLen: 64,
    mgf: mgf1,
    sLen: 64,
    max_message_size: I64::maximum,             // actually 2^128 bits = 2^125 bytes
};

// 9.2. EMSA-PKCS1-v1_5
// EMSA-PKCS1-v1_5-ENCODE (M, emLen)
// Option: Hash hash function (hLen denotes the length in octets of the hash function output)
// Input:  M        message to be encoded
//           emLen    intended length in octets of the encoded message, at
//               least tLen + 11, where tLen is the octet length of the
//               Distinguished Encoding Rules (DER) encoding T of
//               a certain value computed during the encoding operation
// Output: EM       encoded message, an octet string of length emLen
// Errors:  "message too long"; "intended encoded message length too short"
emsa_pkcs1_v1_5_encode: Array U8 -> I64 -> EmsaPkcs1Options -> Result ErrMsg (Array U8);
emsa_pkcs1_v1_5_encode = |_M, emlen, options| (
    // 1.  Apply the hash function to the message M to produce a hash value H:
    let _H: Array U8 = (options.@hash)(_M);
    // 2.  Encode the algorithm ID for the hash function and the hash
    // value into an ASN.1 value of type DigestInfo (see
    // Appendix A.2.4) with the DER
    let _T: Array U8 = options.@der_encoding.append(_H);
    let tlen = _T.get_size;
    // 3.  If emLen < tLen + 11, output "intended encoded message length too short" and stop.
    if emlen < tlen + 11 {
        err $ "intended encoded message length too short"
    };
    // 4.  Generate an octet string PS consisting of emLen - tLen - 3
    //     octets with hexadecimal value 0xff.  The length of PS will be
    //     at least 8 octets.
    let _PS = Array::fill(emlen - tlen - 3, 0xFF_U8);
    // 5.  Concatenate PS, the DER encoding T, and other padding to form
    //     the encoded message EM as
    let _EM = [0x00_U8, 0x01_U8].append(_PS).append([0x00_U8]).append(_T);
    pure $ _EM
);


type EmsaPkcs1Options = unbox struct {
    hash: Array U8 -> Array U8,
    der_encoding: Array U8,         // see "Notes 1" of "9.2. EMSA-PKCS1-v1_5"
};

emsa_pkcs1_options_sha1: EmsaPkcs1Options;
emsa_pkcs1_options_sha1 = EmsaPkcs1Options {
    hash: SHA1::digest,
    der_encoding: "30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha256: EmsaPkcs1Options;
emsa_pkcs1_options_sha256 = EmsaPkcs1Options {
    hash: SHA256::digest,
    der_encoding: "30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha384: EmsaPkcs1Options;
emsa_pkcs1_options_sha384 = EmsaPkcs1Options {
    hash: SHA384::digest,
    der_encoding: "30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30".from_string_hex.as_ok,
};

emsa_pkcs1_options_sha512: EmsaPkcs1Options;
emsa_pkcs1_options_sha512 = EmsaPkcs1Options {
    hash: SHA512::digest,
    der_encoding: "30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40".from_string_hex.as_ok,
};

// B.2. Mask Generation Functions
// B.2.1. MGF1

type MaskGenerationFunction = Array U8 -> I64 -> (Array U8 -> Array U8) -> I64 -> Result ErrMsg (Array U8);

mgf1: MaskGenerationFunction;
mgf1 = |mgf_seed, mask_len, hash, hLen| (
    if mask_len >= 1.shift_left(32) * hLen {
        err $ "mask too long"
    };
    let _T = Array::empty(0);
    let n = (mask_len + hLen - 1) / hLen;
    let _T = *Iterator::range(0, n).fold_m(_T, |_T, counter|
        let _C = *i2osp(BigInt::from_I64(counter), 4);
        let _T = _T.append(hash(mgf_seed.append(_C)));
        pure $ _T
    );
    ok $ _T.subarray(0, mask_len)
);
