module Sandbox.BigFloat;

import Math;
import Debug;

import Minilib.Math.BigInt;
import Minilib.Text.StringEx;

namespace BigNatEx {
    _is_zero_ex: Array U32 -> Bool;
    _is_zero_ex = |a| (
        loop(
            a.get_size - 1, |i|
            if i < 0 { break $ true };
            if a.@(i) != 0_U32 { break $ false };
            continue $ i - 1
        )
    );

    // Returns the bit length of `a`, ie. one plus the bit position of most significant `1`.
    // Returns 0 if `a` is zero.
    _bit_length: Array U32 -> U64;
    _bit_length = |a| (
        let a = a._remove_last_zeros;
        let n = a.get_size;
        let last_digit = a.@(n-1);
        if last_digit == 0_U32 {
            eval assert(|_| "_remove_last_zeros did not remove last zero", n == 1);
            0_U64
        };
        let last_bit_length = loop(
            _log2_base.to_U32 - 1_U32, |bit|
            if last_digit.shift_right(bit).bit_and(1_U32) != 0_U32 {
                break $ bit + 1_U32
            };
            if bit == 0_U32 {
                eval assert(|_| "should not reach here", false);
                break $ 0_U32
            };
            continue $ bit - 1_U32
        );
        let bit_length = (n-1).to_U64 * _log2_base + last_bit_length.to_U64;
        bit_length
    );

    // Calculates `a^n`.
    _pow_by_U64: Array U32 -> U64 -> Array U32;
    _pow_by_U64 = |a, n| (
        loop(
            ([1_U32], a, n), |(prod, a, n)|
            if n == 0_U64 {
                break $ prod
            };
            let prod = if n.bit_and(1_U64) != 0_U64 {
                _mul(prod, a)
            } else { prod };
            continue $ (prod, _mul(a,a), n.shift_right(1_U64))
        )
    );

    _shift_left: U64 -> Array U32 -> Array U32;
    _shift_left = |shift, a| (
        if shift == 0_U64 { a };
        let (off, shift) = _divmod_log2_base(shift);
        let n = a.get_size;
        let a = loop(
            (a, 0_U64, 0), |(a, carry, i)|
            if i >= n {
                break $ if carry != 0_U64 { a.push_back(carry.to_U32) } else { a }
            };
            let d = a.@(i).to_U64;
            let carry2 = d.shift_right(_log2_base - shift);
            let d = d.shift_left(shift).bit_or(carry);
            let a = a.set(i, d.to_U32);
            continue $ (a, carry2, i + 1)
        );
        if off != 0_U64 { Array::fill(off.to_I64, 0_U32).append(a) } else { a }
    );

    _shift_right: U64 -> Array U32 -> Array U32;
    _shift_right = |shift, a| (
        if shift == 0_U64 { a };
        let (off, shift) = _divmod_log2_base(shift);
        let a = if off == 0_U64 { a }
        else if off.to_I64 < a.get_size { a.get_sub(off.to_I64, a.get_size) }
        else { [0_U32] };
        let n = a.get_size;
        let a = loop(
            (a, 0_U64, n-1), |(a, carry, i)|
            if i < 0 {
                break $ a
            };
            let d = a.@(i).to_U64;
            let carry2 = d.shift_left(_log2_base - shift);
            let d = d.shift_right(shift).bit_or(carry);
            let a = a.set(i, d.to_U32);
            continue $ (a, carry2, i - 1)
        );
        a._remove_last_zeros
    );

    // Calculates `(a0 / 2 ^ exp, a0 % 2 ^ exp)`.
    // Aborts if any error occured.
    _divmod_by_power_of_two: Array U32 -> U64 -> (Array U32, Array U32);
    _divmod_by_power_of_two = |a0, exp| (
        if exp == 0_U64 {
            (a0, BigNat::_zero)
        };
        if exp >= a0.get_size.to_U64 * _log2_base {
            (BigNat::_zero, a0)
        };
        let (exp_quo, exp_rem) = _divmod_log2_base(exp);
        eval assert(|_| "exp_quo too big", exp_quo < a0.get_size.to_U64);
        let quo = a0._shift_right(exp);
        let rem = a0.get_sub(0, exp_quo.to_I64);
        let rem = if exp_rem == 0_U64 { rem }
        else {
            let d0 = a0.@(exp_quo.to_I64);
            let mask = (1_U64.shift_left(exp_rem) - 1_U64).to_U32;
            rem.push_back(d0.bit_and(mask))
        };
        (quo, rem)
    );

    // Returns the square root of `a`.
    _sqrt: Array U32 -> Array U32;
    _sqrt = |a| (
        if a._is_zero { BigNat::_zero };
        let n = a.get_size;
        let x = Array::fill(n / 2, 0_U32).append([1_U32]);
        let max_loop = a.get_size * _log2_base.to_I64;
        _sqrt_inner(x, a, max_loop)
    );

    // Returns the square root of `a` using Newton-Raphson method.
    _sqrt_inner: Array U32 -> Array U32 -> I64 -> Array U32;
    _sqrt_inner = |x, a, max_loop| (
        // f(x) = x^2 - a
        // x <- x - f(x) / f'(x)
        // x <- x - (x^2 - a) / 2x
        // x <- (2x^2 - x^2 + a) / 2x
        // x <- (x^2 + a) / 2x
        if max_loop < 0 { x };
        let xsq_a = _add(_mul(x, x), a);        // x^2 + a
        let x2 = x._mul_u32(2_U32);             // 2x
        let (quo, rem) = _divmod(xsq_a, x2);
        let quo = quo._remove_last_zeros;
        if quo == x { x };
        _sqrt_inner(quo, a, max_loop - 1)
    );
}

namespace BigIntEx {
    shift_right: U64 -> BigInt -> BigInt;
    shift_right = |shift, a| (
        a.mod_nat(_shift_right(shift))
    );
}

// Arbitrary-precision floating point number.
// It is interpreted as `@int * 2 ^ @exp`.
type BigFloat = unbox struct {
    int: BigInt,        // bigint
                        // NOTE: @int.@nat might have trailing zeros.
    exp: I64            // the exponent of base 2
};

namespace BigFloat {
    // Creates a BigFloat from a BigInt and the exponent of base 2.
    make: BigInt -> I64 -> BigFloat;
    make = |int, exp| (
        BigFloat { int: int, exp: exp }
    );

    _zero: BigFloat;
    _zero = BigFloat { int: Zero::zero, exp: 0 };

    // Returns true iff the BigFloat is zero.
    is_zero: BigFloat -> Bool;
    is_zero = |a| a.@int.@nat._is_zero_ex;

    // Returns true iff the BigFloat is positive.
    is_positive: BigFloat -> Bool;
    is_positive = |a| a.@int.is_positive;

    // Returns true iff the BigFloat is negative.
    is_negative: BigFloat -> Bool;
    is_negative = |a| a.@int.is_negative;

    // Converts F64 to BigFloat.
    from_F64: F64 -> BigFloat;
    from_F64 = |f64| (
        if f64 == 0.0 { BigFloat::_zero };
        let sign = if f64 < 0.0 { -1 } else { 1 };
        let f64 = f64.abs;
        let (fr, exp) = Math::frexp(f64);
        let exp = exp.to_I64 - 53;
        let fr = fr * 2.0.Math::pow(53.0);
        let (quo, rem) = _divmod_base(fr.to_U64);
        let nat = [rem.to_U32, quo.to_U32];
        BigFloat::make(BigInt::make(sign, nat), exp)
    );

    // Converts BigFloat to F64. If BigFloat is out of range of F64, unexpected result is returned.
    to_F64: BigFloat -> F64;
    to_F64 = |a| (
        if a.is_zero { 0.0 };
        let a = a.set_prec(53);
        eval assert(|_| "invalid nat size", a.@int.@nat.get_size <= 2);
        let u64 = a.@int.@nat._to_u64;
        let sign = a.@int.@sign;
        let f64 = sign.to_F64 * u64.to_F64 * 2.0.Math::pow(a.@exp.to_F64);
        f64
    );

    // Gets the precision of a BigFloat in base 10.
    // It calls `get_prec()` and converts the precision from base 2.
    get_prec10: BigFloat -> I64;
    get_prec10 = |a| (
        let prec = a.get_prec;
        let prec10 = Math::floor(prec.to_F64 * Math::log10(2.0)).to_I64;
        prec10
    );

    // Gets the precision of a BigFloat in base 2. It is multiple of 32.
    get_prec: BigFloat -> I64;
    get_prec = |a| (
        a.@int.@nat.get_size * BigNat::_log2_base.to_I64
    );
    
    // Sets the precision of a BigFloat in base 10. 
    // It calls `set_prec()` after converting the precision to base 2.
    set_prec10: I64 -> BigFloat -> BigFloat;
    set_prec10 = |prec10, a| (
        let prec = Math::ceil(prec10.to_F64 / Math::log10(2.0)).to_I64;
        a.set_prec(prec)
    );

    // Set the precision of a BigFloat in base2.
    // The precision is round-up to multiple of 32, except if `prec == 0` then the precision is set to 32.
    set_prec: I64 -> BigFloat -> BigFloat;
    set_prec = |prec, a| (
        // Round-up the precision to the multiple of _log2_base.
        let prec = (
            if prec == 0 { _log2_base.to_I64 };
            let (quo, rem) = _divmod_log2_base(prec.to_U64);
            let quo = if rem == 0_U64 { quo } else { quo + 1_U64 };
            (quo * _log2_base).to_I64
        );

        // Shift-left a.@int.@nat such that MSB == 1
        let a = _lift_prec_bf(a);

        let old_size = a.@int.@nat.get_size;
        let new_size = prec / BigNat::_log2_base.to_I64;
        if old_size == new_size {
            a
        };
        let a = if old_size < new_size {
            a.mod_int(mod_nat $ |nat|
                Array::fill(new_size - old_size, 0_U32).append(nat)
            )
        } else { // old_size > new_size
            a.mod_int(mod_nat $ |nat|
                let n = old_size - new_size;
                // round up if truncated part >= 0.5
                let round_up = nat.@(n - 1) >= _base.shift_right(1_U64).to_U32;
                let nat = nat.get_sub(n, old_size);
                let nat = if round_up { _add(nat, BigNat::_one) } else { nat };
                nat
            )
        };
        let a = a.mod_exp(|exp|
            exp + (old_size - new_size) * BigNat::_log2_base.to_I64
        );
        a
    );

    // shift-left such that MSB is 1
    _lift_prec_bf: BigFloat -> BigFloat;
    _lift_prec_bf = |a| (
        if a.is_zero { a };
        let nat = a.@int.@nat;
        let last_digit = nat.@(nat.get_size - 1);
        if last_digit.shift_right(_log2_base.to_U32 - 1_U32).bit_and(1_U32) != 0_U32 {
            a
        };
        let bit_length = nat._bit_length;
        let (_, last_bit_length) = _divmod_log2_base(bit_length);
        let shift = _log2_base - last_bit_length;
        let a = a.mod_int(mod_nat(_shift_left(shift)));
        let a = a.mod_exp(|exp| exp - shift.to_I64);
        a
    );


    // Calculates `a * 2^e`.
    mul_pow2: I64 -> BigFloat -> BigFloat;
    mul_pow2 = |e, a| (
        a.mod_exp(|exp| exp + e)
    );

    // Returns the square root of `a`.
    sqrt: BigFloat -> BigFloat;
    sqrt = |a| (
        eval assert(|_| "out of range: a="+a.to_string, !a.is_negative);
        if a.is_zero { BigFloat::_zero };
        let x = BigFloat::from_F64(1.0);
        let max_loop = a.get_prec;
        BigFloat::_sqrt_inner(x, a, max_loop)
    );

    // Returns the square root of `a` using Newton-Raphson method.
    _sqrt_inner: BigFloat -> BigFloat -> I64 -> BigFloat;
    _sqrt_inner = |x, a, max_loop| (
        // f(x) = x^2 - a
        // x <- x - f(x) / f'(x)
        // x <- x - (x^2 - a) / 2x
        // x <- (2x^2 - x^2 + a) / 2x
        // x <- (x^2 + a) / 2x
        if max_loop < 0 { x };
        let xsq_a = x * x + a;              // x^2 + a
        let x2 = x.mul_pow2(1);             // 2x
        let quo = xsq_a / x2;
        let quo = quo.set_prec(a.get_prec);
        if quo == x { x };
        _sqrt_inner(quo, a, max_loop - 1)
    );

    // Convert to string of internal representation.
    _to_string_rep: BigFloat -> String;
    _to_string_rep = |a| (
        "{ sign=" + a.@int.@sign.to_string +
        " nat=" + a.@int.@nat.to_string +
        " exp=" + a.@exp.to_string +
        " }"
    );

    // Convert a BigFloat to a string. The precision is the count of digits in fractional part,
    // specified in base 10.
    // For example, `a.to_string_precision(20)` has 20 digits in fractional part.
    to_string_precision: I64 -> BigFloat -> String;
    to_string_precision = |prec10, a| (
        eval assert(|_| "invalid prec10", prec10 >= 0);
        if a.is_negative {
            "-" + a.neg.to_string_precision(prec10)
        };
        let a_nat = a.@int.@nat;
        let a_exp = a.@exp;
        // multiply a_nat by 10^prec10.
        let a_nat = if prec10 == 0 { 
            a_nat 
        } else { 
            _mul(a_nat, _pow_by_U64([10_U32], prec10.to_U64))
        };
        // multiply a_nat by 2^a_exp.
        let a_nat = if a_exp >= 0 {
            a_nat._shift_left(a_exp.to_U64)
        } else {
            let neg_exp = (-a_exp).to_U64;
            let (quo, rem) = _divmod_by_power_of_two(a_nat, neg_exp);
            // round-up by rem
            let rem = rem._shift_right(neg_exp - 1_U64)._remove_last_zeros;
            if rem._is_zero { quo } else { _add(quo, BigNat::_one) }
        };
        
        // convert BigNat to a string.
        let str = a_nat._to_string;
        if prec10 == 0 {
            str
        };
        let str = if str.get_size >= prec10 + 1 { str }
        else { 
            let zero_padding = Array::fill(prec10 + 1 - str.get_size, '0');
            zero_padding._unsafe_to_string + str
        };
        let int_part = str.get_sub(0, str.get_size - prec10);
        let frac_part = str.get_sub(str.get_size - prec10, str.get_size);
        int_part + "." + frac_part 
    );
}

impl BigFloat: ToString {
    to_string = |a| (
        // count of fractional digits (not same as a.get_prec10).
        let prec10 = if a.@exp >= 0 { 
            0
        } else { 
            Math::floor((-a.@exp).to_F64 * Math::log10(2.0)).to_I64 
        };
        a.to_string_precision(prec10)
    );
}

impl BigFloat: Eq {
    eq = |a, b| (
        let c = a - b;
        c.is_zero
    );
}

impl BigFloat: LessThan {
    less_than = |a, b| (
        let c = a - b;
        c.is_negative
    );
}

impl BigFloat: LessThanOrEq {
    less_than_or_eq = |a, b| (
        let c = a - b;
        !c.is_positive
    );
}

impl BigFloat: Zero {
    zero = BigFloat::_zero;
}

impl BigFloat: Neg {
    neg = |a| a.mod_int(neg);
}

impl BigFloat: Add {
    add = |a, b| (
        if a.is_zero { b };
        if b.is_zero { a };
        let prec = max(a.get_prec, b.get_prec);
        let a = a.set_prec(prec);
        let b = b.set_prec(prec);
        let a_exp = a.@exp;
        let b_exp = b.@exp;
        if a_exp < b_exp { add(b, a) };
        // now a_exp >= b_exp
        // LSB of a is 2^(a_exp+a_prec-1)
        let c_exp = a_exp;
        let diff_exp = a_exp - b_exp;
        let a_int = a.@int;
        let b_int = b.@int;
        let c_int = if diff_exp >= prec {
            a_int
        } else {
            a_int + b_int.shift_right(diff_exp.to_U64)
        };
        BigFloat::make(c_int, c_exp).set_prec(prec)
    );
}

impl BigFloat: Sub {
    sub = |a, b| (
        a.add(b.neg)
    );
}

impl BigFloat: Mul {
    mul = |a, b| (
        if a.is_zero { BigFloat::_zero };
        if b.is_zero { BigFloat::_zero };
        let prec = max(a.get_prec, b.get_prec);
        let a = a.set_prec(prec);
        let b = b.set_prec(prec);
        let c_int = a.@int * b.@int;
        let c_exp = a.@exp + b.@exp;
        BigFloat::make(c_int, c_exp).set_prec(prec)
    );
}

impl BigFloat: Div {
    div = |a, b| (
        if a.is_zero { BigFloat::_zero };
        if b.is_zero { BigFloat::_zero };
        let prec = max(a.get_prec, b.get_prec);
        let a = a.set_prec(2 * prec);
        let b = b.set_prec(prec);
        // TODO: round c_int by fraction
        let c_int = a.@int / b.@int;
        let c_exp = a.@exp - b.@exp;
        BigFloat::make(c_int, c_exp).set_prec(prec)
    );
}
