module Main;

import Debug;

import RegExp;
import StringEx;
import UnitTest;

impl [a:Eq, e:Eq] Result e a: Eq
{
    eq = |a, b| (
        if a.is_ok && b.is_ok { a.as_ok == b.as_ok };
        if a.is_err && b.is_err { a.as_err == b.as_err };
        false
    );
}

_NotMatch: String;
_NotMatch = "NotMatch";

test_regexp_match_flags: (String, String, String, Result ErrMsg (Array String)) -> TestCase;
test_regexp_match_flags = |(pattern, flags, target, expected)| (
    let testname = "test_regexp_match_flags(" + pattern + "," + flags + "," + target + ")";
    make_test(testname) $ |_|
    let actual = do {
        let regexp = *RegExp::compile(pattern, flags);
        regexp.match(target)
    };
    let _ = *if expected.is_ok {
        assert_equal("eq", expected, actual)
    } else {
        let _ = *assert_true("is_err", actual.is_err);
        // check whether it contains the expected error message
        let check = actual.as_err.find(expected.as_err, 0).is_some;
        assert_true("does not contain expected error message:" +
            " expected=" + expected.as_err +
            " actual=" + actual.as_err, 
            check)
    };
    pure()
);

test_regexp_match: (String, String, Result ErrMsg (Array String)) -> TestCase;
test_regexp_match = |(pattern, target, expected)| (
    test_regexp_match_flags $ (pattern, "", target, expected)
);

test_empty: TestCase;
test_empty = (
    [
        test_regexp_match $ ("", "", ok $ [""]),
        test_regexp_match $ ("", "", ok $ [""]),
        test_regexp_match $ ("a", "", err $ _NotMatch),
        TestCase::empty
    ].run_tests
);

test_char_class_bracket: TestCase;
test_char_class_bracket = (
    [
        test_regexp_match $ ("[a-z]", "a", ok $ ["a"]),
        test_regexp_match $ ("[a-z]", "m", ok $ ["m"]),
        test_regexp_match $ ("[a-z]", "z", ok $ ["z"]),
        test_regexp_match $ ("[a-z]", "A", err $ _NotMatch),
        test_regexp_match $ ("[^a-z]", "a", err $ _NotMatch),
        test_regexp_match $ ("[^a-z]", "A", ok $ ["A"]),
        test_regexp_match $ ("[-a-z]", "-", ok $ ["-"]),
        test_regexp_match $ ("[a-z-]", "-", ok $ ["-"]),
        //test_regexp_match $ ("[---]", "-", ok $ ["-"]),   // not supported
        test_regexp_match $ ("[-]", "-", ok $ ["-"]),
        test_regexp_match $ ("[a-ceg-z]", "c", ok $ ["c"]),
        test_regexp_match $ ("[a-ceg-z]", "d", err $ _NotMatch),
        test_regexp_match $ ("[a-ceg-z]", "e", ok $ ["e"]),
        test_regexp_match $ ("[a-ceg-z]", "f", err $ _NotMatch),
        test_regexp_match $ ("[a-ceg-z]", "g", ok $ ["g"]),
        test_regexp_match $ ("[a-z", "a", err $ "']' is missing"),
        test_regexp_match $ ("[a-z\\]]", "]", ok $ ["]"]),
        test_regexp_match $ ("[\\-]", "-", ok $ ["-"]),
        test_regexp_match $ ("[\\\\]", "\\", ok $ ["\\"]),
        test_regexp_match $ ("[\\d]", "0", ok $ ["0"]),
        test_regexp_match $ ("[\\w]", "a", ok $ ["a"]),
        test_regexp_match $ ("[\\s]", " ", ok $ [" "]),
        test_regexp_match $ ("[\\t]", "\t", ok $ ["\t"]),
        test_regexp_match $ ("[\\r]", "\r", ok $ ["\r"]),
        test_regexp_match $ ("[\\n]", "\n", ok $ ["\n"]),
        test_regexp_match $ ("[\\v]", "\u000b", ok $ ["\u000b"]),
        test_regexp_match $ ("[\\f]", "\u000c", ok $ ["\u000c"]),
        test_regexp_match $ ("[\\b]", "\u0008", ok $ ["\u0008"]),
        TestCase::empty
    ].run_tests
);

test_char_class_nonbracket: TestCase;
test_char_class_nonbracket = (
    [
        test_regexp_match $ (".", "a", ok $ ["a"]),
        test_regexp_match $ (".", "\n", err $ _NotMatch),
        test_regexp_match $ ("\\d", "0", ok $ ["0"]),
        test_regexp_match $ ("\\D", "0", err $ _NotMatch),
        test_regexp_match $ ("\\w", "a", ok $ ["a"]),
        test_regexp_match $ ("\\w", "_", ok $ ["_"]),
        test_regexp_match $ ("\\W", "a", err $ _NotMatch),
        test_regexp_match $ ("\\W", "_", err $ _NotMatch),
        test_regexp_match $ ("\\s", " ", ok $ [" "]),
        test_regexp_match $ ("\\s", "\n", ok $ ["\n"]),
        test_regexp_match $ ("\\S", " ", err $ _NotMatch),
        test_regexp_match $ ("\\S", "\n", err $ _NotMatch),
        test_regexp_match $ ("\\t", "\t", ok $ ["\t"]),
        test_regexp_match $ ("\\r", "\r", ok $ ["\r"]),
        test_regexp_match $ ("\\n", "\n", ok $ ["\n"]),
        test_regexp_match $ ("\\v", "\u000b", ok $ ["\u000b"]),
        test_regexp_match $ ("\\f", "\u000c", ok $ ["\u000c"]),
        TestCase::empty
    ].run_tests
);

test_sequence: TestCase;
test_sequence = (
    [
        test_regexp_match $ (".\\w\\S[a-z][\\w]", "abcde", ok $ ["abcde"]),
        TestCase::empty
    ].run_tests
);

test_assertion: TestCase;
test_assertion = (
    [
        test_regexp_match $ ("^$", "", ok $ [""]),
        test_regexp_match $ ("^abc", "abc", ok $ ["abc"]),
        test_regexp_match $ ("a^bc", "abc", err $ _NotMatch),
        test_regexp_match $ ("abc$", "abc", ok $ ["abc"]),
        test_regexp_match $ ("abc$", "abcde", err $ _NotMatch),
        test_regexp_match $ ("ab$c", "abc", err $ _NotMatch),
        TestCase::empty
    ].run_tests
);

test_quant: TestCase;
test_quant = (
    [
        test_regexp_match $ ("\\w*", "", ok $ [""]),
        test_regexp_match $ ("\\w*", "abc", ok $ ["abc"]),
        test_regexp_match $ ("\\w+", "", err $ _NotMatch),
        test_regexp_match $ ("\\w+", "abc", ok $ ["abc"]),
        test_regexp_match $ ("a+b+", "aabbcc", ok $ ["aabb"]),
        test_regexp_match $ ("a{0,2}", "b", ok $ [""]),
        test_regexp_match $ ("a{0,2}", "ab", ok $ ["a"]),
        test_regexp_match $ ("a{0,2}", "aab", ok $ ["aa"]),
        test_regexp_match $ ("a{0,2}", "aaab", ok $ ["aa"]),
        test_regexp_match $ ("a{1,}", "b", err $ _NotMatch),
        test_regexp_match $ ("a{1,}", "ab", ok $ ["a"]),
        test_regexp_match $ ("a{1,}", "aab", ok $ ["aa"]),
        test_regexp_match $ ("a{1,}", "aaab", ok $ ["aaa"]),
        test_regexp_match $ ("a{2}", "b", err $ _NotMatch),
        test_regexp_match $ ("a{2}", "ab", err $ _NotMatch),
        test_regexp_match $ ("a{2}", "aab", ok $ ["aa"]),
        test_regexp_match $ ("a{2}", "aaab", ok $ ["aa"]),
        test_regexp_match $ ("a{3,5}", "aab", err $ _NotMatch),
        test_regexp_match $ ("a{3,5}", "aaab", ok $ ["aaa"]),
        test_regexp_match $ ("a{3,5}", "aaaab", ok $ ["aaaa"]),
        test_regexp_match $ ("a{3,5}", "aaaaab", ok $ ["aaaaa"]),
        test_regexp_match $ ("a{3,5}", "aaaaaab", ok $ ["aaaaa"]),
        test_regexp_match $ ("a{3,5}$", "aaaaaab", err $ _NotMatch),
        test_regexp_match $ ("a{5,3}", "aab", err $ "Invalid quantifier:{5,3}"),
        TestCase::empty
    ].run_tests
);

test_group: TestCase;
test_group = (
    [
        test_regexp_match $ (".(..).", "abcde", ok $ ["abcd", "bc"]),
        test_regexp_match $ ("(\\w(\\w) )+", "ab cd ef ", ok $ ["ab cd ef ", "ef ", "f"]),
        test_regexp_match $ ("((\\w+)-)?(\\w+)-(\\w+)", "ab-cd-ef", ok $ ["ab-cd-ef", "ab-", "ab", "cd", "ef"]),
        test_regexp_match $ ("((\\w+)-)?(\\w+)-(\\w+)", "cd-ef", ok $ ["cd-ef", "", "", "cd", "ef"]),
        TestCase::empty
    ].run_tests
);

test_either: TestCase;
test_either = (
    [
        test_regexp_match $ ("az\\w+|\\w+d|ab", "abcde", ok $ ["abcd"]),
        test_regexp_match $ ("(az\\w+|\\w+d|ab)", "abcde", ok $ ["abcd", "abcd"]),
        test_regexp_match $ ("^[a-z]([a-z])[a-z]|[\\d]([\\d])[\\d]$", "abcd", ok $ ["abc", "b", ""]),
        test_regexp_match $ ("(\\d+|[a-z]+)(-\\d+|-[a-z]+)*", "01-ab-34", ok $ ["01-ab-34", "01", "-34"]),
        TestCase::empty
    ].run_tests
);

test_match_g: TestCase;
test_match_g = (
    [
        test_regexp_match_flags $ ("[a-z]+", "g", "012 abc def ghi", ok $ ["abc", "def", "ghi"]),
        test_regexp_match_flags $ ("[A-Z][a-z]+", "g", "abc Def ghi Jkl", ok $ ["Def", "Jkl"]),
        test_regexp_match_flags $ ("[A-Z][a-z]+", "g", "abc def ghi jkl", err $ _NotMatch),
        TestCase::empty
    ].run_tests
);

main: IO ();
main = (
    [
        test_empty,
        test_char_class_bracket,
        test_char_class_nonbracket,
        test_sequence,
        test_assertion,
        test_quant,
        test_group,
        test_either,
        test_match_g,
        TestCase::empty
    ]
    .run_test_driver
);
