module Minilib.Crypto.Tls13.ECDHE;

import Character;
import Debug;

import Minilib.Crypto.Tls13.ECDSA;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Monad.Error;
/*
import Minilib.Crypto.SecureRandom;
import Minilib.Crypto.SHA256;
import Minilib.Encoding.Binary;
import Minilib.Math.Modular;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Types;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;
*/

type ECDHE1 = unbox struct {
    ec: ECParam,
    priv_key: ECKeyPair,
};

type ECDHE2 = unbox struct {
    shared_secret: Array U8
};

namespace ECDHE {
    make: [m: RandGen] ECParam -> m ECDHE1;
    make = |ec| (
        let priv_key = *generate_keypair(ec);
        pure $ ECDHE1 {
            ec: ec,
            priv_key: priv_key
        }
    );

    accept_peer_key: Array U8 -> Array U8 -> ECDHE1 -> Result ErrMsg ECDHE2;
    accept_peer_key = |peer_x, peer_y, ecdhe1| (
        let ec = ecdhe1.@ec;
        let priv_key = ecdhe1.@priv_key;
        let peer_x: ECField = ECField::make(*ECInt::from_bytes(peer_x));
        let peer_y: ECField = ECField::make(*ECInt::from_bytes(peer_y));
        let peer_pub_key: ECPoint = ECPoint::make(ec, peer_x, peer_y);
        eval *peer_pub_key.validate_pubkey;
        let dQ = peer_pub_key.mul_by_ECInt(priv_key.@d);
        if dQ.@xy.is_none {
            err $ "cannot calculate shared secret"
        };
        let dQx: ECField = dQ.@xy.as_some.@0;
        let shared_secret = dQx.to_bytes;
        pure $ ECDHE2 {
            shared_secret: shared_secret
        }
    );
}