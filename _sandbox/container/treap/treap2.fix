module Minilib.Collection.Treap2;

import Minilib.Common.Common;
import Minilib.Text.StringEx;

// The priority type. (used internally)
type Priority = U64;

// The type of treap nodes.
type TNode k = box struct {
    prio: Priority, 
    key: k, 
    left: Option (TNode k),
    right: Option (TNode k),
};

type TNodeOpt k = Option (TNode k);

// The type of Treap.
type Treap k = box struct {
    root_opt: TNodeOpt k,
    less_than: k -> k -> Bool,
    size: I64,
    seed: Priority,
};

namespace Treap {
    empty: [k: LessThan] Treap k;
    empty = (
        Treap::make(less_than)
    );

    make: (k -> k -> Bool) -> Treap k;
    make = |less_than| Treap {
        root_opt: none(),
        less_than: less_than,
        size: 0,
        seed: 0x0123456789abcdef_U64,
    };

    _generate_random_priority: Treap k -> (Treap k, Priority);
    _generate_random_priority = |treap| (
        treap.act_seed(|x|
            // generate random number using XORSHIFT
            let x = x.bit_xor(x.shift_left(13_U64));
            let x = x.bit_xor(x.shift_right(7_U64));
            let x = x.bit_xor(x.shift_left(17_U64));
            (x, x)
        ).swap
    );

    get_size: Treap k -> I64;
    get_size = @size;

    insert: k -> Treap k -> Treap k;
    insert = |key, treap| (
        let (treap, prio) = treap._generate_random_priority;
        let less_than = treap.@less_than;
        let (dsize, treap) = treap.act_root_opt(|root_opt| 
            _insert(prio, key, less_than, root_opt)
            .map(some)
        );
        treap.mod_size(add(dsize))
    );

    _insert: Priority -> k -> (k -> k -> Bool) -> TNodeOpt k -> (I64, TNode k);
    _insert = |new_prio, new_key, less_than, node_opt| (
        if node_opt.is_none {
            let new_node = TNode { prio:new_prio, key:new_key, left:none(), right:none() };
            (1, new_node)
        };
        let node = node_opt.as_some;
        if less_than(node.@key, new_key) { // node_key < new_key
            let (dsize, up) = _insert(new_prio, new_key, less_than, node.@right);
            if node.@prio < up.@prio {
                let up = up.mod_left(|left| some $ node.set_right(left));
                (dsize, up)
            } else {
                let node = node.set_right(some $ up);
                (dsize, node)
            }
        } else if less_than(new_key, node.@key) { // new_key < node_key
            let (dsize, up) = _insert(new_prio, new_key, less_than, node.@left);
            if node.@prio < up.@prio {
                let up = up.mod_right(|right| some $ node.set_left(right));
                (dsize, up)
            } else {
                let node = node.set_left(some $ up);
                (dsize, node)
            }
        } else {    // replace key
            let node = node.set_key(new_key);
            (0, node)
        }
    );

    remove: k -> Treap k -> Treap k;
    remove = |key, treap| (
        let root_opt = treap.@root_opt;
        let treap = treap.set_root_opt(none());
        let less_than = treap.@less_than;
        let (dsize, root_opt) = _remove(key, less_than, root_opt);
        treap.set_root_opt(root_opt).mod_size(add(dsize))
    );

    _remove: k -> (k -> k -> Bool) -> TNodeOpt k -> (I64, TNodeOpt k);
    _remove = |key, less_than, node_opt| (
        if node_opt.is_none { (0, none()) };
        let node = node_opt.as_some;
        if less_than(node.@key, key) { // node_key < key
            node.act_right(|right| _remove(key, less_than, right)).map(some)
        } else if less_than(key, node.@key) { // key < node_key
            node.act_left(|left| _remove(key, less_than, left)).map(some)
        } else {    // remove this node
            let node_opt = _join(node.@left, node.@right);
            (-1, node_opt)
        }
    );

    _join: TNodeOpt k -> TNodeOpt k -> TNodeOpt k;
    _join = |left_opt, right_opt| (
        if left_opt.is_none { right_opt };
        if right_opt.is_none { left_opt };
        let left = left_opt.as_some;
        let right = right_opt.as_some;
        if left.@prio >= right.@prio {
            some $ left.set_right(_join(left.@right, right_opt))
        } else {
            some $ right.set_left(_join(left_opt, right.@left))
        }
    );

    to_array: Treap k -> Array k;
    to_array = |treap| (
        let inner = fix $ |inner, node_opt, arr| (
            if node_opt.is_none { arr };
            let node = node_opt.as_some;
            let arr = inner(node.@left, arr);
            let arr = arr.push_back(node.@key);
            let arr = inner(node.@right, arr);
            arr
        );
        inner(treap.@root_opt, [])
    );

    _debug_to_string: [k: ToString] Treap k -> String;
    _debug_to_string = |treap| (
        let inner = fix $ |inner, indent, node_opt, str: String| (
            if node_opt.is_none { str };
            let node = node_opt.as_some;
            let s_indent = Array::fill(indent, ' ')._unsafe_to_string;
            let str: String = inner(indent + 2, node.@left, str);
            let str: String = str + s_indent + (node.@prio, node.@key).format("prio={} key={}\n");
            let str: String = inner(indent + 2, node.@right, str);
            str
        );
        inner(0, treap.@root_opt, "")
    );

    from_iter: [k: LessThan, i: Iterator, Item i = k] i -> Treap k;
    from_iter = |iter| (
        iter.fold(
            Treap::empty, insert
        )
    );
}

