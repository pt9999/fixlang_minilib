module SprintfInternalTest;

import Minilib.Text.Sprintf.SprintfInternal;
import Minilib.Text.SimpleParser;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

parse_trailing: Parser String;
parse_trailing = repeat(match_any_char).map(_unsafe_to_string);

and_trailing: Parser a -> Parser (a, String);
and_trailing = |parser| (
    let a = *parser;
    let trailing = *parse_trailing;
    pure $ (a, trailing)
);

test_parse_flags: TestCase;
test_parse_flags = (
    make_table_test("test_parse_flags",
        [
            ("xyz", (0_U64, "xyz")),
            ("#ab", (Flags::flag_alternate_form, "ab")),
            ("0", (Flags::flag_zero_padding, "")),
            ("-", (Flags::flag_left_adjust, "")),
            (" ", (Flags::flag_space, "")),
            ("+", (Flags::flag_sign, "")),
            ("'", (Flags::flag_thousands, "")),
            ("-0#abc", (Flags::flag_alternate_form.bit_or(Flags::flag_zero_padding).bit_or(Flags::flag_left_adjust), "abc")),
        ],
        |(str, expected)|
        let parser = parse_flags.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_contains_flag: TestCase;
test_contains_flag = (
    make_test("test_contains_flag") $ |_|
    let flags = Flags::flag_alternate_form.bit_or(Flags::flag_zero_padding);
    let f1 = Flags::flag_alternate_form;
    let f2 = Flags::flag_space;
    assert_equal("eq", true, flags.contains_flag(f1));;
    assert_equal("eq", false, flags.contains_flag(f2));;
    pure()
);

test_parse_field_width: TestCase;
test_parse_field_width = (
    make_table_test("test_parse_field_width",
        [
            ("d", (none(), "d")),
            ("8d", (some(8), "d")),
            ("08d", (some(8), "d")),    // currently we accept strings that starts with "0"
            ("-1d", (none(), "-1d")),
        ],
        |(str, expected)|
        let parser = parse_field_width.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_parse_precision: TestCase;
test_parse_precision = (
    make_table_test("test_parse_precision",
        [
            ("f", (none(), "f")),
            (".f", (some(0), "f")),
            (".8f", (some(8), "f")),
            (".08f", (some(8), "f")),    // currently we accept strings that starts with "0"
            (".-0f", (some(0), "f")),    // -0 is not negative
            (".-1f", (none(), "f")),     // a negative precision is taken as if the precision were omitted
        ],
        |(str, expected)|
        let parser = parse_precision.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_parse_length_modifier: TestCase;
test_parse_length_modifier = (
    make_table_test("test_parse_length_modifier",
        [
            ("d", (none(), "d")),
            ("hd", (some("h"), "d")),
            ("hhd", (some("hh"), "d")),
            ("hhhd", (some("hh"), "hd")),
            ("ld", (some("l"), "d")),
            ("lld", (some("ll"), "d")),
            ("qd", (some("q"), "d")),
        ],
        |(str, expected)|
        let parser = parse_length_modifier.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_parse_conversion_specifier: TestCase;
test_parse_conversion_specifier = (
    make_table_test("test_parse_conversion_specifier",
        [
            ("zabc", (none(), "zabc")),
            ("ffff", (some('f'), "fff")),
            ("dfff", (some('d'), "fff")),
        ],
        |(str, expected)|
        let parser = parse_conversion_specifier.if_exists.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_parse_conversion_spec: TestCase;
test_parse_conversion_spec = (
    make_table_test("test_parse_conversion_spec",
        [
            ("zabc", (none(), "zabc")),
            ("%dabc", (some(ConversionSpec::make(0_U64, none(), none(), 'd')), "abc")),
            ("%08dabc", (some(ConversionSpec::make(Flags::flag_zero_padding, some(8), none(), 'd')), "abc")),
            ("%+8.3fabc", (some(ConversionSpec::make(Flags::flag_sign, some(8), some(3), 'f')), "abc")),
        ],
        |(str, expected)|
        let parser = parse_conversion_spec.if_exists.and_trailing;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_parse_format: TestCase;
test_parse_format = (
    make_table_test("test_parse_format",
        [
            ("zabc", ("zabc", [])),
            ("%dabc", ("", [(ConversionSpec::from_U8('d'), "abc")])),
            ("abc%08d", ("abc", [(ConversionSpec::make(Flags::flag_zero_padding, some(8), none(), 'd'), "")])),
            ("abc%ddef%sghi", ("abc", [(ConversionSpec::from_U8('d'), "def"), (ConversionSpec::from_U8('s'), "ghi")])),
        ],
        |(str, expected)|
        let parser = parse_format;
        let (actual, stream) = *parser.run_parser_str(str).from_result;
        assert_equal("eq", expected, actual)
    )
);

test_apply_precision: TestCase;
test_apply_precision = (
    make_table_test("test_apply_precision",
        [
            ("0", "%d", "0"),
            ("0", "%.0d", ""),
            ("1", "%d", "1"),
            ("1", "%.3d", "001"),
            ("12345", "%.3d", "12345"),
        ],
        |(str, format, expected)|
        let (spec, _) = *parse_conversion_spec.run_parser_str(format).from_result;
        let actual = spec.apply_precision(str);
        assert_equal("eq", ok $ expected, actual)
    )
);

test_apply_sign: TestCase;
test_apply_sign = (
    make_table_test("test_apply_sign",
        [
            ("0", false, "%d", "0"),
            ("0", false, "%+d", "+0"),
            ("0", false, "% d", " 0"),
            ("0", false, "% +d", "+0"),
            ("123", false, "%d", "123"),
            ("123", false, "%+d", "+123"),
            ("123", false, "% d", " 123"),
            ("123", false, "% +d", "+123"),
            ("-123", true, "%d", "-123"),
            ("-123", true, "%+d", "-123"),
            ("-123", true, "% d", "-123"),
            ("-123", true, "% +d", "-123"),
        ],
        |(str, is_negative, format, expected)|
        let (spec, _) = *parse_conversion_spec.run_parser_str(format).from_result;
        let actual = spec.apply_sign(str, is_negative);
        assert_equal("eq", ok $ expected, actual)
    )
);

test_apply_padding: TestCase;
test_apply_padding = (
    make_table_test("test_apply_padding",
        [
            ("123", "%d", "123"),
            ("123", "%8d",  "     123"),
            ("123", "%08d", "00000123"),
            ("123", "%-8d", "123     "),
            ("123", "%-08d", "123     "),
            ("12345678", "%0d",  "12345678"),
            ("12345678", "%4d",  "12345678"),
            ("12345678", "%8d",  "12345678"),
        ],
        |(str, format, expected)|
        let (spec, _) = *parse_conversion_spec.run_parser_str(format).from_result;
        let actual = spec.apply_padding(str);
        assert_equal("eq", ok $ expected, actual)
    )
);

main: IO ();
main = (
    [
        test_parse_flags,
        test_contains_flag,
        test_parse_field_width,
        test_parse_precision,
        test_parse_length_modifier,
        test_parse_conversion_specifier,
        test_parse_conversion_spec,
        test_parse_format,
        test_apply_precision,
        test_apply_sign,
        test_apply_padding,
    ]
    .run_test_driver
);