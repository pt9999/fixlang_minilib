module Main;

import Debug;

import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type MonadMsgPack a = State ByteBuffer a;

trait [m: * -> *] m: WriteByte {
    write_byte: U8 -> m ();
}

trait MonadWriteByte = Functor + MonadError + WriteByte;

trait [m: * -> *] m: ReadByte {
    read_byte: m U8;
}

trait MonadReadByte = Functor + MonadError + ReadByte;

type ByteRW = StateT ByteBuffer (Result ErrMsg);

impl ByteRW: WriteByte {
    write_byte = |u8| (
        mod_state(marshal(u8))
    );
}

impl ByteRW: ReadByte {
    read_byte = make_state_t_monad $ unmarshal;
}

//------------------------------------------
trait a: Pack {
    pack: [m: MonadWriteByte, ErrorType m = String] a -> m ();
}

trait a: Unpack {
    unpack: [m: MonadReadByte, ErrorType m = String] m a;
}

_TypeErr: ErrMsg;
_TypeErr = "TypeErr";

impl U8: Pack {
    pack = |i| (
        if i <= 0x7f_U8 {
            // positive fixint 0XXXXXXX
            write_byte(i)
        };
        // 8-bit unsigned integer
        eval *write_byte(0xcc_U8);
        write_byte(i)
    );
}

impl U8: Unpack {
    unpack = (
        let i: U8 = *read_byte;
        if i <= 0x7f_U8 {
            // positive fixint 0XXXXXXX
            pure $ i
        };
        if i == 0xcc_U8 {
            // 8-bit unsigned integer
            read_byte
        };
        error $ _TypeErr 
    );
}

impl U16: Pack {
    pack = |i| (
        if i <= 0xff_U16 {
            i.to_U8.pack
        };
        // 16-bit unsigned integer (big endian)
        eval *write_byte(0xcd_U8);
        eval *write_byte(i.shift_right(8_U16).to_U8);
        write_byte(i.to_U8)
    );
}

impl U16: Unpack {
    unpack = (
        unpack.map(U8::to_U16).catch(|errmsg|
            let i: U8 = *read_byte;
            if i == 0xcd_U8 {
                // 16-bit unsigned integer (big endian)
                let v0 = *read_byte;
                let v1 = *read_byte;
                pure $ v0.to_U16.shift_left(8_U16)
                .bit_or(v1.to_U16)
            };
            error $ _TypeErr
        )
    );
}

impl U32: Pack {
    pack = |i| (
        if i <= 0xffff_U32 {
            i.to_U16.pack
        };
        // 32-bit unsigned integer (big endian)
        eval *write_byte(0xce_U8);
        eval *write_byte(i.shift_right(24_U32).to_U8);
        eval *write_byte(i.shift_right(16_U32).to_U8);
        eval *write_byte(i.shift_right(8_U32).to_U8);
        write_byte(i.to_U8)
    );
}

impl U64: Pack {
    pack = |i| (
        if i <= 0xffffffff_U64 {
            i.to_U32.pack
        };
        // 64-bit unsigned integer (big endian)
        eval *write_byte(0xcf_U8);
        eval *write_byte(i.shift_right(56_U64).to_U8);
        eval *write_byte(i.shift_right(48_U64).to_U8);
        eval *write_byte(i.shift_right(40_U64).to_U8);
        eval *write_byte(i.shift_right(32_U64).to_U8);
        eval *write_byte(i.shift_right(24_U64).to_U8);
        eval *write_byte(i.shift_right(16_U64).to_U8);
        eval *write_byte(i.shift_right(8_U64).to_U8);
        write_byte(i.to_U8)
    );
}

impl I8: Pack {
    pack = |i| (
        if -0x1f_I8 <= i && i <= 0x7f_I8 {
            // positive fixint 0XXXXXXX
            // negative fixint 111XXXXX
            write_byte(i.to_U8)
        };
        // 8-bit signed integer
        eval *write_byte(0xd0_U8);
        write_byte(i.to_U8)
    );
}

impl I16: Pack {
    pack = |i| (
        if -0x80_I16 <= i && i <= 0x7f_I16 {
            i.to_U8.pack
        };
        // 16-bit signed integer (big endian)
        eval *write_byte(0xd1_U8);
        eval *write_byte(i.shift_right(8_I16).to_U8);
        write_byte(i.to_U8)
    );
}

impl I32: Pack {
    pack = |i| (
        if -0x8000_I32 <= i && i <= 0x7fff_I32 {
            i.to_U16.pack
        };
        // 32-bit signed integer (big endian)
        eval *write_byte(0xd2_U8);
        eval *write_byte(i.shift_right(24_I32).to_U8);
        eval *write_byte(i.shift_right(16_I32).to_U8);
        eval *write_byte(i.shift_right(8_I32).to_U8);
        write_byte(i.to_U8)
    );
}

impl I64: Pack {
    pack = |i| (
        if -0x80000000 <= i && i <= 0x7fffffff {
            i.to_U32.pack
        };
        // 64-bit signed integer (big endian)
        eval *write_byte(0xd3_U8);
        eval *write_byte(i.shift_right(56).to_U8);
        eval *write_byte(i.shift_right(48).to_U8);
        eval *write_byte(i.shift_right(40).to_U8);
        eval *write_byte(i.shift_right(32).to_U8);
        eval *write_byte(i.shift_right(24).to_U8);
        eval *write_byte(i.shift_right(16).to_U8);
        eval *write_byte(i.shift_right(8).to_U8);
        write_byte(i.to_U8)
    );
}

test_pack: IO ();
test_pack = (
    let buf = ByteBuffer::empty(0, big_endian());
    let w: ByteRW () = do {
        eval *0x12_U8.pack;
        eval *0x1234_U16.pack;
        eval *0x12345678_U32.pack;
        eval *0x123456789abcdef0_U64.pack;
        eval *-0x12_I8.pack;
        eval *-0x1234_I16.pack;
        eval *-0x12345678_I32.pack;
        eval *-0x123456789abcdef0.pack;
        pure()
    };     
    let res = w.run_state_t(buf);
    if res.is_err { println("err: " + res.as_err) };
    let ((), buf) = res.as_ok;
    println((buf.@array.to_string_hex, ).format("buf={}"))
);

test_unpack: IO ();
test_unpack = (
    let arr = [ 0x12, 0xcc, 0xab, 0xcd, 0xab, 0xcd ].map(to_U8); 
    let buf = ByteBuffer::make(arr, big_endian());
    let r: ByteRW String = do {
        let a1: U8 = *unpack;
        let a2: U8 = *unpack;
        let a3: U16 = *unpack;
        pure $ (a1.to_string_hex, 
                a2.to_string_hex,
                a3.to_string_hex)
                .format("a1={} a2={} a3={}")
    };     
    let res = r.run_state_t(buf);
    if res.is_err { println("err: " + res.as_err) };
    let (str, buf) = res.as_ok;
    println(str)
);

main: IO ();
main = test_unpack;

