module Main;

import Debug;

import Minilib.Crypto.AES;
import Minilib.Text.Hex;

// ----------------------------------------
// Padding
// ----------------------------------------

trait a: PaddingScheme {
    add_padding: Array U8 -> I64 -> a -> Array U8;
    remove_padding: Array U8 -> a -> Array U8;
}

// PKCS#7 Padding
// https://tex2e.github.io/rfc-translater/html/rfc2315.html
type Pkcs7Padding = unbox struct {
    dummy: ()
};

namespace Pkcs7Padding {
    default: Pkcs7Padding;
    default = Pkcs7Padding { dummy: () };
}

impl Pkcs7Padding: PaddingScheme {
    //add_padding: Array U8 -> I64 -> Pkcs7Padding -> Array U8;
    add_padding = |data, block_size, _| (
        let r = block_size - data.get_size % block_size;
        data.append(Array::fill(r, r.to_U8))
    );

    //remove_padding: Array U8 -> Pkcs7Padding -> Array U8;
    remove_padding = |data, _| (
        let r = data.@(data.get_size - 1).to_I64;
        data.get_sub(0, data.get_size - r)
    );
}

test_pkcs7_padding: IO ();
test_pkcs7_padding = (
    let padding_scheme = Pkcs7Padding::default;
    let block_size = 8;
    let strings = [
        "", "a", "ab", "abcdefg", "abcdefgh", "abcdefghi"
    ];
    strings.to_iter.fold_m(
        (), |_, str|
        let data1 = str.get_bytes.pop_back;
        let data2 = padding_scheme.add_padding(data1, block_size);
        let data3 = padding_scheme.remove_padding(data2);
        println("data1=" + data1.to_string_hex + "\n" +
            "data2=" + data2.to_string_hex + "\n" +
            "data3=" + data3.to_string_hex + "\n")
    )
);

// ----------------------------------------

// Block cipher
trait bc: BlockCipher {
    get_block_size: bc -> I64;
    encrypt_block: Array U8 -> bc -> (Array U8, bc);
    decrypt_block: Array U8 -> bc -> (Array U8, bc);
}

_get_sub_ex: I64 -> I64 -> Array a -> Array a;
_get_sub_ex = |b, e, arr| (
    if b == 0 && e == arr.get_size { arr } else { arr.get_sub(b, e) }
);

encrypt: [bc: BlockCipher, ps: PaddingScheme] Array U8 -> ps -> bc -> (Array U8, bc);
encrypt = |plaintext, padding_scheme, cipher| (
    let block_size = cipher.get_block_size;
    let plaintext = padding_scheme.add_padding(plaintext, block_size);
    let block_count = plaintext.get_size / block_size;
    let (ciphertext, cipher) = loop(
        ([], cipher, 0), |(ciphertext, cipher, i)|
        if i >= block_count { break $ (ciphertext, cipher) };
        let plain_block = plaintext._get_sub_ex(i * block_size, (i + 1) * block_size);
        let (cipher_block, cipher) = cipher.encrypt_block(plain_block);
        let ciphertext = ciphertext.append(cipher_block);
        continue $ (ciphertext, cipher, i + 1) 
    );
    (ciphertext, cipher)
);

decrypt: [bc: BlockCipher, ps: PaddingScheme] Array U8 -> ps -> bc -> (Array U8, bc);
decrypt = |ciphertext, padding_scheme, cipher| (
    let block_size = cipher.get_block_size;
    let block_count = ciphertext.get_size / block_size;
    let (plaintext, cipher) = loop(
        ([], cipher, 0), |(plaintext, cipher, i)|
        if i >= block_count { break $ (plaintext, cipher) };
        let cipher_block = ciphertext._get_sub_ex(i * block_size, (i + 1) * block_size);
        let (plain_block, cipher) = cipher.decrypt_block(cipher_block);
        let plaintext = plaintext.append(plain_block);
        continue $ (plaintext, cipher, i + 1) 
    );
    let plaintext = padding_scheme.remove_padding(plaintext);
    (plaintext, cipher)
);


// ----------------------------------------
type AESCipher = unbox struct {
    aes: AES
};

namespace AESCipher {
    make: AES -> AESCipher;
    make = |aes| AESCipher { aes: aes };
}

impl AESCipher: BlockCipher {
    get_block_size = |_| 16;
    encrypt_block = |plaintext, ac| (ac.@aes.encrypt_block(plaintext), ac);
    decrypt_block = |ciphertext, ac| (ac.@aes.decrypt_block(ciphertext), ac);
}

byte_array_from_string_hex: String -> Array U8;
byte_array_from_string_hex = |str| (
    str.split(" ").map(from_string_hex >> as_ok).to_array
);

// ----------------------------------------
// Cipher Block Chaining (CBC)
type CBC bc = unbox struct {
    block_cipher: bc,
    iv: Array U8
};

namespace CBC {
    make: [bc: BlockCipher] bc -> Array U8 -> CBC bc;
    make = |block_cipher, iv| (
        CBC { block_cipher: block_cipher, iv: iv }
    );

    _xor_bytes: Array U8 -> Array U8 -> Array U8;
    _xor_bytes = |a, b| (
        eval assert_eq(|_| "_xor_bytes: mismatch size", a.get_size, b.get_size);
        let n = a.get_size;
        loop(
            (a, 0), |(a, i)|
            if i >= n { break $ a };
            let a = a.mod(i, bit_xor(b.@(i)));
            continue $ (a, i + 1)
        )
    );
}

impl [bc: BlockCipher] CBC bc: BlockCipher {
    get_block_size = |cbc| cbc.@block_cipher.get_block_size;
    encrypt_block = |plaintext, cbc| (
        let ciphertext = cbc.@block_cipher.encrypt_block(cbc.@iv._xor_bytes(plaintext));
        let cbc = CBC::make(cbc.@block_cipher, ciphertext);
        (ciphertext, cbc)
    );
    decrypt_block = |ciphertext, cbc| (
        let plaintext = cbc.@block_cipher.decrypt_block(ciphertext)._xor_bytes(cbc.@iv);
        let cbc = CBC::make(cbc.@block_cipher, ciphertext);
        (plaintext, cbc)
    );
}

test_cipher: [bc: BlockCipher, ps: PaddingScheme] ps -> bc -> IO ();
test_cipher = |padding_scheme, cipher| (
    let strings = [
        "Hello world hello hello",
        "foo bar baz hoge hoge"
    ];
    strings.to_iter.fold_m(
        (), |_, str|
        let plaintext = str.get_bytes.pop_back;
        let (ciphertext, _) = cipher.encrypt(plaintext, padding_scheme);
        let (plaintext2, _) = cipher.decrypt(ciphertext, padding_scheme);
        let str2 = plaintext2.push_back(0_U8)._unsafe_from_c_str;
        eval *println("str='"+str+"'");
        eval *println("ciphertext="+ciphertext.to_string_hex);
        eval *println("str2='"+str2+"'");
        pure()
    )
);

test_aes_cipher: IO ();
test_aes_cipher = (
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(key);
    let cipher = AESCipher::make(aes);
    let padding_scheme = Pkcs7Padding::default;
    test_cipher(padding_scheme, cipher)
);

main: IO ();
//main = test_pkcs7_padding;
main = test_aes_cipher;


