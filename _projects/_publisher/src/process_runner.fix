module Publisher.ProcessRunner;

import AsyncTask;
import Subprocess;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;

import Publisher.Common;

exit_status_to_string: ExitStatus -> String;
exit_status_to_string = |ex| (
    match ex {
        exit(u8) => "exit(" + u8.to_string + ")",
        signaled(u8) => "signaled(" + u8.to_string + ")",
        wait_failed() => "wait_failed()"
    }
);

fileno: IOHandle -> IO CInt;
fileno = |handle| (
    FFI_CALL_IO[CInt fileno(Ptr), *handle.get_file_ptr]
);

dup2_file: IOHandle -> IOHandle -> IO ();
dup2_file = |old_handle, new_handle| (
    let old_fd = *old_handle.fileno;
    let new_fd = *new_handle.fileno;
    FFI_CALL_IO[CInt dup2(CInt, CInt), old_fd, new_fd];;    // TODO error check
    pure()
);

type Worker = (IOHandle, IOHandle, IOHandle) -> IOFail (String, String);
_make_worker: Array String -> Worker;
_make_worker = |options|
    let verbose = options.contains("verbose");
    let has_input = options.contains("has_input");
    |(proc_stdin, proc_stdout, proc_stderr)| (
    if has_input {
        dup2_file(IO::stdin, proc_stdin)    // TODO: doesn't work
    } else {
        proc_stdin.close_file
    }.lift;;
    let drain_output: IOHandle -> IOHandle -> IO (Result ErrMsg String) = |proc_out, out| (
        loop_lines_io(proc_out, "", |lines, line|
            if line.is_empty { break_m $ lines };
            when(verbose,
                write_string(out, line);;
                flush(out).forget.lift
            );;
            let lines = lines + line;
            continue_m $ lines
        ).to_result
    );
    let tasks = [
        *AsyncIOTask::make(drain_output(proc_stdout, IO::stdout)).lift,
        *AsyncIOTask::make(drain_output(proc_stderr, IO::stderr)).lift,
    ];
    let texts = *tasks.to_iter.map(|task| task.get.from_io_result).collect_m;
    pure $ (texts.@(0), texts.@(1))
);

trait MonadRunProcess = MonadIOFail + MonadRunProcessIF;

trait [m: *->*] m: MonadRunProcessIF {
    run_process_with_options: Array String -> Array String -> m (String, String);
}

impl IOFail: MonadRunProcessIF {
    run_process_with_options = |args, options| (
        pure();;
        let verbose = options.contains("verbose");
        when(verbose, eprintln("+ " + args.to_iter.join(" ")).lift);;
        let com = args.@(0);
        let input = "";
        let worker = _make_worker(options);
        let ((stdout, stderr), exit_status) = *Subprocess::run_with_stream(com, args, worker);
        if exit_status.is_exit && exit_status.as_exit == 0_U8 {
            pure $ (stdout, stderr)
        } else {
            throw $ "subprocess failed with " + exit_status_to_string(exit_status)
        }
    );
}

type ProcessRunnerApi = unbox struct {
    run_process_with_options: Array String -> Array String -> IOFail (String, String),
};

trait e: HasProcessRunnerApi {
    get_process_runner_api: e -> IOFail ProcessRunnerApi;
}

impl [e: HasProcessRunnerApi] ReaderT e IOFail: MonadRunProcessIF {
    run_process_with_options = |args, options| (
        call_api(get_process_runner_api, @run_process_with_options, |func| func(args, options))
    );
}

run_process_quietly: [m: MonadRunProcessIF] Array String -> m (String, String);
run_process_quietly = |args| (
    run_process_with_options(args, [])
);

run_process: [m: MonadRunProcessIF] Array String -> m (String, String);
run_process = |args| (
    run_process_with_options(args, ["verbose"])
);
