module Publisher.Tests.MockProcessRunner;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Testing.UnitTest;

import Publisher.Common;
import Publisher.ProcessRunner;

type MockProcess = unbox struct {
    args: Array String,
    options: Array String,
};

impl MockProcess: Eq {
    eq = |a, b| (
        a.@args == b.@args &&
        a.@options == b.@options
    );
}

impl MockProcess: ToString {
    to_string = |process| (
        "MockProcess {"
        + " args=" + process.@args.to_string
        + " options=" + process.@options.to_string
        + " }"
    );
}

namespace MockProcess {
    empty: MockProcess;
    empty = MockProcess {
        args: [],
        options: [],
    };

    make: Array String -> MockProcess;
    make = |args| MockProcess::empty.set_args(args);

    get_cmdline: MockProcess -> String;
    get_cmdline = |process| process.@args.to_iter.join(" ");

    verbose: MockProcess -> MockProcess;
    verbose = mod_options(push_back("verbose"));
}

type MockProcessMatcher = (I64, MockProcess) -> Bool; 

namespace MockProcessMatcher {
    match_nth: I64 -> MockProcessMatcher;
    match_nth = |n| (
        |(index, process)| index == n
    );
    match_cmdline: String -> MockProcessMatcher;
    match_cmdline = |cmdline| (
        |(index, process)| process.get_cmdline == cmdline
    );
}

// ok(stdout, stderr) or err(errmsg)
type MockProcessResult = Result ErrMsg (String, String);

// process matcher and process result
type MockProcessAction = (MockProcessMatcher, MockProcessResult);

namespace MockProcessAction {
    then_print: String -> MockProcessMatcher -> MockProcessAction;
    then_print = |stdout, matcher| (matcher, ok $ (stdout, ""));

    then_err: ErrMsg -> MockProcessMatcher -> MockProcessAction;
    then_err = |errmsg, matcher| (matcher, err $ errmsg);
}

type MockProcessRunner = unbox struct {
    // Executed processes
    processes: Array MockProcess,

    actions: Array MockProcessAction,
};

impl MockProcessRunner: Eq {
    eq = |a, b| (
        a.@processes == b.@processes
    );
}

impl MockProcessRunner: ToString {
    to_string = |runner| (
        "MockProcessRunner {"
        + " processes=" + runner.@processes.to_string
        + " }"
    );
}

namespace MockProcessRunner {
    empty: MockProcessRunner;
    empty = MockProcessRunner {
        processes: [],
        actions: [],
    };

    add_action: MockProcessAction -> MockProcessRunner -> MockProcessRunner;
    add_action = |action| mod_actions(push_back(action));

    find_action: I64 -> MockProcess -> MockProcessRunner -> Option (Result ErrMsg (String, String));
    find_action = |index, process, runner| (
        runner.@actions.to_iter.loop_iter(
            none(), |action, opt|
            let (matcher, res) = action;
            if matcher((index, process)) {
                break $ some $ res
            };
            continue $ none()
        )
    );

    next_stdout: String -> MockProcessRunner -> MockProcessRunner;
    next_stdout = |stdout| (
        let action = match_nth(0).then_print(stdout);
        add_action(action)
    );

    setup: (MockProcessRunner -> MockProcessRunner) -> MockProcessRunner;
    setup = |setup_func| (
        MockProcessRunner::empty.setup_func
    );

    run: Array String -> Array String -> MockProcessRunner -> (MockProcessRunner, MockProcessResult);
    run = |args, options, runner| (
        // Record the process
        let process = MockProcess::empty.set_args(args).set_options(options);
        let index = runner.@processes.get_size;
        let runner = runner.mod_processes(push_back(process));
        let res = runner.find_action(index, process).as_some_or(ok $ ("", ""));
        (runner, res)
    );
}
