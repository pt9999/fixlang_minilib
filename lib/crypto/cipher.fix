module Minilib.Crypto.Cipher;

import Debug;

trait bc: BlockCipher {
    get_block_size: bc -> I64;
    encrypt_block: Array U8 -> bc -> (Array U8, bc);
    decrypt_block: Array U8 -> bc -> (Array U8, bc);
}

// Cipher Block Chaining (CBC)
type CBC bc = unbox struct {
    block_cipher: bc,
    iv: Array U8
};

namespace CBC {
    make: [bc: BlockCipher] bc -> Array U8 -> CBC bc;
    make = |block_cipher, iv| (
        CBC { block_cipher: block_cipher, iv: iv }
    );

    _xor_bytes: Array U8 -> Array U8 -> Array U8;
    _xor_bytes = |a, b| (
        eval assert_eq(|_| "_xor_bytes: mismatch size", a.get_size, b.get_size);
        let n = a.get_size;
        loop(
            (a, 0), |(a, i)|
            if i >= n { break $ a };
            let a = a.mod(i, bit_xor(b.@(i)));
            continue $ (a, i + 1)
        )
    );
}

impl [bc: BlockCipher] CBC bc: BlockCipher {
    get_block_size = |cbc| cbc.@block_cipher.get_block_size;
    encrypt_block = |plaintext, cbc| (
        let ciphertext = cbc.@block_cipher.encrypt_block(cbc.@iv._xor_bytes(plaintext));
        let cbc = CBC::make(cbc.@block_cipher, ciphertext);
        (ciphertext, cbc)
    );
    decrypt_block = |ciphertext, cbc| (
        let plaintext = cbc.@block_cipher.decrypt_block(ciphertext)._xor_bytes(cbc.@iv);
        let cbc = CBC::make(cbc.@block_cipher, ciphertext);
        (plaintext, cbc)
    );
}
