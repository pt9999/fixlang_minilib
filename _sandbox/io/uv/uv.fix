module Minilib.IO.Uv;

//import Minilib.Monad.IO;

log_debug: String -> ();
log_debug = debug_eprintln;
//log_debug = |str| ();

//-----------------------------------------------------------------
// MonadBorrow
//-----------------------------------------------------------------

trait MonadBorrow = Monad + MonadBorrowIF;

trait [m: * -> *] m: MonadBorrowIF {
    borrow_boxed_m: [a: Boxed] (Ptr -> m b) -> a -> m b;
    borrow_m: (a -> m b) -> Destructor a -> m b;
    borrow_c_str_m: (Ptr -> m b) -> String -> m b;
}

/*
impl Iden: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed(f >> Iden::get) >> Iden::make;
    borrow_m = |f| borrow(f >> Iden::get) >> Iden::make;
    borrow_c_str_m = |f| borrow_c_str(f >> Iden::get) >> Iden::make;
}
*/

impl IO: MonadBorrowIF {
    borrow_boxed_m = borrow_boxed_io;
    borrow_m = borrow_io;
    borrow_c_str_m = borrow_c_str_io;
}

impl IOFail: MonadBorrowIF {
    borrow_boxed_m = |f| borrow_boxed_io(f >> to_result) >> from_io_result;
    borrow_m = |f| borrow_io(f >> to_result) >> from_io_result;
    borrow_c_str_m =  |f| borrow_c_str_io(f >> to_result) >> from_io_result;
}

//-----------------------------------------------------------------
// FromPtr, BorrowPtrM
//-----------------------------------------------------------------

trait a: FromPtr {
    from_ptr: Ptr -> IO a;
}

trait a: BorrowPtrM {
    borrow_ptr_m: [m: MonadBorrow] (Ptr -> m b) -> a -> m b;
}

//-----------------------------------------------------------------
// UvPtrWithOwnership
//-----------------------------------------------------------------

type UvPtrWithOwnership = unbox union {
    owned: Destructor Ptr,
    borrowed: Ptr,
};

namespace UvPtrWithOwnership {
    make_owned: Ptr -> (Ptr -> IO Ptr) -> IO UvPtrWithOwnership;
    make_owned = |ptr, dtor| (
        pure $ owned $ *Destructor::make(ptr, dtor)
    );

    make_borrowed: Ptr -> UvPtrWithOwnership;
    make_borrowed = borrowed;
}

impl UvPtrWithOwnership: BorrowPtrM {
    borrow_ptr_m = |f, wrapped_ptr| (
        match wrapped_ptr {
            owned(dtor) => dtor.borrow_m(f),
            borrowed(ptr) => f(ptr),
        }
    );
}

//-----------------------------------------------------------------
// Error Handling
//-----------------------------------------------------------------

namespace Uv {
    strerror: CInt -> String;
    strerror = |err| (
        let buflen = 65536;
        let buf = Array::fill(buflen, 0_U8);
        let (buf, ()) = buf.mutate_boxed(|buf|
            FFI_CALL_IO[() uv_strerror_r(CInt, Ptr, CSizeT), err, buf, buflen.to_CSizeT]
        );
        let errmsg: String = buf.push_back(0_U8).from_bytes.as_ok;
        errmsg
    );
}

_check_err_i: IO CInt -> IOFail CInt;
_check_err_i = |io| (
    let err = *io.lift;
    if err >= 0.to_CInt {
        pure $ err
    };
    throw $ Uv::strerror(err)
);

_check_err: IO CInt -> IOFail ();
_check_err = |io| (
    let err = *io._check_err_i;
    pure()
);

//-----------------------------------------------------------------
// UvLoop
//-----------------------------------------------------------------

type UvLoop = unbox struct {
    wptr: UvPtrWithOwnership
};

namespace UvLoop {
    make: IOFail UvLoop;
    make = (
        let ptr = *FFI_CALL_IO[Ptr minilib_uv_loop_init()].lift;
        if ptr == nullptr { throw $ "uv_loop_init failed!" };
        pure $ UvLoop {
            wptr: *UvPtrWithOwnership::make_owned(ptr, |ptr|
                eval log_debug("dtor called");
                FFI_CALL_IO[() minilib_uv_loop_close(Ptr), ptr].when(ptr != nullptr);;
                pure $ nullptr
            ).lift
        }
    );

    default: UvLoop;
    default = (
        UvLoop {
            wptr: UvPtrWithOwnership::make_borrowed $
                FFI_CALL[Ptr uv_default_loop()]
        }
    );

    run_default: UvLoop -> IOFail ();
    run_default = |loop| (
        loop.borrow_ptr_m(|p_loop|
            _check_err $ FFI_CALL_IO[CInt minilib_uv_loop_run_default(Ptr), p_loop]
        )
    );
}

impl UvLoop: BorrowPtrM {
    borrow_ptr_m = |f, loop| loop.@wptr.borrow_ptr_m(f);
}

//-----------------------------------------------------------------
// UvHandle
//-----------------------------------------------------------------

type UvHandle = unbox struct {
    dtor: Destructor Ptr
};

trait a: ToUvHandle {
    to_uv_handle: a -> UvHandle;
}

impl UvHandle: ToUvHandle {
    to_uv_handle = |handle| handle;
}

impl UvHandle: FromPtr {
    from_ptr = |p_handle| (
        FFI_CALL_IO[() minilib_uv_handle_retain(Ptr), p_handle];;
        pure $ UvHandle {
            dtor: *Destructor::make(p_handle, |p_handle|
                FFI_CALL_IO[() minilib_uv_handle_release(Ptr), p_handle];;
                pure $ nullptr
            )
        }
    );
}

impl UvHandle: BorrowPtrM {
    borrow_ptr_m = |f, handle| handle.@dtor.borrow_m(f);
}

namespace UvHandle {
    close: [handle: ToUvHandle] handle -> IO ();
    close = |handle| (
        handle.to_uv_handle.borrow_ptr_m(|p_handle|
            FFI_CALL_IO[() minilib_uv_handle_close(Ptr), p_handle]
        )
    );
}

//-----------------------------------------------------------------
// UvReq
//-----------------------------------------------------------------

// リクエスト(uv_req_t)を表す型。
type UvReq = unbox struct {
    dtor: Destructor Ptr
};

trait req: ToUvReq {
    to_uv_req: req -> UvReq;
}

impl UvReq: ToUvReq {
    to_uv_req = |req| req;
}

impl UvReq: FromPtr {
    from_ptr = |p_req| (
        FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req];;
        pure $ UvReq {
            dtor: *Destructor::make(p_req, |p_req|
                FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req];;
                pure $ nullptr
            )
        }
    );
}

impl UvReq: BorrowPtrM {
    borrow_ptr_m = |f, req| req.@dtor.borrow_m(f);
}

namespace UvReq {
    // uv_req_t* の参照カウンタを1増加する。
    retain: [req: ToUvReq] req -> IO ();
    retain = |req| (
        req.to_uv_req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_retain(Ptr), p_req])
    );

    // uv_req_t* の参照カウンタを1減少する。参照カウンタが0になったら解放される。
    release: [req: ToUvReq] req -> IO ();
    release = |req| (
        req.to_uv_req.borrow_ptr_m(|p_req| FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req])
    );

    // ユーザが用意したコールバック関数を設定する。型を正しく合わせる必要がある。
    set_user_callback: [req: ToUvReq] cb -> req -> IO ();
    set_user_callback = |cb, req| (
        req.to_uv_req.borrow_ptr_m(|p_req|
            let box_cb: Box cb = Box::make(cb);
            let p_cb: Ptr = *box_cb.boxed_to_retained_ptr;
            eval log_debug("set_user_callback: p_cb=" + p_cb.to_string);
            FFI_CALL_IO[() minilib_uv_req_set_fix_cb(Ptr, Ptr), p_req, p_cb]
        )
    );

    // ユーザが用意したコールバック関数を取得する。型を正しく合わせる必要がある。
    get_user_callback: [req: ToUvReq] req -> IO cb;
    get_user_callback = |req| (
        req.to_uv_req.borrow_ptr_m(|p_req|
            let p_cb = *FFI_CALL_IO[Ptr minilib_uv_req_get_fix_cb(Ptr), p_req];
            eval log_debug("get_user_callback: p_cb=" + p_cb.to_string);
            let box_cb: Box cb = *p_cb.boxed_from_retained_ptr;
            pure $ box_cb.@value
        )
    );
}


//-----------------------------------------------------------------
// UvFs
//-----------------------------------------------------------------

type UvFs = unbox struct {
    req: UvReq
};

impl UvFs: FromPtr {
    from_ptr = |p_req| pure $ UvFs { req: *from_ptr(p_req) };
}

namespace UvFs {
    // uv_fs_t* を確保して初期化し、UvFsを作成する。
    init: IOFail UvFs;
    init = (
        let p_req = *FFI_CALL_IO[Ptr minilib_uv_fs_init()].lift;
        if p_req == nullptr { throw $ "minilib_uv_fs_init failed!" };
        from_ptr(p_req).lift
    );

    // uv_fs_t->result を取得する。
    get_result: UvFs -> IO I64;
    get_result = |fs| (
        fs.@req.borrow_ptr_m(|p_req|
            FFI_CALL_IO[I64 minilib_uv_fs_get_result(Ptr), p_req]
        )
    );

    type UvFsOpenCallback = UvFs -> IO ();

    open: UvLoop -> String -> CInt -> CInt -> UvFsOpenCallback -> IOFail UvFs;
    open = |loop, path, flags, mode, cb| (
        let fs = *UvFs::init;
        let req = fs.@req;
        req.retain.lift;;    // リクエスト発生のためリテインする
        req.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する
        loop.borrow_ptr_m(|p_loop|
            req.borrow_ptr_m(|p_req|
                eval log_debug("UvFs::open: (p_loop, p_req)=" + (p_loop, p_req).to_string);
                path.borrow_c_str_m(|p_path|
                    FFI_CALL_IO[CInt minilib_uv_fs_open(Ptr, Ptr, Ptr, CInt, CInt), p_loop, p_req, p_path, flags.to_CInt, mode.to_CInt]
                    ._check_err
                )
            )
        );;
        pure $ fs
    );

    // fs はあくまでもリクエストで、ファイルディスクリプタは fs->result に返ってくる
    // リクエストの生存期間は、リクエスト発生からコールバックの呼び出しが完了するまでにするべき。
    // コールバック内でリクエストのクリーンアップ処理を呼ぶべき。
    // リクエストをキャンセルしないのなら、すぐに忘れてもいい。

    minilib_uv_fs_open_callback : Ptr -> ();
    minilib_uv_fs_open_callback = |p_req| (
        let io: IO () = do {
            eval log_debug("minilib_uv_fs_open_callback: p_req=" + p_req.to_string);
            let fs: UvFs = *from_ptr(p_req);
            // Fixのコールバックを呼ぶ。コールバックは fs.get_result の値を元にエラー処理する必要がある。
            let cb: UvFsOpenCallback = *fs.@req.get_user_callback;
            cb(fs)
        };
        let io: IO () = do {
            io;;
            // finally: コールバック完了のためリリースする
            FFI_CALL_IO[() minilib_uv_req_release(Ptr), p_req]  // release on callback end
        };
        io.unsafe_perform
    );
    FFI_EXPORT[minilib_uv_fs_open_callback, minilib_uv_fs_open_callback];
}

// ファイルディスクリプタ(uv_file)を表す型。
type UvFile = CInt;

namespace UvFile {
    // 標準入力
    stdin: UvFile = 0.to_CInt;
    // 標準出力
    stdout: UvFile = 1.to_CInt;
    // 標準エラー出力
    stderr: UvFile = 2.to_CInt;
}

// open のフラグ関係
namespace UvFsFlags {
    _find_flag: String -> CInt;
    _find_flag = |name| (
        name.borrow_c_str(|p_name|
            FFI_CALL[CInt minilib_uv_fs_find_flag(Ptr), p_name]
        )
    );

    from_mode_str: String -> CInt;
    from_mode_str = |mode| (
        let has = |str, mode| mode.find(str, 0).is_some;
        if mode.has("r+") { 
            UvFsFlags::_O_RDWR
        } else if mode.has("r") {
            UvFsFlags::_O_RDONLY
        } else if mode.has("w+") {
            UvFsFlags::_O_CREAT.bit_or(UvFsFlags::_O_RDWR).bit_or(UvFsFlags::_O_TRUNC)
        } else if mode.has("w") {
            UvFsFlags::_O_CREAT.bit_or(UvFsFlags::_O_WRONLY).bit_or(UvFsFlags::_O_TRUNC)
        } else if mode.has("a+") {
            UvFsFlags::_O_CREAT.bit_or(UvFsFlags::_O_RDWR).bit_or(UvFsFlags::_O_APPEND)
        } else if mode.has("a") {
            UvFsFlags::_O_CREAT.bit_or(UvFsFlags::_O_WRONLY).bit_or(UvFsFlags::_O_APPEND)
        } else {
            0.to_CInt
        }
    );

    _O_RDONLY: CInt = _find_flag("O_RDONLY");
    _O_WRONLY: CInt = _find_flag("O_WRONLY");
    _O_RDWR: CInt = _find_flag("O_RDWR");
    _O_CREAT: CInt = _find_flag("O_CREAT");
    _O_EXCL: CInt = _find_flag("O_EXCL");
    _O_TRUNC: CInt = _find_flag("O_TRUNC");
    _O_APPEND: CInt = _find_flag("O_APPEND");
}

type UvStream = unbox struct {
    handle: UvHandle
};

trait stream: ToUvStream {
    to_uv_stream: stream -> UvStream;
}

impl UvStream: ToUvHandle {
    to_uv_handle = @handle;
}

impl UvStream: FromPtr {
    from_ptr = |p_stream| pure $ UvStream { handle: *UvHandle::from_ptr(p_stream) };
}

impl UvStream: BorrowPtrM {
    borrow_ptr_m = |f, stream| stream.@handle.borrow_ptr_m(f);
}

namespace UvStream {
    // write のコールバック
    // # Parameters
    // * req: リクエスト(uv_write_t*)
    // * status: ステータス。0未満ならエラー
    type UvWriteCallback = UvReq -> CInt -> IO ();

    write: [stream: ToUvStream] Array U8 -> UvWriteCallback -> stream -> IOFail ();
    write = |buf, cb, stream| (
        let p_req = *FFI_CALL_IO[Ptr minilib_uv_write_init()].lift;
        let req = *UvReq::from_ptr(p_req).lift;
        req.retain.lift;;    // リクエスト発生のためリテインする
        req.set_user_callback(cb).lift;;     // ユーザが用意したコールバック関数を設定する
        req.borrow_ptr_m(|p_req|
            stream.to_uv_stream.@handle.borrow_ptr_m(|p_handle|
                let bufsize = buf.get_size.to_CSizeT;
                buf.borrow_boxed_m(|p_buf|
                    FFI_CALL_IO[CInt minilib_uv_write(Ptr, Ptr, Ptr, CSizeT), p_req, p_handle, p_buf, bufsize]
                    ._check_err
                )
            )
        );;
        pure $ req
    );
    minilib_uv_write_callback : Ptr -> CInt -> ();
    minilib_uv_write_callback = |p_req, status| (
        eval log_debug("minilib_uv_write_callback: p_req=" + p_req.to_string);
        let req: UvReq = *from_ptr(p_req);
        let cb: UvWriteCallback = *req.get_user_callback;
        cb(req, status);;
        req.release  // release on callback end
    ).unsafe_perform;
    FFI_EXPORT[minilib_uv_write_callback, minilib_uv_write_callback];
}

type UvPipe = unbox struct {
    stream: UvStream
};

impl UvPipe: FromPtr {
    from_ptr = |p_pipe| pure $ UvPipe { stream: *from_ptr(p_pipe) };
}

namespace UvPipe {
    // uv_pipe_t* を確保して初期化し、UvFsを作成する。
    init: UvLoop -> IOFail UvPipe;
    init = |loop| (
        loop.borrow_ptr_m(|p_loop|
            let p_pipe = *FFI_CALL_IO[Ptr minilib_uv_pipe_init(Ptr), p_loop].lift;
            if p_pipe == nullptr { throw $ "minilib_uv_pipe_init failed!" };
            UvPipe::from_ptr(p_pipe)
        )
    );

    borrow_ptr_m: [m: MonadBorrow] (Ptr -> m b) -> UvPipe -> m b;
    borrow_ptr_m = |f, pipe| pipe.@stream.borrow_ptr_m(f);

    // Open an existing file descriptor as a pipe.
    open: UvFile -> UvPipe -> IOFail ();
    open = |fd, pipe| (
        pipe.borrow_ptr_m(|p_pipe|
            FFI_CALL_IO[CInt minilib_uv_pipe_open(Ptr, CInt), p_pipe, fd]
            ._check_err
        )
    );
}