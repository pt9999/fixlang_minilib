//module IOEx;
module Main;

import AsyncTask;

flush : IOHandle -> IOFail ();
flush = |handle| (
    let _ = *pure();    // make it lazy
    let res = CALL_C[I32 fflush(Ptr), handle._file_ptr];
    if res < 0_I32 { 
        throw("flush failed!: some error occurred in fflush.")
    };
    pure()
);

fdopen: I32 -> String -> IOFail IOHandle;
fdopen = |fd, mode| (
    let _ = *pure();    // make it lazy
    let file_ptr = mode.borrow_c_str(|p_mode|
        CALL_C[Ptr fdopen(I32, Ptr), fd, p_mode]
    );
    if file_ptr == nullptr { 
        throw("fdopen failed!: some error occurred in fdopen.")
    };
    pure $ IOHandle::from_file_ptr $ file_ptr
);

pipe: IOFail (IOHandle, IOHandle);
pipe = (
    let _ = *pure();    // make it lazy
    let pipefd: Array I32 = Array::fill(2, 0_I32);
    let res = pipefd.borrow_ptr(|p_pipefd|
        CALL_C[I32 pipe(Ptr), p_pipefd]
    );
    if res == -1_I32 {
        throw("pipe failed!: some error occurred in pipe.")
    };
    let read_fh = *fdopen(pipefd.@(0), "r");
    let write_fh = *fdopen(pipefd.@(1), "w");
    pure $ (read_fh, write_fh)
);

usleep: U32 -> IOFail ();
usleep = |usec| (
    let _ = *pure();    // make it lazy
    let res = CALL_C[I32 usleep(U32), usec];
    if res == -1_I32 {
        throw("usleep failed!: some error occurred in usleep.")
    };
    pure()
);

// for testing
test_fdopen: IOFail ();
test_fdopen = (
    let creat: String -> U32 -> IOFail I32 = |path, mode| (
        let fd = path.borrow_c_str(|p_path|
            CALL_C[I32 creat(Ptr, U32), p_path, mode]
        );
        if fd == -1_I32 {
            throw("creat failed!: some error occurred in creat.")
        };
        pure $ fd
    );

    let _ = *pure();    // make it lazy
    let fd = *creat("_test_fdopen.tmp", /* 0o0644 = */ 420_U32);
    let fh = *fdopen(fd, "w");
    let _ = *write_string(fh, "test");
    let _ = *flush(fh);
    let _ = *close_file(fh).lift;
    pure()
);

test_pipe: IOFail ();
test_pipe = (
    let (read_fh, write_fh) = *pipe;

    let reader = fix $ |loop, _| (
        let line = *read_line(read_fh);
        if line == "" {
            let _ = *close_file(read_fh).lift;
            pure ()
        };
        let _ = *println(line.strip_last_newlines).lift;
        loop ()
    );
    let writer = fix $ |loop, i| (
        if i > 10 {
            let _ = *close_file(write_fh).lift;
            pure ()
        };
        let _ = *write_string(write_fh, i.to_string + "\n");
        let _ = *flush(write_fh);
        let _ = *usleep(300000_U32);
        loop $ i + 1
    ); 

    let catch = |iof| iof.try(|err| eprintln(err));
    let read_task = AsyncIOTask::make(reader().catch);
    let write_task = AsyncIOTask::make(writer(0).catch);
    let _ = *write_task.get.lift;
    let _ = *read_task.get.lift;
    pure()
);

main: IO ();
main = (
    do {
        //test_fdopen
        test_pipe
    }
    .try (|err| eprintln(err))
);