module Main;


type Worker = unbox struct {
    app: App
};

namespace Worker {
    make: App -> Worker;
    make = |app| (
        Worker {
            app: app
        }
    );
    handle: Socket -> SocketAddress -> Worker -> IOFail ();
    handle = |socket, remote_addr, worker| (
        let app = worker.@app;
        let connection = BufferedSocket::make(socket);
        let request = *Request::parse(connection, remote_addr);
        let response = Response::make(request);
        let response = *app.@router.route(request, response);
        let _ = *response.end();
        pure $ ()        
    );
}

type App = unbox struct {
    router: Router,
    backlog: I64
};

namespace App {
    empty: App;
    empty = (
        App {
            router: Router::empty,
            backlog: 10
        }
    );

    mount: String -> String -> RequestHandler -> App -> IOFail App;
    mount = |method, path, callback, app| (
        pure $ app.mod_router(|router|
            router.add(method, path, callback)
        )
    );

    get: String -> RequestHandler -> App -> IOFail App;
    get = mount("GET");

    listen: String -> App -> IOFail ();
    listen = |server_host_port, app| (
        let socket = *(listen_tcp_server(server_host_port, app.@backlog));
        let _ = *(lift $ eprintln ("Listening on " + server_host_port));
        let tasks: Array I64 = Array::empty(0);
        loop_m(
            tasks, |tasks|
            let _ = *(lift $ eprintln ("Accepting connections"));
            let (accepted_socket, addr) = *(socket.accept);
            let _ = *(lift $ eprintln ("Accepted new connection: addr=" + addr.to_string));
            let worker = Worker::make(app);
            if true {
                let _ = *worker.handle(accepted_socket, addr);
                continue_m $ tasks
            } else {
                /*
                //let _ = *(lift $ eprintln ("creating task"));
                let task = AsyncIOTask::make(
                    worker.handle(accepted_socket, addr)
                    .try(|err| eprintln("error: " + err))
                );
                //let _ = *(lift $ eprintln ("creating task done"));
                let tasks = tasks.push_back(task);
                */
                continue_m $ tasks
            }
        )
    );
}

main: IO ();
main = (
    do {
        let app = App::empty;
        let app = *app.get("/", |req,res| res.write_str("Hello") );
        app.listen("localhost:8080")
    }
    .try(|err| eprintln("ERROR: " + err))
);


