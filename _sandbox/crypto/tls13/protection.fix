module Minilib.Crypto.Tls13.Protection;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.CipherSuite;
import Minilib.Crypto.Tls13.RecordProtocol;
import Minilib.Crypto.Tls13.Aead;
import Minilib.Crypto.Tls13.Hkdf;
import Minilib.Crypto.Tls13.Secret;
import Minilib.Crypto.HMAC;
import Minilib.Encoding.Binary;
import Minilib.Monad.FunctorM;
import Minilib.Monad.Error;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;


type Secrets = unbox struct {
    hkdf: HKDF,
    psk: Array U8,
    early_secret: Array U8,
    handshake_secret: Array U8,
    server_handshake_traffic_secret: Array U8,
    client_handshake_traffic_secret: Array U8,
    master_secret: Array U8,
};

impl Secrets: ToString {
    to_string = |secrets| (
        "Secrets {" +
        "\n psk=" + secrets.@psk.to_string_hex +
        "\n early_secret=" + secrets.@early_secret.to_string_hex +
        "\n handshake_secret=" + secrets.@handshake_secret.to_string_hex +
        "\n server_handshake_traffic_secret=" + secrets.@server_handshake_traffic_secret.to_string_hex +
        "\n client_handshake_traffic_secret=" + secrets.@client_handshake_traffic_secret.to_string_hex +
        "\n master_secret=" + secrets.@master_secret.to_string_hex +
        "\n}"
    );
}

namespace Secrets {
    from_cipher_suite: CipherSuite -> Result ErrMsg Secrets;
    from_cipher_suite = |cipher_suite| (
        let hkdf = *HKDF::from_cipher_suite(cipher_suite);
        let psk = hkdf.zero_secret;
        let early_secret = *hkdf.calc_early_secret(psk);
        pure $ Secrets {
            hkdf: hkdf,
            psk: psk,
            early_secret: early_secret,
            handshake_secret: [],
            server_handshake_traffic_secret: [],
            client_handshake_traffic_secret: [],
            master_secret: [],
        }
    );

    calc_handshake_secrets: Array U8 -> Array U8 -> Secrets -> Result ErrMsg Secrets;
    calc_handshake_secrets = |dhe, handshake_context, secrets| (
        let hkdf = secrets.@hkdf;
        let handshake_secret = *hkdf.calc_handshake_secret(secrets.@early_secret, dhe);
        let server_handshake_traffic_secret = *hkdf.calc_server_handshake_traffic_secret(handshake_secret, handshake_context);
        let client_handshake_traffic_secret = *hkdf.calc_client_handshake_traffic_secret(handshake_secret, handshake_context);
        ok $ secrets.set_handshake_secret(handshake_secret)
                    .set_server_handshake_traffic_secret(server_handshake_traffic_secret)
                    .set_client_handshake_traffic_secret(client_handshake_traffic_secret)
    );
}

type RecordProtection = unbox struct {
    write_key: Array U8,
    write_iv: Array U8,
    sequence_number: U64,
};

impl RecordProtection: ToString {
    to_string = |p| (
        "RecordProtection {" +
        " write_key=" + p.@write_key.to_string_hex +
        " write_iv=" + p.@write_iv.to_string_hex +
        " sequence_number=" + p.@sequence_number.to_string_hex +
        "}"
    );
}

namespace RecordProtection {
    empty: RecordProtection;
    empty = RecordProtection {
        write_key: [],
        write_iv: [],
        sequence_number: 0_U64,
    };

    set_traffic_keys: Array U8 -> AEAD -> HKDF -> RecordProtection -> Result ErrMsg RecordProtection;
    set_traffic_keys = |secret, aead, hkdf, record_protection| (
        let (key, iv) = *hkdf.calc_traffic_keys(secret, aead.@key_len, aead.@iv_len);
        ok $ record_protection
            .set_write_key(key)
            .set_write_iv(iv)
            .set_sequence_number(0_U64)
    );

    increment_sequence_number: RecordProtection -> RecordProtection;
    increment_sequence_number = mod_sequence_number(add(1_U64));

    // 5.3. Per-Record Nonce
    get_per_record_nonce: RecordProtection -> Array U8;
    get_per_record_nonce = |record_protection| (
        let iv = record_protection.@write_iv;
        let seqnum = record_protection.@sequence_number;
        let seqnum = Array::fill(iv.get_size, 0_U8).set_u64_be(iv.get_size - 8, seqnum);
        let nonce = Array::from_map(iv.get_size, |i| iv.@(i).bit_xor(seqnum.@(i)));
        nonce
    );

    encrypt: Array U8 -> Array U8 -> AEAD -> RecordProtection -> Result ErrMsg (Array U8);
    encrypt = |plaintext, additional_data, aead, record_protection| (
        let write_key = record_protection.@write_key;
        let nonce = record_protection.get_per_record_nonce;
        aead.aead_encrypt(write_key, nonce, additional_data, plaintext)
    );

    decrypt: Array U8 -> Array U8 -> AEAD -> RecordProtection -> Result ErrMsg (Array U8);
    decrypt = |aead_encrypted, additional_data, aead, record_protection| (
        let write_key = record_protection.@write_key;
        let nonce = record_protection.get_per_record_nonce;
        aead.aead_decrypt(write_key, nonce, additional_data, aead_encrypted)
    );

}


type Protection = unbox struct {
    secrets: Secrets,
    aead: AEAD,
    handshake_context: Array U8,
    server: RecordProtection,
    client: RecordProtection,
};

impl Protection: ToString {
    to_string = |p| (
        "Protection {" +
        " secrets=" + p.@secrets.to_string +
        " server=" + p.@server.to_string +
        " client=" + p.@client.to_string +
        "}"
    );
}

namespace Protection {
    make: CipherSuite -> Result ErrMsg Protection;
    make = |cipher_suite| (
        let secrets = *Secrets::from_cipher_suite(cipher_suite);
        let aead = *AEAD::from_cipher_suite(cipher_suite);

        pure $ Protection {
            secrets: secrets,
            aead: aead,
            handshake_context: [],
            server: RecordProtection::empty,
            client: RecordProtection::empty,
        }
    );

    add_handshake_context: Array U8 -> Protection -> Protection;
    add_handshake_context = |handshake_bytes| (
        mod_handshake_context(append(handshake_bytes))
    );

    init_handshake: Array U8 -> Protection -> Result ErrMsg Protection;
    init_handshake = |dhe, prot| (
        let Protection {
            secrets: secrets,
            aead: aead,
            handshake_context: handshake_context,
            server: server,
            client: client
        } = prot;
        let hkdf = secrets.@hkdf;
        let secrets = *secrets.calc_handshake_secrets(dhe, handshake_context);
        let client = *client.set_traffic_keys(secrets.@client_handshake_traffic_secret, aead, hkdf);
        let server = *server.set_traffic_keys(secrets.@server_handshake_traffic_secret, aead, hkdf);
        ok $ prot.set_secrets(secrets).set_client(client).set_server(server)
    );

    decrypt_server: TLSCiphertext -> Protection -> Result ErrMsg TLSInnerPlaintext;
    decrypt_server = |ciphertext, protection| (
        let additional_data = ciphertext.get_additional_data;
        let aead = protection.@aead;
        let inner_plaintext_bytes = *protection.@server.decrypt(ciphertext.@encrypted_record, additional_data, aead);
        //eval debug_println("inner_plaintext_bytes=" + inner_plaintext_bytes.to_string_hex);
        let inner_plaintext: TLSInnerPlaintext = *unmarshal_from_bytes(inner_plaintext_bytes);
        pure $ inner_plaintext
    );

    encrypt_client: TLSInnerPlaintext -> Protection -> Result ErrMsg TLSCiphertext;
    encrypt_client = |inner_plaintext, protection| (
        let inner_plaintext_bytes = marshal_to_bytes(inner_plaintext);
        let aead = protection.@aead;
        let ciphertext = TLSCiphertext::empty;
        let length = inner_plaintext_bytes.get_size + aead.@tag_len;
        let additional_data = ciphertext.get_additional_data_with_length(length);
        let encrypted_record = *protection.@client.encrypt(inner_plaintext_bytes, additional_data, aead);
        pure $ ciphertext.set_encrypted_record(encrypted_record)
    );

    calc_finished_verify_data: Bool -> Protection -> Result ErrMsg (Array U8);
    calc_finished_verify_data = |is_server, prot| (
        let secrets = prot.@secrets;
        let handshake_context = prot.@handshake_context;
        let hkdf = secrets.@hkdf;
        let base_key = if is_server { secrets.@server_handshake_traffic_secret }
        else { secrets.@client_handshake_traffic_secret };
        let finished_key = *hkdf.expand_label(base_key, "finished", [], hkdf.hash_length);
        eval debug_println("finished_key=" + finished_key.to_string_hex);
        let verify_data = hkdf.@hmac.digest(finished_key, hkdf.transcript_hash(handshake_context));
        ok $ verify_data
    );
}
