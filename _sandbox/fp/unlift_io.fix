module Minilib.Monad.UnliftIO;

import Minilib.Monad.IO;
import Minilib.Monad.Reader;
import Minilib.Monad.Result;

trait MonadUnliftIO = Monad + MonadUnliftIOIF;

trait [m: *->*] m: MonadUnliftIOIF {
    with_run_in_io: ((m a -> IO a) -> IO b) -> m b;
}

/*
namespace ResultT {
    from_iofail: IOFail a -> ResultT ErrMsg IO a;
    from_iofail = |iof| (
         result_t $ iof.to_result
    );

    to_iofail: ResultT ErrMsg IO a -> IOFail a;
    to_iofail = |res| (
        from_io_result $ res.run_result_t
    );
}

impl ResultT e IO: MonadUnliftIOIF {
    //with_run_in_io: ((ResultT e IO a -> IO a) -> IO b) -> ResultT e IO b;
    // TODO: cannot implement: ResultT e IO a -> IO a

    with_run_in_io = |f| (
        let run = |res_t| (
            let res = *res_t.run_result_t;
            match res {
                ok(a) => pure $ a,
                err(e) => undefined(e), // xxxxxxx
            }
        )
    );
}
*/

