module Main;

import UnitTest;
import StringEx;

type Deque a = unbox struct {
    front: Array a,     // reversed array
    back: Array a
};

namespace Deque {
    empty: I64 -> Deque a;
    empty = |n| Deque {
        front: Array::empty(n),
        back: Array::empty(n)
    };

    get_front: Deque a -> Option a;
    get_front = |q| (
        if q.@front.get_size > 0 { some $ q.@front.@(q.@front.get_size - 1) };
        if q.@back.get_size > 0 { some $ q.@back.@(0) };
        none()
    );

    get_back: Deque a -> Option a;
    get_back = |q| (
        if q.@back.get_size > 0 { some $ q.@back.@(q.@back.get_size - 1) };
        if q.@front.get_size > 0 { some $ q.@front.@(0) };
        none()
    );

    push_front: a -> Deque a -> Deque a;
    push_front = |x, q| q.mod_front(push_back(x));

    push_back: a -> Deque a -> Deque a;
    push_back = |x, q| q.mod_back(push_back(x));

    pop_front: Deque a -> Deque a;
    pop_front = |q| (
        if q.@front.get_size > 0 { q.mod_front(pop_back) };
        if q.@back.get_size > 0 { 
            Deque {
                front: q.@back._reverse_array.pop_back,
                back: q.@back.truncate(0)
            }
        };
        // if empty, does nothing.
        q
    );

    pop_back: Deque a -> Deque a;
    pop_back = |q| (
        if q.@back.get_size > 0 { q.mod_back(pop_back) };
        if q.@front.get_size > 0 { 
            Deque {
                front: q.@front.truncate(0),
                back: q.@front._reverse_array.pop_back
            }
        };
        // if empty, does nothing.
        q
    );

    to_iter: Deque a -> Iterator a;
    to_iter = |q| (
        q.@front.to_iter.reverse.append(q.@back.to_iter)
    );

    _reverse_array: Array a -> Array a;
    _reverse_array = |arr| (
        let n = arr.get_size;
        let output = arr.force_unique;
        loop((output, 0), |(output, i)|
            if i >= n { break $ output };
            let output = output.set(n - i - 1, arr.@(i));
            continue $ (output, i + 1)
        )
    );

}

//---------------------------------------------

/*
impl [a: ToString] Array a: ToString {
    to_string = |a| (
        "[" +
        a.to_iter.map(|x| x.to_string).join(",")
        + "]"
    );
}
*/

test_get_front_ok: (Array I64, Array I64, Option I64) -> TestCase;
test_get_front_ok = |(front, back, expected)| (
    let testname = "test_get_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let actual = q.get_front;
    assert_equal("equal", expected, actual)
);

test_get_front: TestCase;
test_get_front = (
    [
        test_get_front_ok $ ([], [], none()),
        test_get_front_ok $ ([1], [], some(1)),
        test_get_front_ok $ ([], [1], some(1)),
        test_get_front_ok $ ([2, 1], [], some(1)),
        test_get_front_ok $ ([], [1, 2], some(1)),
        test_get_front_ok $ ([1], [2], some(1)),
        TestCase::empty
    ]
    .run_tests
);

test_get_back_ok: (Array I64, Array I64, Option I64) -> TestCase;
test_get_back_ok = |(front, back, expected)| (
    let testname = "test_get_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let actual = q.get_back;
    assert_equal("equal", expected, actual)
);

test_get_back: TestCase;
test_get_back = (
    [
        test_get_back_ok $ ([], [], none()),
        test_get_back_ok $ ([1], [], some(1)),
        test_get_back_ok $ ([], [1], some(1)),
        test_get_back_ok $ ([2, 1], [], some(2)),
        test_get_back_ok $ ([], [1, 2], some(2)),
        test_get_back_ok $ ([1], [2], some(2)),
        TestCase::empty
    ]
    .run_tests
);

test_push_front_ok: ((Array I64, Array I64), I64, (Array I64, Array I64)) -> TestCase;
test_push_front_ok = |((front, back), value, (expected_front, expected_back))| (
    let testname = "test_push_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.push_front(value);
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_push_front: TestCase;
test_push_front = (
    [
        test_push_front_ok $ (([], []), 1, ([1], [])),
        test_push_front_ok $ (([2], []), 1, ([2, 1], [])),
        test_push_front_ok $ (([], [2]), 1, ([1], [2])),
        test_push_front_ok $ (([2], [3]), 1, ([2, 1], [3])),
        test_push_front_ok $ (([], [2, 3]), 1, ([1], [2, 3])),
        TestCase::empty
    ]
    .run_tests
);

test_push_back_ok: ((Array I64, Array I64), I64, (Array I64, Array I64)) -> TestCase;
test_push_back_ok = |((front, back), value, (expected_front, expected_back))| (
    let testname = "test_push_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.push_back(value);
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_push_back: TestCase;
test_push_back = (
    [
        test_push_back_ok $ (([], []), 1, ([], [1])),
        test_push_back_ok $ (([1], []), 2, ([1], [2])),
        test_push_back_ok $ (([], [1]), 2, ([], [1, 2])),
        test_push_back_ok $ (([1], [2]), 3, ([1], [2, 3])),
        test_push_back_ok $ (([], [1, 2]), 3, ([], [1, 2, 3])),
        TestCase::empty
    ]
    .run_tests
);

test_pop_front_ok: ((Array I64, Array I64), (Array I64, Array I64)) -> TestCase;
test_pop_front_ok = |((front, back), (expected_front, expected_back))| (
    let testname = "test_pop_front_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.pop_front;
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_pop_front: TestCase;
test_pop_front = (
    [
        test_pop_front_ok $ (([], []), ([], [])),
        test_pop_front_ok $ (([1], []), ([], [])),
        test_pop_front_ok $ (([], [1]), ([], [])),
        test_pop_front_ok $ (([2, 1], []), ([2], [])),
        test_pop_front_ok $ (([1], [2]), ([], [2])),
        test_pop_front_ok $ (([], [1, 2]), ([2], [])),
        test_pop_front_ok $ (([3, 2, 1], []), ([3, 2], [])),
        test_pop_front_ok $ (([2, 1], [3]), ([2], [3])),
        test_pop_front_ok $ (([1], [2, 3]), ([], [2, 3])),
        test_pop_front_ok $ (([], [1, 2, 3]), ([3, 2], [])),
        TestCase::empty
    ]
    .run_tests
);

test_pop_back_ok: ((Array I64, Array I64), (Array I64, Array I64)) -> TestCase;
test_pop_back_ok = |((front, back), (expected_front, expected_back))| (
    let testname = "test_pop_back_ok (" + front.to_string + "," + back.to_string + ")";
    make_test(testname) $ |_|
    let q = Deque { front: front, back: back };
    let q = q.pop_back;
    let _ = *assert_equal("front", expected_front, q.@front);
    let _ = *assert_equal("back", expected_back, q.@back);
    pure()
);

test_pop_back: TestCase;
test_pop_back = (
    [
        test_pop_back_ok $ (([], []), ([], [])),
        test_pop_back_ok $ (([1], []), ([], [])),
        test_pop_back_ok $ (([], [1]), ([], [])),
        test_pop_back_ok $ (([2, 1], []), ([], [1])),
        test_pop_back_ok $ (([1], [2]), ([1], [])),
        test_pop_back_ok $ (([], [1, 2]), ([], [1])),
        test_pop_back_ok $ (([3, 2, 1], []), ([], [1, 2])),
        test_pop_back_ok $ (([2, 1], [3]), ([2, 1], [])),
        test_pop_back_ok $ (([1], [2, 3]), ([1], [2])),
        test_pop_back_ok $ (([], [1, 2, 3]), ([], [1, 2])),

        test_pop_front_ok $ (([], []), ([], [])),
        test_pop_front_ok $ (([1], []), ([], [])),
        test_pop_front_ok $ (([], [1]), ([], [])),
        test_pop_front_ok $ (([2, 1], []), ([2], [])),
        test_pop_front_ok $ (([1], [2]), ([], [2])),
        test_pop_front_ok $ (([], [1, 2]), ([2], [])),
        test_pop_front_ok $ (([3, 2, 1], []), ([3, 2], [])),
        test_pop_front_ok $ (([1], [2, 3]), ([], [2, 3])),
        test_pop_front_ok $ (([], [1, 2, 3]), ([3, 2], [])),
        TestCase::empty
    ]
    .run_tests
);

test_reverse_array_ok: (Array I64, Array I64) -> TestCase;
test_reverse_array_ok = |(arr, expected)| (
    let testname = "test_reverse_array_ok (" + arr.to_string + ")";
    make_test(testname) $ |_|
    let actual = arr._reverse_array;
    assert_equal("equal", expected, actual)
);

test_reverse_array: TestCase;
test_reverse_array = (
    [
        test_reverse_array_ok $ ([], []),
        test_reverse_array_ok $ ([1], [1]),
        test_reverse_array_ok $ ([1, 2], [2, 1]),
        test_reverse_array_ok $ ([1, 2, 3], [3, 2, 1]),
        TestCase::empty
    ]
    .run_tests
);

main1: IO ();
main1 = (
    let q = Deque { front: [3,2,1], back: [4,5] };
    let _ = *println(q.to_iter.map(to_string).join(","));

    pure ()
);

main: IO ();
main = (
    [
        test_get_front,
        test_get_back,
        test_push_front,
        test_push_back,
        test_pop_front,
        test_pop_back,
        test_reverse_array,
        TestCase::empty
    ]
    .run_test_driver
);
