// A fractal like a Cayley graph
module Main;

import Math;

import Minilib.Common.Assert;
import Minilib.Media.Svg;
import Minilib.Encoding.Xml;

//----------------------------------------------------------------------------
// Test routine
//----------------------------------------------------------------------------

pi: F64;
pi = 4.0 * atan(1.0);

type Point = (F64, F64);
type Segment = (Point, Point);
type Segments = Array Segment;

type BBox = (F64, F64, F64, F64);

namespace BBox {
    empty: BBox;
    empty = (0.0, 0.0, 0.0, 0.0);

    update_bbox: Point -> BBox -> BBox;
    update_bbox = |p, bbox| (
        (
            min(bbox.Tuple4::@0, p.Tuple2::@0),
            min(bbox.Tuple4::@1, p.Tuple2::@1),
            max(bbox.Tuple4::@2, p.Tuple2::@0),
            max(bbox.Tuple4::@3, p.Tuple2::@1)
        )
    );
}

type GraphParam = unbox struct {
    max_level: I64,
    num_directions: I64,
    base_size: F64,
    scale: F64,
};

namespace Graph {
    default_param: GraphParam;
    default_param = GraphParam {
        max_level: 5,
        num_directions: 4,
        base_size: 20.0,
        scale: 0.48,
    };

    make_graph: GraphParam -> Segments;
    make_graph = |param| (
        let output = [];
        let p = (0.0, 0.0);
        let level = 0;
        Iterator::range(0, param.@num_directions).fold(
            output, |dir, output|
            make_descendants(p, level, dir, param, output)
        )
    );

    make_descendants: Point -> I64 -> I64 -> GraphParam -> Segments -> Segments;
    make_descendants = |p, level, dir, param, output| (
        if level >= param.@max_level { output };
        let q = make_child(p, level, dir, param);
        let output = output.push_back((p, q));
        Iterator::range(0, param.@num_directions).fold(
            output, |d, output|
            let n = param.@num_directions;
            if (d - dir + n) % n == n / 2 { output };
            make_descendants(q, level + 1, d, param, output)
        )
    );

    make_child: Point -> I64 -> I64 -> GraphParam -> Point;
    make_child = |p, level, dir, param| (
        let r = param.@base_size * param.@scale.pow(level.to_F64);
        let th = 2.0 * pi * dir.to_F64 / param.@num_directions.to_F64;
        (p.@0 + r * cos(th), p.@1 + r * sin(th))
    );
}

segment_path: Segment -> XmlElement;
segment_path = |(p, q)| (
    path(
        newpath
        .moveto(p.@0, p.@1)
        .lineto(q.@0, q.@1)
    ).stroke("black")
);

point_circle: F64 -> Point -> XmlElement;
point_circle = |r, p| (
    circle(p.@0, p.@1, r)
    .Svg::fill("black")
);

figure1: XmlElement;
figure1 = (
    let fill = Svg::fill;
    let gr = group
        .stroke("transparent").stroke_width(0.1)
        .fill("transparent");
    let bbox = (0.0, 0.0, 0.0, 0.0);
    let update_bbox = |p, bbox| (
        (
            min(bbox.Tuple4::@0, p.Tuple2::@0),
            min(bbox.Tuple4::@1, p.Tuple2::@1),
            max(bbox.Tuple4::@2, p.Tuple2::@0),
            max(bbox.Tuple4::@3, p.Tuple2::@1)
        )
    );
    let segs = Graph::make_graph(Graph::default_param);
    let r = 0.3;
    let (gr, bbox) = segs.to_iter.fold(
        (gr, bbox), |seg, (gr, bbox)|
        let (p, q) = seg;
        let gr = gr.add(seg.segment_path);
        //let gr = gr.add(p.point_circle(r));
        //let gr = gr.add(q.point_circle(r));
        let bbox = bbox.update_bbox(p);
        let bbox = bbox.update_bbox(q);
        (gr, bbox)
    );
    let margin = 2.0;
    let bbox = (bbox.@0 - margin, bbox.@1 - margin, bbox.@2 + margin, bbox.@3 + margin);
    Svg::svg(600, 600).view_box(bbox.@0, bbox.@1, bbox.@2 - bbox.@0, bbox.@3 - bbox.@1).add(gr)
);

main: IO ();
main = (
    do {
        let svg = figure1;
        let filepath = "tmp.svg";
        eval *svg.write_file(filepath);
        eval *eprintln("Wrote " + filepath).lift;
        pure()
    }
    .try(eprintln)
);
