// Command line argument parser.  (Inspired by `clap` crate of Rust)
// https://docs.rs/clap/3.2.0/clap/index.html

module Clap;

import Debug;
import HashMap;

import StringEx;

//----------------------------------------------
//  ArgAction
//----------------------------------------------

// The action taken when the argument is parsed.
namespace ArgAction {
    type ArgAction = unbox union {
        set: (),        // Sets next input to the single argument value.
        append: (),     // Appends next input to the array of argument values.
        set_true: (),   // Sets "true" as the single argument value.
        set_false: (),  // Sets "false" as the single argument value.
        help: (),       // Displays help for the command.
        version: ()     // Displays the version of the command.
    };
}

//----------------------------------------------
//  Arg
//----------------------------------------------

// A structure that defines arguments.
// Arguments can be either optional or positional arguments.
// If either `short` or `long` is set, it becomes an optional argument. 
// Otherwise, it is a positional argument.
type Arg = unbox struct {
    id: String,             // A unique ID that identifies the argument.
    short: U8,              // A one-hypen option, eg. `-n`
    long: String,           // A two-hypen option, eg. `--count`
    required: Bool,         // Whether the argument is required or not.
    takes_value: Bool,      // Whether the argument takes some value.
    multiple_values: Bool,  // Whether the argument value(s) is singule or multiple.
    default_value: Option String,   // A default value of the argument.
    value_name: String,     // The name of the argument value which is displayed in help message.
    help: String,           // The help message of the argument.
    action: ArgAction       // The action taken when the argument is parsed.
};

namespace Arg {
    // Creates new argument.
    new: String -> Arg;
    new = |id| (
        Arg {
            id: id,
            short: 0_U8,
            long: "",
            required: false,
            takes_value: false,
            multiple_values: false,
            default_value: none(),
            value_name: "VALUE",
            help: "",
            action: ArgAction::set_true()
        }
    );

    // Sets `@short`.
    short: U8 -> Arg -> Arg;
    short = set_short;

    // Sets `@long`.
    long: String -> Arg -> Arg;
    long = set_long;

    // Sets `@required` to true.
    required: Arg -> Arg;
    required = set_required(true);

    // Sets `@takes_value` to true, and `@action` to `set()`.
    takes_value: Arg -> Arg;
    takes_value = |arg| (
        arg.set_takes_value(true).set_action(ArgAction::set())
    );

    // Sets `@takes_value` to true, `@multiple_values` to true, and `@action` to `append()`.
    takes_multiple_values: Arg -> Arg;
    takes_multiple_values = |arg| (
        arg.set_takes_value(true).set_multiple_values(true).set_action(ArgAction::append())
    );
    
    // Sets `@default_value`.
    default_value: String -> Arg -> Arg;
    default_value = |str| set_default_value(some(str));

    // Sets `@value_name`.
    value_name: String -> Arg -> Arg;
    value_name = set_value_name;

    // Sets `@help`.
    help: String -> Arg -> Arg;
    help = set_help;

    _is_positional: Arg -> Bool;
    _is_positional = |arg| (
        arg.@short == 0_U8 && arg.@long == ""
    );

    _short_to_string: Arg -> String;
    _short_to_string = |arg| (
        ['-', arg.@short]._unsafe_to_string
    );

    _long_to_string: Arg -> String;
    _long_to_string = |arg| (
        "--" + arg.@long
    );

    _positional_to_string: Arg -> String;
    _positional_to_string = |arg| (
        let multi = if arg.@multiple_values { "..." } else { "" };
        if arg.@required { 
            "<" + arg.@id + ">" + multi
        } else {
            "[" + arg.@id + "]" + multi
        }
    );

    _option_matches: String -> Arg -> Bool;
    _option_matches = |input, arg| (
        if arg.@short != 0_U8 && arg._short_to_string == input {
            true
        };
        if arg.@long != "" && arg._long_to_string == input {
            true
        };
        false
    );
}

impl Arg: ToString {
    to_string = |arg| (
        if arg.@short != 0_U8 {
            arg._short_to_string    
        };
        if arg.@long != "" {
            arg._long_to_string
        };
        arg._positional_to_string
    );
}

// ---------------------------------
//  Command
// ---------------------------------
type Command = unbox struct {
    name: String,
    bin_name: String,
    display_name: String,
    version: String,
    author: String,
    about: String,
    args: Array Arg,
    help_template: HelpTemplate,
    version_template: HelpTemplate
};

type App = Command;

namespace Command {
    new: String -> Command;
    new = |name| (
        Command {
            name: name,
            bin_name: name,
            display_name: name,
            version: "",
            author: "",
            about: "",
            args: _default_args,
            help_template: HelpTemplate::default_help,
            version_template: HelpTemplate::default_version
        }
    );
    
    // about(), version() .. please use set_about(), set_version() etc.

    arg: Arg -> Command -> Command;
    arg = |arg, command| (
        command.mod_args(|args| args.push_back(arg))
    );

    render_help: Command -> String;
    render_help = |command| (
        command.@help_template.format(command)
    );

    render_version: Command -> String;
    render_version = |command| (
        command.@version_template.format(command)
    );

    _default_args: Array Arg;
    _default_args = (
        Array::empty(100)
        .push_back(Arg::new("help")
            .set_short('h').set_long("help")
            .set_help("Print help information")
            .set_action(ArgAction::help())
        )
        .push_back(Arg::new("version")
            .set_short('V').set_long("version")
            .set_help("Print version information")
            .set_action(ArgAction::version())
        )
    );

    get_matches: Command -> IOFail ArgMatches;
    get_matches = |command| (
        let inputs = *IO::get_args.lift;
        command.get_matches_from(inputs).from_result
    );

    get_matches_from: Array String -> Command -> Result ErrMsg ArgMatches;
    get_matches_from = |inputs, command| (
        let parser = ArgParser::make(inputs, command);
        let parser = *parser.parse_args;
        let parser = *parser.check_required_args_present;
        let parser = *parser.set_default_if_not_present;
        ok $ parser.@matches
    );
}

// ---------------------------------
//  ArgParser
// ---------------------------------
namespace ArgParser
{
    type ArgParser = unbox struct {
        command: Command,
        args: Array Arg,
        matches: ArgMatches,
        inputs: Array String,
        current_index: I64,
        positional_only: Bool
    };

    make: Array String -> Command -> ArgParser;
    make = |inputs, command| (
        ArgParser {
            command: command,
            args: command.@args,
            matches: ArgMatches::empty,
            inputs: inputs,
            current_index: 1,
            positional_only: false
        }
    );


    no_inputs: ArgParser -> Bool;
    no_inputs = |parser| (
        parser.@current_index >= parser.@inputs.get_size
    );

    advance: ArgParser -> Result ErrMsg (String, ArgParser);
    advance = |parser| (
        if parser.no_inputs {
            err $ "No inputs"
        };
        let input = parser.@inputs.@(parser.@current_index);
        let parser = parser.mod_current_index(|i| i + 1);
        ok $ (input, parser)
    );

    get_input: ArgParser -> Result ErrMsg String;
    get_input = |parser| (
        let (input, _) = *parser.advance;
        ok $ input
    );


    // 実際のコマンドライン引数の配列を解析し、Argの値を設定する。
    parse_args : ArgParser -> Result ErrMsg ArgParser;
    parse_args = |parser| (
        loop_m(
            parser, |parser|
            if parser.no_inputs {
                break_m $ parser
            };
            let input = *parser.get_input;
            if parser.@positional_only {
                continue_m $ *parser._process_positional_arg
            };
            if input == "--" {
                let parser = parser.set_positional_only(true);
                let (_, parser) = *parser.advance;
                continue_m $ parser
            };
            if input.substring(0, 1) == "-" {
                continue_m $ *parser._process_option_arg
            };
            continue_m $ *parser._process_positional_arg
        )
    );
    
    _find_option_arg: String -> ArgParser -> Option Arg;
    _find_option_arg = |input, parser| (
        parser.@args.to_iter.filter(|arg| arg._option_matches(input)).get_first
    );

    // 現在の input をオプションと見なして処理する。
    _process_option_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_option_arg = |parser| (
        let (input, parser) = *parser.advance;
        let arg = *parser._find_option_arg(input).map_or(
            err $ "Found argument '" + input + "' which wasn't expected, or isn't valid in this context",
            ok
        );
        let parser = *parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser 
    );

    // 現在の input をポジショナルと見なして処理する。
    _process_positional_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_positional_arg = |parser| (
        let input = *parser.get_input;
        let args = parser.@args.to_iter.filter(|arg| arg._is_positional).to_array;
        if args.get_size == 0 {
            err $ "Found argument '" + input + "' which wasn't expected, or isn't valid in this context"
        };
        let arg = args.@(0);
        let parser = *parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser
    ); 

    // parser.@args から arg を除去する。
    _remove_arg: Arg -> ArgParser -> ArgParser;
    _remove_arg = |arg, parser| (
        parser.mod_args(|args| args.to_iter.filter(|a| a.@id != arg.@id).to_array)
    );

    // Arg に設定されたアクションを遂行する。
    _perform_action: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _perform_action = |arg, parser| (
        let action = arg.@action;
        if action.is_help {
            err $ parser.@command.render_help
        };
        if action.is_version {
            err $ parser.@command.render_version
        };
        if action.is_set_true || action.is_set_false {
            let value = if action.is_set_true { "true" } else { "false" };
            let parser = parser.set_value(arg, value);
            ok $ parser
        };
        if action.is_set || action.is_append {
            parser._set_or_append_value(arg)
        };
        eval assert(|_| "unknown action: arg="+arg.to_string, false);
        err $ "error"
    );

    // 次のinputを値と見なし, set or append アクションを実行する。
    _set_or_append_value: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _set_or_append_value = |arg, parser| (
        if parser.no_inputs {
            err $ "The argument '" + arg.to_string + "' requires a value but none was supplied"
        };
        let (value, parser) = *parser.advance;
        let parser = if arg.@action.is_set {
            parser.set_value(arg, value)
        } else {
            parser.append_value(arg, value)
        };
        ok $ parser
    );
    
    set_value: Arg -> String -> ArgParser -> ArgParser;
    set_value = |arg, value, parser| (
        parser.mod_matches(|matches|
            matches.set_values(arg.@id,
                [value]
            )
        )
    );
    append_value: Arg -> String -> ArgParser -> ArgParser;
    append_value = |arg, value, parser| (
        parser.mod_matches(|matches|
            matches.mod_values(arg.@id, |values|
                values.push_back(value)
            )
        )
    );

    check_required_args_present: ArgParser -> Result ErrMsg ArgParser;
    check_required_args_present = |parser| (
        let missing_args: Iterator Arg = 
            parser.@command.@args.to_iter
            .filter(|arg| arg.@required)
            .filter(|arg| !parser.@matches.@map.contains_key(arg.@id));
        if missing_args.is_empty {
            ok $ parser
        };
        err $ "The following required arguments were not provided:\n" +
        missing_args.map(|arg| "    " + arg.to_string + "\n")
        .concat_iter
    );

    set_default_if_not_present: ArgParser -> Result ErrMsg ArgParser;
    set_default_if_not_present = |parser| (
        pure $ parser.@command.@args.to_iter.fold(
            parser,
            |parser, arg|
            if arg.@default_value.is_none {
                parser
            };
            if parser.@matches.@map.contains_key(arg.@id) {
                parser
            };
            parser.set_value(arg, arg.@default_value.as_some)
        )
    );
}

// ---------------------------------
//  ArgMatches
// ---------------------------------

type ArgMatches = unbox struct {
    map: HashMap String (Array String)
};

namespace ArgMatches {
    empty: ArgMatches;
    empty = ArgMatches { map: HashMap::empty(0) };

    get_many: String -> ArgMatches -> Option (Array String);
    get_many = |id, matches| (
        matches.@map.find(id)
    );
    get_one: String -> ArgMatches -> Option String;
    get_one = |id, matches| (
        let array = *matches.get_many(id);
        if array.get_size == 0 { none() };
        some(array.@(0))
    );

    set_values: String -> Array String -> ArgMatches -> ArgMatches;
    set_values = |id, values, matches| (
        matches.mod_map(|map| map.insert(id, values))
    );

    mod_values: String -> (Array String -> Array String) -> ArgMatches -> ArgMatches;
    mod_values = |id, f, matches| (
        let values = matches.@map.find(id).as_some_or(Array::empty(0));
        let values = f(values);
        matches.mod_map(|map| map.insert(id, values))
    );
}

// ---------------------------------
//  HelpTemplate
// ---------------------------------

type HelpTemplate = unbox struct { 
    data: String 
};
namespace HelpTemplate {
    new: String -> HelpTemplate;
    new = |str| HelpTemplate { data: str };

    default_help: HelpTemplate;
    default_help = HelpTemplate { 
        data: (
            "{name-version}\n" +
            "{author-with-newline}" +
            "{about-with-newline}" +
            "\n" + 
            "{usage}\n" +
            "{all-args}"
        )
    };

    default_version: HelpTemplate;
    default_version = HelpTemplate {
        data: (
            "{name-version}\n"
        )
    };

    format: Command -> HelpTemplate -> String;
    format = |command, help_template| (
        let help = help_template.@data;
        let help = help.replace_all("{name-version}", command.@display_name + 
            if command.@version == "" { "" } else { " " + command.@version });
        let help = help.replace_all("{author-with-newline}", 
            if command.@author == "" { "" } else { command.@author + "\n" }
        );
        let help = help.replace_all("{about-with-newline}", 
            if command.@about == "" { "" } else { command.@about + "\n" }
        );
        let help = help.replace_all("{usage}", 
            help_template._format_usage(command)
        );
        let help = help.replace_all("{all-args}", 
            help_template._format_all_args(command)
        );
        help
    );

    _format_usage: Command -> HelpTemplate -> String;
    _format_usage = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg._is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg._is_positional).to_array;
        let usage = "USAGE:\n";
        let usage = usage + (
            "    " + command.@bin_name + "[EXE]"
        );
        let usage = usage + (
            if options.get_size == 0 { "" } else { " [OPTIONS]" }
        );
        let usage = usage + (
            if args.get_size == 0 { "" } else {
                args.to_iter.map(|arg| " " + arg.to_string).concat_iter
            }
        );
        usage + "\n"
    );

    _format_all_args: Command -> HelpTemplate -> String;
    _format_all_args = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg._is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg._is_positional).to_array;

        let output: Array String = Array::empty(2);
        let output = if args.get_size == 0 { output } else {
            output.push_back(
                "ARGS:\n" +
                args.to_iter.map(_format_arg).concat_iter
            )
        };
        let output = if options.get_size == 0 { output } else {
            output.push_back(
                "OPTIONS:\n" +
                options.to_iter.map(_format_option).concat_iter
            )
        };
        output.to_iter.join("\n")
    );

    _format_arg: Arg -> String;
    _format_arg = |arg| (
        let line = "    " + arg.to_string;
        let line = if line.get_size >= 15 { line } else {
            line + Array::fill(15 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );

    _format_option: Arg -> String;
    _format_option = |arg| (
        let line = "    ";
        let line = line + (
            if arg.@short == 0_U8 { "    " } else {
                arg._short_to_string + (
                    if arg.@long == "" { "  " } else { ", " }
                )
            }
        );
        let line = line + (
            if arg.@long == "" { " " } else {
                arg._long_to_string + " "
            }
        );
        let line = line + (
            if !arg.@takes_value { "" } else {
                "<" + arg.@value_name + ">"
            }
        );
        let line = if line.get_size >= 32 { line } else {
            line + Array::fill(32 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );
}

// ---------------------------------

/*
main: IO ();
main = (
    do {
        let command = (
            Command::new("nice-tool")
            .set_display_name("MyNiceTool")
            .set_version("0.0.1")
            .set_about("A nice tool")
            .arg(Arg::new("count").short('n').long("count").help("How many times to iterate")
                .takes_value)
            .arg(Arg::new("output").short('o').long("output").help("An output file")
                .takes_value)
            .arg(Arg::new("FILE").help("Input files").takes_multiple_values.required)
        );
        //let _ = *println(command.render_help).lift;
        let inputs = *IO::get_args.lift;
        let inputs = if inputs.get_size > 0 { inputs } else {
            ["nice-tool", "hoge"] 
        };
        let _ = *println("inputs="+inputs.to_string).lift;
        let matches = *command.get_matches_from(inputs).from_result;
        let _ = *println("matches="+matches.@map.to_string).lift;
        pure()
    }
    .try(|err| eprintln("error: " + err))
);
*/
