module Main;

import Debug;

import Minilib.Text.StringEx;
import Minilib.Text.Hex;

debug_lazy: Lazy String -> ();
debug_lazy = |lazy_str| (
    if false { debug_println(lazy_str()) }
    else { () }
);

// 数字 (1 から 9)
type Digit = U8;

// 盤面 (9 x 9 マス)
type Board = unbox struct {
    data: Array (Option Digit)
};

namespace Board {
    // 初期状態の盤面
    empty: Board;
    empty = Board {
        data: Array::fill(9 * 9, none())
    };

    // 指定したマスの数字を取得する
    get_digit: I64 -> I64 -> Board -> Option Digit;
    get_digit = |row, col, board| board.@data.@(row * 9 + col);

    // 指定したマスの数字を設定する
    set_digit: I64 -> I64 -> Option Digit -> Board -> Board;
    set_digit = |row, col, digit, board| board.mod_data(set(row * 9 + col, digit));

    // 数字が配置されたマスの数を数える
    get_digit_count: Board -> I64;
    get_digit_count = |board| (
        board.@data.to_iter.map(|digit| if digit.is_some { 1 } else { 0 })
        .fold(0, add)
    );
}

// Read a board from a string. The format is like this:
// ```
// 1..2..3..
// .4...5..6
// ..7.8..9.
// ```
impl Board: FromString {
    from_string = |lines| (
        let board = Board::empty;
        let filter_chars = |f, str| (
            str.get_bytes.pop_back.to_iter.filter(f).to_array._unsafe_to_string
        );
        let lines = lines.split("\n").map(
            filter_chars(|c| ('1' <= c && c <= '9') || c == '.')
        ).filter(|s| s != "").to_array;
        if lines.get_size != 9 { err $ "invalid row size" };
        Iterator::range(0, 9).fold_m(board, |board, row|
            let line = lines.@(row);
            if line.get_size != 9 { err $ "invalid col size" };
            Iterator::range(0, 9).fold_m(board, |board, col|
                let c = line.get_bytes.@(col);
                let digit = if '1' <= c && c <= '9' { some(c - '1' + 1_U8) } else { none() };
                let board = board.set_digit(row, col, digit);
                pure $ board
            )
        )
    );
}

impl Board: ToString {
    to_string = |board| (
        Iterator::range(0, 9).map(|row|
            Iterator::range(0, 9).map(|col|
                let digit = board.get_digit(row, col);
                if digit.is_none { '.' } else { digit.as_some - 1_U8 + '1' }
            ).to_array._unsafe_to_string
        ).join("\n")
    );
}

// 特定のマスに数字を置けるかどうかを表わすビットベクトル。
// bit i の意味は次のいずれか。(i = 1..9)
// 1: 配置可能、0: 配置不可
type BitVec = U16;
namespace BitVec {
    full: BitVec;
    full = 0b1111111110_U16;    //  bit 1..9

    empty: BitVec;
    empty = 0_U16;

    get_bit: I64 -> BitVec -> Bool;
    get_bit = |i, vec| vec.bit_and(1_U16.shift_left(i.to_U16)) != 0_U16;

    set_bit: I64 -> Bool -> BitVec -> BitVec;
    set_bit = |i, b, vec| (
        if b { vec.bit_or(1_U16.shift_left(i.to_U16)) }
        else { vec.bit_and(U16::maximum - 1_U16.shift_left(i.to_U16)) } 
    );

    // 1 (配置可能) の数を数える
    count_ones: BitVec -> I64;
    count_ones = |vec| (
        let vec = vec.bit_and(0xaaaa_U16).shift_right(1_U16) + vec.bit_and(0x5555_U16);
        let vec = vec.bit_and(0xcccc_U16).shift_right(2_U16) + vec.bit_and(0x3333_U16);
        let vec = vec.bit_and(0xf0f0_U16).shift_right(4_U16) + vec.bit_and(0x0f0f_U16);
        let vec = vec.bit_and(0xff00_U16).shift_right(8_U16) + vec.bit_and(0x00ff_U16);
        vec.to_I64
    );
}

// 9 x 9 マスの配置可能候補を管理する
type Candidates = unbox struct {
    data: Array BitVec  // 9 x 9
};

namespace Candidates {
    full: Candidates;
    full = Candidates {
        data: Array::fill(9 * 9, BitVec::full)
    };

    get: I64 -> I64 -> Candidates -> BitVec;
    get = |row, col, cand| cand.@data.@(row * 9 + col);

    mod: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod = |row, col, f, cand| (
        let cand = cand.mod_data(mod(row * 9 + col, f));
        cand
    );

    // 指定した行全体の配置可能候補を更新する
    mod_row: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_row = |row, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, col| cand.mod(row, col, f)
    );

    // 指定した列全体の配置可能候補を更新する
    mod_col: I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_col = |col, f, cand| Iterator::range(0, 9).fold(
        cand, |cand, row| cand.mod(row, col, f)
    );

    // 指定したマスを含むブロックの配置可能候補を更新する
    mod_block: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_block = |row, col, f, cand| (
        let top = row / 3 * 3;
        let left = col / 3 * 3;
        Iterator::range(0, 9).fold(
            cand, |cand, i| cand.mod(top + i / 3, left + i % 3, f)
        )
    );

    // 指定したマスを含む行、列、ブロックの配置可能候補を更新する
    mod_all: I64 -> I64 -> (BitVec -> BitVec) -> Candidates -> Candidates;
    mod_all = |row, col, f, cand| (
        cand.mod_row(row, f)
        .mod_col(col, f)
        .mod_block(row, col, f)
    );

    // 盤面をもとに配置可能候補を初期化する
    init_by_board: Board -> Candidates;
    init_by_board = |board| (
        let cand = Candidates::full;
        Iterator::range(0, 9).fold(cand, |cand, row|
            Iterator::range(0, 9).fold(cand, |cand, col|
                let digit = board.get_digit(row, col);
                if digit.is_none { cand };
                cand.mod_all(row, col, set_bit(digit.as_some.to_I64, false))
            )
        )
    );

    // まだ数値が配置されていないマスのうち、配置可能数が最も少ないマスを求める。
    // 配置可能数は0の場合もある(失敗を意味する)
    // (配置可能数, 行, 列) が返る。
    // 全てのマスに配置済のときは none()が返る。
    find_best_cell: Board -> Candidates -> Option (I64, I64, I64);
    find_best_cell = |board, cand| (
        let best: Option (I64, I64, I64) = none();
        Iterator::range(0, 9).fold(best, |best, row|
            Iterator::range(0, 9).fold(best, |best, col|
                let digit = board.get_digit(row, col);
                if digit.is_some { best };
                let vec = cand.get(row, col);
                let num_cand = vec.count_ones;
                let best = if best.is_none || best.as_some.@0 > num_cand {
                    some $ (num_cand, row, col)
                } else { best };
                best
            )
        )
    );
}


type App = unbox struct {
    board: Board,
    candidates: Candidates,
    digit_count: I64                 // placed digit count
};

namespace App {
    empty: App;
    empty = App {
        board: Board::empty,
        candidates: Candidates::full,
        digit_count: 0
    };

    init_by_board: Board -> App;
    init_by_board = |board| (
        let candidates = Candidates::init_by_board(board);
        let digit_count = board.get_digit_count;
        App {
            board: board,
            candidates: candidates,
            digit_count: digit_count
        }
    );

    place_digit: I64 -> I64 -> I64 -> App -> App;
    place_digit = |row, col, digit, app| (
        eval assert(|_| "digit is already set", app.@board.get_digit(row, col).is_none);
        eval debug_lazy(|_| [app.@digit_count, digit, row, col].format("{}: place {} at ({}, {})"));
        let app = app.mod_board(set_digit(row, col, some(digit.to_U8)));
        let app = app.mod_candidates(mod_all(row, col, set_bit(digit, false)));
        let app = app.mod_digit_count(add(1));
        app
    );

    solve: App -> Array App;
    solve = |app| (
        let solutions = [];
        let stack = [app];
        _solve_inner(stack, solutions)
    );

    _solve_inner: Array App -> Array App -> Array App;
    _solve_inner = |stack, solutions| (
        if stack.is_empty { solutions };
        let app = stack.get_last.as_some;
        let stack = stack.pop_back;
        eval debug_lazy(|_| [app.@digit_count, stack.get_size].format("{}: _solve_inner: stack size={}"));
        if app.@digit_count >= 9 * 9 {
            // success
            eval debug_lazy(|_| "found a solution");
            let solutions = solutions.push_back(app);
            _solve_inner(stack, solutions)
        };
        let best = app.@candidates.find_best_cell(app.@board);
        if best.is_none {
            // failed
            eval debug_lazy(|_| [app.@digit_count].format("{}: no candidates"));
            _solve_inner(stack, solutions)
        };
        let (num_cand, row, col) = best.as_some;
        if num_cand == 0 {
            // failed
            eval debug_lazy(|_| [app.@digit_count, row, col].format("{}: no candidates at ({}, {})"));
            _solve_inner(stack, solutions)
        };

        let vec = app.@candidates.get(row, col);
        eval debug_lazy(|_| (app.@digit_count, num_cand, (row, col), vec).format("{}: find {} candidates at {} = {}"));
        let stack = Iterator::range(0, 9).fold(stack, |stack, digit|
            let digit = digit + 1;
            if vec.get_bit(digit) == false { stack };
            let stack = stack.push_back(app.place_digit(row, col, digit));
            stack
        );
        _solve_inner(stack, solutions)
    );
}

impl App: ToString {
    to_string = |app| app.@board.to_string;
}

test_board1: String;
test_board1 = "
    53..7....
    6..195...
    .98....6.
    8...6....
    4..8.3..1
    7...2...6
    .6....28.
    ...419..5
    ....8..79
";

test1: IO ();
test1 = do {
    let board: Board = *from_string(test_board1).from_result;
    //println(board.to_string).lift
    let app = App::init_by_board(board);
    let solutions = app.solve;
    let _ = *println([solutions.get_size].format("Found {} solutions:")).lift;
    solutions.to_iter.fold_m(
        (), |_, app|
        println("\n" + app.to_string).lift
    )
}.try(eprintln);

main: IO ();
main = test1;
