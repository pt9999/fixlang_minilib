module Request;

import HashMap;
import Debug;

import URL;
import SimpleParser;
import StringEx;
import IOEx;

//------------------------------------------------------------------------------------

// A type that represents a header. The header is a tuple of field name and field value.
type Header = (String, String);

// A collection of headers.
type Headers = unbox struct {
    iter: Iterator Header
};

impl Headers: ToString {
    to_string = |headers| (
        "Headers { " +
            headers.@iter.reverse.map(|(name, value)| name + ": " + value).join(", ")
        + " }"
    );
}

namespace Headers {
    // An empty collection of headers.
    empty: Headers;
    empty = Headers { iter: Iterator::empty };

    // `headers.set(name, value)` sets the value of the field named `name` to `value`.
    // If a field with the same name already exists, it will be removed first.
    set: String -> String -> Headers -> Headers;
    set = |name, value, headers| (
        headers.mod_iter(|iter|
            iter.filter(|(n,v)| n != name)
            .push_front((name, value))
        )
    );

    // `headers.append(name, value)` appends a new field `(name, value)` to the current headers collection.
    // It will not be removed even if a field with the same name already exists, 
    append: String -> String -> Headers -> Headers;
    append = |name, value, headers| (
        headers.mod_iter(|iter|
            iter.push_front((name, value))
        )
    );

    // `headers.find(name)` finds the field with name `name`.
    find: String -> Headers -> Option String;
    find = |name, headers| (
        headers.@iter.loop_iter(
            none(), |_, (n, v)|
            if name == n {
                break $ some(v)
            };
            continue $ none()
        )
    );

    // `headers.to_iter` returns an iterator of headers.
    to_iter: Headers -> Iterator (String, String);
    to_iter = |headers| headers.@iter.reverse;
}

//------------------------------------------------------------------------------------

// A type that represents a HTTP request.
type Request = unbox struct {
    connection: IOHandle,       // An IOHandle of the socket
    remote_addr: String,        // The remote address, eg. "192.168.0.1:65432"
    method: String,             // eg. "GET"
    request_target: String,     // eg. "/blogs/search?q=hello%25world&limit=30"
    http_version: String,       // eg. "HTTP/1.1"
    headers: Headers,           // A collection of headers of the request
    body: Array U8              // The body of the request
};

impl Request: ToString {
    to_string = |request| (
        "Request {"
        + " remote_addr:" + request.@remote_addr
        + ", method:" + request.@method
        + ", request_target:" + request.@request_target
        + ", http_version:" + request.@http_version
        + ", headers:" + request.@headers.to_string
        //+ ", body:" + request.@body.to_string
        + " }"
    );
}

namespace Request {

    // `Request::parse(connection, remote_addr)` reads the HTTP request from `connection` and parse it.
    parse: IOHandle -> String -> IOFail Request;
    parse = |connection, remote_addr| (
        let start_line = *connection.read_line;
        let start_line = start_line.strip_last_newlines;
        let ((method, request_target, http_version), _) = 
            *_match_request_line.run_parser_str(start_line).from_result;
        let headers = *loop_m (
            Headers::empty, |headers|
            let line = *connection.read_line;
            let line = line.strip_last_newlines;
            if line == "" {
                break_m $ headers
            };
            let ((name, value), _) = *_match_header.run_parser_str(line).from_result;
            let headers = headers.append(name, value);
            continue_m $ headers
        );
        // TODO read body
        // TODO parse query string

        let request = Request {
            connection: connection,
            remote_addr: remote_addr,
            method: method,
            request_target: request_target,
            http_version: http_version,
            headers: headers,
            body: Array::empty(0)
        };
        pure $ request
    );

    _match_request_line: Parser (String, String, String);
    _match_request_line = (
        let method = *match_str_class(|c| c != ' ');
        let _ = *match_char(' ');
        let request_target = *match_str_class(|c| c != ' ');
        let _ = *match_char(' ');
        let http_version = *match_str_class(|c| c != ' ');
        pure $ (method, request_target, http_version)
    );

    _match_header: Parser (String, String);
    _match_header = (
        let field_name = *match_str_class(|c| c != ':');
        let _ = *match_char(':');
        let field_value = *match_str_class(|c| true);
        let field_value = field_value.strip_spaces;
        pure $ (field_name, field_value)
    );
}

type Response = unbox struct {
    request: Request,
    connection: IOHandle,
    http_version: String,
    status: I64,
    reason: String,
    headers: Headers,
    headersSent: Bool
};

namespace Response {
    make: Request -> Response;
    make = |req| (
        let res = Response {
            request: req,
            connection: req.@connection,
            http_version: req.@http_version,
            status: 0,
            reason: "",
            headers: Headers::empty,
            headersSent: false
        };
        res.status(200).content_type("text/plain")
    );

    // Sets the HTTP status code. (eg. 404)
    status: I64 -> Response -> Response;
    status = |status, res| (
        let reason = _STATUS_REASON.find_or(status, "");
        res.set_status(status).set_reason(reason)
    );

    // Sets the `Content-Type` header.
    content_type: String -> Response -> Response;
    content_type = |type, res| (
        let content_type = type;    // TODO: support for "json", "html" etc.
        res.header("Content-Type", content_type)
    );

    // Sets a header.
    header: String -> String -> Response -> Response;
    header = |name, value, res| (
        res.mod_headers(|headers| headers.set(name, value))
    );

    // Sends headers with a status line if they have not already been sent.
    _send_headers: Response -> IOFail Response;
    _send_headers = |res| (
        if res.@headersSent {
            pure $ res
        };
        let connection = res.@connection;
        let status_line = res.@http_version + " " + 
            res.@status.to_string + " " + res.@reason + "\r\n";
        let _ = *write_string(connection, status_line);
        let _ = *res.@headers.to_iter.fold_m(
            (), |_, header|
            let (name, value) = header;
            write_string(connection, name + ": " + value + "\r\n")
        );
        let _ = *write_string(connection, "\r\n");
        let res = res.set_headersSent(true);
        pure $ res
    );

    // Sends headers with a status line if they have not already been sent.
    // Then send the specified string.
    write_str: String -> Response -> IOFail Response;
    write_str = |str, res| (
        let res = *res._send_headers;
        let _ = *write_string(res.@connection, str);
        pure $ res
    );

    // Sends headers with a status line if they have not already been sent.
    // Then flush the connection.
    end: Response -> IOFail Response;
    end = |res| (
        let res = *res._send_headers;
        let connection = *res.@connection.fflush;
        pure $ res
    );
}

// RFC9110
// HTTP status and reason-phrase
_STATUS_REASON: HashMap I64 String;
_STATUS_REASON = (
    HashMap::empty(44)
    .insert(100, "Continue")
    .insert(101, "Switching Protocols")
    .insert(200, "OK")
    .insert(201, "Created")
    .insert(202, "Accepted")
    .insert(203, "Non-Authoritative Information")
    .insert(204, "No Content")
    .insert(205, "Reset Content")
    .insert(206, "Partial Content")
    .insert(300, "Multiple Choices")
    .insert(301, "Moved Permanently")
    .insert(302, "Found")
    .insert(303, "See Other")
    .insert(304, "Not Modified")
    .insert(305, "Use Proxy")
    .insert(307, "Temporary Redirect")
    .insert(308, "Permanent Redirect")
    .insert(400, "Bad Request")
    .insert(401, "Unauthorized")
    .insert(402, "Payment Required")
    .insert(403, "Forbidden")
    .insert(404, "Not Found")
    .insert(405, "Method Not Allowed")
    .insert(406, "Not Acceptable")
    .insert(407, "Proxy Authentication Required")
    .insert(408, "Request Timeout")
    .insert(409, "Conflict")
    .insert(410, "Gone")
    .insert(411, "Length Required")
    .insert(412, "Precondition Failed")
    .insert(413, "Content Too Large")
    .insert(414, "URI Too Long")
    .insert(415, "Unsupported Media Type")
    .insert(416, "Range Not Satisfiable")
    .insert(417, "Expectation Failed")
    .insert(421, "Misdirected Request")
    .insert(422, "Unprocessable Content")
    .insert(426, "Upgrade Required")
    .insert(500, "Internal Server Error")
    .insert(501, "Not Implemented")
    .insert(502, "Bad Gateway")
    .insert(503, "Service Unavailable")
    .insert(504, "Gateway Timeout")
    .insert(505, "HTTP Version Not Supported")
);
