module Main;

import Debug;

import Tcp;
import Clap;

http_fetch: String -> String -> IOFail ();
http_fetch = |host_port, path| (
    let socket = *connect_to_tcp_server(host_port);
    let bufsock = BufferedSocket::make(socket);
    let bufsock = *bufsock.write_str("GET " + path + " HTTP/1.0\n\n");
    let bufsock = *bufsock.flush;
    loop_m(
        bufsock, |bufsock| 
        let (line, bufsock) = *(bufsock.read_line);
        if line == "" {
            break_m $ ()
        };
        eval *(lift $ eprint(line));
        continue_m $ bufsock
    )
);

main: IO ();
main = (
    do {
        let command = Command::new("sample_client")
            .version("0.1")
            .about("Fetches contents from remote HTTP server.")
            .arg(Arg::new("host").short('H').long("host").takes_value.default_value("127.0.0.1")
                .help("Remote host (eg. '127.0.0.1', 'www.example.com')"))
            .arg(Arg::new("port").short('p').long("port").takes_value.default_value("80")
                .help("Remote port number (eg. '8080')"))
            .arg(Arg::new("path").short('l').long("path").takes_value.default_value("/index.html")
                .help("Path to fetch"))
            ;
        let matches = *command.get_matches;

        let host_port = "127.0.0.1:8080";
        let host_port = "localhost:8080";
        //let host_port = "183.79.217.124:80";
        //let host_port = "www.yahoo.co.jp:80";
        let host_port = matches.get_one("host").as_some + ":" + matches.get_one("port").as_some;
        let path = matches.get_one("path").as_some;
        let _ = *println("host_port = " + host_port).lift;

        http_fetch(host_port, path)
    }.try (
        |err| eprintln("ERROR: " + err)
    )
);
