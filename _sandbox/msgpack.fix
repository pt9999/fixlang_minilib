module Main;

import Debug;

import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

trait [m: * -> *] m: MonadMarshalIF {
    write_marshal: [a: Marshal] a -> m ();
}

trait MonadMarshal = Functor + Monad + MonadErrorIF + MonadMarshalIF;

trait [m: * -> *] m: MonadUnmarshalIF {
    read_unmarshal: [a: Unmarshal] m a;
}

trait MonadUnmarshal = Functor + Monad + MonadErrorIF + MonadUnmarshalIF;

type ByteBufferState = StateT ByteBuffer (Result ErrMsg);

impl ByteBufferState: MonadMarshalIF {
    write_marshal = |val| (
        mod_state(marshal(val))
    );
}

impl ByteBufferState: MonadUnmarshalIF {
    read_unmarshal = make_state_t_monad $ unmarshal;
}

//------------------------------------------
trait a: Pack {
    pack: [m: MonadMarshal, ErrorType m = String] a -> m ();
}

trait a: Unpack {
    unpack: [m: MonadUnmarshal, ErrorType m = String] m a;
}

_TypeErr: ErrMsg;
_TypeErr = "TypeErr";

impl U8: Pack {
    pack = |u8: U8| (
        if u8 <= 0x7f_U8 {
            // positive fixint 0XXXXXXX
            write_marshal(u8)
        };
        // 8-bit unsigned integer
        eval *write_marshal(0xcc_U8);
        write_marshal(u8)
    );
}

impl U8: Unpack {
    unpack = (
        let u8: U8 = *read_unmarshal;
        if u8 <= 0x7f_U8 {
            // positive fixint 0XXXXXXX
            pure $ u8
        };
        if u8 == 0xcc_U8 {
            // 8-bit unsigned integer
            read_unmarshal
        };
        error $ _TypeErr 
    );
}

impl U16: Pack {
    pack = |u16: U16| (
        if u16 <= 0xff_U16 {
            u16.to_U8.pack
        };
        // 16-bit unsigned integer (big endian)
        eval *write_marshal(0xcd_U8);
        write_marshal(u16)
    );
}

impl U16: Unpack {
    unpack = (
        unpack.map(U8::to_U16).catch(|errmsg|
            let u8: U8 = *read_unmarshal;
            if u8 == 0xcd_U8 {
                // 16-bit unsigned integer (big endian)
                let u16: U16 = *read_unmarshal;
                pure $ u16
            };
            error $ _TypeErr
        )
    );
}

impl U32: Pack {
    pack = |u32: U32| (
        if u32 <= 0xffff_U32 {
            u32.to_U16.pack
        };
        // 32-bit unsigned integer (big endian)
        eval *write_marshal(0xce_U8);
        write_marshal(u32)
    );
}

impl U32: Unpack {
    unpack = (
        unpack.map(U16::to_U32).catch(|errmsg|
            let u8: U8 = *read_unmarshal;
            if u8 == 0xce_U8 {
                // 32-bit unsigned integer (big endian)
                read_unmarshal
            };
            error $ _TypeErr
        )
    );
}

impl U64: Pack {
    pack = |u64: U64| (
        if u64 <= 0xffffffff_U64 {
            u64.to_U32.pack
        };
        // 64-bit unsigned integer (big endian)
        eval *write_marshal(0xcf_U8);
        write_marshal(u64)
    );
}

impl I8: Pack {
    pack = |i8: I8| (
        if -0x1f_I8 <= i8 && i8 <= 0x7f_I8 {
            // positive fixint 0XXXXXXX
            // negative fixint 111XXXXX
            write_marshal(i8.to_U8)
        };
        // 8-bit signed integer
        eval *write_marshal(0xd0_U8);
        write_marshal(i8.to_U8)
    );
}

impl I16: Pack {
    pack = |i16| (
        if -0x80_I16 <= i16 && i16 <= 0x7f_I16 {
            i16.to_U8.pack
        };
        // 16-bit signed integer (big endian)
        eval *write_marshal(0xd1_U8);
        write_marshal(i16.to_U16)
    );
}

impl I32: Pack {
    pack = |i32| (
        if -0x8000_I32 <= i32 && i32 <= 0x7fff_I32 {
            i32.to_U16.pack
        };
        // 32-bit signed integer (big endian)
        eval *write_marshal(0xd2_U8);
        write_marshal(i32.to_U32)
    );
}

impl I64: Pack {
    pack = |i64| (
        if -0x80000000 <= i64 && i64 <= 0x7fffffff {
            i64.to_U32.pack
        };
        // 64-bit signed integer (big endian)
        eval *write_marshal(0xd3_U8);
        write_marshal(i64.to_U64)
    );
}

test_pack: IO ();
test_pack = (
    let buf = ByteBuffer::empty(0, big_endian());
    let w: ByteBufferState () = do {
        eval *0x12_U8.pack;
        eval *0x1234_U16.pack;
        eval *0x12345678_U32.pack;
        eval *0x123456789abcdef0_U64.pack;
        eval *-0x12_I8.pack;
        eval *-0x1234_I16.pack;
        eval *-0x12345678_I32.pack;
        eval *-0x123456789abcdef0.pack;
        pure()
    };     
    let res = w.run_state_t(buf);
    if res.is_err { println("err: " + res.as_err) };
    let ((), buf) = res.as_ok;
    println((buf.@array.to_string_hex, ).format("buf={}"))
);

test_unpack: IO ();
test_unpack = (
    let arr = [ 0x12, 0xcc, 0xab, 0xcd, 0xab, 0xcd ].map(to_U8); 
    let buf = ByteBuffer::make(arr, big_endian());
    let r: ByteBufferState String = do {
        let a1: U8 = *unpack;
        let a2: U8 = *unpack;
        let a3: U16 = *unpack;
        pure $ (a1.to_string_hex, 
                a2.to_string_hex,
                a3.to_string_hex)
                .format("a1={} a2={} a3={}")
    };     
    let res = r.run_state_t(buf);
    if res.is_err { println("err: " + res.as_err) };
    let (str, buf) = res.as_ok;
    println(str)
);

main: IO ();
main = test_pack;

