module URL;

import StringEx;

type URL = unbox struct {
    url: String,
    scheme: String,
    host: String,
    port: String,
    path: String
};

impl URL: Eq {
    eq = |a, b| (
        a.@url == b.@url &&
        a.@scheme == b.@scheme &&
        a.@host == b.@host &&
        a.@port == b.@port &&
        a.@path == b.@path
    );
}

impl URL: ToString {
    to_string = |u| "URL { url:" + u.@url
        + ", scheme:" + u.@scheme
        + ", host:" + u.@host
        + ", port:" + u.@port
        + ", path:" + u.@path
        + "}";
}

namespace URL {
    _cut: String -> String -> (String, String);
    _cut = |delim, str| (
        let pos = str.find(delim, 0);
        if pos.is_none {
            (str, "")
        };
        let pos = pos.as_some;
        (str.substring(0, pos), str.substring(pos + delim.get_size, str.get_size))
    );

    // Parses a string as a URL.
    // Recognized format of a URL is:
    //    [scheme://]host[:port][path]
    // If the scheme part is omitted, a default value ("http") is used as a scheme.
    // The host and port part should not contain "/".
    // If the port part is omitted, a default value ("443" if scheme == "https", "80" otherwise)
    // is used as a port.
    // The path part should be starts with "/".
    // If the path part is omitted, a default value ("/") is used as a path.
    parse: String -> Result ErrMsg URL;
    parse = |url| (
        let (scheme, rest) = if url.find("://", 0).is_some {
            url._cut("://")
        } else {
            ("http", url)
        };
        let (host_port, path) = rest._cut("/");
        let path = if path == "" { "/" } else { "/" + path };
        
        let (host, port) = host_port._cut(":");
        let port = if port == "" { 
            if scheme == "https" { "443" } else { "80" }
        } else { port };
        
        if host == "" {
            err $ "Invalid host"
        };
        let port_res: Result ErrMsg I64 = from_string (port);
        if port_res.is_err {
            err $ "Invalid port"
        };
        ok $ URL { url:url, scheme:scheme, host:host, port:port, path:path }
    );
}

namespace URI {
    _alpha_numeric: Array U8;
    _alpha_numeric = (
        let char_ranges = [
            ('A', 'Z'),
            ('a', 'z'),
            ('0', '9')
        ];
        char_ranges.to_iter.fold(
            Array::fill(256, 0_U8), |array, (min, max)|
            Iterator::range(min.to_I64, max.to_I64 + 1).fold(
                array, |array, c| array.set(c, 1_U8)
            )
        )
    );

    _encodeURIComponent_table: Array U8;
    _encodeURIComponent_table = (
        "-_.!~*'()".get_bytes.pop_back.to_iter.fold(
            _alpha_numeric, |array, c|
            array.set(c.to_I64, 1_U8)
        )
    );

    _encodeURI_table: Array U8;
    _encodeURI_table = (
        ";,/?:@&=+$".get_bytes.pop_back.to_iter.fold(
            _encodeURIComponent_table, |array, c|
            array.set(c.to_I64, 1_U8)
        )
    );

    _decodeURIComponent_table: Array U8;
    _decodeURIComponent_table = (
        Array::fill(256, 0_U8)
    );

    _decodeURI_table: Array U8;
    _decodeURI_table = (
        // preserve_escape_table
        ";/?:@&=+$,#".get_bytes.pop_back.to_iter.fold(
            _decodeURIComponent_table, |array, c|
            array.set(c.to_I64, 1_U8)
        )    
    );

    _encode_with: Array U8 -> String -> String;
    _encode_with = |unescaped_table, str| (
        let input = str.get_bytes.pop_back;
        input.to_iter.fold(
            Array::empty(input.get_size * 3), |output, c|
            if unescaped_table.@(c.to_I64) != 0_U8 {
                output.push_back(c)
            };
            let hi = c.shift_right(4_U8).bit_and(15_U8);
            let lo = c.bit_and(15_U8);
            output.push_back('%')
            .push_back(encode_hex_char(hi))
            .push_back(encode_hex_char(lo))
        )
        ._unsafe_to_string
    );

    _decode_with: Array U8 -> String -> Result ErrMsg String;
    _decode_with = |preserve_escape_table, str| (
        let input = str.get_bytes.pop_back;
        let input_size = input.get_size;
        let output = *loop_m(
            (Array::empty(input_size), 0), |(output, i)|
            if i >= input_size {
                break_m $ output
            };
            let c = input.@(i);
            if c != '%' {
                continue_m $ (output.push_back(c), i + 1)
            };
            if i + 2 >= input_size {
                err $ "Percent sign requires two characters"
            };
            let hi = *decode_hex_char(input.@(i + 1));
            let lo = *decode_hex_char(input.@(i + 2));
            let c = hi.shift_left(4_U8).bit_or(lo);
            if preserve_escape_table.@(c.to_I64) != 0_U8 {
                let output = output.push_back(input.@(i))
                    .push_back(input.@(i + 1))
                    .push_back(input.@(i + 2));
                continue_m $ (output, i + 3)
            };
            continue_m $ (output.push_back(c), i + 3)
        );
        ok $ output._unsafe_to_string
    );

    encodeURI: String -> String;
    encodeURI = |str| (
        str._encode_with(_encodeURI_table)
    );

    decodeURI: String -> Result ErrMsg String;
    decodeURI = |str| (
        str._decode_with(_decodeURI_table)
    );

    encodeURIComponent: String -> String;
    encodeURIComponent = |str| (
        str._encode_with(_encodeURIComponent_table)
    );

    decodeURIComponent: String -> Result ErrMsg String;
    decodeURIComponent = |str| (
        str._decode_with(_decodeURIComponent_table)
    );
}

/*
main: IO ();
main = (
    do {
        let e =  encodeURIComponent ("abc!#$%&-~_. hoge");
        let _ = *println ("encode: '" + e + "'").lift;
        let d = *decodeURIComponent ("abc%21%23%24%25%26-~_.%20hoge").from_result;
        let _ = *println ("decode: '" + d + "'").lift;
        pure()
    }
    .try(|err| eprintln(err))
);
*/
