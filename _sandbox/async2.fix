module Main;

import AsyncTask;
import Random;

impl Task: Functor {
    map = |f, fa| AsyncTask::make(
        TaskPolicy::default,
        |_|
        let a = fa.get;
        f(a)
    );
}

impl Task: Monad {
    pure = |a| AsyncTask::make(
        TaskPolicy::default,
        |_| a);
    bind = |f, ma| AsyncTask::make(
        TaskPolicy::default,
        |_|
        let a = ma.get;
        f(a).get
    );
}

// IO (IOTask a) のラッパー
type IOTaskM a = unbox struct {
    data: IO (IOTask a)
};

namespace IOTaskM {
    make: TaskPolicy -> IO a -> IOTaskM a;
    make = |policy, io| IOTaskM {
        data: AsyncIOTask::make(policy, io)
    };

    // この結果を perform した時点でタスクが作成される
    // 何度もperformするとその都度タスクが作成される
    get: IOTaskM a -> IO a;
    get = |taskm| (
        let task = *taskm.@data;        // この結果を perform した時点でタスクが作成される
        task.get
    );
}

impl IOTaskM: Functor {
    map = |f, fa| IOTaskM::make(
        TaskPolicy::default,
        do {
            let a = *fa.get;
            pure $ f(a)
        }
    );
}

impl IOTaskM: Monad {
    pure = |a| IOTaskM::make(
        TaskPolicy::default,
        pure $ a
    );
    bind = |f, ma| IOTaskM::make(
        TaskPolicy::default,
        do {
            let a = *ma.get;    // これをperformした時点で1つ目のタスクが作成され、実行される
            f(a).get            // これをperformした時点で2つ目のタスクが作成され、実行される
        }
    );
}

myTask: () -> Task I64;
myTask = |_| (
    let a = *pure(42);
    let b = *pure(a*2);
    pure $ b
);

myIOTaskM: () -> IOTaskM I64;
myIOTaskM = |_| (
    let a = *pure(42);
    let _ = *IOTaskM::make(TaskPolicy::default, println("a="+a.to_string));
    let b = *pure(a*2);
    pure $ b
);

test1: IO ();
test1 = (
    let x = myTask().map(|x| x + 2).get;
    let _ = *println("x="+x.to_string);
    let y = *myIOTaskM().map(|y| y + 2).get;
    let _ = *println("y="+y.to_string);
    pure()
);

test2: IO ();
test2 = (
    let policy = TaskPolicy::run_after_destructed.bit_or(TaskPolicy::on_dedicated_thread);
    let loop = fix $ |loop, i| (
        let _ = *println(i.to_string);
        eval CALL_C[I32 sleep(U32), 1_U32];
        let task = *AsyncIOTask::make(policy, loop(i + 1));
        pure()
    );
    let task = *AsyncIOTask::make(policy, loop(0));
    let forever = *Var::make(false);
    forever.wait_and_lock(|b|b, |b|pure())
);

test3: IO ();
test3 = (
    let rand_var = *Var::make(Random::init_by_seed(1234_U64));
    let next_u64 = rand_var.lock(|rand|
            let (u64, rand) = rand.generate_U64;
            let _ = *rand_var.Var::set(rand);
            pure $ u64
    );
    let thread_count_var = *Var::make(0);
    let policy = TaskPolicy::run_after_destructed.bit_or(TaskPolicy::on_dedicated_thread);
    let loop = fix $ |loop, i| (
        let _ = *println(i.to_string);
        let usec = (*next_u64 % 500000_U64).to_U32;
        eval CALL_C[I32 usleep(U32), usec];
        let nchild = (*next_u64 % 3_U64).to_I64;
        let _ = *Iterator::range(0, nchild).fold_m(
            (), |_, _|
            let task = *AsyncIOTask::make(policy, loop(i + 1));
            thread_count_var.mod(|n| n + 1)
        );
        thread_count_var.mod(|n| n - 1)
    );
    let task = *AsyncIOTask::make(policy, loop(0));
    let _ = *thread_count_var.mod(|n| n + 1);
    thread_count_var.wait_and_lock(|n|n == 0, |n|pure())
);

type Node = box struct {
    val: Array U8,
    next: Var (Option Node)
};

test4: IO ();
test4 = (
    let loop = fix $ |loop, i| (
        if (false) { pure() };
        let _ = *println(i.to_string);
        eval CALL_C[I32 sleep(U32), 1_U32];
        let next = *Var::make(none());
        let node = Node {
            val: Array::fill(10000000, 0_U8),
            next: next
        };
        let _ = *next.Var::set(some(node)); // memory leak
        loop(i+1)
    );
    loop(0)
);

main: IO ();
main = test3;
