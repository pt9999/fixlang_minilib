//module Minilib.Data.Fragment;
module Main;

import Minilib.Trait.Semigroup;
import Minilib.Trait.Monoid;
import Minilib.Monad.Writer;

type Fragment a = box union {
    empty: (),
    leaf: a,
    branch: (Fragment a, Fragment a),
};

namespace Fragment {
    to_array: Fragment a -> Array a;
    to_array = |fa| fa._collect_array([]);

    _collect_array: Array a -> Fragment a -> Array a;
    _collect_array = |out, fa| match fa {
        empty() => out,
        leaf(x) => out.push_back(x),
        branch((left, right)) => right._collect_array(left._collect_array(out))
    };
}

impl Fragment a: MEmpty {
    mempty = empty();
}

impl Fragment a: Semigroup {
    sappend = |right, left| (
        branch((left, right))
    );
}

impl Fragment: Functor {
    map = |f, fa| match fa {
        empty() => empty(),
        leaf(x) => leaf(f(x)),
        branch((left, right)) => branch(left.map(f), right.map(f)),
    };
}

impl Fragment: Monad {
    pure = |a| leaf(a);
    bind = |f, fa| match fa {
        empty() => empty(),
        leaf(x) => f(x),
        branch((left, right)) => branch(left.bind(f), right.bind(f)),
    };
}

/*
trait ma: Singleton {
    type Element ma;
    singleton: Element ma -> ma;
}

impl [m: Monad] m a: Singleton {
    type Element (m a) = a;
    singleton = pure;
}
*/

//write_one: [f: Monad, fe: Monoid, fe = f e, m: Monad] e -> WriterT (f e) m ();
write_one: [m: Monad] e -> WriterT (Fragment e) m ();
write_one = |e| write(pure(e));

//fragment_test1: [f: Monad, fe: Monoid, fe = f I64, m: Monad] I64 -> I64 -> WriterT (f I64) m I64;
fragment_test1: [m: Monad] I64 -> I64 -> WriterT (Fragment I64) m I64;
fragment_test1 = |n, sum| (
    write_one(sum);;
    if n <= 0 {
        pure $ sum 
    };
    fragment_test1(n - 1, sum + n)
);

fragment_perf: I64 -> IO ();
fragment_perf = |n| (
    println("=== fragment_perf ===");;
    let (_, time) = *consumed_time_while_io(do {
        pure();;
        let (fa, sum) = fragment_test1(n, 0).run_writer : (Fragment I64, I64);
        println("sum=" + sum.to_string);;
        println("arr.size=" + fa.to_array.get_size.to_string);;
        pure $ ()
    });
    println("time=" + (time * 1000.0).to_string_precision(3_U8) + " msec")
);

array_test1: [m: Monad] I64 -> I64 -> WriterT (Array I64) m I64;
array_test1 = |n, sum| (
    write([sum]);;
    if n <= 0 {
        pure $ sum 
    };
    array_test1(n - 1, sum + n)
);

array_perf: I64 -> IO ();
array_perf = |n| (
    println("=== array_perf ===");;
    let (_, time) = *consumed_time_while_io(do {
        pure();;
        let (fa, sum) = array_test1(n, 0).run_writer : (Array I64, I64);
        println("sum=" + sum.to_string);;
        println("arr.size=" + fa.get_size.to_string);;
        pure $ ()
    });
    println("time=" + (time * 1000.0).to_string_precision(3_U8) + " msec")
);

main: IO ();
main = (
    //let n = 200000;
    //let n = 100000;     // requires building with `-O max`,
                        // but sometimes a stack overflow still occurs
    let n = 50000;
    fragment_perf(n);;  // n = 50000 time=13.209 msec
    array_perf(n)       // n = 50000 time=6122.529 msec
);
