module Main;

import Minilib.Monad.FreeT;
import Minilib.Monad.Reader;
import Minilib.Monad.Iden;
//import Minilib.Text.Hex;

type Wrap a = unbox struct {
    data: a
};

namespace Wrap {
    wrap: a -> Wrap a;
    wrap = |a| Wrap { data: a };

    unwrap: Wrap a -> a;
    unwrap = @data;
}

//-------------------------------------------

type Toy next = box union {
    output: (String, next),
    bell: next,
    done: ()
};

done_: Toy ();
done_ = done();

impl Toy: Functor {
    map = |f, toy| (
        match toy {
            output((x, next)) => output((x, f(next))),
            bell(next) => bell(f(next)),
            done() => done(),
        }
    );
}

test_toy_1: IO ();
test_toy_1 = (
    let toy1: Toy (Toy ()) = output $ ("A", done());
    let toy2: Toy (Toy (Toy ()))  = bell $ output $ ("A", done());
    pure()
);

impl [a: ToString] Wrap (Free Toy a): ToString {
    to_string = |wma| (
        match wma.unwrap.get {
            f_free(toy) => match toy {
                output((x, next)) => "output " + x + "\n" + next.wrap.to_string,
                bell(next) => "bell\n" + next.wrap.to_string,
                done() => "done\n",
            },
            f_pure(value) => "pure " + value.to_string + "\n",
        }
    );
}

foutput: String -> Free Toy ();
foutput = |x| output((x, ())).lift_f;

fbell: Free Toy ();
fbell = bell().lift_f;

fdone: Free Toy ();
fdone = done().lift_f;

output_: String -> next -> Toy next;
output_ = |x, next| output $ (x, next);

test_toy_f_free: IO ();
test_toy_f_free = (
    println("=== test_toy_f_free ===");;
    let toy = do {
        output_("A",()).lift_f;;
        bell().lift_f;;
        done_.lift_f;;
        pure()
    };
    print(toy.wrap.to_string)
);

test_toy_f_free2: IO ();
test_toy_f_free2 = (
    println("=== test_toy_f_free2 ===");;
    let pretty = |x| (
        println("------------");;
        print(x.wrap.to_string)
    );
    pretty(foutput("A"));;
    pretty(pure("A").bind(foutput));;
    pretty(foutput("A").bind(pure));;
    pretty(foutput("A");; foutput("B"));;
    pretty(foutput("A");; fdone;; foutput("B"));;
    pure()
);

//-------------------------------------------
// Free monad as a coroutine

type StrParser = Free (ReaderT String Iden);

parse_text1: StrParser (Array String);
parse_text1 = (
    f_free $ reader $ |line| (
        let lines = [line];
        parse_text2 $ lines
    )
);

parse_text2: Array String -> StrParser (Array String);
parse_text2 = |lines| (
    f_free $ reader $ |line| (
        let lines = lines.push_back(line);
        parse_text3 $ lines
    )
);

parse_text3: Array String -> StrParser (Array String);
parse_text3 = |lines| (
    f_free $ reader $ |line| (
        let lines = lines.push_back(line);
        f_pure $ lines
    )
);

test_str_parser: IO ();
test_str_parser = (
    println("=== test_str_parser ===");;
    let parser = parse_text1;
    loop_m(
        (parser, 0), |(parser, i)|
        match parser {
            f_pure(value) => (
                println(value.to_string);;
                break_m $ ()
            ),
            f_free(reader) => (
                let parser = reader.run_reader(i.to_string);
                continue_m $ (parser, i + 1)
            ),
        }
    )
);

//-------------------------------------------
// Free monad as a effect

trait [m: * -> *] m: MonadCommIF {
    send_bytes: Array U8 -> m ();
    recv_bytes: I64 -> m (Array U8);
    gen_bytes: I64 -> m (Array U8);
}

trait MonadComm = Monad + MonadCommIF;

type Comm next = box union {
    comm_send_bytes: (Array U8, () -> next),
    comm_recv_bytes: (I64, Array U8 -> next),
    comm_gen_bytes: (I64, Array U8 -> next),
};

impl Comm: Functor {
    map = |f, obj| (
        match obj {
            comm_send_bytes(tuple2) => comm_send_bytes $ tuple2.map(|g| g >> f),
            comm_recv_bytes(tuple2) => comm_recv_bytes $ tuple2.map(|g| g >> f),
            comm_gen_bytes(tuple2) => comm_gen_bytes $ tuple2.map(|g| g >> f),
        }
    );
}

impl Free Comm: MonadCommIF {
    send_bytes = |bytes| lift_f $ comm_send_bytes $ (bytes, pure);
    recv_bytes = |length| lift_f $ comm_recv_bytes $ (length, pure);
    gen_bytes = |length| lift_f $ comm_gen_bytes $ (length, pure);
}

namespace FreeComm {
    interpret: [m: MonadComm] Free Comm a -> m a;
    interpret = |free| (
        match free {
            f_pure(value) => pure(value),
            f_free(comm) => match comm {
                comm_send_bytes((bytes, cont)) => cont(*send_bytes(bytes)).interpret,
                comm_recv_bytes((length, cont)) => cont(*recv_bytes(length)).interpret,
                comm_gen_bytes((length, cont)) => cont(*gen_bytes(length)).interpret,
            }
        }
    );
}

impl IO: MonadCommIF {
    send_bytes = |bytes| (
        println("send_bytes: " + bytes.to_string);;
        pure()
    );
    recv_bytes = |length| (
        let bytes = Array::from_map(length, |i| i.to_U8);
        println("recv_bytes: " + bytes.to_string);;
        pure $ bytes
    );
    gen_bytes = |length| (
        let bytes = Array::from_map(length, |i| ((i + 33) * 31).to_U8);
        println("gen_bytes: " + bytes.to_string);;
        pure $ bytes
    );
}

monad_comm_1: [m: MonadComm] m ();
monad_comm_1 = (
    let size = 20;
    let bytes = *gen_bytes(size);
    send_bytes(bytes);;
    let bytes = *recv_bytes(size);
    send_bytes(bytes);;
    pure()
);

test_monad_comm: IO ();
test_monad_comm = (
    println("=== test_monad_comm ===");;
    // Record a computation as a free monad
    let ma: Free Comm () = monad_comm_1;
    // Interpret the free monad as an IO monad
    ma.interpret
);

main: IO ();
main = (
    test_toy_f_free;;
    test_toy_f_free2;;
    test_str_parser;;
    test_monad_comm;;
    pure()
);
