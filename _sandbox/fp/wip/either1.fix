module Main;

type [m: * -> *, n: * -> *] EitherT m n a = unbox union {
    left: m a,
    right: n a,
};

impl [m: Functor, n: Functor] EitherT m n: Functor {
    map = |f, ea| (
        match ea {
            left(ma) => left(ma.map(f)),
            right(na) => right(na.map(f)),
        }
    );
}

impl [m: Monad, n: Monad] EitherT m n: Monad {
    // pure(a) becomes right
    pure = |a| right(pure(a));

    bind = |f, ea| (
        match ea {
            left(ma) => left(ma.bind(f)),       // type error: ma.bind(f), since f: a -> EitherT m n b, not a -> m b
            right(na) => right(na.bind(f)),
        }
    );
}

