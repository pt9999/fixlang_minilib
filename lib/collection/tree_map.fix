module TreeMap;

import RBTree;
import StringEx;

namespace TreeMap {
    trait TreeMapKey = RBNodeElem;

    _lift_lt: (k -> k -> Bool) -> (k, v) -> (k, v) -> Bool;
    _lift_lt = |key_less_than, (k1, v1), (k2, v2)| (
        key_less_than(k1, k2)
    );

    type TreeMap k v = unbox struct {
        root: RBNode (k, v),
        key_less_than: k -> k -> Bool,
        entry_less_than: (k, v) -> (k, v) -> Bool
    };

    make: [k: LessThan, k: TreeMapKey] () -> TreeMap k v;
    make = |_| (
        make_lt(RBNode::_less_than)
    );

    make_lt: [k: TreeMapKey] (k -> k -> Bool) -> TreeMap k v;
    make_lt = |key_less_than| (
        TreeMap {
            root: RBNode::empty(),
            key_less_than: key_less_than,
            entry_less_than: _lift_lt(key_less_than)
        }
    );
    
    insert: [k: TreeMapKey] k -> v -> TreeMap k v -> TreeMap k v;
    insert = |k, v, ts| (
       ts.mod_root(insert_lt((k, v), ts.@entry_less_than))
    );

    erase: [k: TreeMapKey] k -> TreeMap k v -> TreeMap k v;
    erase = |k, ts| (
        let less_than = ts.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, k);
        let lt_end   = |(ent_k,_)| !less_than(k, ent_k);
        ts.mod_root(remove_range(lt_begin, lt_end))
    );

    is_empty: [k: TreeMapKey] TreeMap k v -> Bool;
    is_empty = |ts| (
        ts.@root.is_empty
    );

    contains_key: [k: TreeMapKey] k -> TreeMap k v -> Bool;
    contains_key = |k, ts| (
        ts.find(k).is_some
    );

    keys: [k: TreeMapKey] TreeMap k v -> Iterator k;
    keys = |ts| (
        ts.to_iter.map(|e| e.@0)
    );

    find: [k: TreeMapKey] k -> TreeMap k v -> Option v;
    find = |k, ts| (
        let less_than = ts.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, k);
        let lt_end   = |(ent_k,_)| !less_than(k, ent_k);
        let iter = ts.@root.find_range(lt_begin, lt_end);
        iter.get_first.map(|entry| entry.@1)
    );

    // `ts.find_range(begin, end)` finds all entries `(k,v)`
    // where `!less_than(k, begin) && less_than(k, end)` is true.
    // In default `LessThan` ordering, that condition is same as `begin <= k && k < end`.
    find_range: [k: TreeMapKey] k -> k -> TreeMap k v -> Iterator (k, v);
    find_range = |begin, end, ts| (
        let less_than = ts.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, begin);
        let lt_end   = |(ent_k,_)| less_than(ent_k, end);
        ts.@root.find_range(lt_begin, lt_end)
    );

    // `ts.find_raw_range(lt_begin, lt_end)` finds all entries `(k,v)`
    // where `!lt_begin((k, v)) && lt_end((k, v))` is true.
    find_raw_range: [k: TreeMapKey] ((k,v) -> Bool) -> ((k,v) -> Bool) -> TreeMap k v -> Iterator (k, v);
    find_raw_range = |lt_begin, lt_end, ts| (
        ts.@root.find_range(lt_begin, lt_end)
    );

    to_iter: [k: TreeMapKey] TreeMap k v -> Iterator (k, v);
    to_iter = |ts| (
        ts.@root.to_iter.map(|entry| (entry.@0, entry.@1))
    );

    from_iter_lt: [k: TreeMapKey] (k -> k -> Bool) -> Iterator (k, v) -> TreeMap k v;
    from_iter_lt = |key_less_than, iter| (
        let ts = TreeMap::make_lt(key_less_than);
        let root = RBNode::from_iter_lt(ts.@entry_less_than, iter);
        ts.set_root(root)
    );

    from_iter: [k: LessThan, k: TreeMapKey] Iterator (k, v) -> TreeMap k v;
    from_iter = |iter| (
        TreeMap::from_iter_lt(RBNode::_less_than, iter) 
    );
}

impl [k: TreeMapKey, v: ToString] TreeMap k v: ToString {
    to_string = |ts| (
        "TreeMap{" + ts.to_iter.map(to_string).join(",") + "}"
    );
}
