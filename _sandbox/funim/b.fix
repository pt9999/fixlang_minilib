module Main;

import Funim;
import Funim.Machine;

import MiscAlgos.Geometry;
import MiscAlgos.Functional;
import Math;
import Time;
import Cairo;
import Cairo.ImageSurface;
import RingBuffer;
import Random;

import Minilib.Common.IORef;
import Minilib.Monad.Random;
import Minilib.Monad.State;

type RGBColor = (F64, F64, F64);
type RGBAColor = (F64, F64, F64, F64);

window_size : (I64, I64);
window_size = (1280, 720);

color_cyan: RGBColor = (0.0, 1.0, 1.0);

color_red: RGBColor = (1.0, 0.0, 0.0);
color_green: RGBColor = (0.0, 1.0, 0.0);
color_blue: RGBColor = (0.0, 0.0, 1.0);

color_white_a50 : RGBAColor;
color_white_a50 = (1.0, 1.0, 1.0, 0.5);

null_random: Random;
null_random = Random::init_by_seed(0_U64);

eval_random: IORef Random -> State Random a -> IO a;
eval_random = |ior_random, sma| (
    ior_random.act(|random|
        let random = random.assert_unique(|_| "not unique");
        let (random, a) = sma.run_state(random);
        pure $ (a, random)
    )
);

random_F64_range: [m: MonadRandom] F64 -> F64 -> m F64;
random_F64_range = |begin, end| (
    let r = *random_U64;
    let r = r.to_F64 / U64::maximum.to_F64;
    let r = begin + r * (end - begin);
    pure $ r
);

type Obj = box struct {
    ior_random: IORef Random,
    point: Vec2,
    line: RingBuffer Vec2,
    velocity: Vec2,
    color: RGBColor,
};

namespace Obj {
    generate: IORef Random -> IO Obj;
    generate = |ior_random| (
        eval_random(ior_random) $ do {
            let win_w = window_size.@0.to_F64;
            let win_h = window_size.@1.to_F64;
            let x = -0.50 * win_w; // *random_F64_range(-0.9 * win_w, -0.8 * win_w);
            let y = 0.00 * win_h; // *random_F64_range(-0.49 * win_h, 0.49 * win_h);
            let vx = 0.10 * win_w; // *random_F64_range(0.15 * win_w, 0.2 * win_w);
            let vy = 0.00 * win_h; // *random_F64_range(-0.002 * win_h, 0.002 * win_h);
            let c = *random_I64_range(0,3);
            let color = if c < 1 { color_red } 
            else if c < 2 { color_green }
            else { color_blue };
            let line = RingBuffer::create([]);

            pure $ Obj {
                ior_random: ior_random,
                point: Vec2::make(x, y),
                line: line,
                velocity: Vec2::make(vx, vy),
                color: color
            }
        }
    );

    render : Obj -> Cairo -> IO ();
    render = |obj, cairo| (
        let x = obj.@point.@x;
        let y = obj.@point.@y;
        let d = 10.0;
        cairo.arc((x, y), d, 0.0, 2.0 * pi64);;
        cairo.set_source_rgba(color_white_a50);;
        cairo.fill_preserve;;
        cairo.set_source_rgb(obj.@color);;
        cairo.stroke;;
        cairo.set_source_rgba(color_white_a50);;
        range(0, obj.@line.get_size).fold_m(
            (), |i, _|
            let p = obj.@line.@(i);
            if i == 0 { cairo.move_to(p.to_tuple) }
            else { cairo.line_to(p.to_tuple) }
        );;
        cairo.stroke;;
        pure()
    );

    move: TimeDelta -> Obj -> IO Obj;
    move = |dt, obj| (
        let g = 0.0; // 150.0;
        let win_w = window_size.@0.to_F64;
        let win_h = window_size.@1.to_F64;
        let (min_x, max_x) = (-win_w / 2.0, win_w / 2.0);
        let (min_y, max_y) = (-win_h / 2.0, win_h / 2.0);
        let obj = obj[^velocity][^y].imod(add(g * dt));
        //let th = *random_F64_range(-1.0, 1.0).eval_random(obj.@ior_random);
        //let th = th * (pi64 * 5.0 / 180.0);
        //let obj = obj.mod_velocity(rotated(th));
        let obj = obj[^point].imod(add(obj.@velocity.scaled(dt)));
        let dydt = 0.50 * win_h * *random_F64_range(-1.0, 1.0).eval_random(obj.@ior_random);
        let obj = obj[^point][^y].imod(add(dydt * dt));
        let obj = if obj.@point.@x < min_x {
            let obj = obj[^velocity][^x].imod(mul(-1.0));
            obj[^point][^x].imod(|x| 2.0 * min_x - x)
        } else if obj.@point.@x > max_x {
            let obj = obj[^velocity][^x].imod(mul(-1.0));
            obj[^point][^x].imod(|x| 2.0 * max_x - x)
        } else { obj };
        /*
        let obj = if obj.@point.@y < min_y {
            obj.mod_velocity(mod_y(mul(-1.0))).mod_point(mod_y(|y| 2.0 * min_y - y))
        } else if obj.@point.@y > max_y {
            obj.mod_velocity(mod_y(mul(-1.0))).mod_point(mod_y(|y| 2.0 * max_y - y))
        } else { obj };
        */
        let obj = obj[^line].imod(|line|
            let line = line.push_back(obj.@point);
            loop(line, |line|
                if line.get_size <= 100 { break $ line };
                continue $ line.pop_front
            )
        );
        pure $ obj
    );

// type Draw = Cairo -> IO ();
// type Animation = Machine TimeDelta Draw;
// from_transition : s -> (i -> s -> (s, o)) -> Machine i o;

    animate: Obj -> Animation;
    animate = |obj| (
        Machine::from_transition_io(obj, |dt, obj|
            let obj = *obj.move(dt);
            pure $ (obj, obj.render)
        )
    );
}

main : IO ();
main = (
    let random = Random::init_by_seed((*Time::get_now).to_F64.to_U64);
    let ior_random = *IORef::make(random);
    let config = Funim::Config::default(window_size);
    //let config = Funim::Config::encode(window_size, 60.0, "frames");

    let n_obj = 50;
    let objs = *range(0, 50).map(|_| Obj::generate(ior_random)).collect_m;
    let animation = Animation::stack $ objs.map(animate);
    /*
    let animation : Animation = Animation::stack $ [
        Obj::make(Vec2::make(0.0, -150.0), color_red).animate,
        Obj::make(Vec2::make(50.0, 0.0), color_blue).animate,
        Obj::make(Vec2::make(0.0, 150.0), color_green).animate,
    ];
    */

    Funim::run_animation(animation, config)
);


