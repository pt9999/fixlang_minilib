// IO extensions
module IOEx;

import StringEx;

// Creates a new file or rewrites an existing one.
// For details, see Linux manual page for [creat()](https://man7.org/linux/man-pages/man3/creat.3p.html).
creat: String -> U32 -> IOFail I32;
creat = |path, mode| (
    let _ = *pure();    // make it lazy
    let fd = path.borrow_c_str(|p_path|
        CALL_C[I32 creat(Ptr, U32), p_path, mode]
    );
    if fd == -1_I32 {
        throw("creat failed!: some error occurred in creat.")
    };
    pure $ fd
);

// Deletes a name from the filesystem and possibly the file it refers to.
// For details, see Linux manual page for [unlink()](https://man7.org/linux/man-pages/man2/unlink.2.html).
unlink: String -> IOFail ();
unlink = |path| (
    let _ = *pure();    // make it lazy
    let res = path.borrow_c_str(|p_path|
        CALL_C[I32 unlink(Ptr), p_path]
    );
    if res == -1_I32 { 
        throw("unlink failed!: some error occurred in unlink.")
    };
    pure()
);

type DirHandle = unbox struct {
    dtor: Destructor Ptr
};

_opendir: String -> IOFail DirHandle;
_opendir = |dir_path| (
    let _ = *pure();    // make it lazy
    let dirp = dir_path.borrow_c_str(|p_path|
        CALL_C[Ptr opendir(Ptr), p_path]
    );
    if dirp == nullptr { 
        throw("unlink failed!: some error occurred in unlink.")
    };
    pure $ DirHandle {
        dtor: Destructor::make(dirp, |dirp|
            //eval debug_eprintln ("closing dir handle");
            eval CALL_C[I32 closedir(Ptr), dirp];
            ()
        )
    }
);


_readdir: DirHandle -> IOFail String;
_readdir = |dir_handle| (
    let dirent: Ptr = dir_handle.@dtor.borrow(|dirp|
        CALL_C[Ptr readdir(Ptr), dirp]
    );
    if dirent == nullptr {
        // The end of directory stream is reached (`errno` is not changed),
        // or an error occured (`errno` is set).
        // We cannot get or set `errno`, so simply ignore errors.
        pure $ ""
    };

    //   struct dirent {
    //       ino_t          d_ino;       /* Inode number */
    //       off_t          d_off;       /* Not an offset; see below */
    //       unsigned short d_reclen;    /* Length of this record */
    //       unsigned char  d_type;      /* Type of file; not supported
    //                                      by all filesystem types */
    //       char           d_name[256]; /* Null-terminated filename */
    //   };
    // (offset of d_name) = sizeof(ino_t) + sizeof(off_t) + 2 + 1
    //                    = 8 + 8 + 2 + 1 = 19
    let d_name: Ptr = dirent.add_offset(19);
    let name = String::_unsafe_from_c_str_ptr(d_name);
    pure $ name 
);

// Lists a directory.
// Returns filenames in the specified directory.
// The filenames will be sorted in lexicographical order.
list_dir: String -> IOFail (Array String);
list_dir = |dirpath| (
    let _ = *pure();    // make it lazy
    let dir_handle = *_opendir(dirpath);
    let names: Array String = Array::empty(10);
    let names = *loop_m(
        names, |names|
        let name = *_readdir(dir_handle);
        if name == "" {
            break_m $ names
        };
        if name == "." || name == ".." {
            continue_m $ names
        };
        let names = names.push_back(name);
        continue_m $ names
    );
    let names = names.sort_by(string_less_than);
    pure $ names
);

// Flushes a file stream.
// For details, see Linux manual page for [fflush()](https://man7.org/linux/man-pages/man3/fflush.3.html).
fflush : IOHandle -> IOFail ();
fflush = |handle| (
    let _ = *pure();    // make it lazy
    let res = CALL_C[I32 fflush(Ptr), handle._file_ptr];
    if res < 0_I32 { 
        throw("flush failed!: some error occurred in fflush.")
    };
    pure()
);

// Associates a stream with a file descriptor.
// For details, see Linux manual page for [fdopen()](https://man7.org/linux/man-pages/man3/fdopen.3p.html).
fdopen: I32 -> String -> IOFail IOHandle;
fdopen = |fd, mode| (
    let _ = *pure();    // make it lazy
    let file_ptr = mode.borrow_c_str(|p_mode|
        CALL_C[Ptr fdopen(I32, Ptr), fd, p_mode]
    );
    if file_ptr == nullptr { 
        throw("fdopen failed!: some error occurred in fdopen.")
    };
    pure $ IOHandle::from_file_ptr $ file_ptr
);


// Creates a pipe. It returns `(read_fd, write_fd)` where `read_fd` is the file descriptor of 
// read-end of the pipe, and `write_fd` is the file descriptor of write-end of the pipe.
// For details, see Linux manual page for [pipe()](https://man7.org/linux/man-pages/man2/pipe.2.html).
pipe: IOFail (I32, I32);
pipe = (
    let _ = *pure();    // make it lazy
    let pipefd: Array I32 = Array::fill(2, 0_I32);
    let res = pipefd.borrow_ptr(|p_pipefd|
        CALL_C[I32 pipe(Ptr), p_pipefd]
    );
    if res == -1_I32 {
        throw("pipe failed!: some error occurred in pipe.")
    };
    let read_fd = pipefd.@(0);
    let write_fd = pipefd.@(1);
    pure $ (read_fd, write_fd)
);

// Creates a pipe stream. It returns `(read_fh, write_fh)` where `read_fd` is the stream of 
// read-end of the pipe, and `write_fd` is the stream of write-end of the pipe.
// For details, see Linux manual page for [pipe()](https://man7.org/linux/man-pages/man2/pipe.2.html).
open_pipe: IOFail (IOHandle, IOHandle);
open_pipe = (
    let (read_fd, write_fd) = *pipe;
    let read_fh = *fdopen(read_fd, "r");
    let write_fh = *fdopen(write_fd, "w");
    pure $ (read_fh, write_fh)
);

// Sleeps for specified micro-seconds.
// For details, see Linux manual page for [usleep()](https://man7.org/linux/man-pages/man3/usleep.3.html).
usleep: U32 -> IOFail ();
usleep = |usec| (
    let _ = *pure();    // make it lazy
    let res = CALL_C[I32 usleep(U32), usec];
    if res == -1_I32 {
        throw("usleep failed!: some error occurred in usleep.")
    };
    pure()
);
