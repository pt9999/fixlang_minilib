// RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3
// https://tex2e.github.io/rfc-translater/html/rfc8446.html
module Minilib.Crypto.Tls13.TLSSession;

import AsyncTask;
import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.RandGen;
import Minilib.Crypto.Tls13.Connection;
import Minilib.Crypto.Tls13.Handshake;
/*
import Minilib.Crypto.Tls13.HandshakeProtocol;
import Minilib.Crypto.Tls13.RecordProtocol;
import Minilib.Encoding.Binary;
*/
import Minilib.Crypto.SecureRandom;
import Minilib.Monad.State;
import Minilib.Monad.Trans;
import Minilib.Monad.Error;
import Minilib.Net.Tcp;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type TLSSession = unbox struct {
    socket: Socket,
    var_secure_random: Var SecureRandom,
    handshake_state: HandshakeState,
};

impl TLSSession: GetRandomSource {
    type RandomGeneratorType TLSSession = SecureRandom;
    get_random_generator = @var_secure_random;
}

impl TLSSession: GetByteIO {
    type ByteIOType TLSSession = Socket;
    get_byte_io = TLSSession::@socket;
}


namespace TLSSession {
    make: Socket -> IOFail TLSSession;
    make = |socket| (
        let secure_random = *SecureRandom::make;
        let var_secure_random = *Var::make(secure_random).lift;
        pure $ TLSSession {
            socket: socket,
            var_secure_random: var_secure_random,
            handshake_state: HandshakeState::empty(),
        }
    );

    get_hstate: StateT TLSSession IOFail HandshakeState;
    get_hstate = get_state.map(@handshake_state);

    set_hstate: HandshakeState -> StateT TLSSession IOFail ();
    set_hstate = |hstate| mod_state(set_handshake_state(hstate));

    send_client_hello: String -> StateT TLSSession IOFail ();
    send_client_hello = |server_name| (
        let hstate = *get_hstate;
        let hstate = *hstate.make_client_hello;
        eval *hstate.send_records;
        set_hstate(hstate)
    );

    recv_server_hello: StateT TLSSession IOFail ();
    recv_server_hello = (
        let session = *get_state;
        if !session.@handshake_state.is_client_hello_sent {
            error $ "handshake state is not client_hello_sent"
        };
        let client_hello_state = session.@handshake_state.as_client_hello_sent;
        let server_hello_state = *ServerHelloState::recv(client_hello_state);
        mod_state(set_handshake_state(HandshakeState::server_hello_received $ server_hello_state))
    );
}