module IntTrieTest;

import Minilib.Collection.IntTrie;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;

test_simple: IO ();
test_simple = (
    let node: RNode String = empty();
    //let c: Combine String = |old_value, new_value| new_value;
    //let c: Combine String = add;
    let c: Combine String = |old_value, new_value| add(old_value, new_value);
    let node = node.insert(c, 1_U64, "111");
    let node = node.insert(c, 2_U64, "222");
    let node = node.insert(c, 3_U64, "333");
    let node = node.insert(c, 2_U64, "aaa");
    //println(node.to_string);;
    println(node.find(2_U64).to_string)
);

test_insert_find_perf: IO ();
test_insert_find_perf = (
    let n = 1000000;
    //let n = 100;
    let array = Iterator::range(0, n).to_array;
    let array = array.reorder(shuffle(345));
    let (node, insert_time) = *consumed_time_while_io(do {
        pure();;
        pure $ range(0,n).fold(
            RNode::empty(), |i, node|
            //eval if i % 10000 == 0 { debug_eprintln(i.to_string) } else { () };
            node.insert(overwrite, array.@(i).to_U64, i))
    });
    println("n=" + n.to_string + " insert_time=" + insert_time.to_string_precision(3_U8) + " sec");;
    //println(node.to_string);;
    let (_, find_time) = *consumed_time_while_io(do {
        pure();;
        pure $ range(0,n).fold(
            0, |i, ans|
            let opt = node.find(array.@(i).to_U64);
            //eval if i % 10000 == 0 { debug_eprintln(i.to_string) } else { () };
            //eval debug_eprintln(array.@(i).to_string + " -> " + i.to_string);
            if opt != some(i) { undefined("find fail: " + opt.to_string) };
            ans + opt.as_some
        )
    });
    println("n=" + n.to_string + " find_time=" + find_time.to_string_precision(3_U8) + " sec")
);

main: IO () = (
    test_simple;;
    test_insert_find_perf;;
    pure()
);
