module Main;

import Character;
import Debug;

import SimpleParser;
import StringEx;

type CharClass = unbox struct {
    f: U8 -> Bool
};

namespace CharClass {

    empty: CharClass;
    empty = CharClass { f: |c| false };

    make: (U8 -> Bool) -> CharClass;
    make = |f| CharClass { f: f };

    contains: U8 -> CharClass -> Bool;
    contains = |c, cls| (cls.@f)(c);

    singleton: U8 -> CharClass;
    singleton = |c1| CharClass { f: |c| c == c1 };

    range: U8 -> U8 -> CharClass;
    range = |start, end| CharClass { f: |c| start <= c && c <= end };

    consists_of: String -> CharClass;
    consists_of = |str| CharClass { f: |c| str.find_byte(c).is_some };

    negate: CharClass -> CharClass;
    negate = |cls| (
        let f = cls.@f;
        CharClass { f: |c| !f(c) }
    );

    union: CharClass -> CharClass -> CharClass;
    union = |cls1, cls2| (
        let f = cls1.@f;
        let g = cls2.@f;
        CharClass { f: |c| f(c) || g(c) }
    );

    add: U8 -> CharClass -> CharClass;
    add = |c, cls| cls.union(singleton(c));

    to_table: CharClass -> CharClass;
    to_table = |cls| (
        let table = Iterator::count_up(0).take(256).fold(
            Array::fill(256, false), |arr, i|
            arr.set(i, cls.contains(i.to_U8))
        );
        CharClass::make $ |c| table.@(c.to_I64)
    );

    cls_dot: CharClass;
    cls_dot = CharClass::make $ |c| c != '\n' && c != '\r';

    cls_digit: CharClass;
    cls_digit = CharClass::make $ is_digit;

    cls_non_digit: CharClass;
    cls_non_digit = cls_digit.negate;

    cls_word_char: CharClass;
    cls_word_char = CharClass::make $ |c| is_alnum(c) || c == '_';

    cls_non_word_char: CharClass;
    cls_non_word_char = cls_word_char.negate;

    cls_whitespace: CharClass;
    cls_whitespace = CharClass::make $ is_space;

    cls_non_whitespace: CharClass;
    cls_non_whitespace = cls_whitespace.negate;
}


type Pattern = box union {
    pnormal: U8,
//    pliteral: String,
    pclass: CharClass,
    psequence: Array Pattern,
    peither: (Pattern, Pattern),
    prepeat: (Pattern, /*min_count:*/ I64, /*max_count:*/ I64),
    pgroup: Pattern
};

impl Pattern: ToString {
    to_string = |pat| (
        if pat.is_pnormal { 
            pat.as_pnormal.byte_to_string
        };
 /*       if pat.is_pliteral {
            pat.as_pliteral
        }; */
        if pat.is_pclass {
            "[]"
        };
        if pat.is_psequence {
            pat.as_psequence.to_iter.map(to_string).join("")
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            pat1.to_string + "|" + pat2.to_string
        };
        if pat.is_prepeat {
            let (pat1, min, max) = pat.as_prepeat;
            pat1.to_string + "{" + min.to_string + "," + max.to_string + "}"
        };
        if pat.is_pgroup {
            "(" + pat.as_pgroup.to_string + ")"
        };
        eval assert(|_|"err", false);
        ""
    );
}

namespace Pattern {
    match_char_if_exists: U8 -> Parser (Option U8);
    match_char_if_exists = |c| (
        let n: Option U8 = none();
        let p: Parser (Option U8) = match_any_char.filter(|c1| c1 == c).map(some);
        p.or_else(pure $ n)
    );

    parse_pattern: Parser Pattern;
    parse_pattern = do {
        let pat = *pattern_either;
        let _ = *match_end_of_stream;
        pure $ pat
    };

    pattern_either: Parser Pattern;
    pattern_either = do {
        let pat1 = *pattern_seq;
        let bar = *match_char_if_exists('|');
        if bar.is_some {
            let pat2 = *pattern_either;
            pure $ peither $ (pat1, pat2)
        };
        pure $ pat1
    };

    pattern_seq: Parser Pattern;
    pattern_seq = do {
        pure $ psequence $ *zero_or_more(pattern_repeated)
    };

    pattern_repeated: Parser Pattern;
    pattern_repeated = do {
        let pat = *pattern_repeatable;
        let question = *match_char_if_exists('?');
        if question.is_some {
            pure $ prepeat $ (pat, 0, 1)
        };
        let asterisk = *match_char_if_exists('*');
        if asterisk.is_some {
            // TODO: support non-greedy match
            pure $ prepeat $ (pat, 0, maximum)
        };
        let plus = *match_char_if_exists('+');
        if plus.is_some {
            // TODO: support non-greedy match
            pure $ prepeat $ (pat, 1, maximum)
        };
        // TODO: support {n,m}
        pure $ pat
    };

    pattern_repeatable: Parser Pattern;
    pattern_repeatable = do {
        pattern_group.or_else $
        pattern_class
    };

    pattern_group: Parser Pattern;
    pattern_group = do {
        let lparen = *match_char('(');
        let pat = *pattern_either;
        let rparen = *match_char(')').or_error("')' is missing");
        pure $ pgroup $ pat
    };

    _normal_chars: CharClass;
    _normal_chars = (
        CharClass::consists_of(
            ".?*+^$[](){}\\"
        ).negate.to_table
    );

    pattern_class: Parser Pattern;
    pattern_class = do {
        let c = *match_any_char;
        if _normal_chars.contains(c) {
            pure $ pnormal(c)
        };
        if c == '.' {
            pure $ pclass(cls_dot)
        };
        if c == '[' {
            pure $ pclass(*pattern_bracket)
        };
        if c == '\\' {
            pure $ pclass(*pattern_backslash_cls)
        };
        not_match
    };

    pattern_bracket: Parser CharClass;
    pattern_bracket = do {
        let circumflex = *match_char_if_exists('^');
        let start_hyphen = *match_char_if_exists('-');
        let inners = *repeat(pattern_bracket_inner);
        let end_hyphen = *match_char_if_exists('-');
        let _ = *match_char(']').or_error("']' is missing");

        let cls = inners.to_iter.fold(
            CharClass::empty, union
        );
        let cls = if start_hyphen.is_some || end_hyphen.is_some { cls.add('-') } else { cls };
        let cls = if circumflex.is_some { cls.negate } else { cls };
        pure $ cls.to_table
    };

    pattern_bracket_inner: Parser CharClass;
    pattern_bracket_inner = do {
        let _ = *match_char('\\');
        pattern_backslash_cls.or_else $
        pattern_backslash_char
    }.or_else $ do {
        let start = *match_any_char.filter(|c| c != ']' && c != '\\');
        let _ = *match_char('-');
        let end = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::range(start, end)
    }.or_else $ do {
        let c = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::singleton(c)
    };

    pattern_backslash_cls: Parser CharClass;
    pattern_backslash_cls = do {
        let c = *match_any_char;
        if c == 'd' { pure $ CharClass::cls_digit };
        if c == 'D' { pure $ CharClass::cls_non_digit };
        if c == 'w' { pure $ CharClass::cls_word_char };
        if c == 'W' { pure $ CharClass::cls_non_word_char };
        if c == 's' { pure $ CharClass::cls_whitespace };
        if c == 'S' { pure $ CharClass::cls_non_whitespace };
        not_match
    };

    pattern_backslash_char: Parser CharClass;
    pattern_backslash_char = do {
        let c = *match_any_char;
        if c == 't' { pure $ CharClass::singleton('\t') };
        if c == 'r' { pure $ CharClass::singleton('\r') };
        if c == 'n' { pure $ CharClass::singleton('\n') };
        if c == 'v' { pure $ CharClass::singleton(11_U8) };
        if c == 'f' { pure $ CharClass::singleton(12_U8) };
        if c == 'b' { pure $ CharClass::singleton(8_U8) };
        // TODO: support for \xhh, \uhhhh
        not_match
    };
}

// multi-parser
type MParser a = unbox struct {
    _mparser: Stream -> Iterator (ParseResult a)
};

namespace MParser {
    run_mparser: Stream -> MParser a -> Iterator (ParseResult a);
    run_mparser = |s, mp| (mp.@_mparser)(s);
}

impl MParser: Functor {
    map = |f, p| parser $ |s| (
        let (c, s) = *(*(p.run_mparser(s)));
        pure $ pure $ (f(c), s)
    );
}

impl MParser: Monad {
    pure = |a| MParser { _mparser: |s| ok $ pure $ (a, s) };
    bind = |f, pa| (
        parser $ |s|
        let res = (pa.run_parser(s));
        let (a, s) = *res;
        let pb = f(a);
        pb.run_parser(s)
    );
}


type Group = unbox struct {
    start: I64,
    end: I64
};

type MatchState = unbox struct {
    stream: Stream,
    groups: Array Group    // matched groups
};

namespace MatchState {
    make: Stream -> MatchState;
    make = |stream| (
        MatchState {
            stream: stream,
            groups: Array::empty(1)
        }
    );        
            
    _match_pattern: Pattern -> MatchState -> Iterator MatchState;
    _match_pattern = |pattern, state| (
        if pattern.is_pnormal {
            state._match_pattern_pnormal(pattern.as_pnormal)
        };
        if pattern.is_pclass {
            state._match_pattern_pclass(pattern.as_pclass)
        };
        if pattern.is_psequence {
            state._match_pattern_psequence(pattern.as_psequence.to_iter)
        };
        if pattern.is_peither {
            state._match_pattern_peither(pattern.as_peither)
        };
        if pattern.prepeat {
            state._match_pattern_prepeat(pattern.as_prepeat)
        };
    );

    to_iter_parser: Parser a -> Parser (Iterator a);
    to_iter_parser = |p| (
        p.map(pure).or_else(pure $ Iterator::empty)
    );

    run_iter_parsers: Stream -> Iterator (Parser a) -> Iterator (a, Stream);
    run_iter_parsers = |s, piter| (
        piter.map(|p| p.run_parser(s))
    );

    _match_pattern_pnormal: U8 -> MatchState -> Iterator MatchState;
    _match_pattern_pnormal = |c, state| (
        state.@stream.advance.map_or(
            Iterator::empty,
            |c1, next|
            if c != c1 { Iterator::empty };
            pure $ state
        )    
    );
    
    _match_pattern_pclass: (U8 -> Bool) -> MatchState -> Iterator MatchState;
    _match_pattern_pclass = |f, state| (
        state.@stream.advance.map_or(
            Iterator::empty,
            |c1, next|
            if !f(c1) { Iterator::empty };
            pure $ state
        )    
    );
    
    
    _match_pattern_psequence: Iterator Pattern -> MatchState -> Iterator MatchState;
    _match_pattern_psequence = |patterns, state| (
        let pattern = *patterns;
        state._match_pattern(pattern)
    );

    _match_pattern_prepeat: (Pattern, I64, I64) -> MatchState -> Iterator MatchState;
    _match_pattern_prepeat = |(pattern, min_count, max_count), state| (
        let result: Iterator State = Iterator::empty;
        let current: Iterator State = pure $ state;

        loop(
            (result, current, 0), |(result, current, i)|
            if current.is_empty {
                break $ result
            };
            if max_count < i {
                break $ result
            };
            let result = if min_count <= i && i <= max_count {
                result.append(current)
            } else {
                result
            };
            let current = current.map(|state| state._match_pattern(pat));
            continue $ (result, current, i + 1)
        )
    );
    
}

type RegExp = unbox struct {
    pattern: Pattern,
    flags: String, // TODO: support flags
};

namespace RegExp {
    compile: String -> String -> Result ErrMsg RegExp;
    compile = |pattern, flags| (
        let pattern = *parse_pattern.run_parser_str(pattern).map(|(p,_)| p);
        RegExp { pattern: pattern, flags: flags, groups: Array::empty(1), last_index: 0 }
    );

    exec: String -> RegExp -> Result ErrMsg (Array String);
    exec = |target, regexp| (
        let stream: Stream = *from_string(target);
        
        let regexp = regexp.mod_groups();
        
    );
}

main: IO ();
main = (
    do {
        let p = parse_pattern;
        let res = *p.run_parser_str("([abc]+|def|)hi").from_result;
        let (pat, s) = res;
        let _ = println(s.to_string);
        println(pat.to_string).lift
    }
    .try(eprintln)
);
