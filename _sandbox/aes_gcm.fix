// AES-GCM
// NIST Special Publication 800-38D
// Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC
// https://doi.org/10.6028/NIST.SP.800-38D
module Main;

import Debug;
import Random;

import Minilib.Encoding.Binary;
import Minilib.Crypto.AES;
import Minilib.Math.RandomEx;
import Minilib.Text.Hex;
import Minilib.Thread.Time;

import Sandbox.Cipher;
//import Sandbox.StateT;


// A block is a bit string of 128 bits.
// We use two U64 as a representation.
// When converted to a bit string, it is encoded in big-endian.
// If a byte sequence is encoded to a bit string, MSB of the first byte becomes the leftmost bit.
type Block = unbox struct {
  hi: U64,
  lo: U64
};

impl Block: Eq {
    eq = |a, b| a.@hi == b.@hi && a.@lo == b.@lo;
}

impl Block: ToStringHex {
    to_string_hex = |block| block.@hi.to_string_hex + block.@lo.to_string_hex;
}

impl Block: ToString {
    to_string = to_string_hex;
}

namespace Block {
    // `Block::make(hi, lo)` creates a 128bit block.
    make: U64 -> U64 -> Block;
    make = |hi, lo| (
        Block { hi: hi, lo: lo }
    );

    get_block_be: I64 -> Array U8 -> Block;
    get_block_be = |i, array| (
        let hi = array.get_u64_be(i);
        let lo = array.get_u64_be(i + 8);
        Block { hi: hi, lo: lo }
    );

    set_block_be: I64 -> Block -> Array U8 -> Array U8;
    set_block_be = |i, block, array| (
        array.set_u64_be(i, block.@hi)
             .set_u64_be(i + 8, block.@lo)
    );

    from_bytes: Array U8 -> Block;
    from_bytes = |bytes| (
        eval assert(|_| "from_bytes: invalid size", bytes.get_size == 16);
        bytes.get_block_be(0)
    );

    to_bytes: Block -> Array U8;
    to_bytes = |block| (
        Array::fill(16, 0_U8).set_block_be(0, block)
    );

    // 6.1 Basic operation and functions
    _zero: Block;
    _zero = Block { hi: 0_U64, lo: 0_U64 };

    _bit_xor: Block -> Block -> Block;
    _bit_xor = |x, y| (
        let hi = x.@hi.bit_xor(y.@hi);
        let lo = x.@lo.bit_xor(y.@lo);
        x.set_hi(hi).set_lo(lo)
    );

    _shift_right_1: Block -> Block;
    _shift_right_1 = |x| (
        let hi = x.@hi.shift_right(1_U64);
        let lo = x.@lo.shift_right(1_U64);
        let lo = if x.@hi.bit_and(1_U64) == 0_U64 { lo } else { lo.bit_or(1_U64.shift_left(63_U64)) };
        x.set_hi(hi).set_lo(lo)
    );

    _u64_to_bitstring: U64 -> Array U8;
    _u64_to_bitstring = |u64| (
        Array::fill(8, 0_U8).set_u64_be(0, u64)
    );

    // 6.2 Incrementing function
    _inc_32: Block -> Block;
    _inc_32 = |x| (
        let lo = x.@lo.bit_and(0xffffffff00000000_U64)
                .bit_or((x.@lo.to_U32 + 1_U32).to_U64);
        x.set_lo(lo)
    );

    // 6.3 Multiplication operation of Blocks
    _mul: Block -> Block -> Block;
    _mul = _mul_bitwise;

    _mul_bitwise: Block -> Block -> Block;
    _mul_bitwise = |x, y| (
        let z = _zero;
        let v = y;
        loop(
            (z, v, 0), |(z, v, i)|
            if i > 127 { break $ z };
            let z = if x._is_bit_set(i) { z._bit_xor(v) } else { z };
            let v = if v._is_bit_set(127) { v._shift_right_1._bit_xor(_R) } else { v._shift_right_1 };
            continue $ (z, v, i + 1)
        )
    );

    _is_bit_set: I64 -> Block -> Bool;
    _is_bit_set = |i, x| (
        if i < 64 { x.@hi.bit_and(1_U64.shift_left((63 - i).to_U64)) != 0_U64 };
        if i < 128 { x.@lo.bit_and(1_U64.shift_left((127 - i).to_U64)) != 0_U64 };
        false
    );

    _R: Block;
    _R = Block { hi: 0b11100001_U64.shift_left(56_U64), lo: 0_U64 };

    // 6.4 GHASH function
    _GHASH: Block -> Iterator Block -> Block;
    _GHASH = |h, xs| (
        xs.fold(_zero, |y, x| y._bit_xor(x)._mul(h))
    );

    _bytes_to_blocks: Array U8 -> Iterator Block;
    _bytes_to_blocks = |bytes| (
        eval assert(|_| "invalid byte size", bytes.get_size % 16 == 0);
        let n = bytes.get_size / 16;
        Iterator::range(0, n).map(|i|
            bytes.get_block_be(i * 16)
        )
    );


    // 6.5 GCTR function
    _GCTR: (Block -> Block) -> Block -> Array U8 -> Array U8;
    _GCTR = |cipher, initial_counter_block, x_bytes| (
        if x_bytes.is_empty { x_bytes };
        let n = (x_bytes.get_size + 15) / 16;   // ceil(len(x) / 128)
        let padding = n * 16 - x_bytes.get_size;
        let x_bytes_pad = if padding == 0 { x_bytes }
        else { x_bytes.append(Array::fill(padding, 0_U8)) };
        let y_bytes_pad = Array::fill(x_bytes_pad.get_size, 0_U8);
        let cb = initial_counter_block;
        let y_bytes_pad = loop(
            (y_bytes_pad, cb, 0), |(y_bytes_pad, cb, i)|
            if i >= n { break $ y_bytes_pad };
            let x = x_bytes_pad.get_block_be(i * 16);
            let y = x._bit_xor(cipher(cb));
            let y_bytes_pad = y_bytes_pad.set_block_be(i * 16, y);
            let cb = cb._inc_32;
            continue $ (y_bytes_pad, cb, i + 1)
        );
        let y_bytes = if padding == 0 { y_bytes_pad }
        else { y_bytes_pad.get_sub(0, y_bytes_pad.get_size - padding) };
        y_bytes
    );

    _to_cipher: AES -> (Block -> Block);
    _to_cipher = |aes, x| (
        let plaintext = x.to_bytes;
        let ciphertext = aes.encrypt_block(plaintext);
        // NOTE: aes.decrypt_block will not be used
        ciphertext.from_bytes
    );

    // 7.1 Algorithm for the Authenticated Encryption Function

    // Performs authenticated encryption.
    // Input:
    // - cipher: 128-bit block cipher
    // - iv: initialization vector, typically 96 bits
    // - plaintext: a byte sequence which will be encrypted
    // - auth_data: a byte sequence which will not be encrypted
    // - len_t: tag length in bits
    // Output: (c, t)
    // - c: ciphertext
    // - t: authentication tag
    gcm_ae: (Block -> Block) -> Array U8 -> Array U8 -> Array U8 -> I64 -> (Array U8, Array U8);
    gcm_ae = |cipher, iv, plaintext, auth_data, len_t| (
        // h: the hash subkey
        let h: Block = cipher(_zero);
        // j0: the pre-counter block
        let j0: Block  = _get_j0(h, iv);

        let c: Array U8 = _GCTR(cipher, j0._inc_32, plaintext);
        let t = _get_tag(cipher, h, j0, c, auth_data, len_t);
        (c, t)
    );

    // get the pre-counter block
    _get_j0: Block -> Array U8 -> Block;
    _get_j0 = |h, iv| (
        if iv.get_size == 96 / 8 {
            iv.append([0_U8, 0_U8, 0_U8, 1_U8]).get_block_be(0)
        } else {
            let len_iv = iv.get_size * 8;
            let s = 128 * ((len_iv + 127) / 128) - len_iv;
            let zeros = Array::fill((s + 64) / 8, 0_U8);    // NOTE that `s % 8 == 0`.
            let len_iv_str = _u64_to_bitstring(len_iv.to_U64);
            _GHASH(h, iv.append(zeros).append(len_iv_str)._bytes_to_blocks)
        }
    );

    // get the authentication tag
    _get_tag: (Block -> Block) -> Block -> Block -> Array U8 -> Array U8 -> I64 -> Array U8;
    _get_tag = |cipher, h, j0, c, auth_data, len_t| (
        let len_c = c.get_size * 8;
        let u = 128 * ((len_c + 127) / 128) - len_c;
        let len_a = auth_data.get_size * 8;
        let v = 128 * ((len_a + 127) / 128) - len_a;
        // NOTE that `u % 8 == 0` and `v % 8 == 0`.
        //eval debug_eprintln("len_a + v =" + (len_a + v).to_string);
        //eval debug_eprintln("len_c + u =" + (len_c + u).to_string);
        let s: Block = _GHASH(h,
            auth_data
            .append(Array::fill(v / 8, 0_U8))
            .append(c)
            .append(Array::fill(u / 8, 0_U8))
            .append(_u64_to_bitstring(len_a.to_U64))
            .append(_u64_to_bitstring(len_c.to_U64))
            ._bytes_to_blocks
        );
        let t: Array U8 = _GCTR(cipher, j0, s.to_bytes);
        let t = if len_t < t.get_size * 8 { t.get_sub(0, len_t / 8) } else { t };
        t
    );

    // 7.2 Algorithm for the Authenticated Decryption Function

    // Performs authenticated decryption.
    // Input:
    // - cipher: 128-bit block cipher
    // - iv: initialization vector, typically 96 bits
    // - ciphertext: a byte sequence which will be decrypted
    // - auth_data: a byte sequence which will not be encrypted
    // - tag: authentication tag
    // Output: ok(plaintext) or err(ErrMsg)
    // - ok(plaintext): decrypted byte sequence
    // - err(ErrMsg): inauthenticity
    gcm_ad: (Block -> Block) -> Array U8 -> Array U8 -> Array U8 -> Array U8 -> I64 -> Result ErrMsg (Array U8);
    gcm_ad = |cipher, iv, ciphertext, auth_data, tag, len_t| (
        // 5.2.1.1 Input Data
        if ciphertext.get_size > (1.shift_left(39) - 256) / 8 {
            err $ "ciphertext too long"
        };
        if auth_data.get_size > (U64::maximum / 8_U64).to_I64 {
            err $ "auth_data too long"
        };
        if iv.get_size > (U64::maximum / 8_U64).to_I64 {
            err $ "iv too long"
        };
        if iv.get_size < 1 {
            err $ "iv too short"
        };
        if tag.get_size * 8 != len_t {
            err $ "tag length mismatch"
        };
        // h: the hash subkey
        let h: Block = cipher(_zero);
        // j0: the pre-counter block
        let j0: Block  = _get_j0(h, iv);
        // p: plaintext
        let p: Array U8 = _GCTR(cipher, j0._inc_32, ciphertext);
        let t = _get_tag(cipher, h, j0, ciphertext, auth_data, len_t);
        if tag != t {
            err $ "authentication tag mismatch"
        };
        ok $ p
    );
}

test_mul_bitwise: IO ();
test_mul_bitwise = (
    let zero = 0_U64;
    let one = 1_U64.shift_left(63_U64);
    let two = 1_U64.shift_left(62_U64);
    [
        //(one, zero, one, zero),
        //(two, zero, two, zero),
        //(two, zero, zero, 1_U64),
        (zero, 1_U64, two, zero)
    ]
    .to_iter.fold_m(
        (), |_, (x0, x1, y0, y1)|
        let x = Block::make(x0, x1);
        let y = Block::make(y0, y1);
        let z = _mul_bitwise(x, y);
        println([x, y, z].map(to_string_hex).to_string)
    )
);

// time/loop=1.748 usec
test_mul_bitwise_perf: IO ();
test_mul_bitwise_perf = (
    let x = Block::make(0x012389ab4567cdef_U64, 0x12389ab4567cdef0_U64);
    let y = Block::make(0x89ab32107654fedc_U64, 0x2345abcd6789ef01_U64);
    let z = *timeit("_mul_bitwise", |_| _mul_bitwise(x, y));
    pure()
);

test_ghash: IO ();
test_ghash = (
    let h = Block::make(0x112233_U64, 0x223344_U64);
    let xs = [
        Block::make(0x123123_U64, 0x234234_U64),
        Block::make(0x123124_U64, 0x234235_U64)
    ].to_iter;
    let hash = _GHASH(h, xs);
    println(hash.to_string_hex)
);

byte_array_from_string_hex: String -> Array U8;
byte_array_from_string_hex = |str| (
    str.split(" ").map(from_string_hex >> as_ok).to_array
);

test_gctr: IO ();
test_gctr = (
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(key);
    let x_bytes = "Hello world foo bar baz 123 123".get_bytes.pop_back;
    let cipher = _to_cipher(aes);
    let initial_counter_block = cipher(_zero);
    let y_bytes = _GCTR(cipher, initial_counter_block, x_bytes);
    println(y_bytes.to_string_hex)
);

test_gcm_ae_ad: IO ();
test_gcm_ae_ad = (
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(key);
    let cipher = _to_cipher(aes);
    let len_t = 96;
    let iv = "12 34 56 ab cd ef 65 43 21 fe dc ba";
    let iv = iv.byte_array_from_string_hex;
    let plaintext = "Hello world foo bar baz 123 123".get_bytes.pop_back;
    let auth_data = "127.0.0.1".get_bytes.pop_back;
    let (c, t) = gcm_ae(cipher, iv, plaintext, auth_data, len_t);
    //let (c, t) = *timeit("gcm_ae", |_| gcm_ae(cipher, len_t, iv, plaintext, auth_data));
    let _ = *println("c="+c.to_string_hex+"\nt="+t.to_string_hex);
    let res = gcm_ad(cipher, iv, c, auth_data, t, len_t);
    let res = res.map(push_back(0_U8) >> _unsafe_from_c_str);
    println("res="+res.to_string)
);

test_gcm_ae_ad2: IO ();
test_gcm_ae_ad2 = (
    let plaintext = "hello world foo bar baz\nhello world foo bar baz\nhello world foo bar baz\n".get_bytes.pop_back;
    let key = "1234567812345678123456781234abcd".get_bytes.pop_back;
    let iv = "fedc56781234".get_bytes.pop_back;
    let iv = "abcdefghijklmn".get_bytes.pop_back;
    //let auth_data = "auth".get_bytes.pop_back;
    let auth_data = "".get_bytes.pop_back;
    let len_t = 128;
    let aes = AES::make(key);
    let cipher = _to_cipher(aes);
    let (c, t) = gcm_ae(cipher, iv, plaintext, auth_data, len_t);
    let _ = *println("c="+c.to_string_hex+"\nt="+t.to_string_hex);
    let res = gcm_ad(cipher, iv, c, auth_data, t, len_t);
    let res = res.map(push_back(0_U8) >> _unsafe_from_c_str);
    println("res="+res.to_string)
);

// Carryless Multiplication
// NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB

_clmul_u8_u8_table: Array U16;
_clmul_u8_u8_table = Array::from_map(256 * 256, |pos|
    let a = pos.shift_left(0).bit_and(0xff00).to_U16;
    let b = pos.shift_left(8).bit_and(0xff00).to_U16;
    let c = 0_U16;
    loop(
        (c, a, 0), |(c, a, i)|
        if i >= 8 { break $ c };
        let c = if b.shift_right((15 - i).to_U16).bit_and(1_U16) != 0_U16 {
            c.bit_xor(a)
        } else { c };
        let a = a.shift_right(1_U16);
        continue $ (c, a, i + 1)
    )
);

_clmul_u8_u8: U8 -> U8 -> U16;
_clmul_u8_u8 = |a, b| (
    let pos = a.to_I64.shift_left(8).bit_or(b.to_I64);
    _clmul_u8_u8_table.@(pos)
);

_clmul_u16_u16: U16 -> U16 -> U32;
_clmul_u16_u16 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U8;
    let x0 = x.shift_right(8_U16).to_U8;
    let y1 = y.to_U8;
    let y0 = y.shift_right(8_U16).to_U8;
    let z2 = _clmul_u8_u8(x1, y1);
    let z0 = _clmul_u8_u8(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u8_u8(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U32.bit_xor(z1.to_U32.shift_left(8_U32)).bit_xor(z0.to_U32.shift_left(16_U32));
    z
);

_clmul_u32_u32: U32 -> U32 -> U64;
_clmul_u32_u32 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U16;
    let x0 = x.shift_right(16_U32).to_U16;
    let y1 = y.to_U16;
    let y0 = y.shift_right(16_U32).to_U16;
    let z2 = _clmul_u16_u16(x1, y1);
    let z0 = _clmul_u16_u16(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u16_u16(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U64.bit_xor(z1.to_U64.shift_left(16_U64)).bit_xor(z0.to_U64.shift_left(32_U64));
    z
);

_clmul_u64_u64: U64 -> U64 -> Block -> Block;
_clmul_u64_u64 = |x, y, z| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U32;
    let x0 = x.shift_right(32_U64).to_U32;
    let y1 = y.to_U32;
    let y0 = y.shift_right(32_U64).to_U32;
    let z2 = _clmul_u32_u32(x1, y1);
    let z0 = _clmul_u32_u32(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u32_u32(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z.set_hi(z0.bit_xor(z1.shift_right(32_U64)))
             .set_lo(z2.bit_xor(z1.shift_left(32_U64)));
    z
);

//  time/loop=0.468 usec
_clmul_u128_u128_r: Block -> Block -> Block;
_clmul_u128_u128_r = |x, y| (
    let x1 = x.@lo;
    let x0 = x.@hi;
    let y1 = y.@lo;
    let y0 = y.@hi;
    let z2 = x; // reuse as temporary buffer
    let z1 = Block::_zero;
    let z0 = y; // reuse as temporary buffer
    let z2 = _clmul_u64_u64(x1, y1, z2);
    let z0 = _clmul_u64_u64(x0, y0, z0);
    let z1 = _clmul_u64_u64(x1.bit_xor(x0), y1.bit_xor(y0), z1)
             ._bit_xor(z2)._bit_xor(z0);
    let z2 = z2.mod_hi(bit_xor(z1.@lo));
    let z0 = z0.mod_lo(bit_xor(z1.@hi));
    let t  = z2.@lo;
    // shift_left t by 64 bit and clmul 0xe1
    let z0 = z0.mod_lo(bit_xor(t
                               .bit_xor(t.shift_right(1_U64))
                               .bit_xor(t.shift_right(2_U64))
                               .bit_xor(t.shift_right(7_U64))));
    let z2 = z2.mod_hi(bit_xor(t.shift_left(63_U64)
                               .bit_xor(t.shift_left(62_U64))
                               .bit_xor(t.shift_left(57_U64))));
    let t = z2.@hi;
    let z0 = z0.mod_hi(bit_xor(t
                               .bit_xor(t.shift_right(1_U64))
                               .bit_xor(t.shift_right(2_U64))
                               .bit_xor(t.shift_right(7_U64))));
    let z0 = z0.mod_lo(bit_xor(t.shift_left(63_U64)
                               .bit_xor(t.shift_left(62_U64))
                               .bit_xor(t.shift_left(57_U64))));

    z0
);

test_clmul_u8_u8: IO ();
test_clmul_u8_u8 = (
    let print_row = |a:I64| println $ do {
        let b = *Iterator::range(0, 16);
        let c = _clmul_u8_u8(a.to_U8, b.to_U8);
        pure $ c.to_string_hex
    }.join(" ");
    Iterator::range(0, 16).fold_m(
        (), |_, a|
        print_row(a)
    )
);

test_clmul_u32_u32_1: Random -> IO Random;
test_clmul_u32_u32_1 = |random| (
    let trace_mul = |a, b| (
        let c = _clmul_u32_u32(a, b);
        eval *println(a.to_string_hex + " * " + b.to_string_hex + " = " + c.to_string_hex);
        pure $ c
    );
    let (a1, random) = random.generate_U32;
    let (b1, random) = random.generate_U32;
    let (a2, random) = random.generate_U32;
    let (b2, random) = random.generate_U32;
    let c11 = *trace_mul(a1, b1);
    let c12 = *trace_mul(a1, b2);
    let c21 = *trace_mul(a2, b1);
    let c22 = *trace_mul(a2, b2);
    let expected = c11.bit_xor(c12).bit_xor(c21).bit_xor(c22);
    let actual = *trace_mul(a1.bit_xor(a2), b1.bit_xor(b2));
    eval assert_eq(|_|
        "mismatch: " + [a1, b2, a2, b2].map(to_string_hex).to_string,
        expected, actual);
    pure $ random
);

test_clmul_u32_u32: IO ();
test_clmul_u32_u32 = (
    let random = Random::init_by_seed(123_U64);
    let random = *Iterator::range(0, 16).fold_m(
        random, |random, i|
        test_clmul_u32_u32_1(random)
    );
    pure()
);

test_clmul_u128_u128_r_1: Random -> IO Random;
test_clmul_u128_u128_r_1 = |random| (
    let (a0, random) = random.generate_U64;
    let (b0, random) = random.generate_U64;
    let (a1, random) = random.generate_U64;
    let (b1, random) = random.generate_U64;
    let a = Block::make(a0, a1);
    let b = Block::make(b0, b1);
    let expected = _mul_bitwise(a, b);
    let actual = *timeit("_clmul_u128_u128_r", |_| _clmul_u128_u128_r(a, b));
    let _ = *println("expected=" + expected.to_string_hex);
    let _ = *println("actual  =" + actual.to_string_hex);
    eval assert_eq(|_| "eq",
        expected, actual);
    pure $ random
);

test_clmul_u128_u128_r: IO ();
test_clmul_u128_u128_r = (
    let random = Random::init_by_seed(123_U64);
    let random = *Iterator::range(0, 16).fold_m(
        random, |random, i|
        test_clmul_u128_u128_r_1(random)
    );
    pure()
);

main: IO ();
//main = test_clmul_u32_u32;
main = test_clmul_u128_u128_r;
//main = test_mul_bitwise_perf;
//main = test_gcm_ae_ad2;

// TODO:
// - write tests using NIST test vector
