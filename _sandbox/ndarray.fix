module Main;

import Debug;

_All: (I64, I64);
_All = (0, I64::maximum);

trait a: ToCardinal {
    // `a.to_cardinal` returns the cardinal (eg. index, shape) of one dimension.
    to_cardinal: a -> I64;
}

impl I64: ToCardinal {
    to_cardinal = |a| a;
}

trait a: ToNdCardinal {
    to_nd_cardinal: a -> Array I64;
}

impl Array I64: ToNdCardinal {
    to_nd_cardinal = |arr| arr;
}

impl [a: ToCardinal, b: ToCardinal] (a, b): ToNdCardinal {
    to_nd_cardinal = |(a, b)| [a.to_cardinal, b.to_cardinal];
}

impl [a: ToCardinal, b: ToCardinal, c: ToCardinal] (a, b, c): ToNdCardinal {
    to_nd_cardinal = |(a, b, c)| [a.to_cardinal, b.to_cardinal, c.to_cardinal];
}

impl [a: ToCardinal, b: ToCardinal, c: ToCardinal, d: ToCardinal] (a, b, c, d): ToNdCardinal {
    to_nd_cardinal = |(a, b, c, d)| [a.to_cardinal, b.to_cardinal, c.to_cardinal, d.to_cardinal];
}

trait a: ToRange {
    // `a.to_range` returns the range (begin, end) of one dimension.
    to_range: a -> (I64, I64);
}

impl I64: ToRange {
    to_range = |i| (i, i + 1);
}

impl (I64, I64): ToRange {
    to_range = |range| range;
}

impl Array I64: ToRange {
    to_range = |a| (a.@(0), a.@(1));
}

trait a: ToNdRange {
    to_nd_range: a -> Array (I64, I64);
}

impl [a: ToRange] Array a: ToNdRange {
    to_nd_range = |arr| arr.map(to_range);
}

impl [a: ToRange, b: ToRange] (a, b): ToNdRange {
    to_nd_range = |(a, b)| [a.to_range, b.to_range];
}

impl [a: ToRange, b: ToRange, c: ToRange] (a, b, c): ToNdRange {
    to_nd_range = |(a, b, c)| [a.to_range, b.to_range, c.to_range];
}

impl [a: ToRange, b: ToRange, c: ToRange, d: ToRange] (a, b, c, d): ToNdRange {
    to_nd_range = |(a, b, c)| [a.to_range, b.to_range, c.to_range, d.to_range];
}

type NdArray a = unbox struct {
    data: Array a,
    shape: Array I64,
    stride: Array I64,
    offset: I64
};

impl NdArray a: ToNdRange {
    to_nd_range = |ndarray| ndarray.@shape.map(|end| (0, end));
}

namespace NdArray {
    empty: NdArray a;
    empty = NdArray {
        data: Array::empty(0),
        shape: [],
        stride: [],
        offset: 0
    };

    make: Array I64 -> Array a -> NdArray a;
    make = |shape, array| (
        let ndarray = NdArray::from_array(array);
        ndarray.reshape(shape)
    );

    fill: Array I64 -> a -> NdArray a;
    fill = |shape, value| (
        let offset = 0;
        let (size, stride) = _calc_size_and_stride(shape);
        let data = Array::fill(size, value);
        NdArray {
            data: data,
            shape: shape,
            stride: stride,
            offset: offset
        }
    );

    get_size: NdArray a -> I64;
    get_size = |ndarray| ndarray.@shape.to_iter.fold(1, |size, n| size * n);

    get_dim: NdArray a -> I64;
    get_dim = |ndarray| ndarray.@shape.get_size;

    // Returns shape except first dimension
    get_shape_tail: NdArray a -> Array I64;
    get_shape_tail = |ndarray| (
        let shape = ndarray.@shape;
        shape.get_sub(1, shape.get_size)
    );

    _assert_dim_equals: I64 -> NdArray a -> ();
    _assert_dim_equals = |dim, ndarray| (
        assert (|_| "dimension mismatch: " + dim.to_string + " != " + ndarray.get_dim.to_string,
                     dim == ndarray.get_dim)
    );

    _calc_size_and_stride: Array I64 -> (I64, Array I64);
    _calc_size_and_stride = |shape| (
        let (size, stride) = shape.to_iter.reverse.fold (
            (1, Iterator::empty), |(size, stride), n|
            let stride = stride.push_front(size);
            let size = size * n;
            (size, stride)
        );
        (size, stride.to_array)
    );

    _calc_offset: Array I64 -> NdArray a -> I64;
    _calc_offset = |idx, ndarray| (
        eval ndarray._assert_dim_equals(idx.get_size);
        loop(
            (0, ndarray.@offset), |(d, offset)|
            if d >= ndarray.@stride.get_size {
                break $ offset
            };
            let i = idx.@(d);
            let offset = offset + ndarray.@stride.@(d) * i;
            continue $ (d + 1, offset)  
        )
    );

    get: [i: ToNdCardinal] i -> NdArray a -> a;
    get = |idx, ndarray| (
        let idx = idx.to_nd_cardinal;
        let offset = ndarray._calc_offset(idx);
        ndarray.@data.@(offset)
    );

    set: [i: ToNdCardinal] i -> a -> NdArray a -> NdArray a;
    set = |idx, value, ndarray| (
        let idx = idx.to_nd_cardinal;
        let offset = ndarray._calc_offset(idx);
        ndarray.mod_data(set(offset, value))
    );

    clamp_range: Array (I64, I64) -> NdArray a -> Array (I64, I64);
    clamp_range = |range, ndarray| (
        Iterator::range(0, ndarray.get_dim)
        .map(|d|
            let (begin, end) = range.@(d);
            let begin = max(0, min(ndarray.@shape.@(d), begin));
            let end = max(begin, min(ndarray.@shape.@(d), end));
            (begin, end)
        ).to_array
    );

    get_sub: [r: ToNdRange] r -> NdArray a -> NdArray a;
    get_sub = |range, ndarray| (
        let range: Array (I64, I64) = range.to_nd_range;
        eval ndarray._assert_dim_equals(range.get_size);
        let range = ndarray.clamp_range(range);
        let shape = range.map(|(begin, end)| end - begin);
        let index = range.map(|(begin, end)| begin);
        let offset = ndarray._calc_offset(index);
        ndarray.set_offset(offset).set_shape(shape)
    );

    set_sub: [r: ToNdRange] r -> NdArray a -> NdArray a -> NdArray a;
    set_sub = |range, sub, ndarray| (
        let src = sub;
        let dest = ndarray;
        let range = range.to_nd_range;
        eval src._assert_dim_equals(range.get_size);
        eval dest._assert_dim_equals(range.get_size);
        let range = dest.clamp_range(range);
        let dest_shape: Array I64 = range.map(|(begin, end)| end - begin);
        let dest_offset: I64 = dest._calc_offset(range.map(|(begin, end)| begin));
        _copy_loop(src, dest, src.@shape, dest_shape, src.@offset, dest_offset, 0)
    );

    from_array: Array a -> NdArray a;
    from_array = |arr| (
        NdArray {
            data: arr,
            shape: [arr.get_size],
            stride: [1],
            offset: 0
        }
    );

    _copy_new: NdArray a -> NdArray a;
    _copy_new = |src| (
        let (size, stride) = _calc_size_and_stride(src.@shape);
        let dest = NdArray {
            data: if size == 0 { Array::empty(0) } else {
               Array::fill(size, src.@data.@(src.@offset))
            },
            shape: src.@shape,
            stride: stride,
            offset: 0
        };
        let dest = _copy_loop(src, dest, src.@shape, dest.@shape, src.@offset, dest.@offset, 0);
        dest
    );

    _copy_loop: NdArray a -> NdArray a -> Array I64 -> Array I64 -> I64 -> I64 -> I64 -> NdArray a;
    _copy_loop = |src, dest, src_shape, dest_shape, src_begin, dest_begin, dim| (
        let src_stride = src.@stride.@(dim);
        let dest_stride = dest.@stride.@(dim);
        let src_end = src_begin + src_stride * src_shape.@(dim);
        let dest_end = dest_begin + dest_stride * dest_shape.@(dim);
        let is_last_dim = (dim == dest.get_dim - 1);
        if is_last_dim {
            let src_data = src.@data;
            let dest_data = dest.@data;
            let dest_data = loop(
                (dest_data, src_begin, dest_begin), |(dest_data, src_pos, dest_pos)|
                if dest_pos >= dest_end {
                    break $ dest_data
                };
                // wrap source
                let src_pos = if src_pos < src_end { src_pos }
                else { src_pos - src_end + src_begin };
                // TODO loop-unrolling
                let dest_data = dest_data.set(dest_pos, src_data.@(src_pos));
                continue $ (dest_data, src_pos + src_stride, dest_pos + dest_stride)
            );
            dest.set_data(dest_data)
        } else {
            loop(
                (dest, src_begin, dest_begin), |(dest, src_pos, dest_pos)|
                if dest_pos >= dest_end {
                    break $ dest
                };
                // wrap source
                let src_pos = if src_pos < src_end { src_pos }
                else { src_pos - src_end + src_begin };
                let dest = _copy_loop(src, dest, src_shape, dest_shape, src_pos, dest_pos, dim + 1);
                continue $ (dest, src_pos + src_stride, dest_pos + dest_stride)
            )
        }
    );

    reshape: Array I64 -> NdArray a -> NdArray a;
    reshape = |shape, ndarray| (
        if ndarray.@offset != 0 {
            ndarray._copy_new.reshape(shape)
        };
        eval assert(|_|"shape is empty", shape.get_size > 0);
        // check that shape.@(i) >= 0 except for i == 0
        eval shape.set(0, 0).to_iter.fold (
            (), |_, n|
            assert(|_|"invalid shape: " + n.to_string, n >= 0)
        );
        // if first element of shape is negative, calculate it automatically
        let shape = if shape.@(0) >= 0 { shape } else {
            let (size1, _) = _calc_size_and_stride(shape.get_sub(1, shape.get_size));
            let n = ndarray.get_size / size1;
            shape.set(0, n)
        };
        let (size, stride) = _calc_size_and_stride(shape);
        let old_size = ndarray.@data.get_size;
        eval assert(|_| "reshape failed: size overflow: " + 
                    old_size.to_string + " < " + size.to_string,
                    old_size >= size);
        let offset = 0;
        NdArray {
            data: ndarray.@data,
            shape: shape,
            stride: stride,
            offset: offset
        }
    );

    transpose: NdArray a -> NdArray a;
    transpose = |ndarray| (
        eval assert (|_| "transpose: dimension mismatch", ndarray.get_dim >= 2);
        ndarray.transpose_generic(0, 1)
    );

    transpose_generic: I64 -> I64 -> NdArray a -> NdArray a;
    transpose_generic = |i, j, ndarray| (
        eval assert (|_| "transpose_generic: dimension out of range",
            0 <= i && i < ndarray.get_dim &&
            0 <= j && j < ndarray.get_dim);
        let swap = |a| let tmp = a.@(i) in a.set(i, a.@(j)).set(j, tmp);
        ndarray.mod_shape(swap).mod_stride(swap)
    );

    from_array_of_ndarray: Array (NdArray a) -> NdArray a;
    from_array_of_ndarray = |children| (
        let child_count = children.get_size;
        if (child_count == 0) { NdArray::empty };
        let first_child = children.@(0);
        let child_shape = first_child.@shape;
        eval Iterator::range(1, child_count).fold(
            (), |_, i|
            let child = children.@(i);
            assert (|_| "from_array_of_ndarray: shapes of children must be same", child_shape == child.@shape)
        );
        let parent_shape = child_shape.to_iter.push_front(child_count).to_array;
        let (parent_size, parent_stride) = _calc_size_and_stride(parent_shape);
        if parent_size == 0 {
            NdArray {
                data: Array::empty(0),
                shape: parent_shape,
                stride: parent_stride,
                offset: 0
            }
        };
        // child size > 0 because parent_size > 0
        let initial_value = first_child.@data.@(0);
        let parent = NdArray::fill(parent_shape, initial_value);
        let parent = Iterator::range(0, child_count).fold(
            parent, |parent, i|
            let child = children.@(i);
            let child = child.reshape(child.@shape.to_iter.push_front(1).to_array);
            let parent_range = child.to_nd_range.set(0, i.to_range);
            parent.set_sub(parent_range, child)
        );
        parent
    );

    _next_index: Array I64 -> Array I64 -> Array I64;
    _next_index = |shape, idx| (
        let ndim = shape.get_size;
        loop(
            (idx, ndim - 1), |(idx, dim)|
            if dim < 0 {
                idx
            };
            let idx = idx.mod(dim, |i| i + 1);
            if idx.@(dim) < shape.@(dim) {
                idx
            };
            let idx = idx.set(dim, 0);
            (idx, dim - 1)
        )
    );

    _to_string: [a: ToString] NdArray a -> String;
    _to_string = |ndarray| (
        let output: Array String = Array::empty(ndarray.get_size * 3);
        let idx: Array I64 = Array::fill(ndarray.get_dim, 0);
        let (output, idx) = ndarray._to_string_loop((output, idx), 0);
        output.to_iter.concat_iter
    );

    _to_string_loop: [a: ToString] (Array String, Array I64) -> I64 -> NdArray a -> (Array String, Array I64);
    _to_string_loop = |(output, idx), dim, ndarray| (
        let count = ndarray.@shape.@(dim);
        let is_last_dim =  (dim == ndarray.@shape.get_size - 1);
        let output = output.push_back("[");
        let (output, idx) = loop(
            (output, idx, 0), |(output, idx, i)|
            if i >= count {
                break $ (output, idx)
            };
            let idx = idx.set(dim, i);
            let (output, idx) = if is_last_dim {
                let v = ndarray.get(idx);
                let output = if idx.@(dim) == 0 { output } else { output.push_back(",") };
                let output = output.push_back(v.to_string);
                (output, idx)
            } else {
                ndarray._to_string_loop((output, idx), dim + 1)
            };
            continue $ (output, idx, i + 1)
        );
        let output = output.push_back("]");
        (output, idx)
    );
}

impl [a: ToString] NdArray a: ToString {
    to_string = NdArray::_to_string;
}

trait [f: * -> *] f: ToNdArray {
    to_nd_array: f a -> NdArray a;
}



main: IO ();
main = (
    do {
        let base = NdArray::make([3,3], [1,2,3,4,5,6,7,8,9]);
        let _ = *println(base.to_string).lift;
        let _ = *println(base.transpose.to_string).lift;
        let a = base.reshape([-1,4]);
        let _ = *println(a.to_string).lift;
        let a = a.reshape([-1]);
        let _ = *println(a.to_string).lift;
        let a = base.get_sub((1, _All));
        let _ = *println(a.to_string).lift;
        let base2 = base.set_sub((_All, _All), a);  // base2 = base; base2[:,:] = base[1,:]
        let _ = *println(base2.to_string).lift;
        let v = base2.get((0, 1));
        let _ = *println(v.to_string).lift;
        let a = base2.set((0, 1), 100);
        let _ = *println(a.to_string).lift;
        let parent = from_array_of_ndarray(Array::fill(4, base));
        let _ = *println(parent.to_string).lift;

        pure()
    }.try(eprintln)
);
