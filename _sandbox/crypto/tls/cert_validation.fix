module Minilib.Crypto.Tls.CertValidation;

import Debug;
import HashMap;

import Minilib.Crypto.Cert.CACertificates;
import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.X509Path;
import Minilib.Crypto.Cert.X509Signature;
import Minilib.Crypto.Cert.X509Time;
import Minilib.Crypto.Cert.X509DnsName;
import Minilib.Crypto.Tls.Extensions;
import Minilib.Crypto.Cipher.CipherApi;
import Minilib.Crypto.Cipher.Rsa.RsaApi;
import Minilib.Crypto.Cipher.Ec.EcApi;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

decode_certificates: [m: MonadError] Array (Array U8) -> m (Array Certificate);
decode_certificates = |cert_data_array| (
    cert_data_array.map_m(|cert_data| from_bytes(cert_data)).from_result_t
);

validate_certificate_signatures: [m: MonadError] CipherApi -> Array Certificate -> CACertificates -> Option X509Time -> m ();
validate_certificate_signatures = |cipher_api, certs, ca_certs, time| (
    let cert_path: CertificatePath = *CertificatePath::make(certs, ca_certs);
    eval debug_eprintln("cert_path=" + cert_path.@data.to_iter.map(|c| "\n  " + c.to_string).concat_iter);
    eval *cert_path.validate_date(time);
    cert_path.validate_certificate_signatures(cipher_api)
);

check_certificate_verify: [m: MonadError] CipherApi -> Certificate -> Array U8 -> SignatureScheme -> Array U8 -> m ();
check_certificate_verify = |cipher_api, certificate, message, algorithm, signature| (
    let public_key = certificate.get_subject_public_key;
    let hash_name = algorithm._find_rsa_hash_name;
    if hash_name.is_some {
        verify_signature_rsassa_pss(cipher_api, hash_name.as_some, public_key, message, signature).from_result_t
    };
    let hash_name = algorithm._find_ec_hash_name;
    if hash_name.is_some {
        verify_signature_ecdsa(cipher_api, hash_name.as_some, public_key, message, signature).from_result_t
    };
    error $ "check_certificate_verify: unsupported algorithm: " + algorithm.to_string_hex
);

_find_rsa_hash_name: SignatureScheme -> Option RsaHashName;
_find_rsa_hash_name = |algorithm| (
    if algorithm == SignatureScheme::rsa_pss_rsae_sha256 {
        some $ "sha256"
    };
    if algorithm == SignatureScheme::rsa_pss_rsae_sha384 {
        some $ "sha384"
    };
    if algorithm == SignatureScheme::rsa_pss_rsae_sha512 {
        some $ "sha512"
    };
    none()
);

_find_ec_hash_name: SignatureScheme -> Option EcHashName;
_find_ec_hash_name = |algorithm| (
    if algorithm == SignatureScheme::ecdsa_secp256r1_sha256 {
        some $ "sha256"
    };
    if algorithm == SignatureScheme::ecdsa_secp384r1_sha384 {
        some $ "sha384"
    };
    none()
);

check_certificate_identity: [m: MonadError] Certificate -> String -> m ();
check_certificate_identity = |cert, target_server_name| (
    eval debug_eprintln("check_certificate_identity: target_server_name=" + target_server_name);

    // RFC2818 3.1.  Server Identity
    let subjectAltName: Option SubjectAltName = do {
        let extn = *cert.find_extension(match_name("id-ce-subjectAltName"));
        let bytes = extn.@extn_value.to_bytes;
        let res = decode_der_from_bytes(bytes);
        if res.is_err { none () };
        some $ res.as_ok
    };
    eval debug_eprintln("subjectAltName=" + subjectAltName.to_string);

    let dns_names: Array String = (
        if subjectAltName.is_none { [] };
        subjectAltName.as_some.@data
            .to_iter
            .filter(is_dNSName)
            .map(as_dNSName)
            .map(to_string) // IA5String -> String
            .to_array
    );

    eval debug_eprintln("dns_names=" + dns_names.to_string);
    let dns_names = *(
        if dns_names.get_size > 0 {
            pure $ dns_names
        };

        let common_name: Option String = cert.get_subject.find_common_name;
        if common_name.is_some {
            eval debug_eprintln("Using the common name as a DNS name: common_name=" + common_name.to_string);
            pure $ [ common_name.as_some ]
        };
        error $ "Neither the DNS name nor the common name are not found"
    );

    let accepted_dns_names = (
        dns_names.to_iter
        .filter(|dns_name| match_dns_name(dns_name, target_server_name))
        .to_array
    );

    if accepted_dns_names.get_size == 0 {
        error $ "DNS names did not match"
    };
    pure()
);

