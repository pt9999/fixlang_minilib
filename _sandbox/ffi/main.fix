module Main;

import Debug;

boxed: a -> Boxed a;
boxed = |value| Boxed { value: value };

boxedvalue_register_func: (() -> a) -> IO Ptr;
boxedvalue_register_func = |f| (
    //let boxed_f = Boxed{ value: |_: ()| Boxed{ value: f() } };
    let boxed_f = boxed $ |_: ()| boxed(f());
    let _ = *pure();
    let ptr = *boxedvalue_register(boxed_f);
    let _ = boxed_f;
    pure $ ptr
);

boxedvalue_register: Boxed a -> IO Ptr;
boxedvalue_register = |boxed| (
    let _ = *pure();
    let p_value = unsafe_get_retained_ptr_of_boxed_value(boxed);
    let p_retain = unsafe_get_retain_function_of_boxed_value(boxed);
    let p_release = unsafe_get_release_function_of_boxed_value(boxed);
    let ptr = CALL_C[
        Ptr boxedvalue_register(Ptr, Ptr, Ptr),
        p_value, p_retain, p_release
    ];
    let _ = p_value;
    let _ = p_retain;
    let _ = p_release;
    pure $ ptr
);

boxedvalue_unregister: Ptr -> IO ();
boxedvalue_unregister = |ptr| (
    let _ = *pure();
    let _ = CALL_C[
        () boxedvalue_unregister(Ptr),
        ptr
    ];
    pure $ ()
);

type Vec = box struct {
    x: CInt,
    y: CInt,
    z: CInt
};

main: IO ();
main = (
    let _ = *pure();
    let callback = |_| (
        eval debug_eprintln("callback is called");
        42.to_CInt
        //Boxed { value: 42.to_CInt }
        //nullptr
    );
    let ptr = *boxedvalue_register_func(callback);
    eval CALL_C[() set_callback(Ptr), ptr];

    let vec = Vec { x: 1000.to_CInt, y: 2000.to_CInt, z: 3000.to_CInt };
    eval vec.unsafe_borrow_boxed_data_ptr(|p| CALL_C[() access_vec(Ptr), p]);

    eval debug_eprintln("calling c_function_1");
    let ret = CALL_C[CInt c_function_1(CInt), 100_I32];
    eval debug_eprintln("called c_function_1: ret=" + ret.to_string);

    eval debug_eprintln("vec.@z=" + vec.@z.to_string);
    pure()
);
