module Main;

import Debug;

type MyBuffer = unbox struct {
    array: Array U8,
    position: I64,
    end: I64,
};

type Decoder a = unbox struct {
    func: MyBuffer -> Result ErrMsg (MyBuffer, a)
};

// Runs the decoder repeatedly until it reaches the end-of-stream.
repeat: Decoder a -> MyBuffer -> Result ErrMsg (MyBuffer, Array a);
repeat = |decoder, buf| (
    _repeat_inner(decoder, buf, [])
);

_repeat_inner: Decoder a -> MyBuffer -> Array a -> Result ErrMsg (MyBuffer, Array a);
_repeat_inner = |decoder, buf, arr| (
    if buf.@position >= buf.@end { ok $ (buf, arr) };
    let res = (decoder.@func)(buf);
    if res.is_err { err $ res.as_err };
    let (buf, a) = res.as_ok;
    let arr = arr.push_back(a);
    eval if arr.get_size % 100 == 0 { debug_eprintln("_repeat_inner: " + arr.get_size.to_string) } else { () };
    _repeat_inner(decoder, buf, arr)
);

decode_u16: Decoder U16;
decode_u16 = Decoder {
    func: |buf| (
        let MyBuffer {
            array: array,
            position: position,
            end: end
        } = buf;
        if position + 1 >= end { err $ "EndOfStream" };
        let hi = array.@(position);
        let lo = array.@(position + 1);
        let u16 = hi.to_U16.shift_left(8_U16).bit_or(lo.to_U16);
        let buf = buf.set_position(position + 2);
        ok $ (buf, u16)
    )
};

main: IO ();
main = (
    let n = 10 * 1024 * 1024;
    let u8_arr = Array::from_map(n, |i| i.to_U8);
    let buf = MyBuffer {
        array: u8_arr,
        position: 0,
        end: u8_arr.get_size
    };
    let res = repeat(decode_u16, buf);
    if res.is_err { println ("err: " + res.as_err) };
    let (buf, u16_arr) = res.as_ok;
    println("u16_arr.get_size=" + u16_arr.get_size.to_string)
);
