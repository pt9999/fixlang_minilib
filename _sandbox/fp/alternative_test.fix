module Main;

import Minilib.Monad.Alternative;
import Minilib.Monad.State;
import Minilib.Monad.Option;
import Minilib.Monad.Result;
import Minilib.Monad.Trans;
import Minilib.Testing.UnitTest;
import Minilib.Trait.Traversable;

test_option: TestCase;
test_option = (
    make_test("test_option") $ |_|
    assert_equal("fail", none(): Option I64, fail);;
    assert_equal("none-none", none(): Option I64, none().or_else(none()));;
    assert_equal("some-none", some(1), some(1).or_else(none()));;
    assert_equal("none-some", some(2), none().or_else(some(2)));;
    assert_equal("some-some", some(1), some(1).or_else(some(2)));;
    do {
        let x = *[none(), some(1)];
        let y = *[none(), some(2)];
        let z = *[none(), some(3)];
        pure $ assert_equal("assoc:" + (x,y,z).to_string, x.or_else(y).or_else(z), x.or_else(y.or_else(z)))
    }
    .sequence.forget
);

test_result: TestCase;
test_result = (
    make_test("test_result") $ |_|
    assert_equal("fail", err(""): Result ErrMsg I64, fail);;
    assert_equal("err-err", err("e2"): Result ErrMsg I64, err("e1").or_else(err("e2")));;
    assert_equal("ok-err", ok(1): Result ErrMsg I64, ok(1).or_else(err("e2")));;
    assert_equal("err-ok", ok(2): Result ErrMsg I64, err("e1").or_else(ok(2)));;
    assert_equal("ok-ok", ok(1): Result ErrMsg I64, ok(1).or_else(ok(2)));;
    do {
        let x = *[err("e1"), ok(1)];
        let y = *[err("e2"), ok(2)];
        let z = *[err("e3"), ok(3)];
        pure $ assert_equal("assoc:" + (x,y,z).to_string, x.or_else(y).or_else(z), x.or_else(y.or_else(z)))
    }
    .sequence.forget
);

// TODO: add OptionT, ResultT test

test_iofail: TestCase;
test_iofail = (
    make_test("test_iofail") $ |_|
    let to_res = |iof: IOFail I64| iof.to_result.lift;
    assert_equal("fail", err(""): Result ErrMsg I64, *fail.to_res);;
    assert_equal("throw-throw", err("e2"): Result ErrMsg I64, *throw("e1").or_else(throw("e2")).to_res);;
    assert_equal("pure-throw", ok(1): Result ErrMsg I64, *pure(1).or_else(throw("e2")).to_res);;
    assert_equal("throw-pure", ok(2): Result ErrMsg I64, *throw("e1").or_else(pure(2)).to_res);;
    assert_equal("pure-pure", ok(1): Result ErrMsg I64, *pure(1).or_else(pure(2)).to_res);;
    do {
        let x = *[throw("e1"), pure(1)];
        let y = *[throw("e2"), pure(2)];
        let z = *[throw("e3"), pure(3)];
        pure $ do { assert_equal("assoc:" + (*x.to_res,*y.to_res,*z.to_res).to_string, *x.or_else(y).or_else(z).to_res, *x.or_else(y.or_else(z)).to_res) }
    }
    .sequence.forget
);

test_array: TestCase;
test_array = (
    make_test("test_array") $ |_|
    assert_equal("fail", []: Array I64, fail);;
    let a = [1,2];
    let b = [3,4];
    assert_equal("arr-arr", [1,2,3,4], a.or_else(b))
);

type Parser a = StateT (String, I64) Option a;

parse: String -> Parser a -> Option a = |input, st| (
    let ((input, pos), a) = *st.run_state_t((input, 0));
    pure $ a
);

match_any_char: Parser String = do {
    let (input, pos) = *get_state;
    if pos >= input.get_size { fail };
    put_state((input, pos+1));;
    pure $ input.get_sub(pos, pos+1)
};

match_alpha: Parser String = do {
    match_any_char.filter(|c| "a" <= c && c <= "z")
};

match_digit: Parser String = do {
    match_any_char.filter(|c| "0" <= c && c <= "9")
};

match_alpha_or_digit: Parser String = match_alpha.or_else(match_digit);

test_state: TestCase;
test_state = (
    make_test("test_state") $ |_|
    assert_equal("fail", none(), (fail: Parser String).parse("abc"));;
    assert_equal("match_alpha", some("a"), match_alpha.parse("abc"));;
    assert_equal("match_alpha", none(), match_alpha.parse("012"));;
    assert_equal("match_digit", none(), match_digit.parse("abc"));;
    assert_equal("match_digit", some("0"), match_digit.parse("012"));;
    assert_equal("match_alpha_or_digit", some("a"), match_alpha_or_digit.parse("abc"));;
    assert_equal("match_alpha_or_digit", some("0"), match_alpha_or_digit.parse("012"));;
    assert_equal("zero_or_more(match_alpha_or_digit)", some(["a", "0", "b", "1"]), zero_or_more(match_alpha_or_digit).parse("a0b1!#c2"));;
    assert_equal("zero_or_more(match_alpha_or_digit)", some([]), zero_or_more(match_alpha_or_digit).parse("!#$"));;
    assert_equal("one_or_more(match_alpha_or_digit)", some(["a", "0", "b", "1"]), one_or_more(match_alpha_or_digit).parse("a0b1!#c2"));;
    assert_equal("one_or_more(match_alpha_or_digit)", none(), one_or_more(match_alpha_or_digit).parse("!#$"));;
    pure()
);

test_guard: TestCase;
test_guard = (
    make_test("test_guard") $ |_|
    let arr = do {
        let a = *[3, 4, 5];
        let b = *[1, 2, 3];
        guard(a % b == 0);;
        pure $ a * 100 + b
    };
    assert_equal("eq", [301, 303, 401, 402, 501], arr)
);

test_filter: TestCase;
test_filter = (
    make_test("test_filter") $ |_|
    let arr = do {
        let a = *[3, 4, 5].filter(|x| x % 2 != 0);
        let b = *[1, 2, 3].filter(|x| x % 2 != 0);
        pure $ a * 100 + b
    };
    assert_equal("eq", [301, 303, 501, 503], arr)
);

test_if_exists: TestCase;
test_if_exists = (
    make_test("test_if_exists") $ |_|
    let p: Parser String = do {
        let a = *match_alpha.if_exists;
        let b = *match_digit.if_exists;
        // TODO: implement combine: [m: MonadAlt] (a -> a -> a) -> m a -> m a -> m a
        // or implement concat: [t: Traversable, m: MonadAlt] (a -> a -> a) -> t (m a) -> m a
        pure $ a.as_some_or("") + b.as_some_or("")
    };
    assert_equal("abc", some("a"), p.parse("abc"));;
    assert_equal("012", some("0"), p.parse("012"));;
    assert_equal("a0b1c2", some("a0"), p.parse("a0b1c2"));;
    assert_equal("!#$", some(""), p.parse("!#$"));;
    pure()
);

// StateT s Option a == s -> Option (s, a)
// where the state is not changed when it failed
count_down_so: StateT I64 Option I64;
count_down_so = do {
    let i = *get_state;
    if i <= 0 { fail };
    put_state(i - 1);;
    pure $ i
};

// OptionT (State s) a == s -> (s, Option a)
// where the state may be changed even if it failed
count_down_os: OptionT (State I64) I64;
count_down_os = do {
    let i = *get_state.lift_t;
    if i <= 0 { fail };
    put_state(i - 1).lift_t;;
    pure $ i
};

run_so: s -> StateT s Option a -> Option (s, a);
run_so = |s, so| so.run_state_t(s);

run_os: s -> OptionT (State s) a -> (s, Option a);
run_os = |s, os| os.run_option_t.run_state(s);

test_zero_or_more_so: TestCase;
test_zero_or_more_so = (
    make_test("test_zero_or_more_so") $ |_|
    assert_equal("3", some $ (0, [3,2,1]), zero_or_more(count_down_so).run_so(3));;
    assert_equal("1", some $ (0, [1]), zero_or_more(count_down_so).run_so(1));;
    assert_equal("0", some $ (0, []), zero_or_more(count_down_so).run_so(0));;
    pure()
);

test_zero_or_more_os: TestCase;
test_zero_or_more_os = (
    make_test("test_zero_or_more_os") $ |_|
    assert_equal("3", (0, some $ [3,2,1]), zero_or_more(count_down_os).run_os(3));;
    assert_equal("1", (0, some $ [1]), zero_or_more(count_down_os).run_os(1));;
    assert_equal("0", (0, some $ []), zero_or_more(count_down_os).run_os(0));;
    pure()
);

test_one_or_more_so: TestCase;
test_one_or_more_so = (
    make_test("test_one_or_more_so") $ |_|
    assert_equal("3", some $ (0, [3,2,1]), one_or_more(count_down_so).run_so(3));;
    assert_equal("1", some $ (0, [1]), one_or_more(count_down_so).run_so(1));;
    assert_equal("0", none(), one_or_more(count_down_so).run_so(0));;
    pure()
);

test_one_or_more_os: TestCase;
test_one_or_more_os = (
    make_test("test_one_or_more_os") $ |_|
    assert_equal("3", (0, some $ [3,2,1]), one_or_more(count_down_os).run_os(3));;
    assert_equal("1", (0, some $ [1]), one_or_more(count_down_os).run_os(1));;
    assert_equal("0", (0, none()), one_or_more(count_down_os).run_os(0));;
    pure()
);

test_try_first_opt: TestCase;
test_try_first_opt = (
    make_test("test_try_first_opt") $ |_|
    let opt_array = range_step(10, 0, -1).map(|i| some(i)).to_array;
    assert_equal("2mod5", some $ 7, try_first(opt_array.map(filter(|x| x % 5 == 2))));;
    assert_equal("3", some $ 3, try_first(opt_array.map(filter(|x| x == 3))));;
    assert_equal("11", none(), try_first(opt_array.map(filter(|x| x == 11))));;
    pure()
);

test_try_first_so: TestCase;
test_try_first_so = (
    make_test("test_try_first_so") $ |_|
    // `count_down_so` will not change the state when it fails,
    // so we have to choice another strategy
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i % 5 == 2).map(|x| (x, i)));
    assert_equal("2mod5", some $ (9, (10, 2)), try_first(so_array).run_so(10));;
    assert_equal("2mod5, starting from 2", some $ (1, (2, 2)), try_first(so_array).run_so(2));;
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i == 3).map(|x| (x, i)));
    assert_equal("3", some $ (9, (10, 3)), try_first(so_array).run_so(10));;
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i == 31).map(|x| (x, i)));
    assert_equal("31", none(), try_first(so_array).run_so(10));;
    pure()
);

test_try_first_os: TestCase;
test_try_first_os = (
    make_test("test_try_first_os") $ |_|
    let os_array = Array::fill(20, count_down_os);
    assert_equal("2mod5", (6, some $ 7), try_first(os_array.map(filter(|x| x % 5 == 2))).run_os(10));;
    assert_equal("3", (2, some $ 3), try_first(os_array.map(filter(|x| x == 3))).run_os(10));;
    assert_equal("11", (0, none()), try_first(os_array.map(filter(|x| x == 11))).run_os(10));;
    pure()
);

test_try_all_opt: TestCase;
test_try_all_opt = (
    make_test("test_try_all_opt") $ |_|
    let opt_array = range_step(10, 0, -1).map(|i| some(i)).to_array;
    assert_equal("2mod5", some $ [7, 2], try_all(opt_array.map(filter(|x| x % 5 == 2))));;
    assert_equal("3", some $ [3], try_all(opt_array.map(filter(|x| x == 3))));;
    assert_equal("11", some $ [], try_all(opt_array.map(filter(|x| x == 11))));;
    pure()
);

test_try_all_so: TestCase;
test_try_all_so = (
    make_test("test_try_all_so") $ |_|
    // `count_down_so` will not change the state when it fails,
    // so we have to choice another strategy
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i % 5 == 2).map(|x| (x, i)));
    assert_equal("2mod5", some $ (6, [(10, 2), (9, 7), (8, 12), (7, 17)]), try_all(so_array).run_so(10));;
    assert_equal("2mod5, starting from 2", some $ (0, [(2, 2), (1, 7)]), try_all(so_array).run_so(2));;
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i == 3).map(|x| (x, i)));
    assert_equal("3", some $ (9, [(10, 3)]), try_all(so_array).run_so(10));;
    let so_array = Array::from_map(20, |i| count_down_so.filter(|x| i == 31).map(|x| (x, i)));
    assert_equal("31", some $ (10, []), try_all(so_array).run_so(10));;
    pure()
);

test_try_all_os: TestCase;
test_try_all_os = (
    make_test("test_try_all_os") $ |_|
    let os_array = Array::fill(20, count_down_os);
    assert_equal("2mod5", (0, some $ [7,2]), try_all(os_array.map(filter(|x| x % 5 == 2))).run_os(10));;
    assert_equal("3", (0, some $ [3]), try_all(os_array.map(filter(|x| x == 3))).run_os(10));;
    assert_equal("11", (0, some $ []), try_all(os_array.map(filter(|x| x == 11))).run_os(10));;
    pure()
);

main: IO ();
main = (
    [
        test_option,
        test_result,
        test_iofail,
        test_array,
        test_state,
        test_guard,
        test_filter,
        test_if_exists,
        test_zero_or_more_so,
        test_zero_or_more_os,
        test_one_or_more_so,
        test_one_or_more_os,
        test_try_first_opt,
        test_try_first_so,
        test_try_first_os,
        test_try_all_opt,
        test_try_all_so,
        test_try_all_os,
    ]
    .run_test_driver
);

