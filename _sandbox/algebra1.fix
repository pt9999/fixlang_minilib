module Main;

import Debug;

import Minilib.Math.Types;
import Minilib.Text.StringEx;

trait a: Finite {
    finite: ();     // dummy
}

trait FiniteGroup = Finite + Group;

//-------------------------------------------------------------
// Modular Arithmetic
// https://en.wikipedia.org/wiki/Modular_arithmetic

type Modular a = unbox struct {
    value: a,
    modulus: a          // zero if unknown
};

namespace Modular {
    make: [a: Euclid] a -> a -> Modular a;
    make = |value, modulus| (
        let value = if modulus == zero { value } else { value % modulus };
        Modular { value: value, modulus: modulus }
    );

    modulo: [a: Euclid] a -> a -> Modular a;
    modulo = make;

    _get_modulus: [a: Euclid] Modular a -> Modular a -> a;
    _get_modulus = |x, y| (
        eval if x.@modulus != y.@modulus &&
                x.@modulus != zero && 
                y.@modulus != zero {
            debug_eprintln("warning: modulus mismatch")
        } else { () };
        if x.@modulus != zero { 
            x.@modulus
        };
        y.@modulus
    );

    is_zero: [a: Euclid] Modular a -> Bool;
    is_zero = |x| x.@value == zero;

    // Extended Euclidean algorithm
    // Solve a * x + b * y = d, where d = gcd(a, b)
    // Returns (x, y, d)
    _extended_euclid: [a: Euclid] a -> a -> (a, a, a);
    _extended_euclid = |a, b| (
        if b == zero {
            (one, zero, a)
        };
        let q = a / b;
        let r = a % b;
        eval assert(|_| "division-with-remainder failed", a == q * b + r);
        let (y, z, d) = _extended_euclid(b, r);
        // b * y + r * z = d
        // b * y + (a - q * b) * z = d
        // a * z + b * (y - q * z) = d
        let x = z;
        let y = y - q * z;
        eval assert(|_| "extended euclid failed"
            // + " ((a,x),(b,y),(ans, d))=" + ((a, x), (b, y), (a * x + b * y, d)).to_string
        , a * x + b * y == d);
        (x, y, d)
    );
}

impl [a: ToString] Modular a: ToString {
    to_string = |x| x.@value.to_string;         // does not show modulus
}

impl [a: Euclid] Modular a: Eq {
    eq = |x, y| (
        if x.is_zero { y.is_zero };
        if y.is_zero { false };
        let modulus = _get_modulus(x, y);
        if modulus == zero { x.@value == y.@value };
        (x.@value - y.@value) % modulus == zero
    );
}

impl [a: Euclid] Modular a: Zero {
    zero = Modular::make(zero, zero);       // modulus is unknown
}

impl [a: Euclid] Modular a: One {
    one = Modular::make(one, zero);       // modulus is unknown
}

impl [a: Euclid] Modular a: Neg {
    neg = |x| (
        Modular::make(-x.@value, x.@modulus)
    );
}

impl [a: Euclid] Modular a: Add {
    add = |x, y| (
        if x.is_zero { y };
        if y.is_zero { x };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value + y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Sub {
    sub = |x, y| (
        if x.is_zero { -y };
        if y.is_zero { x };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value - y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Mul {
    mul = |x, y| (
        if x.is_zero { zero };
        if y.is_zero { zero };

        let modulus = _get_modulus(x, y);
        Modular::make(x.@value * y.@value, modulus)
    );
}

impl [a: Euclid] Modular a: Div {
    div = |x, y| (
        eval assert(|_| "Divide by zero", !y.is_zero);
        if x.is_zero { zero };

        let modulus = _get_modulus(x, y);
        if modulus == zero { 
            // TODO correct?
            Modular::make(x.@value / y.@value, modulus)
        };
        let (u, v, d) = _extended_euclid(y.@value, modulus);
        // y.@value * u + modulus * v = d
        eval assert(|_| "cannot inverse", u % d == zero);
        Modular::make(x.@value * (u / d), modulus)
    );
}

impl [a: Euclid] Modular a: Finite {
    finite = ();
}

//-------------------------------------------------------------

// Polynomial
type Polynomial a = unbox struct {
    coeff: Array a
};

namespace Polynomial {
    make: [a: Ring] Array a -> Polynomial a;
    make = |coeff| (
        // remove last zeros
        let coeff = loop(
            coeff, |coeff|
            let n = coeff.get_size;
            if n <= 1 { break $ coeff };
            if coeff.@(n - 1) != zero { break $ coeff };
            let coeff = coeff.pop_back;
            continue $ coeff
        );
        eval assert(|_| "invalid size", coeff.get_size >= 1);
        Polynomial { coeff: coeff }
    );

    polynomial: [a: Ring] Array a -> Polynomial a;
    polynomial = make;

    of_power: [a: Ring] a -> I64 -> Polynomial a;
    of_power = |x, power| (
        eval assert(|_| "invalid power", power >= 0);
        let coeff = Array::from_map(power + 1, |i|
            if i == power { x } else { zero }
        );
        Polynomial::make(coeff)
    );

    is_zero: [a: Ring] Polynomial a -> Bool;
    is_zero = |p| p == zero;

    get: [a: Ring] I64 -> Polynomial a -> a;
    get = |i, p| (
        if i < 0 || p.@coeff.get_size <= i { zero };
        p.@coeff.@(i)
    );

    get_degree: Polynomial a -> I64;
    get_degree = |p| p.@coeff.get_size - 1;

    divmod: [a: Field] Polynomial a -> Polynomial a -> (Polynomial a, Polynomial a);
    divmod = |num, den| (
        eval assert (|_| "Divide by zero", !den.is_zero);
        let (quo, rem) = loop(
            (zero, num), |(quo, num)|
            if num.is_zero { break $ (quo, num) };
            let num_degree = num.get_degree;
            let den_degree = den.get_degree;
            if num_degree < den_degree { break $ (quo, num) };
            let n = num.get(num_degree);
            let d = den.get(den_degree);
            let q = n / d;
            let qd = q * d;
            eval assert(|_| "has remainder", n == qd);
            let q = Polynomial::of_power(n / d, num_degree - den_degree);
            let quo = quo + q;
            let rem = num - q * den;
            eval assert(|_| "has reminder !!", rem.get_degree < num.get_degree);
            continue $ (quo, rem)
        );
        (quo, rem)
    );
}

impl [a: Ring, a: ToString] Polynomial a: ToString {
    to_string = |x| (
        let degree = x.get_degree;
        Iterator::range(0, degree + 1).map(|i|
            x.get(i).to_string + "x^" + i.to_string
        ).join(" + ")
    );
}

impl [a: Ring] Polynomial a: Eq {
    eq = |x, y| (
        x.@coeff == y.@coeff
    );
}

impl [a: Ring] Polynomial a: Zero {
    zero = Polynomial::make([zero]);
}

impl [a: Ring] Polynomial a: One {
    one = Polynomial::make([one]);
}

impl [a: Ring] Polynomial a: Neg {
    neg = |x| (
        Polynomial::make(x.@coeff.map(neg))
    );
}

impl [a: Ring] Polynomial a: Add {
    add = |x, y| (
        let degree = max(x.get_degree, y.get_degree);
        let coeff = Array::from_map(degree + 1, |i| x.get(i) + y.get(i));
        Polynomial::make(coeff)
    );
}

impl [a: Ring] Polynomial a: Sub {
    sub = |x, y| (
        let degree = max(x.get_degree, y.get_degree);
        let coeff = Array::from_map(degree + 1, |i| x.get(i) - y.get(i));
        Polynomial::make(coeff)
    );
}


impl [a: Ring] Polynomial a: Mul {
    mul = |x, y| (
        let x_degree = x.get_degree;
        let y_degree = y.get_degree;
        let degree = x_degree + y_degree;
        let iter = do {
            pure $ (*Iterator::range(0, x_degree + 1), *Iterator::range(0, y_degree + 1))
        };
        let coeff = Array::fill(degree + 1, zero);
        let coeff = iter.fold(
            coeff, |coeff, (ix, iy)|
            coeff.mod(ix + iy, add(x.get(ix) * y.get(iy)))
        );
        Polynomial::make(coeff)
    );
}

impl [a: Field] Polynomial a: Div {
    div = |x, y| (
        let (quo, rem) = divmod(x, y);
        quo
    );
}

impl [a: Field] Polynomial a: Rem {
    rem = |x, y| (
        let (quo, rem) = divmod(x, y);
        rem
    );
}

namespace Ring {

    // Calculates x.op(a).op(a)... for n times.
    // `op` is associative binary operation.
    // Same as `Iterator::range(0, n).fold(x, |x, _| x.op(a))` but fast.
    // https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#Russian_peasant_multiplication
    repeat_by_U64: [a: Ring] (a -> a -> a) -> a -> a -> U64 -> a;
    repeat_by_U64 = |op, x, a, n| (
        loop(
            (x, a, n), |(x, a, n)|
            if n == 0_U64 {
                break $ x
            };
            let x = if n.bit_and(1_U64) != 0_U64 {
                op(x, a)
            } else { x };
            continue $ (x, op(a, a), n.shift_right(1_U64))
        )
    );

    // Calculates `a * n`
    times_by_U64: [a: Ring] U64 -> a -> a;
    times_by_U64 = |n, a| (
        repeat_by_U64(add, zero, a, n)
    );

    // Calculates `a ^ n`
    pow_by_U64: [a: Ring] U64 -> a -> a;
    pow_by_U64 = |n, a| (
        repeat_by_U64(mul, one, a, n)
    );

    gcd: [a: Euclid] a -> a -> a;
    gcd = |a, b| (
        if b == zero { a };
        let c = a % b;
        gcd(b, c)
    );
}

namespace I64 {

    factorization: I64 -> Array I64;
    factorization = |n| (
        eval assert(|_| "invalid n", n > 0);

        loop(
            ([], n, 2), |(output, n, i)|
            if n <= 1 { output };
            if n % i == 0 {
                continue $ (output.push_back(i), n/i, i)
            };
            if i == 2 {
                continue $ (output, n, i + 1)
            } else {
                continue $ (output, n, i + 2)
            }
        )
    );
}

namespace Polynomial {
    
    // Calculates `f'`, ie. derivative of `f`.
    derivative: [a: Ring] Polynomial a -> Polynomial a;
    derivative = |f| (
        let n = f.get_degree;
        if n == 0 {
            zero
        };
        let coeff_ = Array::from_map(n, |i|
            Ring::from_U64((i + 1).to_U64) * f.get(i + 1)
        );
        Polynomial::make(coeff_)
    );

    // Square-free factorization
    // https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Square-free_factorization
    square_free_factorization: [a: FiniteGroup] Polynomial a -> Array (Polynomial a);
    square_free_factorization = |f| (
        let r = one;
        let c = Ring::gcd(f, f.derivative);
        let w = f / c;
        let (r, c, w) = loop(
            (r, c, w, 1), |(r, c, w, i)|
            if w == one { break $ (r, c, w) };
            let y = gcd(w, c);
            let fac = w / y;
            let r = r * fac.pow_by_U64(i.to_U64);
            let w = y;
            let c = c / y;
            continue $ (r, w, c, i + 1) 
        );

        // TODO: calculates p-th root of c
        abort();
    );

    // https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Rabin's_test_of_irreducibility
    rabin_irreducibility_test: [a: FiniteGroup] Polynomial a -> Bool;
    rabin_irreducibility_test = |f| (

    );
}



//---------------------------------------

test1: IO ();
test1 = (
    let m = 31;
    let a = 3;
    let a = Modular::make(a, m);
    let one = Modular::make(1, m);
    let x = *Iterator::range(0, m).fold_m(
        one, |x, i|
        let _ = *println((a, i, x, m).format("{}^{} = {} (mod {})"));
        pure $ x * a
    );
    pure()
);

test2: IO ();
test2 = (
    let a = Polynomial::make([1, 3]);
    let one = Polynomial::make([1]);
    let x = *Iterator::range(0, 5).fold_m(
        one, |x, i|
        let _ = *println((a, i, x).format("({})^{} = {}"));
        pure $ x * a
    );
    pure()
);

test3: IO ();
test3 = (
    let table = [
        (5, 7),
        (20, 32),
        (40, 30)
    ];
    table.to_iter.fold_m(
        (), |_, (a, b)|
        let (x, y, d) = _extended_euclid(a, b);
        println([a, x, b, y, d].format("{} * {} + {} * {} = {}"))
    )
);

test4: IO ();
test4 = (
    let m = 31;
    let table = [
        (5, 7),
        (20, 12),
        (10, 3)
    ];
    table.to_iter.fold_m(
        (), |_, (a, b)|
        let a = modulo(a, m);
        let b = modulo(b, m);
        let c = a / b;
        let cc = c * b;
        let d = b / a;
        let dd = d * a;
        println([a, b, c, cc].format("a={}, b={}, a/b={}, a/b*b={}\n") +
                [a, b, d, dd].format("a={}, b={}, b/a={}, b/a*a={}\n") +
                [cc == a, dd == b].format("ok={} {}\n")
                )
    )
);

test5: IO ();
test5 = (
    let m = 3;
    let p = polynomial([ modulo(0, m), modulo(1, m) ]);
    //let q = polynomial([ modulo(2, m), modulo(2, m), modulo(1, m) ]);
    let q = polynomial([ modulo(2, m), modulo(2, m), modulo(1, m), modulo(1, m) ]);
    let a = modulo(p, q);
    let one_ = modulo(one, q);
    let x = *Iterator::range(0, 9).fold_m(
        one_, |x, i|
        let is_one = if x == one_ { " !!!" } else { "" };
        let _ = *println((a, i, x).format("({})^{} = {}") + is_one);
        let _ = *println([x.@value, derivative(x.@value)].format("deriv {} = {}"));
        pure $ x * a
    );
    pure()    
);

main: IO ();
main = test5;
