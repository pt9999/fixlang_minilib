// Fix document generator
module Main;

import Character;

import StringEx;
import SimpleParser;
import Clap;

// Matches `/^module\s+(\w+)/`.
match_module: Parser String;
match_module = do {
    let _ = *match_str("module");
    let _ = *one_or_more(match_char_class(is_space));
    let chars = *one_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    pure $ chars._unsafe_to_string
};

// Matches `/^type\s+(\w+)/`.
match_type: Parser String;
match_type = do {
    let _ = *match_str("type");
    let _ = *one_or_more(match_char_class(is_space));
    let chars = *one_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    pure $ chars._unsafe_to_string
};

// Matches `/^(impl [^{]+)/`.
match_impl: Parser String;
match_impl = do {
    let _ = *match_str("impl ");
    let decl = *one_or_more(match_char_class(|c| c != '{'));
    pure $ ("impl " + decl._unsafe_to_string).strip_spaces
};

// Matches `/^[a-z]\w*\s*:[^;]*;/`. Note that a line that begins with '_' does not match.
match_global: Parser ();
match_global = do {
    let _ = *match_char_class(is_lower);
    let _ = *zero_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    let _ = *zero_or_more(match_char_class(is_space));
    let _ = *match_char(':');
    let _ = *zero_or_more(match_char_class(|c| c != ';'));
    let _ = *match_char(';');
    pure()    
};

// Matches `/^namespace\s+(\w+)`.
match_namespace: Parser String;
match_namespace = do {
    let _ = *match_str("namespace");
    let _ = *one_or_more(match_char_class(is_space));
    let chars = *one_or_more(match_char_class(|c| c.is_alnum || c == '_'));
    pure $ chars._unsafe_to_string
};

// `parser.matches(str)` runs the parser and returns the parsed result.
matches: String -> Parser a -> Result ErrMsg a;
matches = |str, parser| (
    parser.run_parser_str(str).map(|(x,_)| x)
);

// The state of parsing FixLang source code.
type State = unbox struct {
    output: IOHandle,   // output file handle
    //first_decl: Bool,   // first declaration has appered
    doc: String,        // document (function comment etc.)
    type_name: String,  // name of type declaration
    type_decl: String    // body of type declaration
};

namespace State {
    // Creates new state and sets the output stream.
    make: IOHandle -> State;
    make = |output| (
        State{
            output: output,
            //first_decl: false,
            doc: "",
            type_name: "",
            type_decl: ""
        }
    );

    // Prints a string to the output stream.
    print: String -> State -> IOFail ();
    print = |str, state| (
        write_string(state.@output, str)
    );

    // Prints a string and a newline to the output stream.
    println: String -> State -> IOFail ();
    println = |str, state| (
        state.print(str + "\n")
    );

    // Prints the doc comment, and clears the doc comment.
    print_doc: State -> IOFail State;
    print_doc = |state| (
        let _ = *if state.@doc == "" {
            state.print("") 
        } else {
            state.print(state.@doc + "\n")
        };
        pure $ state.set_doc("")
    );

    // Prints the declaration of the type.
    print_type_declaration: State -> IOFail State;
    print_type_declaration = |state| (
        let _ = *state.println("```");
        let _ = *state.print(state.@type_decl);
        let _ = *state.println("```");
        pure $ state.set_type_decl("")
    );

    process_comment: String -> State -> IOFail State;
    process_comment = |line, state| (
        let after_comment = line.get_sub(2, line.get_size).strip_spaces + "\n";
        let state = state.mod_doc(|doc| doc + after_comment);
        pure $ state
    );

    process_module_decl: String -> State -> IOFail State;
    process_module_decl = |module_name, state| (
        let _ = *state.println("## module " + module_name + "\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_impl_decl: String -> State -> IOFail State;
    process_impl_decl = |impl_, state| (
        let _ = *state.println("#### `" + impl_ + "`\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_global_decl: String -> State -> IOFail State;
    process_global_decl = |line, state| (
        let _ = *state.println("#### " + line + "\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_type_decl: String -> String -> Result ErrMsg String -> State -> IOFail State;
    process_type_decl = |orig_line, line, type_name, state| (
        let state = if type_name.is_ok { 
            state.set_type_name(type_name.as_ok) 
        } else { 
            state 
        };
        let state = state.mod_type_decl(|t| t + orig_line + "\n");
        if state.@type_decl.find(";", 0).is_none {
            pure $ state
        };
        let _ = *state.println("### type " + state.@type_name + "\n");
        let state = *state.print_doc;
        let state = *state.print_type_declaration;
        pure $ state
    );

    process_namespace_decl: String -> String -> State -> IOFail State;
    process_namespace_decl = |line, namespace_name, state| (
        let _ = *state.println("### namespace " + namespace_name + "\n");
        let state = *state.print_doc;
        pure $ state
    );

    process_other: String -> State -> IOFail State;
    process_other = |line, state| (
        /*
        if !state.@first_decl {
            if line == "" {
                pure $ state
            };
            let state = *state.print_doc;
            let state = state.set_first_decl(true).set_doc("");
            pure $ state
        };
        */
        let state = state.set_doc("");
        pure $ state
    );

    process_line: String -> State -> IOFail State;
    process_line = |orig_line, state| (
        let line = orig_line.strip_spaces;
        let is_comment = line.get_sub(0, 2) == "//";
        if (is_comment) {
            state.process_comment(line)
        };
        let module_decl = match_module.matches(line);
        if module_decl.is_ok {
            state.process_module_decl(module_decl.as_ok)
        };
        let impl_decl: Result ErrMsg String = match_impl.matches(line);
        if impl_decl.is_ok {
            state.process_impl_decl(impl_decl.as_ok)
        };
        let global_decl: Result ErrMsg () = match_global.matches(line);
        if global_decl.is_ok {
            state.process_global_decl(line)
        };
        let type_name: Result ErrMsg String = match_type.matches(line);
        if type_name.is_ok || state.@type_decl != "" {
            state.process_type_decl(orig_line, line, type_name)
        };
        let namespace_decl: Result ErrMsg String = match_namespace.matches(line);
        if namespace_decl.is_ok {
            state.process_namespace_decl(line, namespace_decl.as_ok)
        };
        state.process_other(line)
    );

    process_file: String -> String -> IOHandle -> IOFail ();
    process_file = |input_filepath, contents, output| (
        let input_filename = input_filepath.split_ex("/").to_array.get_last.as_some;
        let state = State::make(output);
        let _ = *state.println("# " + input_filename);
        let _ = *state.println("");
        let state = *contents.split("\n").loop_iter_m(
            state,
            |state, orig_line|
            let state = *state.process_line(orig_line);
            continue_m $ state
        );
        pure $ ()
    );
}

command: Command;
command = (
    Command::new("fixdoc")
    .version("0.1.0")
    .about("Output a reference document from a fix source file")
    .arg(Arg::new("FILE").help("Input file (*.fix)").required.takes_value)
    .arg(Arg::new("output").short('o').long("output").help("Output file").takes_value)
);

main: IO ();
main = (
    do {
        let matches = *command.get_matches;
        let input_file = matches.get_one("FILE").as_some;
        let output_file = matches.get_one("output");
        let output = *if output_file.is_some {
            open_file(Path::parse(output_file.as_some).as_some, "w")
        } else {
            pure $ IO::stdout
        };
        let contents = *read_file_string(Path::parse(input_file).as_some);
        let _ = *process_file(input_file, contents, output);
        pure()
    }
    .try(|err| eprintln (err))
);
