// Simple NdArray Calculator
//
// Prerequisite: readline library is required.
// For Ubuntu 22.04, you can install libreadline-dev with command below.
// ```
// $ sudo apt install libreadline-dev
// ```
//
// How to run:
// ```
// $ ../bin/fixautolink run -L ../lib -L . -f ndarray_calc.fix -d readline
// ```

module Main;

import Character;
import Debug;
import HashMap;
import AsyncTask;

import Minilib.Text.StringEx;
import Minilib.Text.SimpleParser;
import Minilib.Monad.State;
import Sandbox.NdArray;

_EOF: String;
_EOF = "EOF";

readline: String -> IOFail String;
readline = |prompt| (
    let ptr = prompt.borrow_c_str(|p_prompt|
        CALL_C[Ptr readline(Ptr), p_prompt]
    );
    if ptr == nullptr {
        throw $ _EOF
    };
    let str = String::_unsafe_from_c_str_ptr(ptr);
    let _ = if str.get_size > 0 {
        CALL_C[() add_history(Ptr), ptr]
    } else {
        ()
    };
    let _ = CALL_C[() free(Ptr), ptr];
    pure $ str
);

is_all: (a -> Bool) -> Array a -> Bool;
is_all = |f, array| (
    array.to_iter.fold(
        true, |b, x|
        b && f(x)
    )
);

type Expr = box union {
    ex_none: (),
    ex_var: String,
    ex_float: F64,
    ex_apply: (String, Array Expr),
    ex_array: Array Expr,
    ex_subsc: (Expr, Array Expr),
    ex_range: (Option Expr, Option Expr),
    ex_assign: (Expr, Expr),
    ex_unary: (String, Expr),
    ex_infix: (Expr, String, Expr)
};

impl Expr: ToString {
    to_string = |ex| (
        if ex.is_ex_var { ex.as_ex_var };
        if ex.is_ex_float { ex.as_ex_float.to_string };
        if ex.is_ex_apply {
            let (name, args) = ex.as_ex_apply;
            name + "(" + args.to_iter.map(to_string).join(",") + ")"
        };
        if ex.is_ex_array {
            "[" + ex.as_ex_array.to_iter.map(to_string).join(",") + "]"
        };
        if ex.is_ex_subsc {
            let (a, b) = ex.as_ex_subsc;
            a.to_string + "[" + b.to_iter.map(to_string).join(",") + "]"
        };
        if ex.is_ex_range {
            let (a, b) = ex.as_ex_range;
            a.map_or("", to_string) + ":" + b.map_or("", to_string)
        };
        if ex.is_ex_assign {
            let (a, b) = ex.as_ex_assign;
            a.to_string + "=" + b.to_string
        };
        if ex.is_ex_unary {
            let (op, b) = ex.as_ex_unary;
            "(" + op + a.to_string + ")"
        };
        if ex.is_ex_infix {
            let (a, op, b) = ex.as_ex_infix;
            "(" + a.to_string + " " + op + " " + b.to_string + ")"
        };
        ""
    );
}

// num_lit
// var
// "(" expr ")"
// expr "(" (expr ("," expr)*)? ")"
// "[" (expr ("," expr)*)? "]"
// expr ("[" (expr ("," expr)*)? "]")+
// "-" expr
// expr ( "*" | "/" ) expr
// expr ( "+" | "-" ) expr
// expr ":" expr
// expr "=" expr
// 

namespace Expr {

    parse_expr: String -> Result ErrMsg Expr;
    parse_expr = |line| (
        let parser = do {
            let ex = *_parse_expr;
            let _ = *_skip_whitespaces;
            let _ = *match_end_of_stream;
            pure $ ex
        };
        parser.run_parser_str(line).map(@0)
    );

    _parse_expr: Parser Expr;
    _parse_expr = do {
        let _ = *_skip_whitespaces;
        let expr = *(
            _parse_assign
        );
        pure $ expr
    };

    _parse_assign: Parser Expr;
    _parse_assign = do {
        let lhs = *_parse_range;
        let _ = *_skip_whitespaces;
        let equal = *match_char('=').if_exists;
        if equal.is_none {
            pure $ lhs
        };
        let rhs = *_parse_range;
        pure $ ex_assign $ (lhs, rhs)
    };

    _parse_range: Parser Expr;
    _parse_range = do {
        let colon = *match_char(':').if_exists;
        if colon.is_some {
            let rhs = *_parse_add_sub.if_exists;
            pure $ ex_range $ (none(), rhs)
        };
        let lhs = *_parse_add_sub;
        let _ = *_skip_whitespaces;
        let colon = *match_char(':').if_exists;
        if colon.is_none {
            pure $ lhs
        };
        let rhs = *_parse_add_sub.if_exists;
        pure $ ex_range $ (some(lhs), rhs)
    };

    _parse_add_sub: Parser Expr;
    _parse_add_sub = do {
        let lhs = *_parse_mult_div;
        loop_m(
            lhs, |lhs|
            let _ = *_skip_whitespaces;
            let add = *match_char_if_exists('+');
            let sub = *match_char_if_exists('-');
            if add.is_none && sub.is_none {
                break_m $ lhs
            };
            let rhs = *_parse_mult_div;
            let op = if add.is_some { "+" } else { "-" };
            continue_m $ ex_infix $ (lhs, op, rhs)
        )
    };

    _parse_mult_div: Parser Expr;
    _parse_mult_div = do {
        let lhs = *_parse_neg;
        loop_m(
            lhs, |lhs|
            let _ = *_skip_whitespaces;
            let mul = *match_char_if_exists('*');
            let div = *match_char_if_exists('/');
            if mul.is_none && div.is_none {
                break_m $ lhs
            };
            let rhs = *_parse_neg;
            let op = if mul.is_some { "*" } else { "/" };
            continue_m $ ex_infix $ (lhs, op, rhs)
        )
    };

    _parse_neg: Parser Expr;
    _parse_neg = do {
        let _ = *_skip_whitespaces;
        let neg = *match_char_if_exists('-');
        let expr = *_parse_term;
        let expr = if neg.is_some { ex_unary $ ("-", expr) } else { expr };
        pure $ expr
    };

    _parse_term: Parser Expr;
    _parse_term = do {
        _parse_apply
        .or_else(_parse_array)
        .or_else(_parse_subsc)
        .or_else(_parse_paren)
        .or_else(_parse_number_lit)
    };

    _parse_expr_list: Parser (Array Expr);
    _parse_expr_list = do {
        let a = *_parse_expr.if_exists;
        if a.is_none {
            pure $ []
        };
        let a = a.as_some;
        let rest = *repeat(do {
            let _ = *_skip_whitespaces;
            let _ = *match_char(',');
            _parse_expr
        });
        pure $ [a].append(rest)
    };

    _parse_apply: Parser Expr;
    _parse_apply = do {
        let _ = *_skip_whitespaces;
        let name = *_parse_var;
        let name = name.as_ex_var;
        let _ = *_skip_whitespaces;
        let _ = *match_char('(');
        let args = *_parse_expr_list;
        let _ = *_skip_whitespaces;
        let _ = *match_char(')').or_error("')' is missing");
        pure $ ex_apply $ (name, args)
    };

    _parse_array: Parser Expr;
    _parse_array = do {
        let _ = *_skip_whitespaces;
        let _ = *match_char('[');
        let array = *_parse_expr_list;
        let _ = *_skip_whitespaces;
        let _ = *match_char(']').or_error("']' is missing");
        pure $ ex_array(array)
    };

    _parse_subsc: Parser Expr;
    _parse_subsc = do {
        let var = *_parse_var;
        loop_m(
            var, |expr|
            let _ = *_skip_whitespaces;
            let lbracket = *match_char('[').if_exists;
            if lbracket.is_none {
                break_m $ expr
            };
            let indices = *_parse_expr_list;
            let _ = *_skip_whitespaces;
            let _ = *match_char(']').or_error("']' is missing");
            continue_m $ ex_subsc $ (expr, indices)
        )
    };

    _parse_paren: Parser Expr;
    _parse_paren = do {
        let _ = *match_char('(');
        let expr = *_parse_expr;
        let _ = *match_char(')');
        pure $ expr
    };

    _parse_var: Parser Expr;
    _parse_var = do {
        let c = *match_char_class(|c| is_alpha(c) || c == '_');
        let rest = *repeat(match_char_class(is_alnum));
        let str = [c].append(rest)._unsafe_to_string;
        pure $ ex_var(str)
    };
 
    _parse_number_lit: Parser Expr;
    _parse_number_lit = (
        let match_decimal_point = match_str(".");
        let match_digit = match_any_char.filter(|c| '0' <= c && c <= '9');
        let match_digit1_9 = match_any_char.filter(|c| '1' <= c && c <= '9');
        let match_e = match_any_char.filter(|c| c == 'e' || c == 'E');
        let match_minus = match_str("-");
        let match_plus = match_str("+");
        let match_zero = match_str("0");
        let match_int = match_zero.or_else(
            do {
                let _ = *match_digit1_9;
                let _ = *(repeat(match_digit));
                pure $ ()
            }
        );
        let match_exp = do {
            let _ = *match_e;
            let _ = *(match_minus.or_else(match_plus).or_else(unit));
            let _ = *(one_or_more(match_digit));
            pure $ ()
        };
        let match_frac = do {
            let _ = *match_decimal_point;
            let _ = *(repeat(match_digit));
            pure $ ()
        };
        let match_number = do {
            let _ = *(match_minus.or_else(unit));
            let _ = *(match_int);
            let _ = *(match_frac.or_else(unit));
            let _ = *(match_exp.or_else(unit));
            pure $ ()
        };

        do {
            let stream_begin = *get_stream;
            let _ = *match_number;
            let stream_end = *get_stream;
            let byte_count = stream_end.@position - stream_begin.@position;
            eval assert(|_| "number byte count is negative", byte_count >= 0);
            let number_str = stream_begin.read_string(byte_count);
            let res: Result ErrMsg F64 = from_string(number_str);
            if res.is_err {
                error_parser(res.as_err)
            };
            pure $ ex_float $ res.as_ok
        }
    );

    _skip_whitespaces: Parser ();
    _skip_whitespaces = do {
        match_str_class_whitespace.map(|_|())
    };
}

type Value = box union {
    v_none: (),
    v_err: String,
    v_float: F64,
    v_range: (Option I64, Option I64),
    v_func: (String, Value -> IOFail Value),
    v_array: Array Value,
    v_ndarray: NdArray F64
};

err_type: Value;
err_type = v_err $ "TYPE";

impl Value: ToString {
    to_string = |v| (
        if v.is_v_none { "" };
        if v.is_v_err { "ERR:" + v.as_v_err };
        if v.is_v_float {
            let str = v.as_v_float.to_string;
            str.strip_last_bytes(|c| c == '0').strip_last_bytes(|c| c == '.')
        };
        if v.is_v_range { 
            let (lhs, rhs) = v.as_v_range;
            lhs.map_or("", to_string) + ":" + rhs.map_or("", to_string)
        };
        if v.is_v_func {
            let (name, _) = v.as_v_func;
            "#{function " + name + "}"
        };
        if v.is_v_array {
            "[" + v.as_v_array.to_iter.map(to_string).join(",") + "]"
        };
        if v.is_v_ndarray {
            "#" + v.as_v_ndarray.to_string
        };
        ""
    );
}

// Type of environment
type Environ = box struct {
    map: HashMap String Value,
    parent: Option Environ
};

namespace Environ {
    empty: Environ;
    empty = Environ {
        map: HashMap::empty(0),
        parent: none()
    };

    make_child: Environ -> Environ;
    make_child = |parent| (
        Environ::empty.set_parent(parent)
    );

    find: String -> Environ -> Option Value;
    find = |key, env| (
        let opt = env.@map.find(key);
        if opt.is_some { opt };
        env.@parent.map_or(
            none(),
            |parent| parent.find(key)
        )
    );

    insert: String -> Value -> Environ -> Environ;
    insert = |key, value, env| (
        env.mod_map(insert(key, value))
    );
}

type Evaluator = unbox struct {
    env: Var Environ
};

// Expr evaluator
namespace Evaluator
{
    make: Var Environ -> Evaluator;
    make = |env| (
        Evaluator {
            env: env
        }
    );

    get_environ: Evaluator -> IOFail Environ;
    get_environ = |ev| (
        ev.@env.get.lift
    );

    mod_environ: (Environ -> Environ) -> Evaluator -> IOFail ();
    mod_environ = |f, ev| (
        ev.@env.mod(f).lift
    );

    evaluate: Expr -> Evaluator -> IOFail Value;
    evaluate = |expr, ev| (
        if expr.is_ex_var {
            ev._eval_var(expr.as_ex_var)
        };
        if expr.is_ex_assign {
            ev._eval_assign(expr.as_ex_assign)
        };
        if expr.is_ex_range {
            ev._eval_range(expr.as_ex_range)
        };
        if expr.is_ex_apply {
            ev._eval_apply(expr.as_ex_apply)
        };
        if expr.is_ex_array {
            ev._eval_array(expr.as_ex_array)
        };
        if expr.is_ex_subsc {
            ev._eval_subsc(expr.as_ex_subsc)
        };
        if expr.is_ex_infix {
            ev._eval_infix(expr.as_ex_infix)
        };
        if expr.is_ex_unary {
            ev._eval_unary(expr.as_ex_unary)
        };
        if expr.is_ex_none {
            pure $ v_none $ expr.as_ex_none
        };
        if expr.is_ex_float {
            pure $ v_float $ expr.as_ex_float
        };
        eval assert (|_| "unknown expr", false);
        pure $ v_none()
    );

    _evaluate_array: Array Expr -> Evaluator -> IOFail (Array Value);
    _evaluate_array = |array_expr, ev| (
        array_expr.to_iter.fold_m(
            [], |array_value, expr|
            let value = *ev.evaluate(expr);
            pure $ array_value.push_back(value)
        )
    );

    _eval_var: String -> Evaluator -> IOFail Value;
    _eval_var = |name, ev| (
        let env: Environ = *ev.get_environ;
        let opt = env.find(name);
        if opt.is_none {
            throw $ "not found: " + name
        };
        pure $ opt.as_some
    );
    
    _eval_assign: (Expr, Expr) -> Evaluator -> IOFail Value;
    _eval_assign = |(lhs, rhs), ev| (
        if lhs.is_ex_var {
            let lhs = lhs.as_ex_var;
            let rhs = *ev.evaluate(rhs);
            let _ = *ev.mod_environ(insert(lhs, rhs));
            pure $ v_none()
        };
        throw $ "assign type mismatch"
    );

    _eval_apply: (String, Array Expr) -> Evaluator -> IOFail Value;
    _eval_apply = |(name, args), ev| (
        let f = *ev._eval_var(name);
        args.to_iter.fold_m(
            f, |f, arg|
            if !f.is_v_func {
                throw $ "invalid func type: " + f.to_string
            }; 
            let (f_name, f) = f.as_v_func;
            let arg = *ev.evaluate(arg);
            let value = *f(arg);
            pure $ value
        )
    );
    
    _eval_infix: (Expr, String, Expr) -> Evaluator -> IOFail Value;
    _eval_infix = |(lhs, op, rhs), ev| (
        let lhs = *ev.evaluate(lhs);
        let rhs = *ev.evaluate(rhs);
        if lhs.is_v_float && rhs.is_v_float {
            _eval_infix_op((lhs.as_v_float, op, rhs.as_v_float), v_float)
        };
        if lhs.is_v_ndarray && rhs.is_v_ndarray {
            _eval_infix_op((lhs.as_v_ndarray, op, rhs.as_v_ndarray), v_ndarray)
        };
        if lhs.is_v_ndarray && rhs.is_v_float {
            _eval_infix_op((lhs.as_v_ndarray, op, scalar(rhs.as_v_float)), v_ndarray)
        };
        if lhs.is_v_float && rhs.is_v_ndarray {
            _eval_infix_op((scalar(lhs.as_v_float), op, rhs.as_v_ndarray), v_ndarray)
        };
        throw $ "_eval_infix: type mismatch"
    );

    _eval_infix_op: [a: Add, a: Sub, a: Mul, a: Div] (a, String, a) -> (a -> Value) -> IOFail Value;
    _eval_infix_op = |(lhs, op, rhs), to_value| (
        if op == "+" { pure $ to_value $ lhs + rhs };
        if op == "-" { pure $ to_value $ lhs - rhs };
        if op == "*" { pure $ to_value $ lhs * rhs };
        if op == "/" { pure $ to_value $ lhs / rhs };
        throw $ "invalid op: " + op
    );

    _eval_unary: (String, Expr) -> Evaluator -> IOFail Value;
    _eval_unary = |(op, expr), ev| (
        let value = *ev.evaluate(expr);
        
        if value.is_v_float {
            _eval_unary_op((op, value.as_v_float), v_float)
        };
        if value.is_v_ndarray {
            _eval_unary_op((op, value.as_v_ndarray), v_ndarray)
        };
        throw $ "_eval_unary: type mismatch"
    );

    _eval_unary_op: [a: Neg] (String, a) -> (a -> Value) -> IOFail Value;
    _eval_unary_op = |(op, val), to_value| (
        if op == "-" { pure $ to_value $ -val };
        throw $ "invalid op: " + op
    );

    _eval_array: Array Expr -> Evaluator -> IOFail Value;
    _eval_array = |array_expr, ev| (
        let array_value = *ev._evaluate_array(array_expr);
        if array_value.is_all(is_v_float) {
            //ev debug_eprintln("all v_float");
            let ndarray = NdArray::from_array(array_value.map(as_v_float));
            pure $ v_ndarray(ndarray)
        };
        //ev debug_eprintln("not all v_float");
        pure $ v_array (array_value)
    );

    _eval_subsc: (Expr, Array Expr) -> Evaluator -> IOFail Value;
    _eval_subsc = |(lhs, rhs), ev| (
        let lhs = *ev.evaluate(lhs);
        let rhs = *ev._evaluate_array(rhs);
        if lhs.is_v_array {
            let array = lhs.as_v_array;
            let idx = rhs;
            if idx.get_size != 1 {
                throw $ "invalid subsc (idx size)"
            };
            let idx = idx.@(0);
            if !idx.is_v_float {
                throw $ "invalid subsc (idx type)"
            };
            let i = idx.as_v_float.to_I64;
            if !(0 <= i && i <= array.get_size) {
                throw $ "invalid subsc (idx out of range)"
            };
            pure $ array.@(i)
        };
        if lhs.is_v_ndarray {
            let ndarray = lhs.as_v_ndarray;
            let idx = rhs;
            if idx.get_size != ndarray.get_dim {
                throw $ "invalid subsc (idx size)"
            };
            let tuple2_array = *idx.to_iter.fold_m(
                [], |tuple2_array, i|
                if i.is_v_float {
                    let i = i.as_v_float.to_I64;
                    pure $ tuple2_array.push_back((i, i + 1))
                };
                if i.is_v_range {
                    let (begin, end) = i.as_v_range;
                    let begin = begin.as_some_or(0);
                    let end = end.as_some_or(I64::maximum);
                    pure $ tuple2_array.push_back((begin, end))
                };
                throw $ "invalid subsc (idx type): " + i.to_string
            );
            let val = ndarray.get_sub(tuple2_array);
            pure $ v_ndarray $ val
        };
        throw $ "invalid subsc: lhs="+lhs.to_string + " rhs="+rhs.to_string
    );

    _eval_range: (Option Expr, Option Expr) -> Evaluator -> IOFail Value;
    _eval_range = |(lhs, rhs), ev| (
        let inner: Option Expr -> IOFail (Option I64) = |expr| (
            if expr.is_none {
                pure $ none ()
            };
            let v = *ev.evaluate(expr.as_some);
            if !v.is_v_float {
                throw $ "invalid range type: " + v.to_string
            };
            pure $ some(v.as_v_float.to_I64)
        );
        let lhs = *inner(lhs);
        let rhs = *inner(rhs);
        pure $ v_range $ (lhs, rhs)
    );
}


type Func = Value -> IOFail Value;

namespace Builtin {

    // initialize builtin functions
    init_builtin_funcs: Environ -> Environ;
    init_builtin_funcs = |env| (
        env
        .add_builtin_func("ndarray", Builtin::ndarray)
        .add_builtin_func("stack", Builtin::stack)
    );

    add_builtin_func: String -> Func -> Environ -> Environ;
    add_builtin_func = |name, f, env| (
        let func = v_func $ (name, f);
        env.insert(name, func)
    ); 

    ndarray: Value -> IOFail Value;
    ndarray = |arg| (
        if arg.is_v_ndarray {
            pure $ arg
        };
        if arg.is_v_array {
            let array = arg.as_v_array;
            if !array.is_all(is_v_float) {
                throw $ "not all v_float"
            };
            let ndarray = NdArray::from_array(array.map(as_v_float));
            pure $ v_ndarray(ndarray)
        };
        throw $ "invalid arg: arg=" + arg.to_string
    );

    stack: Value -> IOFail Value;
    stack = |arg| (
        if !arg.is_v_array {
            throw $ "invalid arg type"
        }; 
        let array = arg.as_v_array;
        if array.get_size == 0 {
            throw $ "invalid arg count"
        };
        if !array.is_all(is_v_ndarray) {
            throw $ "type mismatch"
        };
        let children = array.map(as_v_ndarray);
        let first_child = children.@(0);
        if !children.is_all(|child| child.@shape == first_child.@shape) {
            throw $ "shape mismatch"
        };
        let parent = NdArray::stack(0, children);
        pure $ v_ndarray $ parent
    );
}

type App = unbox struct {
    global: Var Environ
};

namespace App {
    make: () -> IOFail App;
    make = |_| (
        let global = Environ::empty;
        let global = global.init_builtin_funcs;
        pure $ App {
            global: *Var::make(global).lift
        }
    );

    process_line: String -> App -> IO App;
    process_line = |line, app| (
        do {
            //let _ = *println("process_line: " + line).lift;
            let expr = *parse_expr(line).from_result;
            let ev = Evaluator::make(app.@global);
            let value = *ev.evaluate(expr);
            let _ = *println("--> " + value.to_string).lift;
            pure $ app
        }
        .try(|err| 
            let _ = *eprintln("ERROR: " + err);
            pure $ app
        )
    );

    main_loop: () -> IOFail ();
    main_loop = |_| (
        let app = *App::make();
        loop_m(
            app, |app|
            let line = *readline("$ ");
            let app = *app.process_line(line).lift;
            continue_m $ app
        )
    );
}


main: IO ();
main = (
    do {
        main_loop()
    }.try(eprintln)
);

