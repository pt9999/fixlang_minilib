module Main;

// `iter_iter.transpose` transposes an iterator of iterators.
// For example, [[0, 1, 2], [3, 4, 5], [6, 7, 8]] ==> [[0, 3, 6], [1, 4, 7], [2, 5, 8]].
// Note that `iter_iter` must be finite.
// This function is very similar to `zip` function of Python.
transpose : [i2 : Iterator, i : Iterator, Item i2 = i] i2 -> TransposeIterator i;
transpose = |iter_iter| TransposeIterator { iters: iter_iter.to_array };

type TransposeIterator i = unbox struct { iters : Array i };
impl [i : Iterator] TransposeIterator i : Iterator {
    type Item (TransposeIterator i) = ArrayIterator (Item i);
    advance = |TransposeIterator { iters : iters }| (
        let advanced = iters.map(advance);
        if advanced.to_iter.check_any(is_none) { none() };
        let iters = advanced.map(as_some >> Tuple2::@0);
        let arr = advanced.map(as_some >> Tuple2::@1);
        some $ (TransposeIterator { iters : iters }, arr.to_iter)
    );
}

test_transpose: IO ();
test_transpose = (
    println("=== test_transpose ===");;
    let arr = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
    ];
    let iter_iter = arr.to_iter.map(to_iter);
    let trans = iter_iter.transpose;
    let actual = trans.map(to_array).to_array;
    println("arr=" + arr.to_string);;
    println("transpose=" + actual.to_string)
);

//-------------------------------------------------------------------------

type AdjacentIterator a = unbox struct { arr : Array a, idx : I64 };

impl AdjacentIterator a : Iterator {
    type Item (AdjacentIterator a) = (a, a);
    advance = |AdjacentIterator { arr : arr, idx : idx }| (
        if idx + 1 >= arr.get_size { none() };
        let u = arr.@(idx);
        let v = arr.@(idx + 1);
        some((AdjacentIterator { arr: arr, idx: idx + 1 }, (u, v)))
    );
}

adjacent: Array a -> AdjacentIterator a;
adjacent = |arr| AdjacentIterator { arr: arr, idx: 0 };

test_adjacent: IO ();
test_adjacent = (
    println("=== test_adjacent ===");;
    [
        ([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]),
        ([1], []),
        ([], []),
    ]
    .to_iter.fold_m(
        (), |(arr, expected), _|
        let actual = arr.adjacent.to_array;
        println("arr=" + arr.to_string);;
        println("adjacent=" + actual.to_string);;
        assert_eq(|_| "eq", expected, actual)
    )
);

//-------------------------------------------------------------------------

type TailsIterator i = unbox struct { i: i };

impl [i: Iterator] TailsIterator i : Iterator {
    type Item (TailsIterator i) = i;
    advance = |TailsIterator { i: i }| (
        match i.advance {
            none() => none(),
            some((next, a)) => some((TailsIterator {i: next}, i))
        }
    );
}

tails: [i: Iterator] i -> TailsIterator i;
tails = |i| TailsIterator { i: i };

test_tails: IO ();
test_tails = (
    println("=== test_tails ===");;
    [
        ([1, 2, 3, 4, 5], [[1, 2, 3, 4, 5], [2, 3, 4, 5], [3, 4, 5], [4, 5], [5]]),
        ([1], [[1]]),
        ([], []),
    ]
    .to_iter.fold_m(
        (), |(arr, expected), _|
        let actual = arr.to_iter.tails.map(to_array).to_array;
        println("arr=" + arr.to_string);;
        println("tails=" + actual.to_string);;
        assert_eq(|_| "eq", expected, actual)
    )
);


main: IO () = (
    test_transpose;;
    test_adjacent;;
    test_tails;;
    pure()
);
