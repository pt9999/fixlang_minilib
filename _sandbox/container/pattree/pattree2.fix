/*

Patricia Tree

This module was inspired by Haskell's `Data.IntMap` package.
https://hackage-content.haskell.org/package/containers-0.8/docs/Data-IntMap.html

In particular, I used the following papers mentioned in the `Data.IntMap` package's documentation:

Chris Okasaki and Andy Gill, "Fast Mergeable Integer Maps", Workshop on ML, September 1998, pages 77-86,
https://web.archive.org/web/20150417234429/https://ittc.ku.edu/~andygill/papers/IntMap98.pdf

*/
module Minilib.Collection.PatTree2;

import Minilib.Text.Hex;

type Key = U64;
type Prefix = U64;
type Mask = U64;

// A type of combining function that resolves collisions.
// `combine(old_value, new_value)` returns a combined value.
type Combine a = a -> a -> a;

namespace Combine {
    overwrite: Combine a = |old_value, new_value| new_value;
    append: [a: Add] Combine a = add;
}

// PNode is just a array index.
type PNode = I64;

namespace PNode {
    // An empty node.
    empty: PNode = -1;
}

// Patricia Tree.
type PTree a = unbox struct {
    _root: PNode,
    _combine: Combine a,
/*
    For leafs, @_branch.@(i) = false, @_prefix.@(i) = key, @_data.@(i) = some(data).
    For branches, @_branch.@(i) = true, @_prefix.@(i) = prefix, @_mask.@(i) = mask,
    @_left.@(i) = left, @right.@(i) = right.
*/
    _branch: Array Bool,     
    _prefix: Array Prefix,
    _mask: Array Mask,
    _left: Array PNode,
    _right: Array PNode,
    _data: Array (Option a),
};

namespace PTree {
    empty: PTree a;
    empty = PTree {
        _root: PNode::empty,
        _combine: overwrite,
        _branch: [],
        _prefix: [],
        _mask: [],
        _left: [],
        _right: [],
        _data: [],
    };

    make_branch: Prefix -> Mask -> PNode -> PNode -> PTree a -> (PTree a, PNode);
    make_branch = |prefix, mask, left, right, tree| (
        let node = tree.@_branch.get_size;
        let tree = tree.mod__branch(push_back(true))
        .mod__prefix(push_back(prefix))
        .mod__mask(push_back(mask))
        .mod__left(push_back(left))
        .mod__right(push_back(right))
        .mod__data(push_back(none()));
        (tree, node)
    );

    make_leaf: Key -> a -> PTree a -> (PTree a, PNode);
    make_leaf = |key, value, tree| (
        let node = tree.@_branch.get_size;
        let tree = tree.mod__branch(push_back(false))
        .mod__prefix(push_back(key))
        .mod__mask(push_back(0_U64))
        .mod__left(push_back(PNode::empty))
        .mod__right(push_back(PNode::empty))
        .mod__data(push_back(some(value)));
        (tree, node)
    );

    is_empty: PNode -> PTree a -> Bool;
    is_empty = |node, tree| node == PNode::empty;

    is_leaf: PNode -> PTree a -> Bool;
    is_leaf = |node, tree| !tree.@_branch.@(node);

    is_branch: PNode -> PTree a -> Bool;
    is_branch = |node, tree| tree.@_branch.@(node);

    get_leaf: PNode -> PTree a -> (Key, a);
    get_leaf = |node, tree| (
        if !tree.is_leaf(node) { undefined("not a leaf") };
        (tree.@_prefix.@(node), tree.@_data.@(node).as_some)
    );

    get_branch: PNode -> PTree a -> (Prefix, Mask, PNode, PNode);
    get_branch = |node, tree| (
        if !tree.is_branch(node) { undefined("not a branch") };
        (tree.@_prefix.@(node), 
         tree.@_mask.@(node),
         tree.@_left.@(node),
         tree.@_right.@(node))
    );

    set_left: PNode -> PNode -> PTree a -> PTree a;
    set_left = |node, left, tree| (
        tree.mod__left(set(node, left))
    );

    set_right: PNode -> PNode -> PTree a -> PTree a;
    set_right = |node, right, tree| (
        tree.mod__right(set(node, right))
    );

    find: Key -> PTree a -> Option a;
    find = |key, tree| (
        let root = tree.@_root;
        tree._lookup(key, root)
    );

    _lookup: Key -> PNode -> PTree a -> Option a;
    _lookup = |key, node, tree| (
        if tree.is_empty(node) { none() };
        if tree.is_leaf(node) {
            let (k, x) = tree.get_leaf(node);
            if k == key { some(x) } else { none() }
        };
        if tree.is_branch(node) {
            let (prefix, m, left, right) = tree.get_branch(node);
            if !key._match_prefix(prefix, m) { none() };
            if key <= prefix { // key._zero_bit(m)
                tree._lookup(key, left) 
            } else { 
                tree._lookup(key, right)
            }
        };
        undefined("")
    );

    _zero_bit: Mask -> Key -> Bool;
    _zero_bit = |mask, key| (
        key.bit_and(mask) == 0_U64
    );

    _mask: Mask -> Key -> Mask;
    _mask = |m, key| (
        // little-endian mask
        //key.bit_and(m - 1_U64)
        // big-endian mask
        key.bit_or(m - 1_U64).bit_and(bit_not(m))
    );

    _match_prefix: Prefix -> Mask -> Key -> Bool;
    _match_prefix = |prefix, m, key| (
        key._mask(m) == prefix
    );

    _join: Prefix -> Mask -> PNode -> Prefix -> Mask -> PNode -> PTree a -> (PTree a, PNode);
    _join = |p0, m0, t0, p1, m1, t1, tree| (
        let m = _branching_bit(p0, m0, p1, m1);
        if p0._zero_bit(m) { 
            tree.make_branch(p0._mask(m), m, t0, t1)
        } else { 
            tree.make_branch(p0._mask(m), m, t1, t0)
        }
    );

    _branching_bit: Prefix -> Mask -> Prefix -> Mask -> Mask;
    //_branching_bit = |p0, p1| p0.bit_xor(p1)._lowest_bit;
    _branching_bit = |p0, m0, p1, m1| (
        _highest_bit(p0.bit_xor(p1), max(1_U64, 2_U64 * max(m0, m1)))
    );

    _lowest_bit: Prefix -> Mask;
    _lowest_bit = |x| x.bit_and(x.bit_not + 1_U64);

    _highb: Prefix -> Mask;
    _highb = |x| (
        let m = x._lowest_bit;
        if x == m { m };
        _highb(x - m)
    );

    _highest_bit: Prefix -> Mask -> Mask;
    _highest_bit = |x, m| (
        // zero all bits below m
        let xx = x.bit_and((m - 1_U64).bit_not);
        //eval debug_eprintln("(x,m)=" + x.to_string_hex + "," + m.to_string_hex + " xx=" + xx.to_string_hex);
        let b = _highb(xx);
        //eval debug_eprintln("_highb(" + xx.to_string_hex + ")=" + b.to_string_hex);
        b
    );

    insert: Key -> a -> PTree a -> PTree a;
    insert = |new_key, new_value, tree| (
        let root = tree.@_root;
        let (tree, root) = tree._insert(new_key, new_value, root);
        tree.set__root(root)
    );

    _insert: Key -> a -> PNode -> PTree a -> (PTree a, PNode);
    _insert = |new_key, new_value, old_node, tree| (
        if tree.is_empty(old_node) { 
            tree.make_leaf(new_key, new_value)
        };
        if tree.is_leaf(old_node) {
            let (old_key, old_value) = tree.get_leaf(old_node);
            if old_key == new_key { 
                let value = (tree.@_combine)(old_value, new_value);
                tree.make_leaf(new_key, value)
            } else { 
                let (tree, new_node) = tree.make_leaf(new_key, new_value);
                tree._join(new_key, 0_U64, new_node, old_key, 0_U64, old_node)
            }
        };
        if tree.is_branch(old_node) {
            let (prefix, m, left, right) = tree.get_branch(old_node);
            if new_key._match_prefix(prefix, m) {
                if new_key <= prefix { // new_key._zero_bit(m)
                    let (tree, left) = tree._insert(new_key, new_value, left);
                    //tree.make_branch(prefix, m, left, right) 
                    let tree = tree.set_left(old_node, left);
                    (tree, old_node)
                } else { 
                    let (tree, right) = tree._insert(new_key, new_value, right);
                    //tree.make_branch(prefix, m, left, right)
                    let tree = tree.set_right(old_node, right);
                    (tree, old_node)
                }
            } else { 
                let (tree, new_node) = tree.make_leaf(new_key, new_value);
                tree._join(new_key, 0_U64, new_node, prefix, m, old_node)
            }
        };
        undefined("")
    );
/*
    merge: Combine a -> PNode -> PNode -> PTree a -> (PTree a, PNode);
    merge = |combine, new_node, old_node| (
        let mrg: PNode a -> PNode a -> PNode a = fix $ |mrg, new_node, old_node| (
            if new_node.is_empty { old_node };
            if old_node.is_empty { new_node };
            if new_node.is_leaf { 
                let (new_key, new_value) = new_node.as_leaf;
                old_node.insert(combine, new_key, new_value)
            };
            if old_node.is_leaf { 
                let (old_key, old_value) = old_node.as_leaf;
                new_node.insert(|x,y| combine(y,x), old_key, old_value)
            };
            let (new_prefix, new_mask, new_left, new_right) = new_node.as_branch;
            let (old_prefix, old_mask, old_left, old_right) = old_node.as_branch;
            if new_mask == old_mask && new_prefix == old_prefix {
                // same prefix
                let left = mrg(new_left, old_left);
                let right = mrg(new_right, old_right);
                branch((new_prefix, new_mask, left, right))
            };
            if new_mask < old_mask && old_prefix._match_prefix(new_prefix, new_mask) {
                // old_prefix contains new_prefix
                if old_prefix <= new_prefix { //old_prefix._zero_bit(new_mask)
                    branch((new_prefix, new_mask, mrg(new_left, old_node), new_right)) 
                } else { 
                    branch((new_prefix, new_mask, new_left, mrg(new_right, old_node))) 
                }
            };
            if (old_mask < new_mask && new_prefix._match_prefix(old_prefix, old_mask)) {
                // new_prefix contains old_prefix
                if new_prefix <= old_prefix { //new_prefix._zero_bit(old_mask)
                    branch((old_prefix, old_mask, mrg(new_node, old_left), old_right)) 
                } else { 
                    branch((old_prefix, old_mask, old_left, mrg(new_node, old_right))) 
                }
            };
            // the prefixes disagree.
            _join(new_prefix, new_mask, new_node, old_prefix, old_mask, old_node)
        );
        mrg(new_node, old_node)
    );
*/

} // namespace PTree

impl [a: ToString] PTree a: ToString {
    to_string = |tree| tree._node_to_string(0, tree.@_root);
}

_node_to_string: [a: ToString] I64 -> PNode -> PTree a -> String;
_node_to_string = |indent, node, tree| (
    let indent_str: String = Array::fill(indent, ' ').push_back('\0').from_bytes.as_ok;
    if tree.is_empty(node) { indent_str + "()" };
    if tree.is_leaf(node) {
        let (key,value) = tree.get_leaf(node);
        indent_str + "leaf(key=" + key.to_string + ", value=" + value.to_string + ")"
    };
    if tree.is_branch(node) {
        let (prefix,mask,left,right) = tree.get_branch(node);
        indent_str + "branch(prefix=" + prefix.to_string + ", mask=" + mask.to_string + ")\n" +
                tree._node_to_string(indent + 1, left) + "\n" + 
                tree._node_to_string(indent + 1, right)
    };
    undefined("")
);

