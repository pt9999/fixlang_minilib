module Main;

// 多相型の関数を引数として渡したい。
// しかし、多相型の関数は単一の型にならないので、関連型で何とかする。
// と思ったが、うまくいかない。

trait p: Pol {
    type PolFrom p a;
    type PolTo p a;
    run_pol: PolFrom p a -> p -> PolTo p a;     // p から a が決まらないからエラーになる？
}

trait p: Pol2 {
    run_pol2: Array a -> p -> a;
}

run_pol_array: [p: Pol, PolFrom p a = Array a, PolTo p a = a] Array a -> p -> a;
run_pol_array = run_pol;

run_pol2_array: [p: Pol2] Array a -> p -> a;
run_pol2_array = run_pol2;

array_zip: /*[
        p: Pol
        , PolFrom p b = Array b, PolTo p b = b
        , PolFrom p c = Array c, PolTo p c = c
    ]*/ 
    [p: Pol2]
    Array b -> Array c -> p -> (b, c);
array_zip = |arr_b, arr_c, p| (
    let arr_b: Array b = arr_b;
    let arr_c: Array c = arr_c;
    let b: b = p.run_pol2(arr_b: Array b);
    let c: c = p.run_pol2(arr_c: Array c);
    (b, c)
);

array_first: Array a -> a;
array_first = |arr| arr.@(0);

type PolArrayFirst = unbox struct {};
impl PolArrayFirst: Pol {
    type PolFrom PolArrayFirst a = Array a;
    type PolTo PolArrayFirst a = a;
    run_pol = |arr, p| arr.array_first;
}
impl PolArrayFirst: Pol2 {
    run_pol2 = |arr, p| arr.array_first;
}

array_sum: [a: Additive] Array a -> a;      // 追加の制約は付けられない
array_sum = |arr| arr.to_iter.fold(zero, add);

pol_test1: IO ();
pol_test1 = (
    let pol = PolArrayFirst{};
    let arr_b = [1, 2, 3];
    let arr_c = ["a", "b", "c"];
    //let (b, c) = pol.array_zip(arr_b, arr_c);
    //println((b, c).to_string)
    let b = pol.run_pol_array(arr_b);
    //let b = pol.run_pol2_array(arr_b);
    println(b.to_string)
);

main: IO ();
main = pol_test1;
