// AES-GCM
// NIST Special Publication 800-38D
// Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC
// https://doi.org/10.6028/NIST.SP.800-38D

5 Elements of GCM
5.1 Block Cipher
... AES
... key: K,  key size: at least 128 bits
... block size: 128 bits
... forward cipher function CIPH_{K} ... permutation on bit strings (blocks)
... inverse cipher function ... GCM does not employ

5.2 Two GCM Functions
- authenticated encryption
   confidential data ... encrypted
   non-confidential data ... not encrypted
   computes authentication tag for both conf and non-conf data
- authenticated decryption
   confidential data ... decrypted
   non-confidential data    
   contingent on verification of tag
- if only non-conf data, it is called GMAC.
   auth enc ... generates auth tag
   auth dec ... verifies auth tag
 - algorithm is for Section 7

5.2.1.1 Input Data
- P: a plain text ... protected
- A: additional authenticated data (AAD) ... protected
     eg. ip address, ports, seqnum, protocol ver.
- IV: an initialization vector
     a nonce, requires uniqueness. see Section 8.2
     typically 96 bits = 12 bytes
requirements:
  len(P) <= 2**39 - 256
  len(A) <= 2**64 - 1
  1 <= len(IV) <= 2**64 - 1

5.2.1.2 Output Data
- C: ciphertext
- T: tag, authentication tag
     len(T) is 128, 120, 112, 104, 96  see Appendix B

5.2.2 Authenticated Decryption Function
  (IV, A, C, T) -> Either P Fail
  if T is correct tag, then P is returned. otherwise, Fail is returned.

5.3 Primitives for Confidentiality and Authentication
  Counter mode, inc_32
  first counter block for plaintext enc is generated by
  incrementing a block gen. from IV.
  The auth mechanism for GCM is GHASH function
    multiplication of the hash subkey H within binary Galois field
    H = apply(block cipher, zero block)
    GHASH_{H} is used for compress AAD and ciphertext into a single block
    and enc to auth tag
    H shall be secret

6. Mathematical components of GCM
   6.1 .. bit string operation
   6.2 .. inc function
   6.3 .. mult block
   6.4 .. GHASH func
   6.5 .. GCTR func

6.1 Basic operation
   ceil(x) ... x:real
   0^s     ... s `0` bits           eg. 0^8 = 00000000
   X||Y    ... concats X and Y      eg. 010 || 110 = 010110
   X xor Y ... bitwise XOR
   len(X)  ... bit length           eg. len(00100) = 5
   LSB_s(X) ... least significant s bits of X       eg. LSB_3(11101010) = 010
   MSB_s(X) ... most  significant s bits of X       eg. MSB_3(11101010) = 111
   X >> 1   ... right shift   MSB_{len(X)}(0 || X)  eg. 0110111 >> 1 = 0011011
   [x]_s    ... integer to bit string of s bits     eg. [39]_8 = 00100111
   int(X)   ... bit string to integer               eg. int(00011010) = 26

6.2 Incrementing function
   s: positive integer
   X: bit string, len(X) >= s
   s-bit incrementing function is
   inc_s(X) = MSB_{len(X)-s}(X) || [ int(LSB_{s}(X)) + 1 mod 2**s]_{s}
    in other words, increment right-most s-bits of X, modulo 2**s
    left-most (len(X)-s) bits are unchanged

6.3 Multiplication operation on Blocks
   R = 11100001 || 0^120   (fixed block)
   Algorithm 1: product block X * Y
    Input: block X, Y
    Output: block (X * Y)
    Steps:
    1. let (x[0], x[1], ..., x[127]) denote the sequence of bits in X.
       QUESTION: X is big endian? MSB to LSB?
       block is bit string.
    2. let Z[0] = 0^128 and V[0] = Y.
    3. for i = 0 to 127, calculate blocks Z[i+1] and V[i+1] as follows:
         Z[i+1] = if x[i] == 0 { Z[i] } else { Z[i] xor V[i] }
         V[i+1] = if LSB_1(V[i]) == 0 { V[i] >> 1 } else { (V[i] >> 1) xor R }
    4. return Z[128].

   The `*` operation of 2**128 possible blocks corresponds to multiplication operation
   for the binary Galois field of 2**128 elements.  GF(2^128)
   The fixed block, R, determines modular multiplication of polynomials in GF(2) in degree less than 128.

   For a positive interger `i`, `X^i` denotes the i-th power of block X.
   For example, H^2 = H * H, H^3 = H * H * H.



       









