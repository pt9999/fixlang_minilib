module Minilib.Crypto.Tls13.Connection;

import Debug;

import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Net.Tcp;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

_Err_EOF: ErrMsg;
_Err_EOF = "EOF";

trait TLSConnection = Functor + Monad + MonadErrorIF + TLSConnectionIF;

trait [m: * -> *] m: TLSConnectionIF {
    send_bytes: Array U8 -> m ();
    recv_n_bytes: I64 -> m (Array U8);
    try_recv_n_bytes: I64 -> m (Option (Array U8));
}

trait a: ByteIO {
    // type IOType a: * -> *;
    send: Array U8 -> a -> IOFail ();
    recv: I64 -> a -> IOFail (Array U8);
    try_recv: I64 -> a -> IOFail (Option (Array U8));
}

impl Socket: ByteIO {
    // type IOType Socket = IOFail;
    send = |bytes, sock| (
        let expected_length = bytes.get_size;
        let actual_length = *sock.Socket::send(bytes); // TODO check size
        eval debug_eprintln("sent:" + actual_length.to_string + " bytes: " + bytes.to_string_hex);
        if actual_length < expected_length {
            throw $ "send error: expected=" + expected_length.to_string
                    + " actual=" + actual_length.to_string
        };
        pure()
    );
    recv = |length, sock| (
        eval debug_eprintln("receiving " + length.to_string + " bytes");
        let bytes = *sock.Socket::recv(length);
        eval debug_eprintln("received " + bytes.get_size.to_string + " bytes: " +
            (
                let max_size = 100;
                if bytes.get_size > max_size { bytes.subarray(0, max_size).to_string_hex + "..." }
                else { bytes.to_string_hex }
            )
        );
        pure $ bytes
    );

    try_recv = |length, sock| (
        eval debug_eprintln("try receiving " + length.to_string + " bytes");
        let opt_bytes = *sock.Socket::try_recv(length);
        eval debug_eprintln(
            opt_bytes.map_or(
                "data not available",
                |bytes| "received " + bytes.get_size.to_string + " bytes: " + bytes.to_string_hex
            )
        );
        pure $ opt_bytes
    );
}

trait a: GetByteIO {
    type ByteIOType a;
    get_byte_io: a -> ByteIOType a;
}

impl [s: GetByteIO, bio: ByteIO, ByteIOType s = bio]
    StateT s IOFail: TLSConnectionIF {
    send_bytes = |bytes| (
        let byte_io = (*get_state).get_byte_io;
        byte_io.ByteIO::send(bytes).lift_t
    );

    recv_n_bytes = |length| (
        let byte_io = (*get_state).get_byte_io;
        byte_io.ByteIO::recv(length).lift_t
    );

    try_recv_n_bytes = |length| (
        let byte_io = (*get_state).get_byte_io;
        byte_io.ByteIO::try_recv(length).lift_t
    );
}
