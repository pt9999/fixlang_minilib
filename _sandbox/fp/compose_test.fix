module Main;

import Minilib.Functor.Compose;
import Minilib.Trait.Applicative;
import Minilib.Testing.UnitTest;

test_compose_functor: TestCase;
test_compose_functor = (
    make_test("test_compose_functor") $ |_|
    let comp = Compose::make $ [some(1), some(2), none()];
    let comp = comp.map(|i| (i + 1).to_string);
    assert_equal("eq", [some("2"), some("3"), none()], comp.run_compose);;
    pure()
);

test_compose_functor2: TestCase;
test_compose_functor2 = (
    make_test("test_compose_functor") $ |_|
    let comp = Compose::make $ [("a", 1), ("b", 2), ("c", 3)];
    let comp = comp.map(|i| (i + 1).to_string);
    assert_equal("eq", [("a", "2"), ("b", "3"), ("c", "4")], comp.run_compose);;
    pure()
);

test_compose_applicative: TestCase;
test_compose_applicative = (
    make_test("test_compose_applicative") $ |_|
    let ca: Compose Array Option I64 = Compose::make $ [some(1), some(2), none()];
    let cf: Compose Array Option (I64 -> String) = pure_a(|i| (i + 1).to_string);
    let cb: Compose Array Option String = ca.app_a(cf);
    assert_equal("eq", [some("2"), some("3"), none()], cb.run_compose);;
    pure()
);

test_compose_monad: TestCase;
test_compose_monad = (
    make_test("test_compose_functor") $ |_|
    let comp: Compose Array Option String = do {
        let a = *Compose::make([some(1), some(2), none()]);
        pure $ (a + 1).to_string
    };
    assert_equal("eq", [some("2"), some("3"), none()], comp.run_compose);;
    pure()
);

main: IO ();
main = (
    [
        test_compose_functor,
        test_compose_functor2,
        test_compose_applicative,
        test_compose_monad,
    ]
    .run_test_driver
);
