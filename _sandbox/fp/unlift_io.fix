module Minilib.Monad.UnliftIO;

import Minilib.Monad.IO;
import Minilib.Monad.Iden;
import Minilib.Monad.Reader;
import Minilib.Monad.Result;

trait MonadUnliftIO = Monad + MonadUnliftIOIF;

trait [m: *->*] m: MonadUnliftIOIF {
    type FunctorType m a;
    with_run_in_io: ((m a -> IO (FunctorType m a)) -> IO (FunctorType m b)) -> m b;
}

impl ReaderT e IO: MonadUnliftIOIF {
    type FunctorType (ReaderT e IO) a = Iden a;
    with_run_in_io: ((ReaderT e IO a -> IO (FunctorType (ReaderT e IO) a)) -> IO (FunctorType (ReaderT e IO) b)) -> ReaderT e IO b
         = |f| (
        reader_t $ |e|
        let run: ReaderT e IO a -> IO (Iden a) = |rma| (
            let io_a: IO a = rma.run_reader_t(e);
            io_a.map(Iden::make)
        );
        let io_iden_b: IO (Iden b) = f(run);
        io_iden_b.map(get)
    );
}

/*
namespace ResultT {
    from_iofail: IOFail a -> ResultT ErrMsg IO a;
    from_iofail = |iof| (
         result_t $ iof.to_result
    );

    to_iofail: ResultT ErrMsg IO a -> IOFail a;
    to_iofail = |res| (
        from_io_result $ res.run_result_t
    );
}

impl ResultT e IO: MonadUnliftIOIF {
    //with_run_in_io: ((ResultT e IO a -> IO a) -> IO b) -> ResultT e IO b;
    // TODO: cannot implement: ResultT e IO a -> IO a

    with_run_in_io = |f| (
        let run = |res_t| (
            let res = *res_t.run_result_t;
            match res {
                ok(a) => pure $ a,
                err(e) => undefined(e), // xxxxxxx
            }
        )
    );
}
*/

