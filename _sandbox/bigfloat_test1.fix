module Main;

import Math;
import Debug;

import Minilib.Math.BigFloat;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
//import Minilib.Testing.Timeit;

namespace BigFloatEx {
    exp: BigFloat -> BigFloat;
    exp = |a| (
        if a.is_zero { BigFloat::_one };
        let k = max(0, a.@int.@nat._bit_length.to_I64 + a.@exp + 3);
        let x = a.mul_pow2(-k);
        // x = a * 2^-k,  a = x * 2^k
        // exp(a) = exp(x*2^k) = exp(x)^(2^k)
        eval assert (|_| "x out of range: x = "+x.to_string, x <= BigFloat::_one);
        //eval debug_eprintln("(k, x)="+(k, x).to_string);
        let sum = BigFloat::_one;
        let x_i = BigFloat::_one;
        let factorial = BigFloat::_one;
        let exp_x = loop(
            (sum, x_i, factorial, 1), |(sum, x_i, factorial, i)|
            let x_i = x_i * x;
            let factorial = factorial * BigFloat::from_F64(i.to_F64);
            let sum2 = sum + x_i / factorial;
            //eval debug_eprintln("(i, sum2)="+(i, sum2).to_string);
            if sum2 == sum { break $ sum };
            continue $ (sum2, x_i, factorial, i + 1)
        );
        loop(
            (exp_x, 0), |(exp_a, i)|
            if i >= k { break $ exp_a };
            continue $ (exp_a * exp_a, i + 1)
        )
    );
}


test_exp: IO ();
test_exp = (
    let _ = *eprintln("--- test_exp");
    let test: BigFloat -> IO () = |x| (
        eprintln([x, x.set_prec10(30).exp].map(to_string_exp).format("exp({{})={}"))
    );
    let _ = *test(BigFloat::from_F64(0.0));
    let _ = *test(BigFloat::from_F64(-0.000001));
    let _ = *test(BigFloat::from_F64(0.000001));
    let _ = *test(BigFloat::from_F64(1.0));
    let _ = *test(BigFloat::from_F64(3.0));
    let _ = *test(BigFloat::from_F64(100.0));
    let _ = *test(BigFloat::from_F64(-100.0));
    pure()
);

test_sqrt: IO ();
test_sqrt = (
    let _ = *eprintln("--- test_sqrt");
    let prec10 = 20;
    let a = BigFloat::from_F64(1234567890.0).set_prec10(prec10);
    let x = a.sqrt;
    let _ = *eprintln("a  =" + a._to_string_rep);
    let _ = *eprintln("a  =" + a.to_string);
    let _ = *eprintln("x  =" + x.to_string);
    let _ = *eprintln("x*x=" + (x * x).to_string);
    pure()
);

test_misc: IO ();
test_misc = (
    let _ = *eprintln("--- test_misc");
    let a = BigFloat::from_F64(1024.0).set_prec(256) / BigFloat::from_F64(1000.0);
    let b = BigFloat::from_F64(64.0).set_prec(256)  / BigFloat::from_F64(10.0);
    let _ = *eprintln("a="+a.to_string);
    let _ = *eprintln("a="+a.to_string_precision(20));
    let _ = *eprintln("b="+b.to_string);
    let _ = *eprintln("b="+b.to_string_precision(20));
    let c = a * b;
    let _ = *eprintln("c="+c.to_string);
    let _ = *eprintln("c="+c.to_string_precision(20));
    let _ = *eprintln("c.to_F64="+c.to_F64.to_string);
    let d = c / a;
    let _ = *eprintln("d="+d.to_string);
    let _ = *eprintln("d.to_F64="+d.to_F64.to_string);
    pure()
);


main: IO ();
main = (
    let _ = *test_exp;
    if true { pure() };
    let _ = *test_sqrt;
    let _ = *test_misc;
    pure()
);
