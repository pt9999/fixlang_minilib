// Command line argument parser.  (partial port of `clap` crate)
// https://docs.rs/clap/3.2.0/clap/index.html

module Main;

import Debug;
import HashMap;

import StringEx;

//----------------------------------------------
//  ArgAction
//----------------------------------------------
namespace ArgAction {
    type ArgAction = unbox union {
        set: (),        // set next argument to the single value
        append: (),     // append next argument to the values
        set_true: (),   // set "true" as the single value
        set_false: (),  // set "false" as the single value
        help: (),
        version: ()
    };
}

//----------------------------------------------
//  Arg
//----------------------------------------------
type Arg = unbox struct {
    id: String,
    short: U8,
    long: String,
    required: Bool,
    takes_value: Bool, // TODO
    multiple_values: Bool,
    default_value: Option String,
    value_name: String,
    help: String,
    action: ArgAction
};

namespace Arg {
    new: String -> Arg;
    new = |id| (
        Arg {
            id: id,
            short: 0_U8,
            long: "",
            required: false,
            takes_value: false,
            multiple_values: false,
            default_value: none(),
            value_name: "VALUE",
            help: "",
            action: ArgAction::set_true()
        }
    );

    // short(), long() .. please use set_short(), set_long() etc.
    short: U8 -> Arg -> Arg;
    short = set_short;

    long: String -> Arg -> Arg;
    long = set_long;

    required: Bool -> Arg -> Arg;
    required = set_required;

    takes_value: Bool -> Arg -> Arg;
    takes_value = |b, arg| (
        arg.set_takes_value(b).set_action(ArgAction::set())
    );

    help: String -> Arg -> Arg;
    help = set_help;



    is_positional: Arg -> Bool;
    is_positional = |arg| (
        arg.@short == 0_U8 && arg.@long == ""
    );
}

impl Arg: ToString {
    to_string = |arg| (
        if arg.@short != 0_U8 {
            Array::empty(3).push_back('-').push_back(arg.@short)._unsafe_to_string
        };
        if arg.@long != "" {
            "--" + arg.@long
        };
        if arg.@required { 
            "<" + arg.@id + ">"
        } else {
            "[" + arg.@id + "]"
        }
    );
}

// ---------------------------------
//  Command
// ---------------------------------
type Command = unbox struct {
    name: String,
    bin_name: String,
    display_name: String,
    version: String,
    author: String,
    about: String,
    args: Array Arg,
    help_template: HelpTemplate,
    version_template: HelpTemplate
};

type App = Command;

namespace Command {
    new: String -> Command;
    new = |name| (
        Command {
            name: name,
            bin_name: name,
            display_name: name,
            version: "",
            author: "",
            about: "",
            args: _default_args,
            help_template: HelpTemplate::default_help,
            version_template: HelpTemplate::default_version
        }
    );
    
    // about(), version() .. please use set_about(), set_version() etc.

    arg: Arg -> Command -> Command;
    arg = |arg, command| (
        command.mod_args(|args| args.push_back(arg))
    );

    render_help: Command -> String;
    render_help = |command| (
        command.@help_template.format(command)
    );

    render_version: Command -> String;
    render_version = |command| (
        command.@version_template.format(command)
    );

    _default_args: Array Arg;
    _default_args = (
        Array::empty(100)
        .push_back(Arg::new("help")
            .set_short('h').set_long("help")
            .set_help("Print help information")
            .set_action(ArgAction::help())
        )
        .push_back(Arg::new("version")
            .set_short('V').set_long("version")
            .set_help("Print version information")
            .set_action(ArgAction::version())
        )
    );

    get_matches: Command -> IOFail ArgMatches;
    get_matches = |command| (
        let raw_args = *IO::get_args;
        command.get_matches_from(raw_args).from_result
    );

    get_matches_from: Array String -> Command -> Result ErrMsg ArgMatches;
    get_matches_from = |raw_args, command| (
        let parser = ArgParser::make(raw_args, command);
        let parser = *parser.parse_args;
        let parser = *parser.check_required_args_present;
        let parser = *parser.set_default_if_not_present;
        ok $ parser.@matches
    );
}

// ---------------------------------
//  ArgParser
// ---------------------------------
namespace ArgParser
{
    type ArgParser = unbox struct {
        command: Command,
        args: Array Arg,
        matches: ArgMatches,
        raw_args: Array String,
        current_index: I64,
        positional_only: Bool
    };

    make: Array String -> Command -> ArgParser;
    make = |raw_args, command| (
        ArgParser {
            command: command,
            args: command.@args,
            matches: ArgMatches::empty,
            raw_args: raw_args,
            current_index: 1,
            positional_only: false
        }
    );

    no_raw_args: ArgParser -> Bool;
    no_raw_args = |parser| (
        parser.@current_index >= parser.@raw_args.get_size
    );

    advance: ArgParser -> Result ErrMsg (String, ArgParser);
    advance = |parser| (
        if parser.no_raw_args {
            err $ "No raw arg"
        };
        let raw_arg = parser.@raw_args.@(parser.@current_index);
        let parser = parser.mod_current_index(|i| i + 1);
        ok $ (raw_arg, parser)
    );

    get_raw_arg: ArgParser -> Result ErrMsg String;
    get_raw_arg = |parser| (
        let (raw_arg, _) = *parser.advance;
        ok $ raw_arg
    );


    // 実際のコマンドライン引数の配列を解析し、Argの値を設定する。
    parse_args : ArgParser -> Result ErrMsg ArgParser;
    parse_args = |parser| (
        loop_m(
            parser, |parser|
            if parser.no_raw_args {
                break_m $ parser
            };
            let raw_arg = *parser.get_raw_arg;
            if parser.@positional_only {
                continue_m $ *parser._process_positional_arg
            };
            if raw_arg == "--" {
                let parser = parser.set_positional_only(true);
                let (_, parser) = *parser.advance;
                continue_m $ parser
            };
            if raw_arg.substring(0, 1) == "-" {
                continue_m $ *parser._process_option_arg
            };
            continue_m $ *parser._process_positional_arg
        )
    );
    
    // 現在のコマンドライン引数をオプションと見なして処理する。
    _process_option_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_option_arg = |parser| (
        let (raw_arg, parser) = *parser.advance;
        let i = parser.@args.find_by(|arg| arg.to_string == raw_arg);
        if i.is_none {
            err $ "Found argument '" + raw_arg + "' which wasn't expected, or isn't valid in this context"
        };
        let arg = parser.@args.@(i.as_some);
        let parser = *parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser 
    );

    // 現在のコマンドライン引数をポジショナルと見なして処理する。
    _process_positional_arg: ArgParser -> Result ErrMsg ArgParser;
    _process_positional_arg = |parser| (
        let raw_arg = *parser.get_raw_arg;
        eval debug_println("_process_positional_arg: raw_arg=" + raw_arg + " i="+ parser.@current_index.to_string);
        let args = parser.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        if args.get_size == 0 {
            err $ "Found argument '" + raw_arg + "' which wasn't expected, or isn't valid in this context"
        };
        let arg = args.@(0);
        let parser = *parser._perform_action(arg);
        let parser = if arg.@multiple_values { parser } else { parser._remove_arg(arg) };
        ok $ parser
    ); 

    // parser.@args から arg を除去する。
    _remove_arg: Arg -> ArgParser -> ArgParser;
    _remove_arg = |arg, parser| (
        eval debug_println("_remove_arg: " + arg.to_string);
        parser.mod_args(|args| args.to_iter.filter(|a| a.@id != arg.@id).to_array)
    );

    // Arg に設定されたアクションを遂行する。
    _perform_action: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _perform_action = |arg, parser| (
        let action = arg.@action;
        if action.is_help {
            err $ parser.@command.render_help
        };
        if action.is_version {
            err $ parser.@command.render_version
        };
        if action.is_set_true || action.is_set_false {
            let value = if action.is_set_true { "true" } else { "false" };
            let parser = parser.set_value(arg, value);
            ok $ parser
        };
        if action.is_set || action.is_append {
            parser._set_or_append_value(arg)
        };
        eval assert(|_| "unknown action: arg="+arg.to_string, false);
        err $ "error"
    );

    // 次のコマンドライン引数を値と見なし, set or append アクションを実行する。
    _set_or_append_value: Arg -> ArgParser -> Result ErrMsg ArgParser;
    _set_or_append_value = |arg, parser| (
        if parser.no_raw_args {
            err $ "The argument '" + arg.to_string + "' requires a value but none was supplied"
        };
        let (value, parser) = *parser.advance;
        let parser = if arg.@action.is_set {
            parser.set_value(arg, value)
        } else {
            parser.append_value(arg, value)
        };
        eval debug_println("_set_or_append_value: value=" + value + " i="+ parser.@current_index.to_string);
        ok $ parser
    );
    
    set_value: Arg -> String -> ArgParser -> ArgParser;
    set_value = |arg, value, parser| (
        parser.mod_matches(|matches|
            matches.set_values(arg.@id,
                Array::empty(1).push_back(value)
            )
        )
    );
    append_value: Arg -> String -> ArgParser -> ArgParser;
    append_value = |arg, value, parser| (
        parser.mod_matches(|matches|
            matches.mod_values(arg.@id, |values|
                values.push_back(value)
            )
        )
    );

    check_required_args_present: ArgParser -> Result ErrMsg ArgParser;
    check_required_args_present = |parser| (
        let missing_args: Iterator Arg = 
            parser.@command.@args.to_iter
            .filter(|arg| arg.@required)
            .filter(|arg| !parser.@matches.@map.contains_key(arg.@id));
        if missing_args.is_empty {
            ok $ parser
        };
        err $ "The following required arguments were not provided:\n" +
        missing_args.map(|arg| "    " + arg.to_string + "\n")
        .concat_iter
    );

    set_default_if_not_present: ArgParser -> Result ErrMsg ArgParser;
    set_default_if_not_present = |parser| (
        pure $ parser.@command.@args.to_iter.fold(
            parser,
            |parser, arg|
            if arg.@default_value.is_none {
                parser
            };
            if parser.@matches.@map.contains_key(arg.@id) {
                parser
            };
            parser.set_value(arg, arg.@default_value.as_some)
        )
    );
}

// ---------------------------------
//  ArgMatches
// ---------------------------------

type ArgMatches = unbox struct {
    map: HashMap String (Array String)
};

namespace ArgMatches {
    empty: ArgMatches;
    empty = ArgMatches { map: HashMap::empty(0) };

    get_many: String -> ArgMatches -> Option (Array String);
    get_many = |id, matches| (
        matches.@map.find(id)
    );
    get_one: String -> ArgMatches -> Option String;
    get_one = |id, matches| (
        let array = *matches.get_many(id);
        if array.get_size == 0 { none };
        some(array.@(0))
    );

    set_values: String -> Array String -> ArgMatches -> ArgMatches;
    set_values = |id, values, matches| (
        matches.mod_map(|map| map.insert(id, values))
    );

    mod_values: String -> (Array String -> Array String) -> ArgMatches -> ArgMatches;
    mod_values = |id, f, matches| (
        let values = matches.@map.find(id).as_some_or(Array::empty(0));
        let values = f(values);
        matches.mod_map(|map| map.insert(id, values))
    );
}

// ---------------------------------
//  HelpTemplate
// ---------------------------------

type HelpTemplate = unbox struct { 
    data: String 
};
namespace HelpTemplate {
    new: String -> HelpTemplate;
    new = |str| HelpTemplate { data: str };

    default_help: HelpTemplate;
    default_help = HelpTemplate { 
        data: (
            "{name} {version}\n" +
            "{author-with-newline}" +
            "{about-with-newline}" +
            "\n" + 
            "{usage}\n" +
            "{all-args}\n"
        )
    };

    default_version: HelpTemplate;
    default_version = HelpTemplate {
        data: (
            "{name} {version}\n"
        )
    };

    format: Command -> HelpTemplate -> String;
    format = |command, help_template| (
        let help = help_template.@data;
        let help = help.replace_all("{name}", command.@display_name);
        let help = help.replace_all("{version}", command.@version);
        let help = help.replace_all("{author-with-newline}", 
            if command.@author == "" { "" } else { command.@author + "\n" }
        );
        let help = help.replace_all("{about-with-newline}", 
            if command.@about == "" { "" } else { command.@about + "\n" }
        );
        let help = help.replace_all("{usage}", 
            help_template._format_usage(command)
        );
        let help = help.replace_all("{all-args}", 
            help_template._format_all_args(command)
        );
        help
    );

    _format_usage: Command -> HelpTemplate -> String;
    _format_usage = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg.is_positional).to_array;
        let usage = "USAGE:\n";
        let usage = usage + (
            "    " + command.@bin_name + "[EXE]"
        );
        let usage = usage + (
            if args.get_size == 0 { "" } else {
                args.to_iter.map(|arg| " " + arg.to_string).concat_iter
            }
        );
        let usage = usage + (
            if options.get_size == 0 { "" } else { " [OPTIONS]" }
        );
        usage + "\n"
    );

    _format_all_args: Command -> HelpTemplate -> String;
    _format_all_args = |command, help_template| (
        let args = command.@args.to_iter.filter(|arg| arg.is_positional).to_array;
        let options = command.@args.to_iter.filter(|arg| !arg.is_positional).to_array;

        let args_text = if args.get_size == 0 { "" } else {
            "ARGS:\n" +
            args.to_iter.map(_format_arg).concat_iter
        };
        let options_text = if options.get_size == 0 { "" } else {
            "OPTIONS:\n" +
            options.to_iter.map(_format_option).concat_iter
        };
        args_text + options_text
    );

    _format_arg: Arg -> String;
    _format_arg = |arg| (
        let line = "    " + arg.to_string;
        let line = if line.get_size >= 15 { line } else {
            line + Array::fill(15 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );

    _format_option: Arg -> String;
    _format_option = |arg| (
        let line = "    ";
        let line = line + (
            if arg.@short == 0_U8 { "    " } else {
                arg.to_string + (
                    if arg.@long == "" { "  " } else { ", " }
                )
            }
        );
        let line = line + (
            if arg.@long == "" { " " } else {
                "--" + arg.@long + " "
            }
        );
        let line = line + (
            if !arg.@takes_value { "" } else {
                "<" + arg.@value_name + ">"
            }
        );
        let line = if line.get_size >= 32 { line } else {
            line + Array::fill(32 - line.get_size, ' ')._unsafe_to_string
        };
        let line = line + arg.@help;
        line + "\n"
    );
}

// ---------------------------------


main: IO ();
main = (
    do {
        let command = (
            Command::new("nice-tool")
            .set_display_name("MyNiceTool")
            .set_version("0.0.1")
            .set_about("A nice tool")
            .arg(Arg::new("count").short('n').long("count").help("How many times to iterate")
                .takes_value(true))
            .arg(Arg::new("output").short('o').long("output").help("An output file")
                .takes_value(true))
            .arg(Arg::new("FILE").help("An input file").takes_value(true))
        );
        let _ = *println(command.render_help).lift;
        let raw_args = ["nice-tool", "hoge"];
        let matches = *command.get_matches_from(raw_args).from_result;
        let _ = *println("matches="+matches.@map.to_string).lift;
        pure()
    }
    .try(|err| eprintln("error: " + err))
);
