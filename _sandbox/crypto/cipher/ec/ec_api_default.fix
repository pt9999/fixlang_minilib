module Minilib.Crypto.Cipher.Ec.EcApiDefault;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cipher.Ec.EcApi;
import Minilib.Crypto.Cipher.Ec.ECDSA;
import Minilib.Crypto.Cipher.Ec.ECDHE;
import Minilib.Encoding.Binary;
import Minilib.Math.BigInt;
import Minilib.Monad.Random;
import Minilib.Monad.State;
import Minilib.Monad.Error;

// TODO: remove MonadRandom from `EcApiDefault::make`.

make: [m: MonadError, m: MonadRandom] m (EcApi m);
make = (
    pure $ EcApi {
        make_ecdhe: _make_ecdhe,
        make_ecdsa: _make_ecdsa,
    }
);

_make_ecdhe: [m: MonadError, m: MonadRandom] EcCurveName -> m (EcdheApi m);
_make_ecdhe = |curve_name| (
    let ec = *ECParam::find_curve(curve_name).lift_result;
    let ecdhe = *ECDHE::make(ec);
    pure $ EcdheApi {
        curve_name: curve_name,
        key_exchange: ecdhe.get_key_exchange,
        accept_peer_key_exchange: |peer_key_exchange| ecdhe.accept_peer_key_exchange(peer_key_exchange).lift_result,
    }
);

_make_ecdsa: [m: MonadError] EcCurveName -> EcHashName -> m (EcdsaApi m);
_make_ecdsa = |curve_name, hash_name| (
    let ec = *ECParam::find_curve(curve_name).lift_result;
    let hash = *ECHashParam::find_hash(hash_name).lift_result;
    let ecdsa_scheme = ECDSAScheme::make(ec, hash);

    pure $ EcdsaApi {
        curve_name: curve_name,
        hash_name: hash_name,
        verify: _ecdsa_verify(ecdsa_scheme),
    }
);

_ecdsa_verify: [m: MonadError] ECDSAScheme -> EcPublicKey -> EcSignature -> EcSigMessage -> m ();
_ecdsa_verify = |ecdsa_scheme, public_key, signature, message| (
    let ec = ecdsa_scheme.@ec;
    let ecpoint = *ECPoint::from_bytes_ec(ec, public_key).lift_result;
    let signature = *_decode_ecdsa_signature(signature);
    ecdsa_scheme.verify(ecpoint, signature, message).lift_result
);

_decode_ecdsa_signature: [m: MonadError] EcSignature -> m ECDSASignature;
_decode_ecdsa_signature = |signature| (
    let sm = do {
        decode_sequence $ do {
            let r: BigInt = *decode_obj;
            let s: BigInt = *decode_obj;
            pure $ ECDSASignature::make(r, s)
        }
    };
    let buf = ByteBuffer::make(signature, big_endian());
    sm.eval_state_t(buf).lift_result
);
