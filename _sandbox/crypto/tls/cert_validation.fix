module Minilib.Crypto.Tls.CertValidation;

import Debug;
import HashMap;

import Minilib.Crypto.Cert.CACertificates;
import Minilib.Crypto.Cipher.Rsa.Pkcs1;
import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.X509Path;
import Minilib.Crypto.Cert.X509Signature;
import Minilib.Crypto.Cert.X509Time;
import Minilib.Crypto.Cert.X509DnsName;
import Minilib.Crypto.Tls.Extensions;
import Minilib.Crypto.Cipher.Ec.ECDSA;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

decode_certificates: [m: MonadError] Array (Array U8) -> m (Array Certificate);
decode_certificates = |cert_data_array| (
    cert_data_array.map_m(|cert_data| from_bytes(cert_data)).from_result_t
);

validate_certificate_signatures: [m: MonadError] Array Certificate -> CACertificates -> Option X509Time -> m ();
validate_certificate_signatures = |certs, ca_certs, time| (
    let cert_path: CertificatePath = *CertificatePath::make(certs, ca_certs);
    eval debug_eprintln("cert_path=" + cert_path.@data.to_iter.map(|c| "\n  " + c.to_string).concat_iter);
    eval *cert_path.validate_date(time);
    cert_path.validate_signatures
);

check_certificate_verify: [m: MonadError] Certificate -> Array U8 -> SignatureScheme -> Array U8 -> m ();
check_certificate_verify = |cert, content, algorithm, signature| (
    let options = algorithm._find_emsa_pss_options;
    if options.is_some {
        _check_certificate_verify_rsae(cert, content, signature, options.as_some)
    };
    let ecdsa_scheme = algorithm._find_ecdsa_scheme;
    if ecdsa_scheme.is_some {
        _check_certificate_verify_ecdsa(cert, content, signature, ecdsa_scheme.as_some)
    };
    error $ "check_certificate_verify: unsupported algorithm: " + algorithm.to_string_hex
);

_check_certificate_verify_rsae: [m: MonadError] Certificate -> Array U8 -> Array U8 -> EmsaPssOptions -> m ();
_check_certificate_verify_rsae = |cert, content, signature, options| (
    let public_key = cert.get_subject_public_key;
    let (n, e) = *public_key.get_rsa_public_key;
    rsassa_pss_verify((n, e), content, signature, options).from_result_t
);

_check_certificate_verify_ecdsa: [m: MonadError] Certificate -> Array U8 -> Array U8 -> ECDSAScheme -> m ();
_check_certificate_verify_ecdsa = |cert, content, signature, ecdsa_scheme| (
    let public_key = cert.get_subject_public_key;
    let (ecdsa_scheme, ec_point) = *get_ec_point_from_public_key(ecdsa_scheme, public_key).from_result_t;
    let sig_value: EcdsaSigValue = *decode_der_from_bytes(signature).from_result_t;
    //eval debug_eprintln("sig_value="+ sig_value.to_string);
    let signature: ECDSASignature = ECDSASignature { r: sig_value.@r, s: sig_value.@s };
    ecdsa_scheme.verify(ec_point, signature, content).from_result_t
);

_find_emsa_pss_options: SignatureScheme -> Option EmsaPssOptions;
_find_emsa_pss_options = |algorithm| (
    if algorithm == SignatureScheme::rsa_pss_rsae_sha256 {
        some $ Pkcs1::emsa_pss_options_sha256
    };
    if algorithm == SignatureScheme::rsa_pss_rsae_sha384 {
        some $ Pkcs1::emsa_pss_options_sha384
    };
    if algorithm == SignatureScheme::rsa_pss_rsae_sha512 {
        some $ Pkcs1::emsa_pss_options_sha512
    };
    none()
);

_find_ecdsa_scheme: SignatureScheme -> Option ECDSAScheme;
_find_ecdsa_scheme = |algorithm| (
    if algorithm == SignatureScheme::ecdsa_secp256r1_sha256 {
        some $ ECDSAScheme::ecdsa_secp256r1_sha256
    };
    if algorithm == SignatureScheme::ecdsa_secp384r1_sha384 {
        some $ ECDSAScheme::ecdsa_secp384r1_sha384
    };
    none()
);


check_certificate_identity: [m: MonadError] Certificate -> String -> m ();
check_certificate_identity = |cert, target_server_name| (
    eval debug_eprintln("check_certificate_identity: target_server_name=" + target_server_name);

    // RFC2818 3.1.  Server Identity
    let subjectAltName: Option SubjectAltName = do {
        let extn = *cert.find_extension(match_name("id-ce-subjectAltName"));
        let bytes = extn.@extn_value.to_bytes;
        let res = decode_der_from_bytes(bytes);
        if res.is_err { none () };
        some $ res.as_ok
    };
    eval debug_eprintln("subjectAltName=" + subjectAltName.to_string);

    let dns_names: Array String = (
        if subjectAltName.is_none { [] };
        subjectAltName.as_some.@data
            .to_iter
            .filter(is_dNSName)
            .map(as_dNSName)
            .map(to_string) // IA5String -> String
            .to_array
    );

    eval debug_eprintln("dns_names=" + dns_names.to_string);
    let dns_names = *(
        if dns_names.get_size > 0 {
            pure $ dns_names
        };

        let common_name: Option String = cert.get_subject.find_common_name;
        if common_name.is_some {
            eval debug_eprintln("Using the common name as a DNS name: common_name=" + common_name.to_string);
            pure $ [ common_name.as_some ]
        };
        error $ "Neither the DNS name nor the common name are not found"
    );

    let accepted_dns_names = (
        dns_names.to_iter
        .filter(|dns_name| match_dns_name(dns_name, target_server_name))
        .to_array
    );

    if accepted_dns_names.get_size == 0 {
        error $ "DNS names did not match"
    };
    pure()
);

