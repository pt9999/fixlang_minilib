
// ecapi.fix
module Minilib.Crypto.EC.EcApi
namespace EcApi {
    type EcCurveName = String;
    type EcHashName = String;
    type EcPublicKey = Array U8;    // UncompressedPointRepresentation
    type EcSharedSecret = Array U8;
    type EcSignature = Array U8;
    type EcMessage = Array U8;

    type EcApi = unbox struct {
        make_ecdhe: EcCurveName -> RandomGenerator -> Result ErrMsg EcdheInstance,
        make_ecdsa: EcCurveName -> EcHashName -> Result ErrMsg EcdsaInstance,
    };

    type EcdheInstance = unbox struct {
        named_group: String,
        key_exchange: EcPublicKey,
        accept_peer_key_exchange: EcPublicKey -> Result ErrMsg EcSharedSecret,
    };

    type EcdsaInstance = unbox struct {     // ECDSAScheme
         verify: EcPublicKey -> EcSignature -> EcMessage -> Result ErrMsg (),
    };

}

// ecapi_impl.fix
module Minilib.Crypto.EC.EcApiImpl

make: [m: MonadError] m EcApi;
make = (
    pure $ EcApi {
        make_ecdhe: _make_ecdhe,
        make_ecdsa: _make_ecdsa,
    }
);

_make_ecdhe: EcCurveName -> RandomGenerator -> Result ErrMsg EcdheInstance;

_make_ecdsa: EcCurveName -> EcHashName -> Result ErrMsg EcdsaInstance;

_get_ecparam: EcCurveName -> Result ErrMsg ECParam;

_get_ecdsa_scheme: EcCurveName -> EcHashName -> Result ErrMsg ECDSAScheme;

_get_public_key: EcPublicKey -> Result ErrMsg ECPoint;
