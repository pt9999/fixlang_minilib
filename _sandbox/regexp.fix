// An implementation of simple regular expression.
//
// Currently it only supports patterns below:
// - Character classes: `[xyz]`, `[^xyz]`, `.`, `\d`, `\D`, `\w`, `\W`, `\s`,
//   `\S`, `\t`, `\r`, `\n`, `\v`, `\f`, `[\b]`, x|y
// - Assertions: `^`, `$`
// - Groups: `(x)`
// - Quantifiers: `x*`, `x+`, `x?`, `x{n}`, `x{n,}`, `x{n,m}`
//
// For details, see
// [mdn web docs: Regular expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions).
//
// LIMITATION:
//
// Currently, only single bytes can be specified in character classes. Non-ascii characters
// (U+100 or hier) cannot be specified in character classes.
//
module Main;

import Character;
import Debug;

import SimpleParser;
import StringEx;

// A type of a character class
type CharClass = unbox struct {
    // A label to be displayed
    label: String,
    // A member
    f: U8 -> Bool
};

namespace CharClass {
    // An empty character class.
    empty: CharClass;
    empty = CharClass {
        label: "",
        f: |c| false
    };

    // Creates a character class from a label and a member function.
    make: String -> (U8 -> Bool) -> CharClass;
    make = |label, f| CharClass { label:label, f:f };

    // Returns true if the character is in the class.
    contains: U8 -> CharClass -> Bool;
    contains = |c, cls| (cls.@f)(c);

    // Creates a character class that consists of only single character.
    singleton: U8 -> CharClass;
    singleton = |c| CharClass {
        label: byte_to_string(c),
        f: |c1| c1 == c
    };

    // Creates a character class that consists of characters from start to end.
    range: U8 -> U8 -> CharClass;
    range = |start, end| CharClass {
        label: byte_to_string(start) + "-" + byte_to_string(end),
        f: |c| start <= c && c <= end
    };

    // Creates a character class that consists of specified string.
    consists_of: String -> CharClass;
    consists_of = |str| CharClass {
        label: str,
        f: |c| str.find_byte(c).is_some
    };

    // Negate the member function of a character class.
    negate: CharClass -> CharClass;
    negate = |cls| (
        let label = "^" + cls.@label;
        let f = cls.@f;
        CharClass {
            label: label,
            f: |c| !f(c)
        }
    );

    // Creates union of two character classes.
    union: CharClass -> CharClass -> CharClass;
    union = |cls1, cls2| (
        let f = cls1.@f;
        let g = cls2.@f;
        CharClass {
            label: cls1.@label + cls2.@label,
            f: |c| f(c) || g(c)
        }
    );

    // Adds a character to the character class.
    add: U8 -> CharClass -> CharClass;
    add = |c, cls| cls.union(singleton(c));

    // For optimization, converts a character class to a table, and create a new class
    // that refers to the table.
    to_table: CharClass -> CharClass;
    to_table = |cls| (
        let table = Iterator::count_up(0).take(256).fold(
            Array::fill(256, false), |arr, i|
            arr.set(i, cls.contains(i.to_U8))
        );
        CharClass {
            label: cls.@label,
            f: |c| table.@(c.to_I64)
        }
    );

    // A character class of `.`. (any character except newlines)
    cls_dot: CharClass;
    cls_dot = CharClass::make(".") $ |c| c != '\n' && c != '\r';

    // A character class of `\d`. (digits)
    cls_digit: CharClass;
    cls_digit = CharClass::make("\\d") $ is_digit;

    // A character class of `\D`. (non-digits)
    cls_non_digit: CharClass;
    cls_non_digit = cls_digit.negate.set_label("\\D");

    cls_word_char: CharClass;
    cls_word_char = CharClass::make("\\w") $ |c| is_alnum(c) || c == '_';

    cls_non_word_char: CharClass;
    cls_non_word_char = cls_word_char.negate.set_label("\\W");

    cls_whitespace: CharClass;
    cls_whitespace = CharClass::make("\\s") $ is_space;

    cls_non_whitespace: CharClass;
    cls_non_whitespace = cls_whitespace.negate.set_label("\\S");
}

impl CharClass: ToString {
    to_string = |cls| (
        if cls.@label.get_size <= 1 {
            cls.@label
        } else {
            "[" + cls.@label + "]"
        }
    );
}


// A type that represents Assertion Pattern.
type PAssertion = unbox union {
    pa_begin: (),       // beginning of line, ie. '^'
    pa_end: ()          // end of line,       ie. '$'
};

// Converts a pattern to a string.
impl PAssertion: ToString {
    to_string = |pa| (
        if pa.is_pa_begin { "^" };
        if pa.is_pa_end { "$" };
        eval assert(|_|"err", false);
        ""
    );
}

// A type that represents Pattern of Regular Expression.
type Pattern = box union {
    // Character class pattern, eg. `a`, `[a-z]`, `\d` etc.
    pclass: CharClass,
    // Assertion pattern, eg. `^`, `$`
    passert: PAssertion,
    // Sequence of patterns, eg. `XYZ`
    psequence: Array Pattern,
    // Either pattern, eg. `X|Y`
    peither: (Pattern, Pattern),
    // Quantified pattern, eg. `X?`, `X*`, `X+`, `X{n,m}`
    pquant: (Pattern, /*min_count:*/ I64, /*max_count:*/ I64),
    // Grouped pattern, eg. `(X)`
    pgroup: (/* group_number:*/ I64, Pattern)
};

impl Pattern: ToString {
    // Converts a pattern to a string.
    to_string = |pat| (
        if pat.is_pclass {
            "[" + pat.as_pclass.@label + "]"
        };
        if pat.is_passert {
            pat.as_passert.to_string
        };
        if pat.is_psequence {
            pat.as_psequence.to_iter.map(to_string).join("")
        };

        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            pat1.to_string + "|" + pat2.to_string
        };
        if pat.is_pquant {
            let (pat1, min, max) = pat.as_pquant;
            pat1.to_string + "{" + min.to_string + "," +
                if max == I64::maximum { "" } else { max.to_string }
            + "}"
        };
        if pat.is_pgroup {
            let (n, pat_inner) = pat.as_pgroup;
            "(" + n.to_string + ":" + pat_inner.to_string + ")"
        };
        eval assert(|_|"err", false);
        ""
    );
}


namespace Pattern {

    // Parses a pattern from the stream.
    parse_pattern: Parser Pattern;
    parse_pattern = do {
        let pat = *_parse_peither;
        let _ = *match_end_of_stream;
        pure $ pat
    };

    // Parses either-pattern, ie. `X|Y`
    _parse_peither: Parser Pattern;
    _parse_peither = do {
        let pat1 = *_parse_psequence;
        let bar = *match_char_if_exists('|');
        if bar.is_some {
            let pat2 = *_parse_peither;
            pure $ peither $ (pat1, pat2)
        };
        pure $ pat1
    };

    // Parses sequence of patterns, ie. `XYZ`
    _parse_psequence: Parser Pattern;
    _parse_psequence = do {
        pure $ psequence $ *zero_or_more(
            _parse_passert.or_else $
            _parse_pquant
        )
    };

    // Parses an assertion pattern, ie. `^`, `$` etc.
    _parse_passert: Parser Pattern;
    _parse_passert = do {
        let circumflex = *match_char_if_exists('^');
        if circumflex.is_some {
            pure $ passert $ pa_begin()
        };
        let dollar = *match_char_if_exists('$');
        if dollar.is_some {
            pure $ passert $ pa_end()
        };
        // TODO word boundary support
        not_match
    };

    // Parses Quantified Pattern, ie. `X?`, `X*`, `X+`, `X{n}`, `X{n,}`, `X{n,m}`
    _parse_pquant: Parser Pattern;
    _parse_pquant = do {
        let pat = *_parse_quantifiable_item;
        let question = *match_char_if_exists('?');
        if question.is_some {
            pure $ pquant $ (pat, 0, 1)
        };
        let asterisk = *match_char_if_exists('*');
        if asterisk.is_some {
            // TODO: support non-greedy match
            pure $ pquant $ (pat, 0, maximum)
        };
        let plus = *match_char_if_exists('+');
        if plus.is_some {
            // TODO: support non-greedy match
            pure $ pquant $ (pat, 1, maximum)
        };
        // `X{n}`, `X{n,}`, `X{n,m}`
        let lbrace = *match_char_if_exists('{');
        if lbrace.is_some {
            let (min_count, max_count) = *_parse_pquant_n_m_inner;
            let _ = *match_char('}').or_error("'}' is missing");
            pure $ pquant $ (pat, min_count, max_count)
        };
        pure $ pat
    };

    // Parses inner of `X{n}`, `X{n,}`, `X{n,m}`
    _parse_pquant_n_m_inner: Parser (I64, I64);
    _parse_pquant_n_m_inner = do {
        let min_count = *match_integer;
        let comma = *match_char_if_exists(',');
        if comma.is_none {
            pure $ (min_count, min_count)
        };
        let max_count = *match_integer.map(some).or_else(pure $ none());
        if max_count.is_some {
            pure $ (min_count, max_count.as_some)
        };
        pure $ (min_count, maximum)
    };

    // Parses quantifiable item.
    _parse_quantifiable_item: Parser Pattern;
    _parse_quantifiable_item = do {
        _parse_pgroup.or_else $
        _parse_pclass
    };

    // TODO: support backreferences, ie. `\\1`, `\\2` etc.

    // Parses Group Pattern, ie. `(X)`
    _parse_pgroup: Parser Pattern;
    _parse_pgroup = do {
        let lparen = *match_char('(');
        let pat = *_parse_peither;
        let rparen = *match_char(')').or_error("')' is missing");
        let group_idx = 0;  // have to assign group index later
        pure $ pgroup $ (group_idx, pat)
    };

    // A table of normal characters, ie. not a meta character.
    _normal_chars: CharClass;
    _normal_chars = (
        CharClass::consists_of(
            ".?*+^$|[](){}\\"
        ).negate.to_table
    );

    // Parses character class pattern, ie. `.`, `[a-z]`, `\w` etc.
    _parse_pclass: Parser Pattern;
    _parse_pclass = do {
        let c = *match_any_char;
        if _normal_chars.contains(c) {
            pure $ pclass(CharClass::singleton(c))
        };
        if c == '.' {
            pure $ pclass(CharClass::cls_dot)
        };
        if c == '[' {
            pure $ pclass(*_parse_pclass_bracket)
        };
        if c == '\\' {
            pure $ pclass(*_parse_backslash_char_class(false))
        };
        not_match
    };

    // Parses a character class that begins with '['.
    // The `[` itself is parsed already.
    _parse_pclass_bracket: Parser CharClass;
    _parse_pclass_bracket = do {
        let circumflex = *match_char_if_exists('^');
        let start_hyphen = *match_char_if_exists('-');
        let components = *repeat(_parse_bracket_component);
        let end_hyphen = *match_char_if_exists('-');
        let _ = *match_char(']').or_error("']' is missing");

        let cls = components.to_iter.fold(
            CharClass::empty, union
        );
        let cls = if start_hyphen.is_some || end_hyphen.is_some { cls.add('-') } else { cls };
        let cls = if circumflex.is_some { cls.negate } else { cls };
        pure $ cls.to_table
    };

    // Parses each component in a bracket.
    _parse_bracket_component: Parser CharClass;
    _parse_bracket_component = do {
        let _ = *match_char('\\');
        _parse_backslash_char_class(true)
    }.or_else $ do {
        let start = *match_any_char.filter(|c| c != ']' && c != '\\');
        let _ = *match_char('-');
        let end = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::range(start, end)
    }.or_else $ do {
        let c = *match_any_char.filter(|c| c != ']' && c != '\\');
        pure $ CharClass::singleton(c)
    };

    // Parses the char class that begins with a backslash.
    // The backslash itself is parsed already.
    _parse_backslash_char_class: Bool -> Parser CharClass;
    _parse_backslash_char_class = |in_bracket| do {
        let c = *match_any_char;
        if c == 'd' { pure $ CharClass::cls_digit };
        if c == 'D' { pure $ CharClass::cls_non_digit };
        if c == 'w' { pure $ CharClass::cls_word_char };
        if c == 'W' { pure $ CharClass::cls_non_word_char };
        if c == 's' { pure $ CharClass::cls_whitespace };
        if c == 'S' { pure $ CharClass::cls_non_whitespace };
        if c == 't' { pure $ CharClass::singleton('\t') };
        if c == 'r' { pure $ CharClass::singleton('\r') };
        if c == 'n' { pure $ CharClass::singleton('\n') };
        if c == 'v' { pure $ CharClass::singleton(11_U8) };
        if c == 'f' { pure $ CharClass::singleton(12_U8) };
        if c == 'b' && in_bracket { pure $ CharClass::singleton(8_U8) };
        // TODO: support for \xhh, \uhhhh

        // other character is treated as itself, ie. `\\`, `\+`, `\*` etc.
        pure $ CharClass::singleton(c)
    };

    // `pat._assign_group_number(n)` assigns group number for each group.
    // The first group number becomes `n + 1`.
    // It returns the translated pattern along with group count.
    _assign_group_number: I64 -> Pattern -> (I64, Pattern);
    _assign_group_number = |n, pat| (
        if pat.is_pclass || pat.is_passert {
            (n, pat)
        };
        if pat.is_psequence {
            let input: Array Pattern = pat.as_psequence;
            let output: Array Pattern = Array::empty(input.get_size);
            let (n, output) = input.to_iter.fold(
                (n, output), |(n, output), pat_inner|
                let (n, pat_inner) = pat_inner._assign_group_number(n);
                let output = output.push_back(pat_inner);
                (n, output)
            );
            let pat = psequence $ output;
            (n, pat)
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            let (n, pat1) = pat1._assign_group_number(n);
            let (n, pat2) = pat2._assign_group_number(n);
            let pat = peither $ (pat1, pat2);
            (n, pat)
        };
        if pat.is_pquant {
            let (pat_inner, min, max) = pat.as_pquant;
            let (n, pat_inner) = pat_inner._assign_group_number(n);
            let pat = pquant $ (pat_inner, min, max);
            (n, pat)
        };
        if pat.is_pgroup {
            let (_, pat_inner) = pat.as_pgroup;
            let gn = n;
            let (n, pat_inner) = pat_inner._assign_group_number(gn + 1);
            let pat = pgroup $ (gn, pat_inner);
            (n, pat)
        };
        eval assert(|_|"err", false);
        (n, pat)
    );
}

// NFA (Nondeterministic Finite Automaton)
//
// For details, see web pages below.
// - https://swtch.com/~rsc/regexp/regexp1.html
// - https://zenn.dev/canalun/articles/regexp_and_automaton

// NFA
type NFA = unbox struct {
    group_count: I64,           // group count
    states: Array NFAState,     // array of states
    initial_state: I64,         // initial state
    accepting_state: I64         // accepting state
};

namespace NFA {
    // An empty NFA.
    empty: NFA;
    empty = NFA {
        group_count: 0,
        states: Array::empty(0),
        initial_state: _ID_NONE,
        accepting_state: _ID_NONE
    };

    // Creates new state. Returns the new state id.
    new_state: NFA -> (NFA, I64);
    new_state = |nfa| (
        let id = nfa.@states.get_size;
        let state = NFAState::empty;
        let state = state.set_id(id);
        let nfa = nfa.mod_states(push_back(state));
        (nfa, id)
    );

    // `nfa.get_state(id)` gets the state whose @id is `id`.
    get_state: I64 -> NFA -> NFAState;
    get_state = |id, nfa| (
        nfa.@states.@(id)
    );

    // `nfa.mod_state(id, f)` modifies the state whose @id is `id`.
    mod_state: I64 -> (NFAState -> NFAState) -> NFA -> NFA;
    mod_state = |id, f, nfa| (
        nfa.mod_states(|states| states.set(id, f(states.@(id))))
    );

    // `nfa.set_frag_output(frag, out)` sets the output of the fragment to `out`.
    set_frag_output: NFAFrag -> I64 -> NFA -> NFA;
    set_frag_output = |frag, out, nfa| (
        (frag.@set_output)(out, nfa)
    );

    // `NFA::compile(pattern)` compiles a pattern to NFA.
    compile: Pattern -> NFA;
    compile = |pattern| (
        let nfa = NFA::empty;
        let (group_count, pattern) = pattern._assign_group_number(0);
        let nfa = nfa.set_group_count(group_count);
        let (nfa, frag) = nfa.compile_pattern(pattern);
        let nfa = nfa.set_initial_state(frag.@input);
        let (nfa, accept_id) = nfa.new_state;
        let nfa = nfa.set_accepting_state(accept_id);
        let nfa = nfa.set_frag_output(frag, accept_id);
        nfa
    );

    // `nfa.execute(stream)` executes matching.
    execute: Stream -> NFA -> Option GroupArray;
    execute = |stream, nfa| (
        let executor = NFAExecutor::make(stream, nfa);
        executor.execute
    );

}

impl NFA: ToString {
    to_string = |nfa| (
        "NFA { states=\n"
        + nfa.@states.to_iter.map(|s| "  " + s.to_string + "\n").concat_iter
        + "  initial_state=" + nfa.@initial_state.to_string + "\n"
        + "  accepting_state=" + nfa.@accepting_state.to_string + "\n"
        +"}"
    );
}

type NFAStateAction = unbox union {
    sa_none: (),
    sa_char_match: CharClass,
    sa_assert: PAssertion,
    sa_group_begin: I64,
    sa_group_end: I64
};

impl NFAStateAction: ToString {
    to_string = |a| (
        if a.is_sa_none { "none" };
        if a.is_sa_char_match { a.as_sa_char_match.to_string };
        if a.is_sa_assert { a.as_sa_assert.to_string };
        if a.is_sa_group_begin { "<g" + a.as_sa_group_begin.to_string + ">" };
        if a.is_sa_group_end { "</g" + a.as_sa_group_end.to_string + ">" };
        ""
    );
}

// An NFA state
type NFAState = unbox struct {
    id: I64,                    // state id
    action: NFAStateAction,     // action
    output_on_action: I64,      // next state when the action succeeded
    output: I64,                // next state with empty string
    output2: I64,               // next state with empty string part 2
    label: String               // a label to display
};

namespace NFAState {
    // An invalid state ID.
    _ID_NONE: I64;
    _ID_NONE = -1;

    // An empty state
    empty: NFAState;
    empty = NFAState {
        id: _ID_NONE,
        action: sa_none(),
        output_on_action: _ID_NONE,
        output: _ID_NONE,
        output2: _ID_NONE,
        label: ""
    };
}

impl NFAState: ToString {
    to_string = |state| (
        "("
        + state.@id.to_string + ":"
        + state.@action.to_string + ":"
        + state.@output_on_action.to_string + ","
        + state.@output.to_string + ","
        + state.@output2.to_string + ":"
        + state.@label
        + ")"
    );
}


// NFA Fragment
type NFAFrag = unbox struct {
    input: I64,                 // state id of input of this fragment
    set_output: I64 -> NFA -> NFA,  // a function to set state id of output
                                    // of this fragment
    label: String               // a label to display
};

namespace NFAFrag {

    // `nfa.compile_pattern(pattern)` compiles a pattern to a NFAFrag.
    compile_pattern: Pattern -> NFA -> (NFA, NFAFrag);
    compile_pattern = |pat, nfa| (
        if pat.is_pclass {
            let action = sa_char_match (pat.as_pclass);
            nfa._compile_action(action)
        };
        if pat.is_psequence {
            let patterns = pat.as_psequence;
            if patterns.get_size == 0 {
                nfa._compile_null_sequence
            };
            if patterns.get_size == 1 {
                nfa.compile_pattern(patterns.@(0))
            };
            let (nfa, frag1) = nfa.compile_pattern(
                psequence $ patterns.pop_back);
            let (nfa, frag2) = nfa.compile_pattern(
                patterns.get_last.as_some);
            nfa._compile_seq(frag1, frag2)
        };
        if pat.is_peither {
            let (pat1, pat2) = pat.as_peither;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa.compile_pattern(pat2);
            nfa._compile_either(frag1, frag2)
        };
        if pat.is_pquant {
            let (pat1, min, max) = pat.as_pquant;
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            if (min == 0 && max == 1) {
                nfa._compile_zero_or_once(frag1)
            };
            if (min == 0 && max == I64::maximum) {
                nfa._compile_zero_or_more(frag1)
            };
            if (min == 1 && max == I64::maximum) {
                nfa._compile_one_or_more(frag1)
            };
            if (min >= 2) {
                let (nfa, frag2) = nfa.compile_pattern(pquant $
                        (pat1, min - 1,
                            if max == I64::maximum { max } else { max - 1}
                        )
                );
                // TODO: frag1 の中にグループがあったら？
                nfa._compile_seq(frag1, frag2)
            };
            eval assert (|_|"invalid quantifier: min=" + min.to_string, false);
            (nfa, frag1)
        };
        if pat.is_pgroup {
            let (n, pat1) = pat.as_pgroup;
            let (nfa, frag0) = nfa._compile_action(sa_group_begin(n));
            let (nfa, frag1) = nfa.compile_pattern(pat1);
            let (nfa, frag2) = nfa._compile_action(sa_group_end(n));
            let (nfa, frag) = nfa._compile_seq(frag0, frag1);
            let (nfa, frag) = nfa._compile_seq(frag, frag2);
            (nfa, frag)
        };
        if pat.is_passert {
            nfa._compile_action(sa_assert(pat.as_passert))
        };
        eval assert (|_|"invalid pattern:" + pat.to_string, false);
        nfa._compile_action(sa_none())
    );

    _compile_action: NFAStateAction -> NFA -> (NFA, NFAFrag);
    _compile_action = |action, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_action(action));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output_on_action(out))
            ),
            label: action.to_string
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // ``
    _compile_null_sequence: NFA -> (NFA, NFAFrag);
    _compile_null_sequence = |nfa| (
        let (nfa, id) = nfa.new_state;
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output(out))
            ),
            label: "``"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e1 e2`
    _compile_seq: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_seq = |frag1, frag2, nfa| (
        let nfa = nfa.set_frag_output(frag1, frag2.@input);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag2, out)
            ),
            label: frag1.@label + frag2.@label
        };
        (nfa, frag)
    );

    // `e1|e2`
    _compile_either: NFAFrag -> NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_either = |frag1, frag2, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.mod_state(id, set_output2(frag2.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.set_frag_output(frag1, out)
                   .set_frag_output(frag2, out)
            ),
            label: frag1.@label + "|" + frag2.@label
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)

    );

    // `e?`
    _compile_zero_or_once: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_once = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                let nfa = nfa.set_frag_output(frag1, out);
                nfa.mod_state(id, set_output2(out))
            ),
            label: frag1.@label + "?"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e*`
    _compile_zero_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_zero_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: id,
            set_output: |out, nfa| (
                nfa.mod_state(id,set_output2(out))
            ),
            label: frag1.@label + "*"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );

    // `e+`
    _compile_one_or_more: NFAFrag -> NFA -> (NFA, NFAFrag);
    _compile_one_or_more = |frag1, nfa| (
        let (nfa, id) = nfa.new_state;
        let nfa = nfa.mod_state(id, set_output(frag1.@input));
        let nfa = nfa.set_frag_output(frag1, id);
        let frag = NFAFrag {
            input: frag1.@input,
            set_output: |out, nfa| (
                nfa.mod_state(id, set_output2(out))
            ),
            label: frag1.@label + "+"
        };
        let nfa = nfa.mod_state(id, set_label(frag.@label));
        (nfa, frag)
    );
}

// Matched group
type Group = unbox struct {
    begin: I64,         // position of the start of the group
    end: I64            // position of the end of the group
};

impl Group: ToString {
    to_string = |group| (
        "Group{"
        + "begin:" + group.@begin.to_string
        + ", end:" + group.@end.to_string
        + "}"
    ) ;
}

// The array of matched groups
type GroupArray = Array (Option Group);


// NFA State set, used for NFA state transition
type NFAStateSet = unbox struct {
    ordered: Array (I64, GroupArray),   // array of state id and groups
    mask: Array Bool       // mask whether id is contained or not
};

namespace NFAStateSet {

    // `NFAStateSet::empty(n)` creates an empty state set.
    // `n` is number of NFA states.
    empty: I64 -> NFAStateSet;
    empty = |n| NFAStateSet {
        ordered: Array::empty(n),
        mask:  Array::fill(n, false)
    };

    // Checks whether the state set is empty.
    is_empty: NFAStateSet -> Bool;
    is_empty = |state_set| (
        state_set.@ordered.is_empty
    );

    // Checks whether the state set contains a state.
    contains: I64 -> NFAStateSet -> Bool;
    contains = |id, state_set| (
        state_set.@mask.@(id)
    );

    // Adds a state to the state set.
    add: (I64, GroupArray) -> NFAStateSet -> NFAStateSet;
    add = |(id, groups), state_set| (
        if state_set.contains(id) { state_set };
        let state_set = state_set.mod_ordered(push_back((id, groups)));
        let state_set = state_set.mod_mask(set(id, true));
        state_set
    );

    get_groups: I64 -> NFAStateSet -> Option GroupArray;
    get_groups = |id, state_set| (
        state_set.@ordered.to_iter.filter(|(id1,_)| id1 == id)
        .get_first
        .map(|(id, groups)| groups)
    );
}

// The NFA executor
type NFAExecutor = unbox struct {
    stream: Stream,            // stream of characters
    nfa: NFA,                       // NFA
    empty_state_set: NFAStateSet,   // an empty state set
    state_set: NFAStateSet,         // current state set
    stack: Iterator (I64, GroupArray) // temporary stack for transition
};

namespace NFAExecutor {
    // Creates an executor.
    make: Stream -> NFA -> NFAExecutor;
    make = |stream, nfa| (
        let empty_state_set = NFAStateSet::empty(nfa.@states.get_size);
        let groups: GroupArray = Array::fill(nfa.@group_count, none());
        let state_set = empty_state_set.add((nfa.@initial_state, groups));
        NFAExecutor {
            stream: stream,
            nfa: nfa,
            empty_state_set: empty_state_set,
            state_set: state_set,
            stack: Iterator::empty
        }
    );

    execute: NFAExecutor -> Option GroupArray;
    execute = |executor| (
        loop(
            executor, |executor|
            let executor = executor.transition_with_empty_string;
            if executor.@state_set.contains(executor.@nfa.@accepting_state) {
                let opt = executor.@state_set.get_groups(executor.@nfa.@accepting_state);
                eval assert (|_|"not found groups", opt.is_some);
                break $ some $ opt.as_some   // match success
                // TODO: 現状では受理状態になったらループを抜けるため、最短一致になる。
            };
            executor.@stream.advance.map_or(
                break $ none(),  // failed to match
                |(c, stream)|
                let executor = executor.transition_with_char(c);
                let executor = executor.set_stream(stream);
                eval debug_println("stream position="+stream.@position.to_string);
                continue $ executor
            )
        )
    );

    transition_with_empty_string: NFAExecutor -> NFAExecutor;
    transition_with_empty_string = |executor| (
        let executor = executor._init_transition;
        loop(
            executor, |executor|
            let opt = executor._pop_stack;
            if opt.is_none {
                break $ executor
            };
            let ((id, groups), executor) = opt.as_some;
            let state = executor.@nfa.get_state(id);
            let executor = executor._transition(state.@output, groups);
            let executor = executor._transition(state.@output2, groups);
            let executor = executor._transition_on_action(state, state.@output_on_action, groups);
            continue $ executor
        )
    );

    _init_transition: NFAExecutor -> NFAExecutor;
    _init_transition = |executor| (
        executor.set_stack(executor.@state_set.@ordered.to_iter)
    );

    _pop_stack: NFAExecutor -> Option ((I64, GroupArray), NFAExecutor);
    _pop_stack = |executor| (
        executor.@stack.advance.map(|(id_groups, next)|
            (id_groups, executor.set_stack(next))
        )
    );

    // Adds state id to the state set, then pushes id to the stack.
    _transition: I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition = |id, groups, executor| (
        if id == _ID_NONE {
            executor
        };
        if executor.@state_set.contains(id) {
            executor
        };
        eval debug_eprintln("transition " + id.to_string + " groups="+groups.to_string);
        executor
            .mod_state_set(add((id, groups)))
            .mod_stack(push_front((id, groups)))
    );
    
    _transition_on_action: NFAState -> I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition_on_action = |state, id, groups, executor| (
        let action = state.@action;
        if action.is_sa_assert {
            executor._transition_with_passert(action.as_sa_assert, id, groups)
        };
        if action.is_sa_group_begin {
            let group_idx = action.as_sa_group_begin;
            let begin = executor.@stream.@position;
            let group = Group { begin: begin, end: -1 };
            let groups = groups.set(group_idx, some(group));
            executor._transition(id, groups)
        };
        if action.is_sa_group_end {
            let group_idx = action.as_sa_group_end;
            let begin = groups.@(group_idx).map_or(-1, |group| group.@begin);
            let end = executor.@stream.@position;
            let group = Group { begin: begin, end: end };
            let groups = groups.set(group_idx, some(group));
            executor._transition(id, groups)
        };
        executor
    );

    _transition_with_passert: PAssertion -> I64 -> GroupArray -> NFAExecutor -> NFAExecutor;
    _transition_with_passert = |pa, id, groups, executor| (
        if pa.is_pa_begin && executor.@stream.@position == 0 {
            executor._transition(id, groups)
        };
        if pa.is_pa_end && executor.@stream.@iter.is_empty {
            executor._transition(id, groups)
        };
        executor
    );

    transition_with_char: U8 -> NFAExecutor -> NFAExecutor;
    transition_with_char = |char, executor| (
        let old_states = executor.@state_set.@ordered.to_iter;
        let executor = old_states.fold(
            // Clear new state set
            executor.set_state_set(executor.@empty_state_set),
            |executor, (id, groups)|
            // For each old state:
            let state = executor.@nfa.get_state(id);
            let action = state.@action;
            if !action.is_sa_char_match {
                executor
            };
            if !action.as_sa_char_match.contains(char) {
                executor
            };

            // note: stack is not used
            executor._transition(state.@output_on_action, groups)
        );
        let executor = executor.set_stack(Iterator::empty);
        executor
    );
}

type RegExp = unbox struct {
    pattern: Pattern,
    flags: String, // TODO: support flags
    nfa: NFA
};

namespace RegExp {

    compile: String -> String -> Result ErrMsg RegExp;
    compile = |pattern, flags| (
        let pattern = *parse_pattern.run_parser_str(pattern).map(|(p,_)| p);
        let pattern = pgroup $ (0, pattern); // since whole pattern is group 0
        let nfa = NFA::compile(pattern);
        eval debug_eprintln(nfa.to_string);
        ok $ RegExp { pattern: pattern, flags: flags, nfa:nfa }
    );

    exec: String -> RegExp -> Result ErrMsg (Array String);
    exec = |target, regexp| (
        let stream: Stream = *from_string(target);
        let opt = regexp.@nfa.execute(stream);
        eval debug_eprintln("regexp.@nfa.execute done");
        if opt.is_none {
            err $ _NotMatch
        };
        let groups: GroupArray = opt.as_some;
        let groups: Array String = groups.to_iter.map(|opt|
            opt.map_or("", 
                |group| 
                if group.@begin < 0 || group.@end < 0 { "" };
                target.substring(group.@begin, group.@end)
            )
        ).to_array;
        ok $ groups
    );
}

check_regexp: String -> String -> Array String -> IO ();
check_regexp = |pattern, target, expected| (
    let _ = *println("===============================================");
    let _ = *println("pattern=" + pattern);
    let _ = *println("target=" + target);

    let res = do {
        let regexp = *RegExp::compile(pattern, "");
        //let res: Result ErrMsg (Array String) = regexp.exec(target);
        let groups: Array String = *regexp.exec(target);
        let lines = groups.to_iter.zip(Iterator::count_up(0)).map(
            |(group, i)| "group[" + i.to_string + "]=" + group.to_string + "\n"
        ).concat_iter;
        let actual = groups;
        let lines = if expected != actual {
            lines + "ERROR: expected="+expected.to_string+" actual="+actual.to_string + "\n"
        } else { lines };
        pure $ lines
    };
    if res.is_ok {
        println(res.as_ok)
    } else {
        println("ERROR: " + res.as_err)
    }
);

main: IO ();
main = (
    let _ = *check_regexp(".*([ade])+", "abcdef", ["abcde", "e"]);
    /*
    let _ = *check_regexp(".*", "abcdef", ["abcdef"]);
    let _ = *check_regexp(".*([ade]+)", "abcdef", ["abcde", "de"]);
    let _ = *check_regexp("\\w+", "abcd,efg", ["abcd"]);
    let _ = *check_regexp("\\s*(\\w+)\\s*", "  abc d,e fg ", ["  abc ", "abc"]);
    let _ = *check_regexp(".*(bc|c*df*e)", "abcccdef", ["abcccde", "de"]);
    */
    pure()
);
