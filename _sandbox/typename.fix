module Main;

import Minilib.Common.Common;

type Phantom a = unbox struct {};

phantom: Phantom a = Phantom{};

trait a: ToTypename {
    to_typename: Phantom a -> String;
}

impl I8: ToTypename { to_typename = |_| "I8"; }
impl I16: ToTypename { to_typename = |_| "I16"; }
impl I32: ToTypename { to_typename = |_| "I32"; }
impl I64: ToTypename { to_typename = |_| "I64"; }
impl U8: ToTypename { to_typename = |_| "U8"; }
impl U16: ToTypename { to_typename = |_| "U16"; }
impl U32: ToTypename { to_typename = |_| "U32"; }
impl U64: ToTypename { to_typename = |_| "U64"; }
impl F32: ToTypename { to_typename = |_| "F32"; }
impl F64: ToTypename { to_typename = |_| "F64"; }
impl Ptr: ToTypename { to_typename = |_| "Ptr"; }

impl String: ToTypename { to_typename = |_| "String"; }

impl [a: ToTypename] Array a: ToTypename {
    to_typename = |_| "(Array " + (phantom: Phantom a).to_typename + ")";
}

impl [a: ToTypename] Option a: ToTypename {
    to_typename = |_| "(Option " + (phantom: Phantom a).to_typename + ")";
}

impl [e: ToTypename, a: ToTypename] Result e a: ToTypename {
    to_typename = |_| "(Result " + (phantom: Phantom e).to_typename + " " + (phantom: Phantom a).to_typename + ")";
}

impl [a: ToTypename] IO a: ToTypename {
    to_typename = |_| "(IO " + (phantom: Phantom a).to_typename + ")";
}

impl [a: ToTypename] IOFail a: ToTypename {
    to_typename = |_| "(IOFail " + (phantom: Phantom a).to_typename + ")";
}

impl [a: ToTypename, b: ToTypename] Arrow a b: ToTypename {
    to_typename = |_| "(" + (phantom: Phantom a).to_typename + " -> " + (phantom: Phantom b).to_typename + ")";
}

impl (): ToTypename { 
    to_typename = |_| "()"; 
}
impl [a: ToTypename] (a, ): ToTypename { 
    to_typename = |_| "(" + (phantom: Phantom a).to_typename + ",)"; 
}

impl [a: ToTypename, b: ToTypename] (a, b): ToTypename { 
    to_typename = |_| "(" + (phantom: Phantom a).to_typename + "," + (phantom: Phantom b).to_typename +")"; 
}

impl [a: ToTypename, b: ToTypename, c: ToTypename] (a, b, c): ToTypename { 
    to_typename = |_| "("
    + (phantom: Phantom a).to_typename
    + "," + (phantom: Phantom b).to_typename 
    + "," + (phantom: Phantom c).to_typename 
    + ")"; 
}


test1: [a: ToTypename] a -> a;
test1 = |a| (
    eval debug_eprintln("test1: " + (phantom: Phantom a).to_typename);
    a
);

test_typename: IO ();
test_typename = (
    println("=== test_typename ===");;
    (phantom: Phantom I64).to_typename.println;;
    (phantom: Phantom (I64 -> Array String)).to_typename.println;;
    (phantom: Phantom (Result ErrMsg ())).to_typename.println;;
    42.test1.to_string.println;;
    pure()
);

type TypedPtr = unbox struct {
    typename: String,
    dtor: Destructor Ptr,   // retained ptr of `Box a`
};

namespace TypedPtr {
    to_typed_ptr: [a: ToTypename] a -> TypedPtr;
    to_typed_ptr = |a| (
        TypedPtr {
            typename: (phantom: Phantom a).to_typename,
            dtor: Destructor::make(
                Box::make(a).boxed_to_retained_ptr,             // retain ptr
                |ptr|
                if ptr == nullptr { pure $ nullptr };
                eprintln("TypedPtr: destructor is called: ptr=" + ptr.to_string);;
                let ba: Box a = ptr.boxed_from_retained_ptr;    // release ptr
                pure $ nullptr
            )
        }
    );

    get: [a: ToTypename] TypedPtr -> (TypedPtr, a);
    get = |typed_ptr| (
        let typename = (phantom: Phantom a).to_typename;
        if typename != typed_ptr.@typename {
            undefined("from_typed_ptr: type mismatch: typed_ptr:" + typed_ptr.@typename + " target:" + typename)
        };
        typed_ptr.act_dtor(
            |dtor| dtor.mutate_unique(
                |ptr| eprintln("mutate_unique ctor");; pure $ ptr,   // should call boxed_to_retained_ptr?
                |ptr| eprintln("mutate_unique action");; let ba: Box a = ptr.boxed_from_retained_ptr; pure $ ba.@value
            ).swap
        ).swap
    );
}

type Obj = box struct {
    data: Destructor I64,
};

impl Obj: ToTypename { 
    to_typename = |_| "Obj"; 
}

impl Obj: ToString {
    to_string = |obj| obj.@data.borrow(to_string);
}

namespace Obj {
    make: I64 -> Obj;
    make = |i| Obj { 
        data: Destructor::make(i, 
            |i| eprintln("destructor is called: i=" + i.to_string);; 
            pure $ 0
        )
    };
}

make_typed_ptrs: () -> (TypedPtr, TypedPtr, TypedPtr);
make_typed_ptrs = |_| (
    let pa = "abc".to_typed_ptr;
    let pb = Obj::make(123).to_typed_ptr;
    let pc = Obj::make(234).to_typed_ptr;
    (pa, pb, pc)
);

test_typed_ptr: IO ();
test_typed_ptr = (
    println("=== test_typed_ptr ===");;
    let (pa, pb, pc) = make_typed_ptrs();
    range(0,2).fold_m(
        (pa, pb, pc), |_, (pa, pb, pc)|
        let (pa, a: String) = pa.get;
        let (pb, b: Obj) = pb.get;
        let (pc, c: Obj) = pc.get;   // retain されたまま
        eprintln("a="+ a.to_string + " b=" + b.to_string);;
        pure $ (pa, pb, pc)
    ).forget
);

main: IO () = (
    test_typename;;
    test_typed_ptr;;
    pure()
);
