// Tested platform: x86_64-linux-gnu, aarch64-linux-gnu
// WARNING: IPv6 is not supported yet.

module Tcp;

import Debug;

get_sub_ex: I64 -> I64 -> Array a -> Array a;
get_sub_ex = |s, e, array| (
    let s = max(0, s);
    let e = max(s, min(array.get_size, e));
    if s == 0 && e == array.get_size {
        array
    };
    array.get_sub(s,e)
);

_perror: String -> IO ();
_perror = |str| (
    pure $ str.borrow_c_str(|ptr|
        CALL_C[() perror(Ptr), ptr]
    )
);


type IpAddress = unbox struct {
    addr: Array U8
};

impl IpAddress: FromString {
    // Parse host string (eg. "127.0.0.1" -> [127_U8, 0_U8, 0_U8, 1_U8])
    from_string = |host| (
        let host_split = host.split(".").to_array;
        if host_split.get_size != 4 {
            err $ "Invalid host format: " + host
        }; 
        let addr: Array U8 = Array::fill(4, 0_U8);
        loop_m (
            (addr, 0), |(addr, i)|
            if i >= 4 {
                break_m $ IpAddress { addr: addr }
            };
            let res: Result ErrMsg U8 = from_string(host_split.@(i));
            if res.is_err {
                err $ "Invalid host format: " + host + ": " + res.as_err
            };
            let addr = addr.set(i, res.as_ok);
            continue_m $ (addr, i + 1)
        )
    );
}

impl IpAddress: ToString {
    to_string = |ipaddress| (
        let addr = ipaddress.@addr;
        addr.@(0).to_string + "." + addr.@(1).to_string + "." + 
        addr.@(2).to_string + "." + addr.@(3).to_string
    );
}

type HostEnt = unbox struct {
    data: Array U8,
    buf: Array U8
};

namespace HostEnt {
    _hostent_size: I64;
    _hostent_size = 32;

    // Extract an I32 value, ie. *(u32_t*)(ptr + offset)
    _get_I32: Ptr -> I64 -> I32;
    _get_I32 = |ptr, offset| (
        let a_i32 = Array::fill(1, 0_I32);
        eval a_i32.borrow_ptr(|p_i32|
            CALL_C[() memcpy(Ptr,Ptr,U64), p_i32, ptr.add_offset(offset), 4_U64]
        );
        a_i32.@(0)
    );

    // Extract an Ptr value, ie. *(void**)(ptr + offset)
    _get_Ptr: Ptr -> I64 -> Ptr;
    _get_Ptr = |ptr, offset| (
        let a_ptr = Array::fill(1, nullptr);
        eval a_ptr.borrow_ptr(|p_ptr|
            CALL_C[() memcpy(Ptr,Ptr,U64), p_ptr, ptr.add_offset(offset), 8_U64]
        );
        a_ptr.@(0)
    );

    _gethostbyname_r: String -> IOFail HostEnt;
    _gethostbyname_r = |host| (
        let ret: Array U8 = Array::fill(_hostent_size, 0_U8);    
        let buf: Array U8 = Array::fill(1024, 0_U8);
        let buflen = buf.get_size.to_U64;
        let result: Array Ptr = Array::fill(1, nullptr);
        let h_errornop: Array I32 = Array::fill(1, 0_I32);
        let res = host.borrow_c_str(|p_host| 
            ret.borrow_ptr(|p_ret|
                buf.borrow_ptr(|p_buf|
                    result.borrow_ptr(|p_result|
                        h_errornop.borrow_ptr(|p_h_errornop|
                            CALL_C[I32 gethostbyname_r(Ptr,Ptr,Ptr,U64,Ptr,Ptr),
                                p_host, p_ret, p_buf, buflen, p_result, p_h_errornop]
                        )
                    )
                )
            )
        );
        if res != 0_I32 {
            let _ = *_perror("gethostbyname_r").lift;
            throw $ "gethostbyname_r failed: " + host
        };
        let hostent: Ptr = result.@(0);
        if hostent == nullptr {
            throw $ "gethostbyname_r failed (hostent == nullptr): " + host
        };
        // hostent and ret._get_ptr should be same pointer, but Ptr does not implement Eq.
        //eval ret.borrow_ptr(|p_ret|
        //    assert (hostent == p_ret)
        //);
        pure $ HostEnt { data: ret, buf: buf }
    );

    // get `h_length` field of the hostent.
    get_h_length: HostEnt -> I64;
    get_h_length = |hostent| (
        hostent.@data.borrow_ptr(|p_hostent|
            _get_I32(p_hostent, 20).to_I64
        )
    );

    // get `h_addr_list[index]` field of the hostent.
    get_h_addr: I64 -> HostEnt -> IpAddress;
    get_h_addr = |index, hostent| (
        let h_addr_list: Ptr = (                    // char**
            hostent.@data.borrow_ptr(|p_hostent|
                _get_Ptr(p_hostent, 24)
            )
        );
        let h_addr: Ptr = (                         // char*
            _get_Ptr(h_addr_list, 8 * index)
        );

        let addr = Array::fill(4, 0_U8);
        eval addr.borrow_ptr(|p_addr|
            CALL_C[() memcpy(Ptr,Ptr,U64), p_addr, h_addr, 4_U64]
        );
        IpAddress { addr: addr }
    );
}

namespace IpAddress {
    // Resolve a hostname such as "127.0.0.1" or "www.example.com".
    resolve: String -> IOFail IpAddress;
    resolve = |host| (
        // 最初に xxx.xxx.xxx.xxx 形式で解釈する
        let res: Result ErrMsg IpAddress = from_string(host);
        if res.is_ok {
            res.from_result
        };
        let hostent = *_gethostbyname_r(host);
        let h_length = hostent.get_h_length;
        if h_length < 1 {
            throw $ "resolve_host: h_length < 1: " + host
        };
        let ipaddress = hostent.get_h_addr(0);
        pure $ ipaddress
    );
}

type Port = unbox struct { port: U16 };

impl Port: FromString
{
    // Parse port string (eg. "8080" -> 8080_U16)
    from_string = |port_str| (
        let res: Result ErrMsg U16 = from_string(port_str);
        if res.is_err {
            err $ "Invalid port: " + port_str + ": " + res.as_err
        };
        ok $ Port { port: res.as_ok }
    );
}

impl Port: ToString
{
    to_string = |port| port.@port.to_string;
}

namespace SocketAddress {
    _sockaddr_in_size: I64;
    _sockaddr_in_size = 16;

    type SocketAddress = unbox struct {
        sockaddr_in: Array U8
    };

    _unsafe_from_array: Array U8 -> SocketAddress;
    _unsafe_from_array = |array| (
        SocketAddress { sockaddr_in: array }
    );

    make: IpAddress -> Port -> SocketAddress;
    make = |ipaddress, port| (
        //eval debug_eprintln("ipaddress="+ipaddress.to_string + " port="+port.to_string);
        let addr = ipaddress.@addr;
        let port = port.@port;
        let port_h: U8 = port.shift_right(8_U16).bit_and(255_U16).to_U8;
        let port_l: U8 = port.bit_and(255_U16).to_U8;
        //eval debug_eprintln ("port_h="+port_h.to_string+" port_l="+port_l.to_string);
        let sockaddr_in = [
            2_U8, 0_U8, // sin_family = _AF_INET, host byte order
            port_h, port_l, // sin_port
            addr.@(0), addr.@(1), addr.@(2), addr.@(3), // sin_addr
            0_U8, 0_U8, 0_U8, 0_U8,
            0_U8, 0_U8, 0_U8, 0_U8
        ];
        SocketAddress { sockaddr_in: sockaddr_in }
    );

    resolve: String -> IOFail SocketAddress;
    resolve = |host_port| (
        let split = host_port.split(":").to_array;
        if split.get_size <= 0 || split.get_size > 2 {
            throw $ "Invalid host_port format: " + host_port
        };
        let host = split.@(0);
        let port = if split.get_size == 2 { split.@(1) } else { "80" }; // default HTTP
        let ipaddress: IpAddress = *IpAddress::resolve(host);
        let port: Port = *from_string(port).from_result;
        pure $ SocketAddress::make(ipaddress, port)
    );
}

impl SocketAddress : ToString {
    to_string = |socket_address| (
        let sa = socket_address.@sockaddr_in;
        let port = sa.@(2).to_U16.shift_left(8_U16).bit_or(sa.@(3).to_U16).to_string;
        let addr = sa.@(4).to_string + "." + sa.@(5).to_string + "." + 
            sa.@(6).to_string + "." + sa.@(7).to_string;
        addr + ":" + port
    );
}

type Socket = unbox struct {
    data: Destructor I32
};

impl Socket: ToString {
    to_string = |socket| (
        socket.@data.borrow (|fd| "Socket{fd:" + fd.to_string + "}")
    );        
}

namespace Socket {
    // from /usr/include/x86_64-linux-gnu/bits/
    _AF_INET: I32;
    _AF_INET = 2_I32;

    _SOCK_STREAM: I32;
    _SOCK_STREAM = 1_I32;

    make_tcp_socket: () -> IOFail Socket;
    make_tcp_socket = |_| (
        let sockfd = CALL_C[I32 socket(I32, I32, I32), _AF_INET, _SOCK_STREAM, 0.to_I32];
        if sockfd < 0_I32 {
            let _ = *_perror("socket").lift;
            throw $ "creating socket failed"
        };
        let data = Destructor::make(sockfd, |sockfd|
            //eval debug_eprintln ("closing sockfd: " + sockfd.to_string);
            eval CALL_C[I32 close(I32), sockfd];
            ()
        );
        pure $ Socket { data: data }
    );

    bind: SocketAddress -> Socket -> IOFail ();
    bind = |socket_address, socket| (
        let addr = socket_address.@sockaddr_in;
        let ret = socket.@data.borrow (|fd|
            addr.borrow_ptr(|p_addr| 
                CALL_C[I32 bind(I32, Ptr, U32), fd, p_addr, addr.get_size.to_U32]
            )
        );
        if ret == -1_I32 {
            let _ = *_perror("bind").lift;
            throw $ "bind failed"
        };
        pure $ ()
    );

    listen: I64 -> Socket -> IOFail ();
    listen = |backlog, socket| (
        let ret = socket.@data.borrow (|fd|
            CALL_C[I32 listen(I32, I32), fd, backlog.to_I32]
        );
        if ret == -1_I32 {
            let _ = *_perror("listen").lift;
            throw $ "listen failed"
        };
        pure $ ()
    );

    accept: Socket -> IOFail (Socket, SocketAddress);
    accept = |socket| (
        let addr: Array U8 = Array::fill(_sockaddr_in_size, 0_U8);
        let addrlen: Array U32 = Array::fill(1, 0_U32);
        let addrlen = addrlen.set(0, addr.get_size.to_U32);
        let fd = socket.@data.borrow(|sockfd|
            addr.borrow_ptr(|p_addr|
                addrlen.borrow_ptr(|p_addrlen|
                    CALL_C[I32 accept(I32, Ptr, Ptr), sockfd, p_addr, p_addrlen]
                )
            )
        );
        if fd == -1_I32 {
            let _ = *_perror("accept").lift;
            throw $ "accept failed"
        };
        //eval debug_eprintln ("accepted fd="+fd.to_string+" addrlen="+addrlen.@(0).to_string);
        let remote_address : SocketAddress = (
            let len = addrlen.@(0).to_I64;
            let addr = addr.get_sub_ex(0, len);
            SocketAddress::_unsafe_from_array(addr)
        );
        let accepted_socket : Socket = (
            Socket {
                data: Destructor::make(fd, |fd|
                    //eval debug_eprintln ("closing sockfd: " + fd.to_string);
                    eval CALL_C[I32 close(I32), fd];
                    ()
                )
            }
        );
        pure $ (accepted_socket, remote_address)
    );

    connect: SocketAddress -> Socket -> IOFail ();
    connect = |remote_address, socket| (
        let addr = remote_address.@sockaddr_in;
        let addrlen = addr.get_size;
        let ret = socket.@data.borrow(|fd|
            addr.borrow_ptr(|p_addr| 
                CALL_C[I32 connect(I32, Ptr, U32), fd.to_I32, p_addr, addrlen.to_U32]
            )
        );
        if ret == -1_I32 {
            let _ = *_perror("connect").lift;
            throw $ "connect failed"
        };
        pure $ ()
    );

    send: Array U8 -> Socket -> IOFail I64;
    send = |bytes, socket| (
        let size_to_send = bytes.get_size.to_U64;
        let flags = 0_I32;
        let size = socket.@data.borrow(|fd|
            bytes.borrow_ptr(|p_bytes| 
                CALL_C[I64 send(I32, Ptr, U64, I32), fd, p_bytes, size_to_send, flags]
            )
        );
        if size == -1 {
            let _ = *_perror("send").lift;
            throw $ "send failed"
        };
        pure $ size
    );

    recv: I64 -> Socket -> IOFail (Array U8);
    recv = |size_to_recv, socket| (
        let bytes = Array::fill(size_to_recv, 0_U8);
        let flags = 0_I32;
        let size = socket.@data.borrow(|fd|
            bytes.borrow_ptr(|p_bytes| 
                CALL_C[I64 recv(I32, Ptr, U64, I32), fd, p_bytes, size_to_recv.to_U64, flags]
            )
        );
        if size == -1 {
            let _ = *_perror("recv").lift;
            throw $ "recv failed"
        };
        let bytes =  bytes.get_sub_ex(0, size);
        pure $ bytes
    );
}

type BufferedSocket = unbox struct {
    socket: Socket,
    write_buf: Array U8,
    read_buf: Array U8,
    eof: Bool
};

namespace BufferedSocket {
    _BUFSIZE: I64;
    _BUFSIZE = 1024;

    make: Socket -> BufferedSocket;
    make = |socket| (
        BufferedSocket {
            socket: socket,
            write_buf: Array::empty(_BUFSIZE),
            read_buf: Array::empty(_BUFSIZE),
            eof: false
        }
    );

    write_str: String -> BufferedSocket -> IOFail BufferedSocket;
    write_str = |str, bufsock| (
        let bytes = str.get_bytes.pop_back;
        let bufsock = bufsock.mod_write_buf(|buf| buf.append(bytes));
        if bufsock.@write_buf.get_size < _BUFSIZE {
            pure $ bufsock
        };
        bufsock.flush
    );

    flush: BufferedSocket -> IOFail BufferedSocket;
    flush = |bufsock| (
        loop_m(
            bufsock, |bufsock|
            let bytes = bufsock.@write_buf;
            let size_to_write = bytes.get_size;
            if size_to_write <= 0 {
                break_m $ bufsock
            };
            let socket = bufsock.@socket;
            let size = *socket.send(bytes);
            //eval debug_eprintln("size="+size.to_string+ " to="+size_to_write.to_string);
            let bytes = bytes.get_sub_ex(size, size_to_write);
            let bufsock = bufsock.set_write_buf(bytes);
            continue_m $ bufsock
        )
    );

    read_line: BufferedSocket -> IOFail (String, BufferedSocket);
    read_line = |bufsock| (
        loop_m(
            bufsock, |bufsock|
            let read_buf = bufsock.@read_buf;
            if bufsock.@eof {
                let line: String = read_buf.push_back(0_U8)._unsafe_from_c_str;
                let bufsock = bufsock.set_read_buf(Array::empty(1));
                break_m $ (line, bufsock)
            };
            let index = read_buf.find_by(|b| b == '\n');
            if index.is_some {
                let index = index.as_some;
                let line = read_buf.get_sub_ex(0, index + 1);
                let line: String = line.push_back(0_U8)._unsafe_from_c_str;
                let read_buf = read_buf.get_sub_ex(index + 1, read_buf.get_size);
                let bufsock = bufsock.set_read_buf(read_buf);
                break_m $ (line, bufsock)
            };
            let socket = bufsock.@socket;
            let bytes = *socket.recv(_BUFSIZE);
            let bufsock = bufsock
                .set_read_buf(read_buf.append(bytes))
                .set_eof(bytes.get_size == 0);
            continue_m $ bufsock
        )
    );
}

connect_to_tcp_server: String  -> IOFail Socket;
connect_to_tcp_server = |host_port| (
    let socket_address: SocketAddress = *SocketAddress::resolve(host_port);
    let socket = *Socket::make_tcp_socket();
    let _ = *socket.connect(socket_address);
    pure $ socket
);

listen_tcp_server: String -> I64 -> IOFail Socket;
listen_tcp_server = |server_host_port, backlog| (
    let socket_address: SocketAddress = *SocketAddress::resolve(server_host_port);
    let socket: Socket = *Socket::make_tcp_socket();
    let _ = *socket.bind(socket_address);
    let _ = *socket.listen(backlog);
    pure $ socket
);
