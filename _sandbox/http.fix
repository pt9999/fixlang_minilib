module Main;

import Debug;

import Tcp;
import SimpleParser;
import StringEx;
import HashMap;

type URL = unbox struct {
    url: String,
    scheme: String,
    host: String,
    port: String,
    path: String
};

namespace URL {
    _cut: String -> String -> (String, String);
    _cut = |delim, str| (
        let pos = str.find(delim, 0);
        if pos.is_none {
            (str, "")
        };
        let pos = pos.as_some;
        (str.substring(0, pos), str.substring(pos + delim.get_size, str.get_size))
    );

    parse: String -> Result ErrMsg URL;
    parse = |url| (
        let (scheme, rest) = if url.find("://", 0).is_some {
            url._cut("://")
        } else {
            ("http", url)
        };
        let (host_port, path) = rest._cut("/");
        let path = if path == "" { "/" } else { "/" + path };
        
        let (host, port) = host_port._cut(":");
        let port = if port == "" { "80" } else { port };
        
        ok $ URL { url:url, scheme:scheme, host:host, port:port, path:path }
    );

}

namespace URI {
    _unreserved_table: Array U8 = (
        let chars = "-._~".get_bytes.pop_back.to_iter.append $
            Iterator::seq('A').take(26).append $
            Iterator::seq('a').take(26).append $
            Iterator::seq('0').take(10);
        chars.fold(Array::fill(256, 0_U8), |array, c|
            array.set(c.to_I64, 1_U8)
        )
    );
    _hex: Array U8 = "0123456789ABCDEF".get_bytes.pop_back;
        
    encodeURIComponent: String -> String;
    encodeURIComponent = |str| (
        str.get_bytes.pop_back.fold(
            Array::empty(str.get_size * 3), |array, c|
            if _unreserved_table.@(c.to_I64) != 0_U8 {
                array.push_back(c)
            };
            array.push_back('%')
            .push_back(_hex.@(c.shift_right(4_U8).bit_and(15_U8).to_I64))
            .push_back(_hex.@(c.bit_and(15_U8).to_I64))
        )
        ._unsafe_from_array
    );

}


type Header = (String, String);

type Headers = unbox struct {
    map: HashMap String String
};

impl Headers: ToString {
    to_string = |headers| headers.@map.to_string;
}

namespace Headers {
    empty: Headers;
    empty = Headers { map: HashMap::empty(100) };

    add: Header -> Headers -> Headers;
    add = |(name, value), headers| (
        headers.mod_map(|map| map.insert (name, value))
    );

    find: String -> Headers -> Option String;
    find = |name, headers| (
        headers.@map.find(name)
    );

    to_iter: Headers -> Iterator Header;
    to_iter = |headers| headers.@map.to_iter;
}

type Request = unbox struct {
    connection: BufferedSocket,
    remote_addr: SocketAddress,
    method: String,             // eg. "GET"
    request_target: String,     // eg. "/blogs/search?q=hello%25world&limit=30"
    http_version: String,       // eg. "HTTP/1.1"
    headers: Headers,
    body: Array U8
};

impl Request: ToString {
    to_string = |request| (
        "Request {"
        + " connection: " + connection.to_string
        + " remote_addr:" + request.@remote_addr.to_string
        + ", method:" + request.@method
        + ", request_target:" + request.@request_target
        + ", http_version:" + request.@http_version
        + ", headers:" + request.@headers.to_string
        //+ ", body:" + request.@body.to_string
        + " }"
    );
}

namespace Request {
    parse: BufferedSocket -> SocketAddress -> IOFail Request;
    parse = |connection, remote_addr| (
        let start_line = (*connection.read_line).strip_last_newlines;
        let (method, request_target, http_version) = 
            *match_request_line.run_parser_str(line).from_result;
        let headers = loop_m (
            Array::empty(100), |headers| 
            let line = (*connection.read_line).strip_last_newlines;
            if line == "" {
                break_m $ headers
            };
            let header = *match_header.run_parser_str(line).from_result;
            continue_m $ headers.add(header)
        );
        // TODO read body
        // TODO parse query string

        let request = Request {
            connection: connection,
            remote_addr: remote_addr,
            method: method,
            request_target: request_target,
            http_version: http_version,
            headers: headers,
            body: Array::empty(0)
        };
        pure $ request
    );

    match_request_line: Parser (String, String, String);
    match_request_line = (
        let method = *match_str_class(|c| c != ' ');
        let _ = *match_char(' ');
        let request_target = *match_str_class(|c| c != ' ');
        let _ = *match_char(' ');
        let http_version = *match_str_class(|c| c != ' ');
        pure $ (method, request_target, http_version)
    );

    match_header: Parser Header;
    match_header = (
        let field_name = *match_str_class(|c| c != ':');
        let _ = *match_char(':');
        let field_value = *match_str_class(|c| true);
        let field_value = field_value.strip_whitespaces;
        (field_name, field_value)
    );



}

type Response = unbox struct {
    request: Request,
    connection: BufferedSocket,
    http_version: String,
    status: I64,
    reason: String,
    headers: Headers,
    headersSent: Bool
};

namespace Response {
    make: Request -> Response;
    make = |req| (
        Response {
            request: req,
            connection: req.@connection,
            http_version: req.@http_version,
            status: 200,
            reason: "",
            headers: Headers::empty,
            headersSent: false
        }
    );

    status: I64 -> Response -> Response;
    status = set_status;

    _send_headers: Response -> IOFail Response;
    _send_headers = |res| (
        if res.@headersSent {
            pure $ res
        };
        let status_line = res.@http_version + " " + 
            res.@status.to_string + " " + res.@reason + "\r\n";
        let _ = *res.@connection.write_str(status_line);
        let _ = *res.@headers.to_iter.fold_m(
            (), |_, header|
            let (name, value) = header;
            res.@connection.write_str(name + ":" + value + "\r\n")
        );
        let _ = *res.@connection.write_str("\r\n");
        let res = res.set_headersSent(true);
        pure $ res
    );

    write_str: String -> Response -> IOFail Response;
    write_str = |str, res| (
        let res = *res._send_headers;
        let _ = *res.@connection.write_str(str);
        pure $ res
    );

    end: Response -> IOFail ();
    end = |res| (
        let _ = *res.@connection.flush;
        pure $ ()
    );
}

type RequestHandler = Request -> Response -> IOFail Response;

type Router = unbox struct {
    map: HashMap (String, String) RequestHandler
};

namespace Router {
    type Node = unbox union {
        branch: HashMap String Node,
        leaf: RequestHandler
    };
    namespace Node {
        empty: Node;
        empty = branch $ HashMap::new(0);

        insert: Iterator String -> RequestHandler -> Node -> Node;
        insert: |components, handler, node| (
            if components.is_empty {
                leaf $ handler
            };
            let (component, next) = component.advance.as_some;
            let node = if node.is_branch { node } else {
                // leafだった場合は branch に変更される。
                // leaf が branch の "" に入る。
                let map = HashMap::empty(0).insert("", node);
                branch $ map
            };
            let opt = node.as_branch.find(component);
            if opt.is_none
        );
    }

    empty: Router;
    empty = Router {
        map: HashMap::empty(100)
    };

    add: String -> String -> RequestHandler -> Router -> Router;
    add = |method, path, callback, router| (
        router.mod_map(|map| map.insert((method, path), callback))
    );

    route: Request -> Response -> Router -> IOFail Response;
    route = |req, res, router| (
        // TODO: split query and path
        // TODO: lookup hierarchy
        let opt = router.@map.find(req.request_target);
        xxx
    );

    _split_target: String -> (String, String);
    _split_target
    /*
        /               ... [ ]
        /about.html     ... [ "about.html" ]
        /users          ... [ "users" ]
        /users/         ... [ "users" ]
        /users/:id      ... [ "users", ":id" ]
        /users/:id/     ... [ "users", ":id" ]
    */
}


type Worker = unbox struct {
    app: App
};

namespace Worker {
    make: App -> Worker;
    make = |app| (
        Worker {
            app: app
        }
    );
    handle: Socket -> SocketAddress -> Worker -> IOFail ();
    handle = |socket, remote_addr, worker| (
        let app = worker.@app;
        let connection = BufferedSocket::make(socket);
        let request = *Request::parse(connection, remote_addr);
        let response = Response::make(request);
        let response = *app.@router.route(request, response);
        let _ = *response.end();
        pure $ ()        
    );
}

type App = unbox struct {
    router: Router,
    backlog: I64
};

namespace App {
    empty: App;
    empty = (
        App {
            router: Router::empty,
            backlog: 10
        }
    );

    mount: String -> String -> RequestHandler -> App -> IOFail App;
    mount = |method, path, callback, app| (
        pure $ app.mod_router(|router|
            router.add(method, path, callback)
        )
    );

    get: String -> RequestHandler -> App -> IOFail App;
    get = mount("GET");

    listen: String -> App -> IOFail ();
    listen = |server_host_port, app| (
        let socket = *(listen_tcp_server(server_host_port, app.@backlog));
        let _ = *(lift $ eprintln ("Listening on " + server_host_port));
        let tasks: Array I64 = Array::empty(0);
        loop_m(
            tasks, |tasks|
            let _ = *(lift $ eprintln ("Accepting connections"));
            let (accepted_socket, addr) = *(socket.accept);
            let _ = *(lift $ eprintln ("Accepted new connection: addr=" + addr.to_string));
            let worker = Worker::make(app);
            if true {
                let _ = *worker.handle(accepted_socket, addr);
                continue_m $ tasks
            } else {
                /*
                //let _ = *(lift $ eprintln ("creating task"));
                let task = AsyncIOTask::make(
                    worker.handle(accepted_socket, addr)
                    .try(|err| eprintln("error: " + err))
                );
                //let _ = *(lift $ eprintln ("creating task done"));
                let tasks = tasks.push_back(task);
                */
                continue_m $ tasks
            }
        )
    );
}

main: IO ();
main = (
    do {
        let app = App::empty;
        let app = *app.get("/", |req,res| res.write_str("Hello") );
        app.listen("localhost:8080")
    }
    .try(|err| eprintln("ERROR: " + err))
);


