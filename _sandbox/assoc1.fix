// From the paper "Associated type synomyms".
// https://www.researchgate.net/publication/221241277_Associated_type_synonyms
// DOI:10.1145/1086365.1086397
module Main;

// 2.1 Formatting: type functions compute function types
type IntField next = unbox struct { next: next };
type CharField next = unbox struct { next: next };
type ConstStr next = unbox struct { data: String, next: next };

trait fspec: FormatSpec {
    type Formatter fspec;
    to_formatter: String -> fspec -> Formatter fspec;
}
impl String: FormatSpec {
    type Formatter String = String;
    to_formatter = |prefix, str| prefix + str;
}
impl [a: FormatSpec] IntField a: FormatSpec {
    type Formatter (IntField a) = I64 -> Formatter a;
    to_formatter = |prefix, fspec, i| to_formatter(prefix + i.to_string, fspec.@next);
}
impl [a: FormatSpec] CharField a: FormatSpec {
    type Formatter (CharField a) = U8 -> Formatter a;
    to_formatter = |prefix, fspec, c| to_formatter(prefix + [c, 0_U8]._unsafe_from_c_str.to_string, fspec.@next);
}
impl [a: FormatSpec] ConstStr a: FormatSpec {
    type Formatter (ConstStr a) = Formatter a;
    to_formatter = |prefix, fspec| to_formatter(prefix + fspec.@data, fspec.@next);
}

int_field: [next: FormatSpec] next -> IntField next;
int_field = |next| IntField { next: next };

char_field: [next: FormatSpec] next -> CharField next;
char_field = |next| CharField { next: next };

const_str: [next: FormatSpec] String -> next -> ConstStr next;
const_str = |str, next| ConstStr { data: str, next: next };

sprintf: [fspec: FormatSpec] fspec -> Formatter fspec;
sprintf = to_formatter("");

test_sprintf: IO ();
test_sprintf = (
    let format_spec : ConstStr (IntField (ConstStr (CharField String)))
        = const_str("Int: ") $ int_field $ const_str(" Char: ") $ char_field $ ".";
    let msg = sprintf(format_spec, 123, 'a');
    println(msg)
);

main: IO ();
main = test_sprintf;

