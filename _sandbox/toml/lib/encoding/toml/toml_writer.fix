module Minilib.Encoding.Toml.TomlWriter;

import Minilib.Common.Common;
import Minilib.Text.StringEx;
import Minilib.Encoding.Toml;

trait a: TomlWrite {
    toml_write: a -> String -> String;
}

impl String: TomlWrite {
    toml_write = |s, out| (
        out + s
    );
}

impl Toml: TomlWrite {
    toml_write = |toml, out| (
        let iter = toml.to_iter;
        let out = iter.filter(|(k, v)| !(v.is_v_table || v.is_v_array_table || v.is_v_none)).fold(
            out, |(k, v), out|
            out.toml_write_kv(k, v)
        );
        // TODO: recursively extract table names with dotted keys
        let out = iter.filter(|(k, v)| v.is_v_table).fold(
            out, |(k, v), out|
            out.toml_write_table(k, v.as_v_table)
        );
        let out = iter.filter(|(k, v)| v.is_v_array_table).fold(
            out, |(k, v), out|
            out.toml_write_array_table(k, v.as_v_array_table)
        );
        out
    );
}

toml_write_key: TomlKey -> String -> String;
toml_write_key = |key| (
    toml_write(key)     // TODO: escape keys
);

toml_write_kv: TomlKey -> TomlVal -> String -> String;
toml_write_kv = |key, val| (
    toml_write_key(key) >>
    toml_write(" = ") >>
    toml_write(val) >>                       // TODO inline table? array? array of table?
    toml_write("\n")
);

toml_write_table: TomlKey -> TomlTable -> String -> String;
toml_write_table = |key, table, out| (
    let out = out.toml_write("[" + key + "]\n");        // TODO escape, dotted keys
    let iter = table.to_iter;
    iter.fold(
        out, |(k, v), out|
        out.toml_write_kv(k, v)
    )
);

toml_write_array_table: TomlKey -> Array TomlTable -> String -> String;
toml_write_array_table = |key, array_table, out| (
    array_table.to_iter.fold(
        out, |table, out|
        toml_write_table("[" + key + "]", table, out)
    )
);

impl TomlTable: TomlWrite {
    toml_write = |table, out| (
        let out = out.toml_write("{");
        let out = table.to_iter.zip(count_up(0)).fold(
            out, |((key, val), i), out|
            out.mod_if(i != 0, toml_write(", "))
            .toml_write_key(key)
            .toml_write(" = ")
            .toml_write(val)
        );
        out.toml_write("}")
    );
}

impl TomlArray: TomlWrite {
    toml_write = |array, out| (
        let out = out.toml_write("[");
        let out = array.to_iter.zip(count_up(0)).fold(
            out, |(val, i), out|
            out.mod_if(i != 0, toml_write(", "))
            .toml_write(val)
        );
        out.toml_write("]")
    );
}

impl TomlVal: TomlWrite {
    toml_write = |val, out| (
        match val {
            v_none() => (
                out.toml_write("(none)")                // should not be written to toml file
            ),
            v_string(str) => (
                out.toml_write("\"" + str + "\"")       // TODO: basic-string, ml-basic-string, literal-string, ml-literal-string
            ),
            v_int(i64) => (
                out.toml_write(i64.to_string)           // TODO: ok?
            ),
            v_float(f64) => (
                out.toml_write(f64.to_string)           // TODO: ok?
            ),
            v_bool(bool) => (
                out.toml_write(bool.to_string)           // TODO: ok?
            ),
            v_array(array) => (
                out.toml_write(array)
            ),
            v_table(table) => (
                out.toml_write(table)
            ),
            // TODO: support v_array_table
            v_array_table(_) => undefined("not impl"),
        }
    );
}
