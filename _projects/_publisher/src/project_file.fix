module Publisher.ProjectFile;

import RegExp;

import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Text.StringEx;

import Publisher.Fs;
import Publisher.ConsoleUi;
import Publisher.Verup;

type ProjectFileField = unbox struct {
    key: String,
    value: String,
    line_index: I64,
};

namespace ProjectFileField {
    make: String -> String -> I64 -> ProjectFileField;
    make = |key, value, line_index| ProjectFileField {
        key: key,
        value: value,
        line_index: line_index
    };

    unquote: ProjectFileField -> String;
    unquote = |field| field.@value.replace_all("\"", "");
}

type ProjectFile = unbox struct {
    filepath: Path,
    lines: Array String,
};

namespace ProjectFile {
    make: Path -> Array String -> ProjectFile;
    make = |path, lines| ProjectFile {
        filepath: path,
        lines: lines
    };

    from_file: [m: MonadFs] Path -> m ProjectFile;
    from_file = |path| (
        let contents = *fs_read_file_string(path);
        let lines = contents.split("\n").to_array;
        pure $ ProjectFile::make(path, lines)
    );

    save: [m: MonadFs, m: MonadConsoleUi] ProjectFile -> m ();
    save = |project_file| (
        let contents = project_file.@lines.to_iter.join("\n");
        fs_write_file_string(project_file.@filepath, contents);;
        ui_println("Wrote " + project_file.@filepath)
    );

    find_field: [m: MonadError] String -> String -> ProjectFile -> m ProjectFileField;
    find_field = 
        |section_to_find, key_to_find, project_file| (
        let regexp_section = *RegExp::compile("^\\[(.*)\\]$", "").lift_result;
        let section = "";
        let lines = project_file.@lines;
        loop_m(
            (section, 0), |(section, line_index)|
            if line_index >= lines.get_size {
                error $ "field not found: " + section_to_find + "." + key_to_find
            };
            let line = lines.@(line_index);
            let res = regexp_section.match_one(line);
            if res.is_ok {
                let groups = res.as_ok;
                let section = groups.@(1);
                continue_m $ (section, line_index + 1)
            };
            let (key, value) = line.split_first("=");
            let key = key.strip_spaces;
            let value = value.strip_spaces;
            if section == section_to_find && key == key_to_find {
                break_m $ ProjectFileField::make(key, value, line_index)
            };
            continue_m $ (section, line_index + 1)
        )
    );

    get_project_name: [m: MonadError, m: Functor] ProjectFile -> m String;
    get_project_name = |project_file| (
        project_file.find_field("general", "name").map(unquote)
    );

    get_project_version: [m: MonadError, m: Functor] ProjectFile -> m String;
    get_project_version = |project_file| (
        project_file.find_field("general", "version").map(unquote)
    );

    set_project_version: [m: MonadError, m: Functor] String -> ProjectFile -> m ProjectFile;
    set_project_version = |version, project_file| (
        let field = *project_file.find_field("general", "version");
        let line = field.@key + " = \"" + version + "\"";
        pure $ project_file[^lines][field.@line_index].iset(line)
    );

    upgrade_project_version: [m: MonadConsoleUi, m: MonadFs] Path -> String -> Bool -> m String;
    upgrade_project_version = |project_file_path, new_version, confirm| (
        let project_file = *ProjectFile::from_file(project_file_path);
        let project_name = *project_file.get_project_name;
        let old_version = *project_file.get_project_version;
        let new_version = *if new_version != "" { 
            pure $ new_version
        } else {
            increment_version(old_version).lift_result
        };
        let new_version = *if confirm {
            ask_new_version(project_name, new_version)
        } else {
            pure $ new_version
        };
        when(confirm,
            confirm_upgrade(old_version, new_version)
        );;
        let project_file = *project_file.set_project_version(new_version);
        project_file.save;;
        pure $ new_version
    );
}
