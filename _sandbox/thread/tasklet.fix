module Main;

import AsyncTask;
import Minilib.Common.TimeEx;
import Minilib.Thread.Future;
import Minilib.Thread.TaskPool;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Monad.Trans;
import Minilib.Trait.Traversable;

type RIO e a = ReaderT e IOFail a;

trait e: HasTaskPool {
    get_taskpool: e -> Var TaskPool;
}

impl Var TaskPool: HasTaskPool {
    get_taskpool = |e| e;
}

trait pool: MakeFuture {
    make_future: [m: MonadIOFail] IO a -> pool -> m (Future a);
}

impl Var TaskPool: MakeFuture {
    make_future = |io, var_pool| (
        var_pool.lock(|pool|
            Future::make(pool, io).to_result
        ).from_io_result.lift_iofail
    );
}

make_future_rio: [e: HasTaskPool] IOFail a -> RIO e (Future (Result ErrMsg a));
make_future_rio = |iof| (
    let var_pool = (*ask).get_taskpool;
    var_pool.make_future(iof.to_result)
);

type Tasklet e a = unbox union {
    tl_pure: a,
    tl_rio: RIO e (Future (Result ErrMsg a))
};

namespace Tasklet {
    from_rio: RIO e (Future (Result ErrMsg a)) -> Tasklet e a;
    from_rio = Tasklet::tl_rio;

    from_iofail: [e: HasTaskPool] IOFail a -> Tasklet e a;
    from_iofail = |iof| (
        Tasklet::from_rio $ make_future_rio $ iof
    );

    to_rio_future: [e: HasTaskPool] Tasklet e a -> RIO e (Future (Result ErrMsg a));
    to_rio_future = |tasklet| (
        match tasklet {
            tl_pure(a) => make_future_rio(pure(a)),
            tl_rio(rio) => rio
        }
    );

    then: [e: HasTaskPool] (a -> Tasklet e b) -> Tasklet e a -> Tasklet e b;
    then = |f, tasklet| (
        match tasklet {
            tl_pure(a) => f(a),
            tl_rio(rio) => Tasklet::from_rio $ do {
                let env = *ask;
                let iof = do {
                    let future = *rio.run_reader_t(env);
                    let res_a = *future.get.lift_iofail;
                    match res_a {
                        err(e) => (
                            err(e).from_result
                        ),
                        ok(a) => (
                            let tasklet = f(a);
                            let res = *tasklet.get.run_reader_t(env);
                            res.from_result
                        )
                    }
                };
                make_future_rio(iof)
            }
        }
    );

    catch: [e: HasTaskPool] (ErrMsg -> IOFail a) -> Tasklet e a -> Tasklet e a;
    catch = |f, tasklet| (
        match tasklet {
            tl_pure(a) => tl_pure(a),
            tl_rio(rio) => Tasklet::from_rio $ do {
                let future = *rio;
                let iof = do {
                    let res_a = *future.get;
                    match res_a {
                        err(e) => f(e),
                        ok(a) => pure $ a
                    }
                };
                make_future_rio(iof)
            }
        }
    );

    get: [e: HasTaskPool] Tasklet e a -> RIO e (Result ErrMsg a);
    get = |tasklet| (
        match tasklet {
            tl_pure(a) => pure $ pure $ a,
            tl_rio(rio) => (
                let future = *rio;
                future.get.lift_iofail
            )
        }
    );

    get_all: [e: HasTaskPool] Array (Tasklet e a) -> RIO e (Array (Result ErrMsg a));
    get_all = |tasklets| (
        // start all futures
        let futures = *tasklets.to_iter.map(to_rio_future).collect_m;
        // wait for all futures
        futures.to_iter.map(get).collect_m.lift_iofail
    );
}

impl [e: HasTaskPool] Tasklet e: Monad {
    pure = |a| tl_pure(a);
    bind = Tasklet::then;
}

impl [e: HasTaskPool] Tasklet e: MonadIOIF {
    lift_io = lift >> lift_iofail;
}

impl [e: HasTaskPool] Tasklet e: MonadIOFailIF {
    lift_iofail = Tasklet::from_iofail;
}


test1: IO ();
test1 = do {
    println("=== test1 ===").lift;;
    let rio: RIO (Var TaskPool) () = do {
        let tasklets = range(0,8).map(|i|
            let tasklet = Tasklet::from_iofail(do {
                println(i.to_string + " sleep start").lift;;
                usleep((300 * 1000 * (10-i)).to_U32);;
                println(i.to_string + " sleep end").lift;;
                if i % 2 == 1 { throw $ "fail" + i.to_string };
                pure $ i
            });
            let tasklet = tasklet.then(|i| pure $ "success" + i.to_string);
            let tasklet = tasklet.catch(|err| pure $ "error:" + err);
            let tasklet = tasklet.then(|str| println(str).lift_io);
            tasklet
        ).to_array;
        tasklets.get_all.forget;;
        //usleep(10000000_U32).lift_iofail;;
        pure()
    };
    let pool = *TaskPool::make(30).lift;    // Deadlocks if too few tasks are created
    let var_pool = *Var::make(pool).lift;
    rio.run_reader_t(var_pool)
}.try(eprintln);

main: IO () = test1;
