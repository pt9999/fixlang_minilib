module Main;

import Debug;

import Minilib.Collection.Queue;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

test_push_pop: TestCase;
test_push_pop = (
    make_test("test_push_pop") $ |_|
    let q = Queue::empty;
    let _ = *assert_equal("0:empty", true, q.is_empty);

    let q = q.push(1);
    let _ = *assert_equal("1:empty", false, q.is_empty);

    let q = q.push(2);
    
    let opt = q.pop;
    let _ = *assert_equal("2:pop is some", true, opt.is_some);
    let (x,q) = opt.as_some;
    let _ = *assert_equal("2:pop value", 1, x);

    let q = q.push(3);

    let opt = q.pop;
    let _ = *assert_equal("3:pop is some", true, opt.is_some);
    let (x,q) = opt.as_some;
    let _ = *assert_equal("3:pop value", 2, x);

    let opt = q.pop;
    let _ = *assert_equal("4:pop is some", true, opt.is_some);
    let (x,q) = opt.as_some;
    let _ = *assert_equal("4:pop value", 3, x);

    let opt = q.pop;
    let _ = *assert_equal("5:pop is none", true, opt.is_none);
    let _ = *assert_equal("5:empty", true, q.is_empty);

    pure()
);

test_perf: TestCase;
test_perf = (
    make_test("test_perf") $ |_|
    let n = 100000;
    let (_, time) = consumed_time_while(|_|
        let q = Queue::empty;
        let q = Iterator::range(0, n).fold(q, |q, i| q.push(i));
        let q = Iterator::range(0, n).fold(q, |q, i| 
            let (x, q) = q.pop.as_some;
            q
        );
        ()
    , ());
    let _ = *eprintln("n="+n.to_string+" time=" + time.to_string).lift;
    pure()
);

main: IO ();
main = (
    [
        test_push_pop,
        test_perf
    ]
    .run_test_driver
);

