module Main;

import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Encoding.Binary;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

map_0: (a -> b) -> (a, c) -> (b, c);
map_0 = |f, (a, c)| (f(a), c);

type U24 = unbox struct {
    v: U32
};

namespace U24 {
    to_U24: U32 -> U24;
    to_U24 = |v| U24 { v: v.bit_and(0xFFFFFF_U32) };

    to_U32: U24 -> U32;
    to_U32 = |u24| u24.@v.bit_and(0xFFFFFF_U32);

    // Gets U24 from the byte buffer at position `i`.
    get_u24: I64 -> ByteBuffer -> U24;
    get_u24 = |i, buf| (
        eval assert(|_| "only big endian is supported", buf.@byte_order.is_big_endian);
        let array = buf.@array;
        array.get_u8_be(i).to_U32.shift_left(16_U32).bit_or(
            array.get_u16_be(i + 1).to_U32
        )
        .to_U24
    );

    // Sets U24 into the byte buffer at position `i`.
    set_u24: I64 -> U24 -> ByteBuffer -> ByteBuffer;
    set_u24 = |i, val, buf| (
        eval assert(|_| "only big endian is supported", buf.@byte_order.is_big_endian);
        buf.mod_array(|array|
            let val = val.to_U32;
            array.set_u8_be(i, val.shift_right(16_U32).to_U8)
                .set_u16_be(i + 1, val.to_U16)
        )
    );
}

impl U24: Marshal {
    marshal = |val, buf| buf._marshal(set_u24, 3, val);
}

impl U24: Unmarshal {
    unmarshal = |buf| buf._unmarshal(get_u24, 3);
}

trait a: GetByteSize {
    get_byte_size: a -> I64;
}

impl U8: GetByteSize {
    get_byte_size = |_| 1;
}

impl U16: GetByteSize {
    get_byte_size = |_| 2;
}

impl U24: GetByteSize {
    get_byte_size = |_| 3;
}

impl U32: GetByteSize {
    get_byte_size = |_| 4;
}

impl [a: GetByteSize] Array a: GetByteSize {
    get_byte_size = |arr| (
        arr.to_iter.map(get_byte_size).fold(0, add)
    );
}

namespace Vector {
    marshal_fixed: [a: Marshal] Array a -> ByteBuffer -> ByteBuffer;
    marshal_fixed = |vector, buf| (
        let n = vector.get_size;
        loop(
            (buf, 0), |(buf, i)|
            if i >= n { break $ buf };
            let buf = buf.marshal(vector.@(i));
            continue $ (buf, i + 1)
        )
    );

    marshal_var_size: [a: Marshal, sz: Marshal] Array a -> (I64 -> sz) -> ByteBuffer -> ByteBuffer;
    marshal_var_size = |vector, to_size, buf| (
        let size_pos = buf.get_position;
        let buf = buf.marshal(0.to_size);
        let begin_pos = buf.get_position;
        let buf = buf.marshal_fixed(vector);
        let end_pos = buf.get_position;
        let buf = buf.set_position(size_pos);
        let buf = buf.marshal((end_pos - begin_pos).to_size);
        let buf = buf.set_position(end_pos);
        buf
    );

    unmarshal_fixed: [a: Unmarshal] I64 -> ByteBuffer -> (Array a, ByteBuffer);
    unmarshal_fixed = |byte_size, buf| (
        let begin_pos = buf.get_position;
        loop(
            (buf, []), |(buf, vector)|
            let pos = buf.get_position;
            if pos - begin_pos >= byte_size { break $ (vector, buf) };
            let (val, buf) = buf.unmarshal;
            let vector = vector.push_back(val);
            continue $ (buf, vector)
        )
    );

    unmarshal_var_size: [a: Unmarshal, sz: Unmarshal] (sz -> I64) -> ByteBuffer -> (Array a, ByteBuffer);
    unmarshal_var_size = |from_size, buf| (
        let (size, buf) = buf.unmarshal;
        let byte_size = size.from_size;
        buf.unmarshal_fixed(byte_size)
    );
}

type Handshake = unbox union {
    client_hello: ClientHello,
    server_hello: (),
    new_session_ticket: (),
    end_of_early_data: (),
    encrypted_extensions: (),
    certificate: (),
    certificate_request: (),
    certificate_verify: (),
    finished: (),
    key_update: (),
    message_hash: ()
};

type HandhshakeType = U8;

namespace Handshake {
    get_msg_type: Handshake -> HandhshakeType;
    get_msg_type = |h| (
        if h.is_client_hello { 1_U8 };
        if h.is_server_hello { 2_U8 };
        if h.is_new_session_ticket { 4_U8 };
        if h.is_end_of_early_data { 5_U8 };
        if h.is_encrypted_extensions { 8_U8 };
        if h.is_certificate { 11_U8 };
        if h.is_certificate_request { 13_U8 };
        if h.is_certificate_verify { 15_U8 };
        if h.is_finished { 20_U8 };
        if h.is_key_update { 24_U8 };
        if h.is_message_hash { 254_U8 };
        eval assert(|_| "unknown msg_type", false);
        0_U8
    );

    _marshal_body: Handshake -> ByteBuffer -> ByteBuffer;
    _marshal_body = |h, buf| (
        if h.is_client_hello { buf.marshal(h.as_client_hello) };
        buf
    );
}

impl Handshake: Marshal {
    marshal = |h, buf| (
        let buf = buf.marshal(h.get_msg_type);
        let length_pos = buf.get_position;
        let buf = buf.marshal(0_U32.to_U24);
        let buf = buf._marshal_body(h);
        let last_pos = buf.get_position;
        let buf = buf.set_position(length_pos);
        let buf = buf.marshal((last_pos - (length_pos + 3)).to_U32.to_U24);
        let buf = buf.set_position(last_pos);
        buf
    );
}


type ProtocolVersion = U16;
type CipherSuite = U16;

type ClientHello = unbox struct {
    legacy_version: ProtocolVersion,        // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id: Array U8,            // <0..32>
    cipher_suites: Array CipherSuite,       // <2..2^16-2>
    legacy_compression_method: Array U8,    // <1..2^8-1>
    extensions: Array Extension            // <8..2^16-1>
};

namespace ClientHello {
    make: SecureRandom -> IOFail ClientHello;
    make = |secure_random| (
        let (random, _) = *secure_random.generate_bytes(32);
        let random = Array::fill(32, 0x0a_U8);
        pure $ ClientHello {
            legacy_version: 0x0303_U16,
            random: random,
            legacy_session_id: [],
            cipher_suites: [],
            legacy_compression_method: [ 0_U8 ],
            extensions: []
        }
    );
}

impl ClientHello: Marshal {
    marshal = |msg, buf| (
        let buf = buf.marshal(msg.@legacy_version);
        let buf = buf.marshal_fixed(msg.@random);
        let buf = buf.marshal_var_size(msg.@legacy_session_id, to_U8);
        let buf = buf.marshal_var_size(msg.@cipher_suites, to_U16);
        let buf = buf.marshal_var_size(msg.@legacy_compression_method, to_U8);
        let buf = buf.marshal_var_size(msg.@extensions, to_U16);
        buf
    );
}

type ServerHello = unbox struct {
    legacy_version: ProtocolVersion,        // = 0x0303
    random: Array U8,                       // [32]
    legacy_session_id_echo: Array U8,       // <0..32>
    cipher_suite: CipherSuite,              //
    legacy_compression_method: U8,          // = 0
    extensions: Array Extension            // <6..2^16-1>
};

impl ServerHello: Unmarshal {
    unmarshal = |buf| (
        let (legacy_version:U16, buf) = buf.unmarshal;
        let (random:Array U8, buf) = buf.unmarshal_fixed(32);
        let (legacy_session_id_echo:Array U8, buf) = buf.unmarshal_var_size(U8::to_I64);
        let (cipher_suite, buf) = buf.unmarshal;
        let (legacy_compression_method, buf) = buf.unmarshal;
        let (extensions, buf) = buf.unmarshal_var_size(U16::to_I64);
        let msg = ServerHello {
            legacy_version: legacy_version,
            random: random,
            legacy_session_id_echo: legacy_session_id_echo,
            cipher_suite: cipher_suite,
            legacy_compression_method: legacy_compression_method,
            extensions: extensions
        };
        (msg, buf)
    );
}

type ExtensionType = U16;
type Extension = unbox union {
    unknown_extension: ExtensionType,
    server_name: (),
    max_fragment_length: (),
    status_request: (),
    supported_groups: NamedGroupList,
    signature_algorithms: (),
    use_srtp: (),
    heartbeat: (),
    application_layer_protocol_negotiation: (),
    signed_certificate_timestamp: (),
    client_certificate_type: (),
    server_certificate_type: (),
    padding: (),
    pre_shared_key: (),
    early_data: (),
    supported_versions: SupportedVersions,
    cookie: (),
    psk_key_exchange_modes: (),
    certificate_authorities: (),
    oid_filters: (),
    post_handshake_auth: (),
    signature_algorithms_cert: (),
    key_share: ()
};

namespace Extension {
    get_extension_type: Extension -> ExtensionType;
    get_extension_type = |ex| (
        if ex.is_unknown_extension { ex.as_unknown_extension.to_I64 };
        if ex.is_server_name { 0 };
        if ex.is_max_fragment_length { 1 };
        if ex.is_status_request { 5 };
        if ex.is_supported_groups { 10 };
        if ex.is_signature_algorithms { 13 };
        if ex.is_use_srtp { 14 };
        if ex.is_heartbeat { 15 };
        if ex.is_application_layer_protocol_negotiation { 16 };
        if ex.is_signed_certificate_timestamp { 18 };
        if ex.is_client_certificate_type { 19 };
        if ex.is_server_certificate_type { 20 };
        if ex.is_padding { 21 };
        if ex.is_pre_shared_key { 41 };
        if ex.is_early_data { 42 };
        if ex.is_supported_versions { 43 };
        if ex.is_cookie { 44 };
        if ex.is_psk_key_exchange_modes { 45 };
        if ex.is_certificate_authorities { 47 };
        if ex.is_oid_filters { 48 };
        if ex.is_post_handshake_auth { 49 };
        if ex.is_signature_algorithms_cert { 50 };
        if ex.is_key_share { 51 };
        eval assert(|_| "invalid extension type", false);
        65535
    ).to_U16;
}

impl Extension: Marshal {
    marshal = |ex, buf| (
        let buf = buf.marshal(ex.get_extension_type);
        let size_pos = buf.get_position;
        let buf = buf.marshal(0_U16);       // size
        let buf = (
            if ex.is_supported_groups { buf.marshal(ex.as_supported_groups) };
            if ex.is_supported_versions { buf.marshal(ex.as_supported_versions) };
            buf
        );
        let last_pos = buf.get_position;
        let buf = buf.set_u16(size_pos, (last_pos - (size_pos + 2)).to_U16);
        buf
    );
}

impl Extension: Unmarshal {
    unmarshal = |buf| (
        let (extension_type, buf) = buf.unmarshal;
        let (extension_data_size: U16, buf) = buf.unmarshal;

        if extension_type == 10_U16 { buf.unmarshal.map_0(supported_groups) };
        if extension_type == 43_U16 { buf.unmarshal.map_0(supported_versions) };

        // skip unknown extension data
        let buf = buf.set_position(buf.get_position + extension_data_size.to_I64);
        (unknown_extension(extension_type), buf)
    );
}

// 4.2.1 Supported Versions
type SupportedVersions = unbox struct {
    versions: Array ProtocolVersion
};

impl SupportedVersions: Marshal {
    marshal = |obj, buf| (
        // for ClientHello
        buf.marshal_var_size(obj.@versions, to_U8)
    );
}

impl SupportedVersions: Unmarshal {
    unmarshal = |buf| (
        // for ServerHello, HelloRetryRequest
        buf.unmarshal.map_0(|version|
            SupportedVersions { versions: [ version ] }
        )
    );
}

// 4.2.3. Signature Algorithms
type SignatureScheme = U16;

namespace SignatureScheme {
    table: Array (String, SignatureScheme);
    table = [
        /* RSASSA-PKCS1-v1_5 algorithms */
        ("rsa_pkcs1_sha256", 0x0401_U16),
        ("rsa_pkcs1_sha384", 0x0501_U16),
        ("rsa_pkcs1_sha512", 0x0601_U16),

        /* ECDSA algorithms */
        ("ecdsa_secp256r1_sha256", 0x0403_U16),
        ("ecdsa_secp384r1_sha384", 0x0503_U16),
        ("ecdsa_secp521r1_sha512", 0x0603_U16),

        /* RSASSA-PSS algorithms with public key OID rsaEncryption */
        ("rsa_pss_rsae_sha256", 0x0804_U16),
        ("rsa_pss_rsae_sha384", 0x0805_U16),
        ("rsa_pss_rsae_sha512", 0x0806_U16),

        /* EdDSA algorithms */
        ("ed25519", 0x0807_U16),
        ("ed448", 0x0808_U16),

        /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
        ("rsa_pss_pss_sha256", 0x0809_U16),
        ("rsa_pss_pss_sha384", 0x080a_U16),
        ("rsa_pss_pss_sha512", 0x080b_U16),

        /* Legacy algorithms */
        ("rsa_pkcs1_sha1", 0x0201_U16),
        ("ecdsa_sha1", 0x0203_U16)
    ];

    find_by_name: String -> Option SignatureScheme;
    find_by_name = |name| (
        table.find_by(@0 >> eq(name)).map(@1)
    );

    find_by_id: SignatureScheme -> Option String;
    find_by_id = |id| (
        table.find_by(@1 >> eq(id)).map(@0)
    );
}

type SignatureSchemeList = unbox struct {
    v: Array SignatureScheme
};

impl SignatureSchemeList: Marshal {
    marshal = |obj, buf| (
        buf.marshal_var_size(obj.@v, to_U16)
    );
}

impl SignatureSchemeList: Unmarshal {
    unmarshal = |buf| (
        buf.unmarshal_var_size(U16::to_I64).map_0(|v|
            SignatureSchemeList { v: v }
        )
    );
}

// 4.2.7 Supported Groups
type NamedGroup = U16;

namespace NamedGroup {
    table: Array (String, NamedGroup);
    table = [
        /* Elliptic Curve Groups (ECDHE) */
        ("secp256r1", 0x0017_U16),
        ("secp384r1", 0x0018_U16),
        ("secp521r1", 0x0019_U16),
        ("x25519", 0x001D_U16),
        ("x448", 0x001E_U16),

        /* Finite Field Groups (DHE) */
        ("ffdhe2048", 0x0100_U16),
        ("ffdhe3072", 0x0101_U16),
        ("ffdhe4096", 0x0102_U16),
        ("ffdhe6144", 0x0103_U16),
        ("ffdhe8192", 0x0104_U16)
    ];

    find_by_name: String -> Option NamedGroup;
    find_by_name = |name| (
        table.find_by(@0 >> eq(name)).map(@1)
    );

    find_by_id: NamedGroup -> Option String;
    find_by_id = |id| (
        table.find_by(@1 >> eq(id)).map(@0)
    );
}

type NamedGroupList = unbox struct {
    v: Array NamedGroup
};

impl NamedGroupList: Marshal {
    marshal = |obj, buf| (
        buf.marshal_var_size(obj.@v, to_U16)
    );
}

impl NamedGroupList: Unmarshal {
    unmarshal = |buf| (
        buf.unmarshal_var_size(U16::to_I64).map_0(|v|
            NamedGroupList { v: v }
        )
    );
}


test1: IO ();
test1 = (
    do {
        let secure_random = *SecureRandom::make;
        let hello = *ClientHello::make(secure_random);
        let handshake = client_hello(hello);
        let buf = ByteBuffer::empty(0, big_endian());
        let buf = buf.marshal(handshake);
        println(buf.@array.to_string_hex).lift
    }.try(eprintln)
);

test2: IO ();
test2 = (
    do {
        let array = *from_string_hex("03030a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a001234000000").from_result;
        let buf = ByteBuffer::make(array, big_endian());
        let (hello:ServerHello, buf) = buf.unmarshal;
        println((hello.@cipher_suite, hello.@legacy_compression_method).format(
            "cipher_suite={} legacy_compression_method={}"
        )).lift
    }.try(eprintln)
);

main: IO ();
main = test1;
