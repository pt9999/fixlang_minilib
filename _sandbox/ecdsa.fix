// 
// secp256r1ï¼ˆNIST P-256)
// https://doi.org/10.6028/NIST.FIPS.186-5

module Main;

import Character;
import Debug;

import Minilib.Crypto.SecureRandom;
import Minilib.Encoding.Binary;
import Minilib.Math.Modular;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Types;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;

type ECInt = BigInt;

namespace ECInt {
    // 2.3.8 OctetString-to-Integer Conversion
    from_bytes: Array U8 -> Result ErrMsg ECInt;
    from_bytes = |bytes| (
        let u8_len = bytes.get_size;
        let u32_len = (u8_len + 3) / 4;
        if u32_len == 0 { ok $ zero };
        let bytes = if 4 * u32_len == u8_len { bytes }
        else { Array::fill(4 * u32_len - u8_len, 0_U8).append(bytes) };
        let nat = Array::from_map(u32_len, |i|
            bytes.get_u32_be(4 * (u32_len - 1 - i))     // big endian
        );
        ok $ BigInt::make(1, nat) 
    );

    from_string_hex: String -> Result ErrMsg ECInt;
    from_string_hex = |str| (
        let bytes: Array U8 = *FromStringHex::from_string_hex(str);
        from_bytes(bytes)
    );

    // 2.3.7 Integer-to-OctetString Conversion
    to_n_bytes: I64 -> ECInt -> Array U8;
    to_n_bytes = |mlen, a| (
        eval assert(|_| "invalid sign", a.@sign >= 0);
        let u32_len = (mlen + 3) / 4;
        let u8_len = u32_len * 4;
        let bytes = Array::fill(u8_len, 0_U8);
        let bytes = Iterator::range(0, u32_len).fold(
            bytes, |bytes, i|
            bytes.set_u32_be(4 * (u32_len - 1 - i), a.@nat.@(i))    // big endian
        );
        if u8_len != mlen { bytes.get_sub(u8_len - mlen, u8_len) } else { bytes }
    );

    to_bytes: ECInt -> Array U8;
    to_bytes = |a| (
        let u32_len = a.@nat.get_size;
        let u8_len = u32_len * 4;
        a.to_n_bytes(u8_len)
    );

    to_string_hex: ECInt -> String;
    to_string_hex = |a| (
        a.to_bytes.to_string_hex
    );

    get_mlen: ECInt -> I64;
    get_mlen = |q| (
        let k = q.@nat._bit_length.to_I64;      // 2^(k-1) <= q < 2^k
        let mlen = (k + 7) / 8;
        mlen
    );

    repeat_by_ECInt: (a -> a -> a) -> a -> a -> ECInt -> a;
    repeat_by_ECInt = |op, x, a, n| (
        eval assert(|_| "invalid sign", n.@sign >= 0);
        // Russian peasant method
        // https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#Russian_peasant_multiplication
        loop(
            (x, a, n), |(x, a, n)|
            if n.is_zero {
                break $ x
            };
            let x = if n.is_odd {
                op(x, a)
            } else { x };
            continue $ (x, op(a, a), n.shift_right(1_U64))
        )
    );

    // Generates random ECInt `r` such that `begin <= r && r < end`.
    generate_ecint_range: ECInt -> ECInt -> SecureRandom -> IOFail (ECInt, SecureRandom);
    generate_ecint_range = |begin, end, secure_random| (
        if begin > end {
            secure_random.generate_ecint_range(end, begin)      // swap range and retry
        };
        let n = end - begin;
        eval assert(|_| "invalid range", n > zero);
        let num_bits = n.@nat.get_size * BigNat::_log2_base.to_I64;
        let (bytes, secure_random) = *secure_random.generate_bytes(num_bits / 8);
        let r = ECInt::from_bytes(bytes).as_ok;
        if r >= ((one: ECInt).shift_left(num_bits.to_U64) / n) * n {
            secure_random.generate_ecint_range(begin, end)      // try again
        };
        let r = r % n;
        let r = begin + r;
        pure $ (r, secure_random)
    );
}

// a number in F(p) where p is an odd prime number
type ECField = Modular ECInt;

namespace ECField {
    
    // `ECField::make(a,p)` creates a number `a` in `F(p)`.
    make: ECInt -> ECInt -> ECField;
    make = Modular::make;

    from_ECInt: ECInt -> ECField;
    from_ECInt = |a| (
        Modular::make(a, zero)
    );

    from_I64: I64 -> ECField;
    from_I64 = |i64| (
        Modular::make(BigInt::from_I64(i64), zero)
    );

    // 2.3.5 FieldElement-to-OctetString Conversion
    to_bytes: ECField -> Array U8;
    to_bytes = |a| (
        let a = a.nonneg;               // 1..(q-1)
        let q = a.@modulus;
        let mlen = q.get_mlen;
        a.@value.to_n_bytes(mlen)
    );

    // Calculates the square root of `z`.
    // Currently only supports `z.@modulus % 4 == 3`.
    // cf. [Square Roots in Finite Prime Fields](https://www.staff.uni-mainz.de/pommeren/Cryptology/Asymmetric/5_NTh/SqRprim.pdf)
    sqrt: ECField -> Result ErrMsg ECField;
    sqrt = |z| (
        let z = z.nonneg;
        let p = z.@modulus;
        let (k, r) = divmod(p, BigInt::from_I64(4));
        if r != BigInt::from_I64(3) {
            err $ "Currently only supports `z.@modulus % 4 == 3`"
        };
        // x = z^(k + 1) mod p
        let x: ECField = repeat_by_ECInt(mul, (one: ECField), z, k + (one: ECInt));
        let x = x.nonneg;
        if x * x != z {
            err $ "Square Root not found"
        };
        ok $ x
    );
}


type ECPoint = unbox struct {
    ec: Option ECParam,    // should be some() if not infinity.
    xy: Option (ECField, ECField)    // none() means `O` (the point at infinity)
};

namespace ECPoint {
    make: ECParam -> ECField -> ECField -> ECPoint;
    make = |ec, x, y| (
        ECPoint { ec: some(ec), xy: some $ (x, y) }
    );

    is_zero: ECPoint -> Bool;
    is_zero = |p| p.@xy.is_none;

    nonneg: ECPoint -> ECPoint;
    nonneg = |p| (
        p.mod_xy(map(|(x, y)| (x.nonneg, y.nonneg)))
    );

    _get_lhs: ECParam -> ECField -> ECField;
    _get_lhs = |ec, y| (
        let lhs = y * y;
        lhs.nonneg
    );

    _get_rhs: ECParam -> ECField -> ECField;
    _get_rhs = |ec, x| (
        let a = ECField::make(ec.@a, ec.@p);
        let b = ECField::make(ec.@b, ec.@p);
        let rhs = x * (x * x + a) + b;
        rhs.nonneg
    );

    check: ECPoint -> Result ErrMsg ();
    check = |p| (
        if p.is_zero { ok() };
        let ec = p.@ec.as_some;
        let (x, y) = p.@xy.as_some;
        let lhs = _get_lhs(ec, y);
        let rhs = _get_rhs(ec, x);
        if lhs != rhs {
            err $ [lhs, rhs].format("ECPoint check failed! lhs={} rhs={}")
        };
        ok()
    );

    // 2.3.3 EllipticCurvePoint-to-OctetString Conversion
    to_bytes_compressed: ECPoint -> Array U8;
    to_bytes_compressed = |p| (
        if p.is_zero { [ 0_U8 ] };
        let (x, y) = p.@xy.as_some;
        let x_bytes = x.to_bytes;
        let y = y.nonneg;
        let y_bytes = if y.@value.is_even { [ 2_U8 ] } else { [ 3_U8 ]};
        y_bytes.append(x_bytes)
    );

    to_bytes_uncompressed: ECPoint -> Array U8;
    to_bytes_uncompressed = |p| (
        if p.is_zero { [ 0_U8 ] };
        let (x, y) = p.@xy.as_some;
        let x_bytes = x.to_bytes;
        let y_bytes = y.to_bytes;
        [ 4_U8 ].append(x_bytes).append(y_bytes)
    );

    // 2.3.4 OctetString-to-EllipticCurvePoint Conversion
    from_bytes_ec: ECParam -> Array U8 -> Result ErrMsg ECPoint;
    from_bytes_ec = |ec, bytes| (
        if bytes == [ 0_U8 ] { ok $ zero };
        let mlen = ec.@p.get_mlen;
        if bytes.get_size == mlen + 1 {     // compressed
            let y_bytes = bytes.get_sub(0, 1);
            let x_bytes = bytes.get_sub(1, mlen + 1);
            let x = ECField::make(*ECInt::from_bytes(x_bytes), ec.@p);
            let y_even = (y_bytes.@(0) == 2_U8);
            let y_odd = (y_bytes.@(0) == 3_U8);
            if !y_even && !y_odd {
                err $ "from_bytes_ec: invalid y parity"
            };
            let alpha = _get_rhs(ec, x);
            let beta = *alpha.sqrt;
            let beta_even = beta.@value.is_even;
            let y: ECField = if y_even == beta_even { beta } else {
                (-beta).nonneg
            };
            let p = ECPoint::make(ec, x, y);
            let _ = *p.check;
            ok $ p
        };
        if bytes.get_size == 2 * mlen + 1 {     // uncompressed
            let w = bytes.get_sub(0, 1);
            let x_bytes = bytes.get_sub(1, mlen + 1);
            let y_bytes = bytes.get_sub(mlen + 1, 2 * mlen + 1);
            if w.@(0) != 4_U8 {
                err $ "from_bytes_ec: invalid uncompressed marker"
            };
            let x = ECField::make(*ECInt::from_bytes(x_bytes), ec.@p);
            let y = ECField::make(*ECInt::from_bytes(y_bytes), ec.@p);
            let p = ECPoint::make(ec, x, y);
            let _ = *p.check;
            ok $ p
        };
        err $ "from_bytes_ec: invalid size"
    );
}

impl ECPoint: ToString {
    to_string = |p| p.@xy.to_string;
}

// `O` (the point at infinity)
impl ECPoint: Zero {
    zero = ECPoint{ ec:none(), xy:none() };
}

// Add two points.
impl ECPoint: Add {
    add = |p1, p2| (
        // 1. O + O = O
        // 2. (x, y) + O = O + (x, y) = (x, y)
        if p1.is_zero { p2 };
        if p2.is_zero { p1 };
        let (x1, y1) = p1.@xy.as_some;
        let (x2, y2) = p2.@xy.as_some;
        eval assert(|_| "ec mismatch", p1.@ec == p2.@ec);
        let ec = p1.@ec.as_some;
        if x1 == x2 {
            // 3. (x, y) + (x, -y) = O
            if y1 == -y2 {
                zero
            };
            // 5. Rule to add a point to itself (double a point)
            eval assert(|_| "invalid y", y1 == y2);
            let dividend = ECField::from_I64(3) * x1 * x1 + ECField::from_ECInt(ec.@a);
            let divisor = ECField::from_I64(2) * y1;
            let lambda = dividend / divisor;
            let x3 = lambda * lambda - ECField::from_I64(2) * x1;
            let y3 = lambda * (x1 - x3) - y1;
            ECPoint::make(ec, x3, y3)
        };
        // 4. Rule to add two points with different x-coordinates 
        let lambda = (y2 - y1) / (x2 - x1);
        let x3 = lambda * lambda - x1 - x2;
        let y3 = lambda * (x1 - x3) - y1; 
        ECPoint::make(ec, x3, y3)
    );
}

namespace ECPoint {
    // `p.mul_by_ECInt(n)` calculates `n * p`.
    mul_by_ECInt: ECInt -> ECPoint -> ECPoint;
    mul_by_ECInt = |n, p| repeat_by_ECInt(add, zero, p, n);
}

// Elliptic Curve Domain Parameters over F(p), where p is an odd prime number
// E(F(p)): y^2 = x^3 + a*x + b
// cf. [2.1 Properties of Elliptic Curve Domain Parameters over F(p)](https://www.secg.org/sec2-v2.pdf#page=7.31)
type ECParam = box struct {
    id: String,    // a unique id
    p: ECInt,      // a prime `p` for F(p)
    a: ECInt,      // coefficient of `x`
    b: ECInt,      // constant
    g: (ECInt, ECInt),     // a base point `G`
    n: ECInt,      // a prime `n` which is order of `G`
    h: ECInt       // the cofactor `h = #E(F(p)) / n`
};

impl ECParam: Eq {
    // NOTE only `id` is compared
    eq = |a, b| a.@id == b.@id;
}

impl ECParam: ToString {
    to_string = |ec| (
        [ec.@p, ec.@a, ec.@b, ec.@g.@0, ec.@g.@1, ec.@n, ec.@h]
        .format("ECParam { p:{}, a:{}, b:{}, g:({},{}), n:{}, h:{} }")
    );
}

namespace ECParam {
    make_point: (ECInt, ECInt) -> ECParam -> ECPoint;
    make_point = |xy, ec| (
        let x = ECField::make(xy.@0, ec.@p);
        let y = ECField::make(xy.@1, ec.@p);
        ECPoint::make(ec, x, y)
    );

    get_g: ECParam -> ECPoint;
    get_g = |ec| (
        ec.make_point(ec.@g)
    );

    secp256r1: ECParam;
    secp256r1 = ECParam {
        id: "secp256r1",
        p: ECInt::from_string_hex("FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF").as_ok,
        a: ECInt::from_string_hex("FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC").as_ok,
        b: ECInt::from_string_hex("5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B").as_ok,
        g: (
            ECInt::from_string_hex("6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296").as_ok,
            ECInt::from_string_hex("4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5").as_ok
        ),
        n: ECInt::from_string_hex("FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551").as_ok,
        h: ECInt::from_string_hex("01").as_ok
    };
}

// Cryptographics key pair
type ECKeyPair = unbox struct {
    ec: ECParam,
    d: ECInt,       // a private key
    q: ECPoint      // a public key
};

impl ECKeyPair: ToString {
    to_string = |kp| (
        (kp.@ec.@id, kp.@d, kp.@q).format("ECKeyPair { ec:{}, d:{}, p:{} }")
    );
}

namespace ECKeyPair {
    generate_keypair: ECParam -> SecureRandom -> IOFail (ECKeyPair, SecureRandom);
    generate_keypair = |ec, secure_random| (
        let n = ec.@n;
        let (d, secure_random) = *secure_random.generate_ecint_range(
            one, n
        );
        eval assert(|_| "d is out of range", one <= d && d <= n - one);
        let g = ec.get_g;
        let q = g.mul_by_ECInt(d);
        let q = q.nonneg;
        let key_pair = ECKeyPair {
            ec: ec,
            d: d,
            q: q
        };
        pure $ (key_pair, secure_random)
    );
}

test1: IO ();
test1 = (
    do {
        let ec = secp256r1;
        let _ = *println("ec="+ec.to_string).lift;
        //let g = ec.get_g;
        //let p = g.mul_by_ECInt(BigInt::from_I64(100));
        //println(p.to_string)
        let secure_random = *SecureRandom::make;
        let (key_pair, _) = *secure_random.generate_keypair(ec);
        //let _ = *println(key_pair.@d.to_bytes.to_string_hex).lift;
        let _ = *println("key_pair=" + key_pair.to_string).lift;

        let _ = *println("checking q").lift;
        let _ = *key_pair.@q.check.from_result;

        let _ = *println("convert q to bytes (uncompressed)").lift;
        let q_bytes = key_pair.@q.to_bytes_uncompressed;
        let _ = *println("q_bytes=" + q_bytes.to_string_hex).lift;

        let _ = *println("convert bytes to q").lift;
        let q: ECPoint = *from_bytes_ec(ec, q_bytes).from_result;
        let _ = *println("q=" + q.to_string).lift;

        let _ = *println("convert q to byte (compressed)").lift;
        let q_bytes = key_pair.@q.to_bytes_compressed;
        let _ = *println("q_bytes=" + q_bytes.to_string_hex).lift;

        let _ = *println("convert bytes to q").lift;
        let q: ECPoint = *from_bytes_ec(ec, q_bytes).from_result;
        let _ = *println("q=" + q.to_string).lift;
        pure()
    }.try(eprintln)
);

main: IO ();
main = (
    test1
);
