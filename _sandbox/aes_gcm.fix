// AES-GCM
// NIST Special Publication 800-38D
// Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC
// https://doi.org/10.6028/NIST.SP.800-38D
module Main;

import Debug;
import Random;

import Minilib.Encoding.Binary;
import Minilib.Crypto.AES;
import Minilib.Math.RandomEx;
import Minilib.Text.Hex;

import Sandbox.Cipher;
//import Sandbox.StateT;


// A block is a bit string of 128 bits.
// We use two U64 as a representation.
// When converted to a bit string, it is encoded in big-endian.
// If a byte sequence is encoded to a bit string, MSB of the first byte becomes the leftmost bit.
type Block = unbox struct {
  hi: U64,
  lo: U64
};

impl Block: ToStringHex {
    to_string_hex = |block| block.@hi.to_string_hex + block.@lo.to_string_hex;
}

namespace Block {
    // `Block::make(hi, lo)` creates a 128bit block.
    make: U64 -> U64 -> Block;
    make = |hi, lo| (
        Block { hi: hi, lo: lo }
    );

    get_block_be: I64 -> Array U8 -> Block;
    get_block_be = |i, array| (
        let hi = array.get_u64_be(i);
        let lo = array.get_u64_be(i + 8);
        Block { hi: hi, lo: lo }
    );

    set_block_be: I64 -> Block -> Array U8 -> Array U8;
    set_block_be = |i, block, array| (
        array.set_u64_be(i, block.@hi)
             .set_u64_be(i + 8, block.@lo)
    );

    from_bytes: Array U8 -> Block;
    from_bytes = |bytes| (
        eval assert(|_| "from_bytes: invalid size", bytes.get_size == 16);
        bytes.get_block_be(0)
    );

    to_bytes: Block -> Array U8;
    to_bytes = |block| (
        Array::fill(16, 0_U8).set_block_be(0, block)
    );

    // 6.1 Basic operation and functions
    _zero: Block;
    _zero = Block { hi: 0_U64, lo: 0_U64 };

    _bit_xor: Block -> Block -> Block;
    _bit_xor = |x, y| (
        Block {
            hi: x.@hi.bit_xor(y.@hi),
            lo: x.@lo.bit_xor(y.@lo)
        }
    );

    _shift_right_1: Block -> Block;
    _shift_right_1 = |x| (
        let hi = x.@hi.shift_right(1_U64);
        let lo = x.@lo.shift_right(1_U64);
        let lo = if x.@hi.bit_and(1_U64) == 0_U64 { lo } else { lo.bit_or(1_U64.shift_left(31_U64)) };
        Block { hi: hi, lo: lo }
    );

    _u64_to_bitstring: U64 -> Array U8;
    _u64_to_bitstring = |u64| (
        Array::fill(8, 0_U8).set_u64_be(u64)
    );

    // 6.2 Incrementing function
    _inc_32: Block -> Block;
    _inc_32 = |x| (
        Block {
            hi: x.@hi,
            lo: x.@lo.bit_and(0xffffffff00000000_U64).bit_or(
                (x.@lo.to_U32 + 1_U32).to_U64
            )
        }
    );

    // 6.3 Multiplication operation of Blocks
    _mul: Block -> Block -> Block;
    _mul = |x, y| (
        let z = _zero;
        let v = y;
        loop(
            (z, v, 0), |(z, v, i)|
            if i > 127 { break $ z };
            let z = if x._is_bit_set(i) { z._bit_xor(v) } else { z };
            let v = if v._is_bit_set(127) { v._shift_right_1._bit_xor(_R) } else { v._shift_right_1 };
            continue $ (z, v, i + 1)
        )
    );

    _is_bit_set: I64 -> Block -> Bool;
    _is_bit_set = |i, x| (
        if i < 64 { x.@hi.bit_and(1_U64.shift_left((63 - i).to_U64)) != 0_U64 };
        if i < 128 { x.@lo.bit_and(1_U64.shift_left((127 - i).to_U64)) != 0_U64 };
        false
    );

    _R: Block;
    _R = Block { hi: 0b11100001_U64.shift_left(56_U64), lo: 0_U64 };

    // 6.4 GHASH function
    _GHASH: Block -> Iterator Block -> Block;
    _GHASH = |h, xs| (
        xs.fold(_zero, |y, x| y._bit_xor(x)._mul(h))
    );

    _bytes_to_blocks: Array U8 -> Iterator Block;
    _bytes_to_blocks = |bytes| (
        eval assert(|_| "invalid byte size", bytes.get_size % 16 == 0);
        let n = bytes.get_size / 16;
        Iterator::range(0, n).map(|i|
            bytes.get_block_be(i * 16)
        )
    );


    // 6.5 GCTR function
    _GCTR: (Block -> Block) -> Block -> Array U8 -> Array U8;
    _GCTR = |cipher, initial_counter_block, x_bytes| (
        if x_bytes.is_empty { x_bytes };
        let n = (x_bytes.get_size + 15) / 16;   // ceil(len(x) / 128)
        let padding = n * 16 - x_bytes.get_size;
        let x_bytes_pad = if padding == 0 { x_bytes }
        else { x_bytes.append(Array::fill(padding, 0_U8)) };
        let y_bytes_pad = Array::fill(x_bytes_pad.get_size, 0_U8);
        let cb = initial_counter_block;
        let y_bytes_pad = loop(
            (y_bytes_pad, cb, 0), |(y_bytes_pad, cb, i)|
            if i >= n { break $ y_bytes_pad };
            let x = x_bytes_pad.get_block_be(i * 16);
            let y = x._bit_xor(cipher(cb));
            let y_bytes_pad = y_bytes_pad.set_block_be(i * 16, y);
            let cb = cb._inc_32;
            continue $ (y_bytes_pad, cb, i + 1)
        );
        let y_bytes = if padding == 0 { y_bytes_pad }
        else { y_bytes_pad.get_sub(0, y_bytes_pad.get_size - padding) };
        y_bytes
    );

    _to_cipher: AES -> (Block -> Block);
    _to_cipher = |aes, x| (
        let plaintext = x.to_bytes;
        let ciphertext = aes.encrypt_block(plaintext);
        ciphertext.from_bytes
    );

    // 7.1 Algorithm for the Authenticated Encryption Function

    // Input:
    // - cipher: 128-bit block cipher
    // - iv: initialization vector
    // - len_t: tag length
    // Output: (c, t)
    // - c: ciphertext
    // - t: authentication tag
    gcm_ae: (Block -> Block) -> I64 -> Array U8 -> Array U8 -> Array U8 -> (Array U8, Array U8)
    gcm_ae = |cipher, len_t, iv, plaintext, auth_data| (
        // h: the hash subkey
        let h: Block = cipher(_zero);
        // j0: the pre-counter block
        let j0: Block  = if iv.get_size == 96 / 8 {
            iv.append([0_U8, 0_U8, 0_U8, 1_U8]).get_block_be(0)
        } else {
            let len_iv = iv.get_size * 8;
            let s = 128 * ((len_iv + 127) / 128) - len_iv;
            let zeros = Array::fill((s + 64) / 8, 0_U8);    // NOTE that `s % 8 == 0`.
            let len_iv_str = _u64_to_bitstring(len_iv);
            _GHASH(h, iv.append(zeros).append(len_iv_str)._bytes_to_blocks)
        };

        let c: Array U8 = _GCTR(cipher, j0._inc_32, plaintext);
        let len_c = c.get_size * 8;
        let u = 128 * ((len_c + 127) / 128) - len_c;
        let len_a = auth_data.get_size * 8;
        let v = 128 * ((len_a + 127) / 128) - len_a;
        // NOTE that `u % 8 == 0` and `v % 8 == 0`.
        let s: Block = _GHASH(h,
            auth_data
            .append(Array::fill(v / 8, 0_U8))
            .append(c)
            .append(Array::fill(u / 8, 0_U8))
            .append(_u64_to_bitstring(len_a.to_U64))
            .append(_u64_to_bitstring(len_c.to_U64))
        );
        let t: Array U8 = _GCTR(cipher, j0, s.to_bytes);
        let t = if len_t < t.get_size * 8 { t.get_sub(0, len_t / 8) } else { t };
        (c, t)
    );
}

test_ghash: IO ();
test_ghash = (
    let h = Block::make(0x112233_U64, 0x223344_U64);
    let xs = [
        Block::make(0x123123_U64, 0x234234_U64),
        Block::make(0x123124_U64, 0x234235_U64)
    ].to_iter;
    let hash = _GHASH(h, xs);
    println(hash.to_string_hex)
);

byte_array_from_string_hex: String -> Array U8;
byte_array_from_string_hex = |str| (
    str.split(" ").map(from_string_hex >> as_ok).to_array
);

test_gctr: IO ();
test_gctr = (
    let key = "2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c";
    let key = key.byte_array_from_string_hex;
    let aes = AES::make(key);
    let x_bytes = "Hello world foo bar baz 123 123".get_bytes.pop_back;
    let cipher = _to_cipher(aes);
    let initial_counter_block = cipher(_zero);
    let y_bytes = _GCTR(cipher, initial_counter_block, x_bytes);
    println(y_bytes.to_string_hex)
);


// Carryless Multiplication
// NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB

_clmul_u8_u8_table: Array U16;
_clmul_u8_u8_table = Array::from_map(256 * 256, |pos|
    let a = pos.shift_left(0).bit_and(0xff00).to_U16;
    let b = pos.shift_left(8).bit_and(0xff00).to_U16;
    let c = 0_U16;
    loop(
        (c, a, 0), |(c, a, i)|
        if i >= 8 { break $ c };
        let c = if b.shift_right((15 - i).to_U16).bit_and(1_U16) != 0_U16 {
            c.bit_xor(a)
        } else { c };
        let a = a.shift_right(1_U16);
        continue $ (c, a, i + 1)
    )
);

_clmul_u8_u8: U8 -> U8 -> U16;
_clmul_u8_u8 = |a, b| (
    let pos = a.to_I64.shift_left(8).bit_or(b.to_I64);
    _clmul_u8_u8_table.@(pos)
);

_clmul_u16_u16: U16 -> U16 -> U32;
_clmul_u16_u16 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U8;
    let x0 = x.shift_right(8_U16).to_U8;
    let y1 = y.to_U8;
    let y0 = y.shift_right(8_U16).to_U8;
    let z2 = _clmul_u8_u8(x1, y1);
    let z0 = _clmul_u8_u8(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u8_u8(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U32.bit_xor(z1.to_U32.shift_left(8_U32)).bit_xor(z0.to_U32.shift_left(16_U32));
    z
);

_clmul_u32_u32: U32 -> U32 -> U64;
_clmul_u32_u32 = |x, y| (
    // NOTE: the bit order is reversed, ie. bit 0 is MSB, bit (n-1) is LSB
    let x1 = x.to_U16;
    let x0 = x.shift_right(16_U32).to_U16;
    let y1 = y.to_U16;
    let y0 = y.shift_right(16_U32).to_U16;
    let z2 = _clmul_u16_u16(x1, y1);
    let z0 = _clmul_u16_u16(x0, y0);
    let z1 = z2.bit_xor(z0).bit_xor(_clmul_u16_u16(x1.bit_xor(x0), y1.bit_xor(y0)));
    let z = z2.to_U64.bit_xor(z1.to_U64.shift_left(16_U64)).bit_xor(z0.to_U64.shift_left(32_U64));
    z
);


test_clmul_u8_u8: IO ();
test_clmul_u8_u8 = (
    let print_row = |a:I64| println $ do {
        let b = *Iterator::range(0, 16);
        let c = _clmul_u8_u8(a.to_U8, b.to_U8);
        pure $ c.to_string_hex
    }.join(" ");
    Iterator::range(0, 16).fold_m(
        (), |_, a|
        print_row(a)
    )
);

test_clmul_u32_u32_1: Random -> IO Random;
test_clmul_u32_u32_1 = |random| (
    let trace_mul = |a, b| (
        let c = _clmul_u32_u32(a, b);
        eval *println(a.to_string_hex + " * " + b.to_string_hex + " = " + c.to_string_hex);
        pure $ c
    );
    let (a1, random) = random.generate_U32;
    let (b1, random) = random.generate_U32;
    let (a2, random) = random.generate_U32;
    let (b2, random) = random.generate_U32;
    let c11 = *trace_mul(a1, b1);
    let c12 = *trace_mul(a1, b2);
    let c21 = *trace_mul(a2, b1);
    let c22 = *trace_mul(a2, b2);
    let expected = c11.bit_xor(c12).bit_xor(c21).bit_xor(c22);
    let actual = *trace_mul(a1.bit_xor(a2), b1.bit_xor(b2));
    eval assert_eq(|_|
        "mismatch: " + [a1, b2, a2, b2].map(to_string_hex).to_string,
        expected, actual);
    pure $ random
);

test_clmul_u32_u32: IO ();
test_clmul_u32_u32 = (
    let random = Random::init_by_seed(123_U64);
    let random = *Iterator::range(0, 16).fold_m(
        random, |random, i|
        test_clmul_u32_u32_1(random)
    );
    pure()
);

main: IO ();
//main = test_clmul_u32_u32;
main = test_gctr;
