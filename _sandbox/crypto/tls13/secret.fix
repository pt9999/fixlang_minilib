// RFC8446 - The Transport Layer Security (TLS) Protocol Version 1.3
// 7. Cryptographic Computations
module Minilib.Crypto.Tls13.Secret;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.CipherSuite;
import Minilib.Crypto.Tls13.Hkdf;
import Minilib.Crypto.HMAC;
import Minilib.Encoding.Binary;
import Minilib.Monad.Error;
import Minilib.Text.Hex;
//import Minilib.Text.StringEx;

// 7.1. Key Schedule

namespace HKDF {
    from_cipher_suite: CipherSuite -> Result ErrMsg HKDF;
    from_cipher_suite = |cipher_suite| (
        let hash_type = cipher_suite.to_hash_type;
        if hash_type.is_sha256 { ok $ HKDF::make $ hmac_sha256 };
        err $ "unsupported hash type"
    );

    // `hkdf.expand_label(secret, label, context, length)` executes `HKDF-Expand-Label` algorithm.
    // HKDF-Expand-Label(Secret, Label, Context, Length) =
    //        HKDF-Expand(Secret, HkdfLabel, Length)
    expand_label: Array U8 -> String -> Array U8 -> I64 -> HKDF -> Result ErrMsg (Array U8);
    expand_label = |secret, label, context, length, hkdf| (
        let label = ("tls13 " + label).get_bytes.pop_back;
        let hkdf_label = HkdfLabel::make(length, label, context);
        let hkdf_label = marshal_to_bytes(hkdf_label);
        //eval debug_println("info="+ hkdf_label.to_string_hex);
        hkdf.expand(secret, hkdf_label, length)
    );

    derive_secret: Array U8 -> String -> Array U8 -> HKDF -> Result ErrMsg (Array U8);
    derive_secret = |secret, label, messages, hkdf| (
        hkdf.expand_label(secret, label, hkdf.transcript_hash(messages), hkdf.hash_length)
    );

    transcript_hash: Array U8 -> HKDF -> Array U8;
    transcript_hash = |messages, hkdf| (
        let hash: Array U8 -> Array U8 = hkdf.@hmac.@h;
        hash(messages)
    );

    hash_length: HKDF -> I64;
    hash_length = |hkdf| (
        hkdf.@hmac.@output_block_size
    );

    zero_secret: HKDF -> Array U8;
    zero_secret = |hkdf| (
        Array::fill(hkdf.hash_length, 0_U8)
    );

    calc_early_secret_0: HKDF -> Result ErrMsg (Array U8);
    calc_early_secret_0 = |hkdf| (
        hkdf.calc_early_secret(hkdf.zero_secret)
    );

    calc_early_secret: Array U8 -> HKDF -> Result ErrMsg (Array U8);
    calc_early_secret = |psk, hkdf| (
        hkdf.extract(hkdf.zero_secret, psk)
    );

    calc_handshake_secret: Array U8 -> Array U8 -> HKDF -> Result ErrMsg (Array U8);
    calc_handshake_secret = |early_secret, dhe, hkdf| (
        let derived = *hkdf.derive_secret(early_secret, "derived", []);
        hkdf.extract(derived, dhe)
    );

    // messages = ClientHello...ServerHello
    calc_client_handshake_traffic_secret: Array U8 -> Array U8 -> HKDF -> Result ErrMsg (Array U8);
    calc_client_handshake_traffic_secret = |handshake_secret, messages, hkdf| (
        hkdf.derive_secret(handshake_secret, "c hs traffic", messages)
    );

    // messages = ClientHello...ServerHello
    calc_server_handshake_traffic_secret: Array U8 -> Array U8 -> HKDF -> Result ErrMsg (Array U8);
    calc_server_handshake_traffic_secret = |handshake_secret, messages, hkdf| (
        hkdf.derive_secret(handshake_secret, "s hs traffic", messages)
    );

    calc_master_secret: Array U8 -> HKDF -> Result ErrMsg (Array U8);
    calc_master_secret = |handshake_secret, hkdf| (
        let derived = *hkdf.derive_secret(handshake_secret, "derived", []);
        hkdf.extract(derived, zero_secret)
    );
}

type HkdfLabel = unbox struct {
    length: U16,
    label: Array U8,
    context: Array U8,
};

namespace HkdfLabel {
    make: I64 -> Array U8 -> Array U8 -> HkdfLabel;
    make = |length, label, context| HkdfLabel {
        length: length.to_U16,
        label: label,
        context: context
    };
}

impl HkdfLabel: Marshal {
    marshal = |hl, buf| (
        let buf = buf.marshal(hl.@length);
        let buf = buf.marshal_var_size(hl.@label, to_U8);
        let buf = buf.marshal_var_size(hl.@context, to_U8);
        buf
    );
}
