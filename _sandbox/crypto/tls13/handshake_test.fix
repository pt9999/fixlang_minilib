module Main;

import Random;
import Debug;

import Minilib.Crypto.Tls13.ECDHE;
import Minilib.Crypto.Tls13.Types;
import Minilib.Crypto.Tls13.Connection;
//import Minilib.Crypto.Tls13.MemConnection;
import Minilib.Crypto.Tls13.Handshake;
import Minilib.Encoding.Binary;
//import Minilib.Monad.FunctorM;
import Minilib.Monad.State;
import Minilib.Text.Hex;
import Minilib.Text.StringEx;
import Minilib.Thread.Time;
import Minilib.Testing.UnitTest;

/*
test_mem_connection: TestCase;
test_mem_connection = (
    make_test("test_mem_connection") $ |_|
    let (local_conn, remote_conn) = *MemConnection::pipe.lift;
    let n = 102400;
    let bytes = Array::from_map(n, |i| i.to_U8);
    let task = do {
        let _ =  *send_bytes(bytes).run_state_t(local_conn);
        let (bytes2, _) = *recv_n_bytes(n).run_state_t(remote_conn);
        pure $ bytes == bytes2
    }.to_result;
    let res = *timeit_io("send_recv", task).lift;
    //eval *println("res="+(bytes == bytes2).to_string).lift;
    pure()
);
*/

/*
type MockServer = unbox struct {

};

namespace MockServer {
    make: IOHandle -> MockServer;
    make = |handle| MockServer {
        handle: handle
    };
}
*/

test_client_hello: TestCase;
test_client_hello = (
    make_test("test_client_hello") $ |_|
    let random = Random::init_by_seed(123_U64);
    let (hello, _) = *do {
        ClientHelloState::make
    }.run_state_t(random);
    eval *println(hello.@client_hello.marshal_to_bytes.to_string_hex).lift;
    eval *println(hello.@ecdhe.get_pub_key.to_string_hex).lift;
    pure()
);

main: IO ();
main = (
    [
        test_mem_connection,
        test_client_hello,
    ]
    .run_test_driver
);
