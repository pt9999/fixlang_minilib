module Minilib.Trait.Traversable;

// A trait for types which can traverse all elements with `Monad`.
trait [t: * -> *] t: Traversable {
    // `ta.sequence` performs all elements sequentially and collects the results.
    sequence: [m: Monad] t (m a) -> m (t a);
}

// `ta.traverse(f)` maps each element with `f`, then performs all elements sequentially and collects the results.
traverse: [m: Monad, t: Traversable, t: Functor] (a -> m b) -> t a -> m (t b);
traverse = |f, ta| ta.map(f).sequence;

// `map_m` is a synonym of `traverse`.
map_m: [m: Monad, t: Traversable, t: Functor] (a -> m b) -> t a -> m (t b);
map_m = traverse;

// `ta.foreach_m(f)` maps each element with `f`, then performs all elements sequentially and forgets the results.
foreach_m: [m: Monad, t: Traversable, t: Functor] (a -> m ()) -> t a -> m ();
foreach_m = |f, ta| ta.map_m(f).bind(|_| pure());

impl Array: Traversable {
    sequence = |array| (
        array.to_iter.fold_m(
            Array::empty(array.get_size), |output, ma|
            pure $ output.push_back(*ma)
        )
    );
}

impl Iterator: Traversable {
    sequence = |iter| (
        let output = *iter.fold_m(
            [], |output, ma|
            pure $ output.push_back(*ma)
        );
        pure $ output.to_iter
    );
}

impl Option: Traversable {
    sequence = |opt| (
        match opt {
            none() => pure $ none(),
            some(ma) => pure $ some(*ma)
        }
    );
}

impl Result e: Traversable {
    sequence = |res| (
        match res {
            err(e) => pure $ err(e),
            ok(ma) => pure $ ok(*ma)
        }
    );
}

impl Tuple2 e: Traversable {
    sequence = |(e, ma)| (
        pure $ (e, *ma)
    );
}