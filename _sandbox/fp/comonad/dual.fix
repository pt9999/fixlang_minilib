module Minilib.Trait.Dual;

import Minilib.Common.Common;
import Minilib.Comonad.Cofree;
import Minilib.Comonad.Env;
import Minilib.Comonad.IdentityC;
import Minilib.Comonad.IOStore;
import Minilib.Comonad.Store;
import Minilib.Comonad.Traced;
import Minilib.Monad.IO;
import Minilib.Monad.Free;
import Minilib.Monad.Reader;
import Minilib.Monad.State;
import Minilib.Monad.Writer;
import Minilib.Trait.Comonad;

// --------------------------------------------------------------------------------
// http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/
// --------------------------------------------------------------------------------

trait [f: *->*] f: Dual {
    type DualOf f: *->*;
    zap: (a -> b -> c) -> f a -> DualOf f b -> c;
}

zapp: [f: Dual] f (a -> b) -> DualOf f a -> b;
zapp = zap(|a| a);

impl Identity: Dual {
    type DualOf Identity = IdentityC;
    zap = |f, ia, ib| f(ia.@data, ib.@data);
}

impl IdentityC: Dual {
    type DualOf IdentityC = Identity;
    zap = flip >> zap >> flip;
}

impl Arrow e: Dual {
    type DualOf (Arrow e) = Tuple2 e;
    zap = |f, e_a, (e, b)| f(e_a(e), b);
}

impl Tuple2 e: Dual {
    type DualOf (Tuple2 e) = Arrow e;
    zap = |f, (e, a), e_b| f(a, e_b(e));
}

impl [m: Monad, w: Comonad, m: Dual, DualOf m = w] ReaderT e m: Dual {
    type DualOf (ReaderT e m) = EnvT e (DualOf m);
    zap = |f, reader, env| (
        zap(zap(f), reader.flip(run_reader_t), (env.@env, env.@value))
    );
}

impl [w: Comonad, m: Monad, w: Dual, DualOf w = m] EnvT e w: Dual {
    type DualOf (EnvT e w) = ReaderT e (DualOf w);
    zap = |f, env, reader| (
        zap(zap(f), (env.@env, env.@value), reader.flip(run_reader_t))
    );
}

impl [m: Monad, w: Comonad, m: Dual, DualOf m = w] StateT s m: Dual {
    type DualOf (StateT s m) = StoreT s (DualOf m);
    zap = |f, state, store| (
        //let ma: Arrow s (m (Tuple2 s a)) = state.flip(run_state_t);
        //let wb: Tuple2 s (w (Arrow s b)) = store.run_store_t;
        zap(zap(zap(f)), state.flip(run_state_t), store.run_store_t)
    );
}

impl [w: Comonad, m: Monad, w: Dual, DualOf w = m] StoreT s w: Dual {
    type DualOf (StoreT s w) = StateT s (DualOf w);
    zap = |f, store, state| (
        zap(zap(zap(f)), store.run_store_t, state.flip(run_state_t))
    );
}

impl [m: Monad, w: Comonad, m: Dual, DualOf m = w] WriterT e m: Dual {
    type DualOf (WriterT e m) = TracedT e (DualOf m);
    zap = |f, writer, traced| (
        zap(zap(f), writer.run_writer_t, traced.run_traced_t)
    );
}

impl [w: Comonad, m: Monad, w: Dual, DualOf w = m] TracedT e w: Dual {
    type DualOf (TracedT e w) = WriterT e (DualOf w);
    zap = |f, traced, writer| (
        zap(zap(f), traced.run_traced_t, writer.run_writer_t)
    );
}

impl [f:Dual] Free f: Dual {
    type DualOf (Free f) = Cofree (DualOf f);
    zap = |op, free, cofree| match free {
        f_pure(a) => (
            let (b, gb) = cofree.run_cofree;
            op(a, b)
        ),
        f_functor(fa) => (
            let (b, gb) = cofree.run_cofree;
            zap(zap(op), fa, gb)
        )
    };
}

impl [g:Dual, f: Dual, DualOf g = f, DualOf f = g] Cofree g: Dual {
    type DualOf (Cofree g) = Free (DualOf g);
    //zap = |op, cofree, free| zap(op.flip, free, cofree);
    zap = flip >> zap >> flip;
}

impl IO: Dual {
    type DualOf IO = IOStore;
    zap = |op, io, io_store| (
        let (ios, fb) =  io_store.run_io_store;
        let (ios, a) = (io.@runner)(ios);
        let b = fb(ios);
        op(a, b)
    );
}

impl IOStore: Dual {
    type DualOf IOStore = IO;
    zap = flip >> zap >> flip;
}
