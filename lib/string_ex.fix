module StringEx;

import Debug;
import HashMap;

//---------------------------------
// ToString for various types
//---------------------------------

impl (): ToString {
    to_string = |_| "()";
}

impl [a : ToString, b : ToString, c : ToString] (a, b, c) : ToString {
    to_string = |(l, m, r)| "(" + l.to_string + ", " + m.to_string + ", " + r.to_string + ")";
}

impl [a : ToString, b : ToString, c : ToString, d : ToString] (a, b, c, d) : ToString {
    to_string = |(l, m, m2, r)| "(" + l.to_string + ", " + m.to_string + ", " + m2.to_string + ", " + r.to_string + ")";
}

impl [a: ToString] Option a: ToString {
    to_string = |o| (
        o.map_or(
            "none()",
            |a| "some(" + a.to_string + ")"
        )
    );
}

impl [a: ToString, e: ToString] Result e a: ToString {
    to_string = |res| (
        if res.is_err {
            "err(" + res.as_err.to_string + ")"
        };
        "ok(" + res.as_ok.to_string + ")"
    );
}


impl [k: ToString, v: ToString] HashMap k v : ToString {
    to_string = |h| (
        "{" +
        h.to_iter.map(|(k,v)| k.to_string + ":" + v.to_string).join(",")
        + "}"
    );
}

impl [a: ToString] Array a: ToString {
    to_string = |a| (
        "[" +
        a.to_iter.map(|x| x.to_string).join(",")
        + "]"
    );
}

//---------------------------------
// String utility functions
//---------------------------------

// Convert a byte array to a string. Specifically, it calls `String::_unsafe_to_string()`
// after appending a null character to the end of the byte array.
_unsafe_to_string: Array U8 -> String;
_unsafe_to_string = |a| (
    String::_unsafe_from_c_str (a.push_back(0_U8))
);

// Converts a byte (a character) to a string of length 1.
byte_to_string: U8 -> String;
byte_to_string = |c| (
    Array::empty(2).push_back(c)._unsafe_to_string
);

// Searches for the specified byte from the beginning of a string.
// If found, returns the index of that byte.
find_byte: U8 -> String -> Option I64;
find_byte = |c, str| (
    let array = str.get_bytes;
    let n = str.get_size;
    loop(
        0, |i|
        if i >= n {
            break $ none()
        };
        if array.@(i) == c {
            break $ some $ i
        };
        continue $ i + 1
    )
);

// Replaces all occurrences of `from` in the string with `to`.
replace_all: String -> String -> String -> String;
replace_all = |from, to, str| (
    if from.get_size <= 0 {
        str
    };
    loop((str, 0), |(str, find_start)|
        let pos = str.find(from, find_start);
        if pos.is_none {
            break $ str
        };
        let pos = pos.as_some;
        let str = (
            str.substring(0, pos) +
            to +
            str.substring(pos + from.get_size, str.get_size)
        );
        let find_start = pos + to.get_size;
        continue $ (str, find_start)
    )
);


// Returns a substring extracted from a specified range from a string.
// If the specified range exceeds the string, it will be truncated to fit within the string.
substring: I64 -> I64 -> String -> String;
substring = |s, e, str| (
    let size = str.get_size;
    let s = (if s < 0 { 0 }; if s >= size { size }; s);
    let e = (if e < s { s }; if e >= size { size }; e);
    if s == 0 && e == size { str };
    str.get_sub(s, e)
);

// Compares two strings. Returns True if and only if the first string is less than the second string.
string_less_than: (String, String) -> Bool;
string_less_than = |(str1, str2)| (
    let a1 = str1.get_bytes;
    let a2 = str2.get_bytes;
    let n1 = a1.get_size;
    let n2 = a2.get_size;
    loop(0, |i|
        if i >= n1 && i >= n2 {
            break $ false
        };
        if i >= n1 {
            break $ true
        };
        if i >= n2 {
            break $ false
        };
        let c1 = a1.@(i);
        let c2 = a2.@(i);
        if c1 < c2 {
            break $ true
        };
        if c1 > c2 {
            break $ false
        };
        continue $ i + 1
    )
);

impl String: LessThan {
    less_than = |str1,str2| string_less_than $ (str1, str2);
}

//---------------------------------
// Hexadecimal
//---------------------------------

// Converts a 4bit number (0..15) to a hex character ('0'..'9', 'A'..'F').
encode_hex_char: U8 -> U8;
encode_hex_char =
    let hex_chars = "0123456789ABCDEF".get_bytes.pop_back
    in |c| hex_chars.@(c.bit_and(15_U8).to_I64);

// Converts a hex character ('0'..'9', 'A'..'F' or 'a'..'f') to a 4bit number (0..15).
decode_hex_char: U8 -> Result ErrMsg U8;
decode_hex_char = |c| (
    if '0' <= c && c <= '9' { ok $ c - '0' };
    if 'A' <= c && c <= 'F' { ok $ c - 'A' + 10_U8 };
    if 'a' <= c && c <= 'f' { ok $ c - 'a' + 10_U8 };
    err $ "Not a hexadecimal character: '" + byte_to_string(c) + "'"
);

// Converts a 64bit number to a hex string.
to_string_hex: U64 -> String;
to_string_hex = |input| (
    let output: Iterator U8 = Iterator::empty;
    let output = loop(
        (output, 0, input), |(output, i, input)|
        if i >= 16 || input == 0_U64 {
            break $ output
        };
        let h = input.bit_and(15_U64).to_U8;
        let input = input.shift_right(4_U64);
        let output = output.push_front(encode_hex_char(h));
        continue $ (output, i + 1, input)
    );
    let output = if output.is_empty { output.push_front ('0') } else { output };
    output.to_array._unsafe_to_string
);

// Converts a hex string to a 64bit number.
from_string_hex: String -> Result ErrMsg U64;
from_string_hex = |input| (
    if input.get_size == 0 {
        err $ "Empty string"
    };
    let input = input.get_bytes.pop_back;
    input.to_iter.fold_m(
        0_U64, |output, c|
        let c = *decode_hex_char(c);
        pure $ output.shift_left(4_U64).bit_or(c.to_U64)
    )
);