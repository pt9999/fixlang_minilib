module Main;

import Funim;
import Funim.Machine;

import MiscAlgos.Geometry;
import MiscAlgos.Functional;
import Math;
import Time;
import Cairo;
import Cairo.ImageSurface;

import AsyncTask;
import RingBuffer;
import Random;
import Minilib.Monad.Random;
import Minilib.Monad.State;

type RGBColor = (F64, F64, F64);
type RGBAColor = (F64, F64, F64, F64);

window_size : (I64, I64);
window_size = (1280, 720);

color_cyan: RGBColor = (0.0, 1.0, 1.0);

color_red: RGBColor = (1.0, 0.0, 0.0);
color_green: RGBColor = (0.0, 1.0, 0.0);
color_blue: RGBColor = (0.0, 0.0, 1.0);

color_white_a50 : RGBAColor;
color_white_a50 = (1.0, 1.0, 1.0, 0.5);

null_random: Random;
null_random = Random::init_by_seed(0_U64);

eval_random: Var Random -> State Random a -> IO a;
eval_random = |var_random, sma| (
    var_random.lock(|random|
        var_random.Var::set(null_random);;   // to make `random` unique
        let (random, a) = sma.run_state(random);
        var_random.Var::set(random);;
        pure $ a
    )
);

random_F64_range: [m: MonadRandom] F64 -> F64 -> m F64;
random_F64_range = |begin, end| (
    let r = *random_U64;
    let r = r.to_F64 / U64::maximum.to_F64;
    let r = begin + r * (end - begin);
    pure $ r
);

type Obj = box struct {
    var_random: Var Random,
    point: Vec2,
    line: RingBuffer Vec2,
    velocity: Vec2,
    color: RGBColor,
};

namespace Obj {
    generate: Var Random -> IO Obj;
    generate = |var_random| (
        eval_random(var_random) $ do {
            let win_w = window_size.@0.to_F64;
            let win_h = window_size.@1.to_F64;
            let x = -0.50 * win_w; // *random_F64_range(-0.9 * win_w, -0.8 * win_w);
            let y = 0.00 * win_h; // *random_F64_range(-0.49 * win_h, 0.49 * win_h);
            let vx = 0.10 * win_w; // *random_F64_range(0.15 * win_w, 0.2 * win_w);
            let vy = 0.00 * win_h; // *random_F64_range(-0.002 * win_h, 0.002 * win_h);
            let c = *random_I64_range(0,3);
            let color = if c < 1 { color_red } 
            else if c < 2 { color_green }
            else { color_blue };
            let line = RingBuffer::create([]);

            pure $ Obj {
                var_random: var_random,
                point: Vec2::make(x, y),
                line: line,
                velocity: Vec2::make(vx, vy),
                color: color
            }
        }
    );

    render : Obj -> Cairo -> IO ();
    render = |obj, cairo| (
        let x = obj.@point.@x;
        let y = obj.@point.@y;
        let d = 10.0;
        cairo.arc((x, y), d, 0.0, 2.0 * pi64);;
        cairo.set_source_rgba(color_white_a50);;
        cairo.fill_preserve;;
        cairo.set_source_rgb(obj.@color);;
        cairo.stroke;;
        cairo.set_source_rgba(color_white_a50);;
        range(0, obj.@line.get_size).fold_m(
            (), |i, _|
            let p = obj.@line.@(i);
            if i == 0 { cairo.move_to(p.to_tuple) }
            else { cairo.line_to(p.to_tuple) }
        );;
        cairo.stroke;;
        pure()
    );

    move: TimeDelta -> Obj -> IO Obj;
    move = |dt, obj| (
        let g = 0.0; // 150.0;
        let win_w = window_size.@0.to_F64;
        let win_h = window_size.@1.to_F64;
        let (x0, x1) = (-win_w / 2.0, win_w / 2.0);
        let (y0, y1) = (-win_h / 2.0, win_h / 2.0);
        let obj = obj.mod_velocity(mod_y(add(g * dt)));
        //let th = *random_F64_range(-1.0, 1.0).eval_random(obj.@var_random);
        //let th = th * (pi64 * 5.0 / 180.0);
        //let obj = obj.mod_velocity(rotated(th));
        let obj = obj.mod_point(add(obj.@velocity.scaled(dt)));
        let dydt = 0.50 * win_h * *random_F64_range(-1.0, 1.0).eval_random(obj.@var_random);
        let obj = obj.mod_point(mod_y(add(dydt * dt)));
        let obj = if obj.@point.@x < x0 {
            obj.mod_velocity(mod_x(mul(-1.0))).mod_point(mod_x(|x| 2.0 * x0 - x))
        } else if obj.@point.@x > x1 {
            obj.mod_velocity(mod_x(mul(-1.0))).mod_point(mod_x(|x| 2.0 * x1 - x))
        } else { obj };
        /*
        let obj = if obj.@point.@y < y0 {
            obj.mod_velocity(mod_y(mul(-1.0))).mod_point(mod_y(|y| 2.0 * y0 - y))
        } else if obj.@point.@y > y1 {
            obj.mod_velocity(mod_y(mul(-1.0))).mod_point(mod_y(|y| 2.0 * y1 - y))
        } else { obj };
        */
        let obj = obj.mod_line(|line|
            let line = line.push_back(obj.@point);
            loop(line, |line|
                if line.get_size <= 100 { break $ line };
                continue $ line.pop_front
            )
        );
        pure $ obj
    );

// type Draw = Cairo -> IO ();
// type Animation = Machine TimeDelta Draw;
// from_transition : s -> (i -> s -> (s, o)) -> Machine i o;

    animate: Obj -> Animation;
    animate = |obj| (
        Machine::from_transition_io(obj, |dt, obj|
            let obj = *obj.move(dt);
            pure $ (obj, obj.render)
        )
    );
}

main : IO ();
main = (
    let random = Random::init_by_seed((*Time::get_now).to_F64.to_U64);
    let var_random = *Var::make(random);
    let config = Funim::Config::default(window_size);
    //let config = Funim::Config::encode(window_size, 60.0, "frames");

    let n_obj = 50;
    let objs = *range(0, 50).map(|_| Obj::generate(var_random)).collect_m;
    let animation = Animation::stack $ objs.map(animate);
    /*
    let animation : Animation = Animation::stack $ [
        Obj::make(Vec2::make(0.0, -150.0), color_red).animate,
        Obj::make(Vec2::make(50.0, 0.0), color_blue).animate,
        Obj::make(Vec2::make(0.0, 150.0), color_green).animate,
    ];
    */

    Funim::run_animation(animation, config)
);


