// https://en.wikipedia.org/wiki/ASN.1
// https://en.wikipedia.org/wiki/X.690
module Minilib.Crypto.Asn1.Der;

import Minilib.Crypto.Asn1;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.FunctorM;

trait MonadReadByte = Functor + Monad + MonadErrorIF + MonadReadByteIF;

trait [m: * -> *] m: MonadReadByteIF {
    // Reads a byte. If the end-of-file is reached, it reports an error.
    read_byte: m U8;
    // Checks whether the end-of-file is reached.
    is_eof: m Bool;
    // Runs the inner monad with the inner contents.
    // The inner contents is created from current position to the position advanced by the specified length,
    run_inner: I64 -> m a -> m a;
}

impl [m: MonadError] StateT ByteBuffer m: MonadReadByteIF {
    read_byte = (
        let buf = *get_state;
        let res: Result ErrMsg (U8, ByteBuffer) = buf.unmarshal;
        if res.is_err {
            error $ res.as_err
        };
        let (u8, buf) = res.as_ok;
        eval *put_state(buf);
        pure $ u8
    );
    is_eof = (
        let buf = *get_state;
        pure $ buf.get_position >= buf.get_size
    );
    run_inner = |length, inner_monad| (
        let buf = *get_state;
        let inner_array = buf.@array.subarray(
            buf.@position,
            min(buf.@position + length, buf.get_size)
        );
        let inner_buf = ByteBuffer::make(inner_array, big_endian());
        inner_monad.run_state_t(inner_buf).map(@0)
    );
}

type Identifier = unbox struct {
    tag_class: TagClass,
    constructed: Bool,
    tag: Tag
}; 

namespace Identifier {
    make: TagClass -> Bool -> Tag -> Identifier;
    make = |tag_class, constructed, tag| Identifier {
        tag_class: tag_class,
        constructed: constructed,
        tag: tag
    };

    assert_tag: [m: MonadError] Tag -> Identifier -> m ();
    assert_tag = |tag, identifier| (
        if identifier.@tag != tag {
            error $ [tag, identifier.@tag].format("tag mismatch: expected={} actual={}")
        };
        pure $ ()
    );
}

impl Identifier: Eq {
    eq = |a, b| (
        a.@tag_class == b.@tag_class &&
        a.@constructed == b.@constructed &&
        a.@tag == b.@tag
    );
}

impl Identifier: ToString {
    to_string = |obj| (
        "Identifier {" +
        " tag_class=" + obj.@tag_class.to_string +
        " constructed=" + obj.@constructed.to_string +
        " tag=" + obj.@tag.to_string +
        " }"
    );
}

decode_identifier: [m: MonadReadByte] m Identifier;
decode_identifier = (
    let u8 = *read_byte;
    let tag_class = u8.shift_right(6_U8).bit_and(3_U8);
    let constructed = (u8.bit_and(0x20_U8) != 0_U8);
    let tag_type = u8.bit_and(31_U8);
    let tag_type = *(
        if tag_type < 31_U8 { pure $ tag_type };
        loop_m(
            0_U8, |tag_type|
            let u8 = *read_byte;
            let tag_type = tag_type.shift_left(7_U8).bit_or(u8.bit_and(0x3f_U8));
            if u8.bit_and(0x80_U8) == 0_U8 { break_m $ tag_type };
            continue_m $ tag_type
        )
    );
    pure $ Identifier {
        tag_class: tag_class,
        constructed: constructed,
        tag: tag_type
    }
);

decode_length: [m: MonadReadByte] m I64;
decode_length = (
    let u8 = *read_byte;
    if u8.bit_and(0x80_U8) == 0_U8 {
        pure $ u8.to_I64
    };
    let n = u8.bit_and(0x3F_U8).to_I64;
    if n == 0 {
        error $ "der does not allow indefinite length"
    };
    if n == 127 {
        error $ "der does not allow reserved length"
    };
    loop_m(
        (0, 0), |(length, i)|
        if i >= n { break_m $ length };
        let u8 = *read_byte;
        let length = length.shift_left(8).bit_or(u8.to_I64); 
        continue_m $ (length, i + 1)
    )
);

decode_n_bytes: [m: MonadReadByte] I64 -> m (Array U8);
decode_n_bytes = |length| (
    Array::fill(length, read_byte).map_m(|x| x)
);

decode_primitive: [m: MonadReadByte] m (Identifier, Array U8);
decode_primitive = (
    let identifier = *decode_identifier;
    if identifier.@constructed {
        error $ "not a primitive"
    };
    let length = *decode_length;
    let contents = *decode_n_bytes(length);
    pure $ (identifier, contents)
);

decode_constructed: [m: MonadReadByte] Tag -> m a -> m a;
decode_constructed = |tag, inner_monad| (
    let identifier = *decode_identifier;
    if identifier.@constructed {
        error $ "not a primitive"
    };
    let length = *decode_length;


    decode_sequence $ do {

    };
);

repeat: [m: MonadReadByte] m a -> m (Array a);
repeat = |inner_monad| (
    loop_m(
        [], |arr|
        if *is_eof { break_m $ arr };
        let a = *inner_monad;
        continue_m $ arr.push_back(a)
    )
);

decode_sequence: [m: MonadReadByte] m a -> m a;
decode_sequence = |inner_monad| (
    decode_constructed(tag_sequence, inner_monad)
);

decode_sequence_of: [m: MonadReadByte] m a -> m (Array a);
decode_sequence_of = |inner_monad| (
    decode_constructed(tag_sequence, repeat $ inner_monad)
);

decode_set_of: [m: MonadReadByte] m a -> m (Array a);
decode_set_of = |inner_monad| (
    decode_constructed(tag_set, repeat $ inner_monad)
);

choice: [m: MonadError] Array (m a) -> m a;
choice = |monads| (
    let inner = fix $ |inner, i| (
        if i >= monads.get_size - 1 { monads.@(i) };
        monads.@(i).catch(|err| inner(i + 1))
    );
    inner(0)
);

trait a: DecodeDer {
    decode_der: [m: MonadReadByte] m a;
}


impl Asn1::Integer: DecodeDer {
    decode_der = (
        let (identifier, contents) = *decode_primitive;
        eval *assert_tag(tag_integer, identifier);
        if contents.get_size > 8 {
            error $ "too large integer"
        };
        let u64 = contents.to_iter.fold(
            0_U64, |u64, u8|
            u64.shift_left(8_U64).bit_or(u8.to_U64)
        );
        pure $ u64.to_I64
    );
}

impl Asn1::ObjectIdentifier: DecodeDer {
    decode_der = (
        let (identifier, contents) = *decode_primitive;
        eval *assert_tag(tag_object_identifier, identifier);
        if contents.get_size <= 0 { error $ "invalid object identifier" };
        let first = contents.@(0) / 20_U8;
        let second = contents.@(0) % 20_U8;
        let numbers = [first, second].append(contents.subarray(1, contents.get_size));

        pure $ ObjectIdentifier { numbers: numbers }
    );
}

// ITU-T Rec. X.680 (02/2021)
// p.63 38	The time type
decode_time: [m: MonadReadByte] m String;
decode_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_time, identifier);
    // contents = hh:mm:ss
    pure $ contents._unsafe_to_string
);

decode_generalized_time: [m: MonadReadByte] m String;
decode_generalized_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_generalized_time, identifier);
    // contents = ????
    pure $ contents._unsafe_to_string
);

decode_utc_time: [m: MonadReadByte] m String;
decode_utc_time = (
    let (identifier, contents) = *decode_primitive;
    eval *assert_tag(tag_utc_time, identifier);
    // contents = YYMMDDhhmm(ss)?(z|[+-]hhmm)
    pure $ contents._unsafe_to_string
);

impl Time::Time: DecodeDer {
    decode_der = (
        let (identifier, contents) = *decode_primitive;
        eval *choice([
            assert_tag(tag_time, identifier),
            assert_tag(tag_time, identifier),
            assert_tag(tag_time, identifier),

        ]);
        if contents.get_size > 8 {
            error $ "too large integer"
        };
        let u64 = contents.to_iter.fold(
            0_U64, |u64, u8|
            u64.shift_left(8_U64).bit_or(u8.to_U64)
        );
        pure $ u64.to_I64
    );
}
