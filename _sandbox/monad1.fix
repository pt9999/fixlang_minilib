module Main;

// Function monad. same as Reader monad
type Function a b = unbox struct {
    data: a -> b
};

namespace Function {
    make: (a -> b) -> Function a b;
    make = |f| Function { data: f };

    get: Function a b -> (a -> b);
    get = @data;
}

impl Function a: Functor {
    map = |f, mb| Function::make(mb.@data >> f);
}

impl Function a: Monad {
    pure = |b| Function::make(|_| b);
    bind = |f, mb| Function::make(|a|
        let mc = f((mb.@data)(a));
        (mc.@data)(a)
    );
}

// A continuation monad.
type Cont r a = unbox struct {
    data: (a -> r) -> r
};

namespace Cont {
    make: ((a -> r) -> r) -> Cont r a;
    make = |g| Cont { data: g };

    run: (a -> r) -> Cont r a -> r;
    run = |f, ma| (
        (ma.@data)(f)
    );
}

impl Cont r: Functor {
    map = |fab, ma| (       // fab: a -> b
        Cont::make $ |fbr|  // fbr: b -> r
        ma.run(fab >> fbr)
    );
}

impl Cont r: Monad {
    pure = |a| Cont::make $ |far| far(a);
    bind = |famb, ma| (     // famb: a -> m b
        Cont::make $ |fbr|  // fbr: b -> r
        ma.run(|a|
            famb(a).run(fbr)
        )
    );
}

test_functor_cont: IO ();
test_functor_cont = (
    let ma: Cont (Array String) I64 = Cont::make $ |far| far(3);
    let mb = ma.map(to_string);
    let c = mb.run(|b| [b, b]);
    println(c.to_string)
);

test_monad_cont: IO ();
test_monad_cont = (
    let mc: Cont (Array String) (Array I64)  = do {
        let a = *pure(3);
        let b = *pure(4);
        pure $ [a, b]
    };
    let md: Cont (Array String) (Array String) = do {
        let ab = *mc;
        if ab.@(0) % 2 == 0 {
            pure $ ab.map(to_string)
        } else {
            pure $ ab.append(ab).map(to_string)
        }
    };
    let ans = md.run(|x| x);
    println (ans.to_string)
);

main: IO ();
main = test_monad_cont;
