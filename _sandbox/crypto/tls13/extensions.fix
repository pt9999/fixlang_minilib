module Minilib.Crypto.Tls13.Extensions;

import Debug;

import Minilib.Crypto.Tls13.Types;
import Minilib.Encoding.Binary;


// 4.2 Extensions

type ExtensionType = U16;
type Extension = unbox union {
    unknown_extension: ExtensionType,
    server_name: (),
    max_fragment_length: (),
    status_request: (),
    supported_groups: NamedGroupList,
    signature_algorithms: (),
    use_srtp: (),
    heartbeat: (),
    application_layer_protocol_negotiation: (),
    signed_certificate_timestamp: (),
    client_certificate_type: (),
    server_certificate_type: (),
    padding: (),
    pre_shared_key: (),
    early_data: (),
    supported_versions: SupportedVersions,
    cookie: (),
    psk_key_exchange_modes: (),
    certificate_authorities: (),
    oid_filters: (),
    post_handshake_auth: (),
    signature_algorithms_cert: (),
    key_share: ()
};

namespace Extension {
    default_extensions: Array Extension;
    default_extensions = [
        supported_groups(NamedGroupList::default),
        supported_versions(SupportedVersions::default),
    ];

    get_extension_type: Extension -> ExtensionType;
    get_extension_type = |ex| (
        if ex.is_unknown_extension { ex.as_unknown_extension.to_I64 };
        if ex.is_server_name { 0 };
        if ex.is_max_fragment_length { 1 };
        if ex.is_status_request { 5 };
        if ex.is_supported_groups { 10 };
        if ex.is_signature_algorithms { 13 };
        if ex.is_use_srtp { 14 };
        if ex.is_heartbeat { 15 };
        if ex.is_application_layer_protocol_negotiation { 16 };
        if ex.is_signed_certificate_timestamp { 18 };
        if ex.is_client_certificate_type { 19 };
        if ex.is_server_certificate_type { 20 };
        if ex.is_padding { 21 };
        if ex.is_pre_shared_key { 41 };
        if ex.is_early_data { 42 };
        if ex.is_supported_versions { 43 };
        if ex.is_cookie { 44 };
        if ex.is_psk_key_exchange_modes { 45 };
        if ex.is_certificate_authorities { 47 };
        if ex.is_oid_filters { 48 };
        if ex.is_post_handshake_auth { 49 };
        if ex.is_signature_algorithms_cert { 50 };
        if ex.is_key_share { 51 };
        eval assert(|_| "invalid extension type", false);
        65535
    ).to_U16;
}

impl Extension: Marshal {
    marshal = |ex, buf| (
        let buf = buf.marshal(ex.get_extension_type);
        let size_pos = buf.get_position;
        let buf = buf.marshal(0_U16);       // size
        let buf = (
            if ex.is_supported_groups { buf.marshal(ex.as_supported_groups) };
            if ex.is_supported_versions { buf.marshal(ex.as_supported_versions) };
            buf
        );
        let last_pos = buf.get_position;
        let buf = buf.set_u16(size_pos, (last_pos - (size_pos + 2)).to_U16);
        buf
    );
}

impl Extension: Unmarshal {
    unmarshal = |buf| (
        let (extension_type, buf) = *buf.unmarshal;
        let (extension_data_size: U16, buf) = *buf.unmarshal;

        if extension_type == 10_U16 { buf.unmarshal.map_res_0(supported_groups) };
        if extension_type == 43_U16 { buf.unmarshal.map_res_0(supported_versions) };

        // skip unknown extension data
        let buf = buf.set_position(buf.get_position + extension_data_size.to_I64);
        pure $ (unknown_extension(extension_type), buf)
    );
}

// 4.2.1 Supported Versions
type SupportedVersions = unbox struct {
    versions: Array ProtocolVersion
};

namespace SupportedVersions {
    default: SupportedVersions;
    default = SupportedVersions {
        versions: [
            0x0304_U16     // TLS 1.3
        ]
    };
}

impl SupportedVersions: Marshal {
    marshal = |obj, buf| (
        // for ClientHello
        buf.marshal_var_size(obj.@versions, to_U8)
    );
}

impl SupportedVersions: Unmarshal {
    unmarshal = |buf| (
        // for ServerHello, HelloRetryRequest
        buf.unmarshal.map_res_0(|version|
            SupportedVersions { versions: [ version ] }
        )
    );
}

// 4.2.3. Signature Algorithms
type SignatureScheme = U16;

namespace SignatureScheme {
    table: Array (String, SignatureScheme);
    table = [
        /* RSASSA-PKCS1-v1_5 algorithms */
        ("rsa_pkcs1_sha256", 0x0401_U16),
        ("rsa_pkcs1_sha384", 0x0501_U16),
        ("rsa_pkcs1_sha512", 0x0601_U16),

        /* ECDSA algorithms */
        ("ecdsa_secp256r1_sha256", 0x0403_U16),
        ("ecdsa_secp384r1_sha384", 0x0503_U16),
        ("ecdsa_secp521r1_sha512", 0x0603_U16),

        /* RSASSA-PSS algorithms with public key OID rsaEncryption */
        ("rsa_pss_rsae_sha256", 0x0804_U16),
        ("rsa_pss_rsae_sha384", 0x0805_U16),
        ("rsa_pss_rsae_sha512", 0x0806_U16),

        /* EdDSA algorithms */
        ("ed25519", 0x0807_U16),
        ("ed448", 0x0808_U16),

        /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
        ("rsa_pss_pss_sha256", 0x0809_U16),
        ("rsa_pss_pss_sha384", 0x080a_U16),
        ("rsa_pss_pss_sha512", 0x080b_U16),

        /* Legacy algorithms */
        ("rsa_pkcs1_sha1", 0x0201_U16),
        ("ecdsa_sha1", 0x0203_U16)
    ];

    find_by_name: String -> Option SignatureScheme;
    find_by_name = |name| (
        table.find_by(@0 >> eq(name)).map(@1)
    );

    find_by_id: SignatureScheme -> Option String;
    find_by_id = |id| (
        table.find_by(@1 >> eq(id)).map(@0)
    );
}

type SignatureSchemeList = unbox struct {
    v: Array SignatureScheme
};

impl SignatureSchemeList: Marshal {
    marshal = |obj, buf| (
        buf.marshal_var_size(obj.@v, to_U16)
    );
}

impl SignatureSchemeList: Unmarshal {
    unmarshal = |buf| (
        buf.unmarshal_var_size(U16::to_I64).map_res_0(|v|
            SignatureSchemeList { v: v }
        )
    );
}

// 4.2.7 Supported Groups

namespace NamedGroup {
    /* Elliptic Curve Groups (ECDHE) */

    secp256r1: NamedGroup;
    secp256r1 = 0x0017_U16;
    secp384r1: NamedGroup;
    secp384r1 = 0x0018_U16;
    secp521r1: NamedGroup;
    secp521r1 = 0x0019_U16;
    x25519: NamedGroup;
    x25519 = 0x001D_U16;
    x448: NamedGroup;
    x448 = 0x001E_U16;

    /* Finite Field Groups (DHE) */
    ffdhe2048: NamedGroup;
    ffdhe2048 = 0x0100_U16;
    ffdhe3072: NamedGroup;
    ffdhe3072 = 0x0101_U16;
    ffdhe4096: NamedGroup;
    ffdhe4096 = 0x0102_U16;
    ffdhe6144: NamedGroup;
    ffdhe6144 = 0x0103_U16;
    ffdhe8192: NamedGroup;
    ffdhe8192 = 0x0104_U16;
/*
    table: Array (String, NamedGroup);
    table = [
        ("secp256r1", 0x0017_U16),
        ("secp384r1", 0x0018_U16),
        ("secp521r1", 0x0019_U16),
        ("x25519", 0x001D_U16),
        ("x448", 0x001E_U16),

        ("ffdhe2048", 0x0100_U16),
        ("ffdhe3072", 0x0101_U16),
        ("ffdhe4096", 0x0102_U16),
        ("ffdhe6144", 0x0103_U16),
        ("ffdhe8192", 0x0104_U16)
    ];

    find_by_name: String -> Option NamedGroup;
    find_by_name = |name| (
        table.find_by(@0 >> eq(name)).map(@1)
    );

    find_by_id: NamedGroup -> Option String;
    find_by_id = |id| (
        table.find_by(@1 >> eq(id)).map(@0)
    );
*/
}

type NamedGroupList = unbox struct {
    v: Array NamedGroup
};

namespace NamedGroupList {
    default: NamedGroupList;
    default = NamedGroupList {
        v: [
           NamedGroup::secp256r1,
        ]
    };
}

impl NamedGroupList: Marshal {
    marshal = |obj, buf| (
        buf.marshal_var_size(obj.@v, to_U16)
    );
}

impl NamedGroupList: Unmarshal {
    unmarshal = |buf| (
        buf.unmarshal_var_size(U16::to_I64).map_res_0(|v|
            NamedGroupList { v: v }
        )
    );
}

// 4.2.8. Key Share
// see key_share.fix
