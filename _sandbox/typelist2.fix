module Main;

trait a: ToTypeName {
    to_typename: a -> String;
}

impl I64: ToTypeName { to_typename: I64 -> String = |_| "I64"; }
impl I32: ToTypeName { to_typename: I32 -> String = |_| "I32"; }
impl I16: ToTypeName { to_typename: I16 -> String = |_| "I16"; }

type TNil = unbox struct {};
impl TNil: Zero { zero = TNil {}; }
impl TNil: ToTypeName { to_typename: TNil -> String = |_| "TNil"; }

type TCons a b = unbox struct { a:a, b:b };
impl [a: Zero, b: Zero] TCons a b: Zero { zero = TCons { a:zero, b: zero }; }
impl [a: ToTypeName, b: ToTypeName] TCons a b: ToTypeName { 
    to_typename: TCons a b -> String = |c| c.@a.to_typename + ":" + c.@b.to_typename; 
}

type TypeList0 = TNil;
type TypeList1 a = TCons a TypeList0;
type TypeList2 a b = TCons a (TypeList1 b);     // この定義を使うと `b` が `c` になる？
//type TypeList2 b c = TCons b (TypeList1 c);   // この定義を使えば期待通り動作する
type TypeList3 a b c = TCons a (TypeList2 b c);

impl [a: ToTypeName, b: ToTypeName, c: ToTypeName,
      a: Zero, b: Zero, c: Zero] Tuple3 a b c: ToTypeName { 
    to_typename: Tuple3 a b c -> String = |_| (zero: TypeList3 a b c).to_typename;
}

/*
// 上記のimplの代わりにこちらのimplを使っても期待通り動作する
impl [x: ToTypeName, y: ToTypeName, z: ToTypeName,
      x: Zero, y: Zero, z: Zero] Tuple3 x y z: ToTypeName { 
    to_typename: Tuple3 x y z -> String = |_| (zero: TypeList3 x y z).to_typename;
}
*/

main: IO ();
main = (
    println $ (1_I64, 1_I32, 1_I16).to_typename
    // expected: "I64:I32:I16:TNil"
    // actual: "I64:I16:I16:TNil"
);
