module SprintfTest;

import Minilib.Text.Sprintf;
import Minilib.Testing.UnitTest;

test_sprintf_tuples: TestCase;
test_sprintf_tuples = (
    make_test("test_sprintf_tuples") $ |_|
    assert_equal("eq", ok $ "abc", ().sprintf("abc"));;
    assert_equal("eq", err $ "Too few arguments", ().sprintf("abc%ddef"));;
    assert_equal("eq", err $ "Too many arguments", (42, ).sprintf("abc"));;
    assert_equal("eq", ok $ "abc42def", (42,).sprintf("abc%ddef"));;
    assert_equal("eq", ok $ "abc42def43ghi", (42,43).sprintf("abc%ddef%dghi"));;
    assert_equal("eq", ok $ "abc hello def world ghi 100 jkl", ("hello", "world", 100).sprintf("abc %s def %s ghi %s jkl"));;
    pure()
);

test_sprintf_i64: TestCase;
test_sprintf_i64 = (
    make_table_test("test_sprintf_i64",
        [
            ("%s", -42, "-42"),
            ("%d", -42, "-42"),
            ("%i", -9223372036854775808, "-9223372036854775808"),
            ("%i", -42, "-42"),
            ("%i", 0, "0"),
            ("%i", 9223372036854775807, "9223372036854775807"),
            ("%u", -9223372036854775808, "9223372036854775808"),
            ("%u", -42, "18446744073709551574"),
            ("%u", 0, "0"),
            ("%u", 9223372036854775807, "9223372036854775807"),
            ("%x", 0x0123abcd, "123abcd"),
            ("%X", 0x0123abcd, "123ABCD"),
            ("%o", 0o0123456, "123456"),
        ],
        |(format, value, expected)|
        let actual = (value,).sprintf(format);
        assert_equal("eq", ok $ expected, actual)
    )
);

// TODO: add test_sprintf_i32
// TODO: add test_sprintf_i16

test_sprintf_i8: TestCase;
test_sprintf_i8 = (
    make_table_test("test_sprintf_i8",
        [
            ("%i", -128_I8, "-128"),
            ("%i", 127_I8, "127"),
            ("%u", -128_I8, "128"),
            ("%u", -1_I8, "255"),
            ("%u", 127_I8, "127"),
            ("%x", -128_I8, "80"),
            ("%x", 127_I8, "7f"),
        ],
        |(format, value, expected)|
        let actual = (value,).sprintf(format);
        assert_equal("eq", ok $ expected, actual)
    )
);

test_sprintf_u64: TestCase;
test_sprintf_u64 = (
    make_table_test("test_sprintf_u64",
        [
            ("%i", 0_U64, "0"),
            ("%i", 9223372036854775807_U64, "9223372036854775807"),
            ("%i", 9223372036854775808_U64, "-9223372036854775808"),
            ("%i", 18446744073709551615_U64, "-1"),
            ("%u", 0_U64, "0"),
            ("%u", 9223372036854775807_U64, "9223372036854775807"),
            ("%u", 9223372036854775808_U64, "9223372036854775808"),
            ("%u", 18446744073709551615_U64, "18446744073709551615"),
            ("%x", 0x0_U64, "0"),
            ("%x", 0x0123abcd_U64, "123abcd"),
            ("%x", 0xffffffffffffffff_U64, "ffffffffffffffff"),
            ("%X", 0x0123abcd_U64, "123ABCD"),
            ("%o", 0o0123456_U64, "123456"),
            ("%o", 0xffffffffffffffff_U64, "1777777777777777777777"),
        ],
        |(format, value, expected)|
        let actual = (value,).sprintf(format);
        assert_equal("eq", ok $ expected, actual)
    )
);

// TODO: add test_sprintf_u32
// TODO: add test_sprintf_u16

test_sprintf_u8: TestCase;
test_sprintf_u8 = (
    make_table_test("test_sprintf_u8",
        [
            ("%i", 0_U8, "0"),
            ("%i", 127_U8, "127"),
            ("%i", 128_U8, "128"),
            ("%i", 255_U8, "255"),
            ("%u", 0_U8, "0"),
            ("%u", 127_U8, "127"),
            ("%u", 128_U8, "128"),
            ("%u", 255_U8, "255"),
            ("%x", 0_U8, "0"),
            ("%x", 127_U8, "7f"),
            ("%x", 128_U8, "80"),
            ("%x", 255_U8, "ff"),
        ],
        |(format, value, expected)|
        let actual = (value,).sprintf(format);
        assert_equal("eq", ok $ expected, actual)
    )
);

test_sprintf_f64: TestCase;
test_sprintf_f64 = (
    make_table_test("test_sprintf_f64",
        [
            // default precision is 6
            ("%f", 123.456, "123.456000"),
            // negative precision is same as default
            ("%.-1f", 123.456, "123.456000"),
            // zero precision will drop the decimal point
            ("%.0f", 123.456, "123"),
            ("%.1f", 123.456, "123.5"),
            ("%.8f", 123.456, "123.45600000"),
            ("%.8f", 1.0 / 0.0, "inf"),
            // 'F' will convert to uppercase
            ("%.8F", -1.0 / 0.0, "-INF"),

            // default precision is 6
            ("%e", 123.456, "1.234560e+02"),
            // negative precision is same as default
            ("%.-1e", 123.456, "1.234560e+02"),
            // zero precision will drop the decimal point
            ("%.0e", 123.456, "1e+02"),
            ("%.1e", 123.456, "1.2e+02"),
            ("%.8e", 123.456, "1.23456000e+02"),
            // 'E' will convert to uppercase
            ("%.8E", 123.456, "1.23456000E+02"),

            // with "%g", trailing zeros in fractional part and (optionally) the decimal point will be removed
            ("%g", 0.0, "0"),
            ("%g", 123.000, "123"),
            // default precision is 6, but trailing zeros in fractional part are removed
            ("%g", 123.456, "123.456"),
            ("%.2g", 1.23456, "1.23"),
            ("%.8g", 123.456, "123.456"),
            // 'G' will convert to uppercase
            ("%G", 123.456e10, "1.23456E+12"),
            // uses %e format when exponent < -4
            ("%g", 0.000099, "9.9e-05"),
            // uses %f format when -4 <= exponent < precision
            ("%g", 0.0001, "0.0001"),
            ("%g", 999999.0, "999999"),
            ("%.3g", 999.0, "999"),
            // uses %e format when exponent >= max(1, precision)
            ("%g", 1000000.0, "1e+06"),
            ("%.3g", 1000.0, "1e+03"),
            ("%.1g", 10.0, "1e+01"),
            ("%.1g", 1.0, "1"),
            ("%.0g", 10.0, "1e+01"),
            ("%.0g", 1.0, "1"),
            // flag_sign and field_width are applied
            ("%+10.2f", 123.456, "   +123.46"),
            // flag_space, flag_left_padding and field_width are applied
            ("%- 10.2f", 123.456, " 123.46   "),
        ],
        |(format, value, expected)|
        let actual = (value,).sprintf(format);
        assert_equal("eq", ok $ expected, actual)
    )
);

// TODO: add test_sprintf_f32

main: IO ();
main = (
    [
        test_sprintf_tuples,
        test_sprintf_i64,
        test_sprintf_i8,
        test_sprintf_u64,
        test_sprintf_u8,
        test_sprintf_f64,
    ]
    .run_test_driver
);