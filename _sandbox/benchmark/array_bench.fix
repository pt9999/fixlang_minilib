module Main;

op_array_i64: I64 -> I64 -> IO I64;
op_array_i64 = |n, a| (
    pure();;
    let arr = Array::fill(n, 0);
    let arr = arr.map(add(a));
    pure $ arr.@(arr.get_size - 1)
);

type Obj = unbox struct {
    a: I64,
    b: I64,
    c: I64,
    d: I64,
};

op_array_obj: I64 -> I64 -> IO I64;
op_array_obj = |n, a| (
    pure();;
    let arr = Array::fill(n, Obj{a:0, b:0, c:0, d:0});
    let arr = arr.map(|obj| obj.mod_a(add(a)).mod_b(add(a)).mod_c(add(a)).mod_d(add(a)));
    let obj = arr.@(arr.get_size - 1);
    pure $ obj.@a + obj.@b + obj.@c + obj.@d
);

bench: String -> I64 -> I64 -> I64 -> (I64 -> I64 -> IO I64) -> IO ();
bench = |name, times, n, a, op| (
    let (result, time) = *consumed_time_while_io(
        pure();;
        range(0, times).fold_m(
            0, |_, sum|
            let sum = sum + *op(n, a);
            pure $ sum
        )
    );
    println(name + ": result="+result.to_string+" time="+time.to_string)
);

main: IO ();
main = (
    let times = 100;
    let n = 1000000;
    bench("op_array_i64 ", times, n, 1, op_array_i64);;
    bench("op_array_obj  ", times, n/4, 1, op_array_obj);;
    pure()
);