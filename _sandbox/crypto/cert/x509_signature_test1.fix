module Main;

import Debug;
//import HashMap;

import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.X509Signature;
/*
import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1.Der;
import Minilib.Crypto.Cert.X509;
import Minilib.Crypto.Cert.Pem;
import Minilib.Crypto.Cert.OID;
import Minilib.Crypto.Cert.Pkcs1;
import Minilib.Encoding.Binary;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;
import Minilib.Thread.Time;
*/
import Minilib.Testing.UnitTest;

test1: IOFail ();
test1 = (
    let path = Path::parse("/etc/ssl/certs/DigiCert_Global_Root_CA.pem").as_some;   // sha-1WithRSAEncryption
    //let path = Path::parse("/etc/ssl/certs/DigiCert_Global_Root_G2.pem").as_some;   // sha256WithRSAEncryption
    let certificates = *read_certificates_from_pem_file(path);
    if certificates.get_size != 1 { throw $ "read_certificates_pem failed" };
    let certificate = certificates.@(0);
    let public_key = certificate.@tbs_certificate.@subject_public_key_info;
    eval *certificate.validate_signature(public_key).from_result;
    println("validation ok").lift
);

main: IO ();
main = do {
    test1
}.try(eprintln);
