module Main;

import HashMap;
import Debug;

//import URL;
//import SimpleParser;
import StringEx;


//type RequestHandler = Request -> Response -> IOFail Response;
type RequestHandler = String;

type RouterEntry = box struct {
    map: HashMap String RequestHandler
};

namespace RouterEntry {
    empty: RouterEntry;
    empty = RouterEntry { 
        map: HashMap::empty(2)
    };

    is_empty: RouterEntry -> Bool;
    is_empty = |entry| entry.@map.get_size == 0;

    update: String -> RequestHandler -> RouterEntry -> RouterEntry;
    update = |method, handler, entry| (
        entry.mod_map(|map| map.insert(method, handler))
    );

    find: String -> RouterEntry -> Option RequestHandler;
    find = |method, entry| (
        entry.@map.find(method)
    );

    show: RouterEntry -> IO ();
    show = |entry| (
        println (entry.@map.to_string)
    );
}

/*
    /               ... [ ]
    /about.html     ... [ "about.html" ]
    /users          ... [ "users" ]
    /users/         ... [ "users" ]
    /users/:id      ... [ "users", ":id" ]
    /users/:id/     ... [ "users", ":id" ]
*/
type RouterNode = box struct {
    directory: HashMap String RouterNode,
    entry: RouterEntry
};
namespace RouterNode {
    empty: RouterNode;
    empty = RouterNode {
        directory: HashMap::empty(8),
        entry: RouterEntry::empty
    };

    create: Iterator String -> (RouterEntry -> RouterEntry) -> RouterNode;
    create =  |path, entry_updater| (
        update(path, entry_updater, RouterNode::empty)
    ); 
    
    // 現在のノードからpathを辿った先のノードを更新する。
    // path は現在のノードから更新対象のノードにたどり着くまでの経路。
    // path の各要素には空文字列を含んではいけない。
    // entry_updater はエントリを更新する関数。
    // node は現在のノード。
    // 更新後のノードが返る。
    update: Iterator String -> (RouterEntry -> RouterEntry) -> RouterNode -> RouterNode;
    update = |path, entry_updater, node| (
        if path.is_empty {
            node.mod_entry(entry_updater)
        };
        let (child_name, child_path) = path.advance.as_some;
        eval assert (|_| "child name should not be an empty string", child_name != "");
        node.mod_directory(|dir|
            let child_node = dir.find(child_name).map_or(
                create(child_path, entry_updater),
                |child_node| child_node.update(child_path, entry_updater)
            );
            dir.insert(child_name, child_node)
        )
    );

    // 現在のノードからpathを辿った先のノードのエントリを取得する。
    find: Iterator String -> RouterNode -> Option RouterEntry;
    find = |path, node| (
        if path.is_empty {
            node.@entry
        };
        let (child_name, child_path) = path.advance.as_some;
        eval assert (|_| "child name should not be an empty string", child_name != "");
        // TODO: `:id` のようなパターンに対応する
        node.@directory.find(child_name).map(|child_node| child_node.find(child_path))
    );

    show: String -> RouterNode -> IO ();
    show = |prefix, node| (
        let print_entry = (
            if node.@entry.is_empty {
                pure()
            };   
            let _ = *print(prefix + ": ");
            node.@entry.show
        );
        let print_directory = (
            let ends_with: String -> String -> Bool = |e,s| (
                s.substring(s.get_size - e.get_size, s.get_size) == e
            );
            let slash = if prefix.ends_with("/") { "" } else { "/" };
            node.@directory.to_iter.fold_m(
                (), |_, (child_name, child_node)|
                child_node.show(prefix + slash + child_name)
            )
        );
        let _ = *print_entry;
        let _ = *print_directory;
        pure()
    );
}

type Router = box struct {
    root: RouterNode
};

namespace Router {

    empty: Router;
    empty = Router {
        root: RouterNode::empty
    };

    insert: String -> String -> RequestHandler -> Router -> Router;
    insert = |method, path, handler, router| (
        let path: Iterator String = path.split("/").filter(|s| s != "");
        let entry_updater : RouterEntry -> RouterEntry = |entry| entry.update(method, handler);
        router.mod_root(|root| root.update(path, entry_updater))
    );

/*
    route: Request -> Response -> Router -> IOFail Response;
    route = |req, res, router| (
        // TODO: split query and path
        // TODO: lookup hierarchy
        let opt = router.@map.find(req.request_target);
        xxx
    );
*/
}

main: IO ();
main = (
    let _ = *eprintln("start");
    let router = Router::empty;
    let router = router.insert("GET", "/", "index");
    let router = router.insert("GET", "/users", "users");
    let router = router.insert("POST", "/users", "users-post");
    let router = router.insert("GET", "/users/1", "users-1");
    let _ = *router.@root.show("/");
    pure()
);
