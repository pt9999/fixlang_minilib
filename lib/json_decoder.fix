module JsonDecoder;

import Debug;
import HashMap;

import Json;
import SimpleParser;
import StringEx;

_ws: Parser ();
_ws = class_whitespace.map(|str| ());

_wrap_whitespaces: Parser a -> Parser a;
_wrap_whitespaces = |p| (
    _ws.then(keep_right, p)
    .then(keep_left, _ws)
);

_begin_array: Parser ();
_begin_array = _wrap_whitespaces(match_str("["));

_begin_object: Parser ();
_begin_object = _wrap_whitespaces(match_str("{"));

_end_array: Parser ();
_end_array = _wrap_whitespaces(match_str("]"));

_end_object: Parser ();
_end_object = _wrap_whitespaces(match_str("}"));

_name_separator: Parser ();
_name_separator = _wrap_whitespaces(match_str(":"));

_value_separator: Parser ();
_value_separator = _wrap_whitespaces(match_str(","));

_parse_null: Parser ();
_parse_null = match_str("null");

_parse_bool: Parser Bool;
_parse_bool = (
    let parse_true = match_str("true").map(|_| true);
    let parse_false = match_str("false").map(|_| false);
    parse_true.or_else(parse_false)
);

_match_unquoted_char: Parser U8;
_match_unquoted_char = any_char.filter(|c| c != _DOUBLEQUOTE && c != _BACKSLASH);

_match_unquoted_str: Parser String;
_match_unquoted_str = (
    one_or_more(_match_unquoted_char).map(|array| array._unsafe_to_string)
);


_unhex: U8 -> Result ErrMsg U8;
_unhex = |c| (
    if /* '0' = */ 48_U8 <= c && c <= /* '9' = */ 57_U8 { ok $ c - 48_U8 };
    if /* 'A' = */ 65_U8 <= c && c <= /* 'F' = */ 70_U8 { ok $ c - 65_U8 + 10_U8 };
    if /* 'a' = */ 97_U8 <= c && c <= /* 'f' = */ 102_U8 { ok $ c - 97_U8 + 10_U8 };
    err $ _Fail
);

_match_quoted_str: Parser String;
_match_quoted_str = (
    let match_escaped: Parser String = (
        any_char
        .map(|c| _unescape_table.@(c.to_I64))
        //.map(|c| eval debug_println("c="+c.to_string); c)
        .filter(|c| c != 0_U8)
        .map(|c| [ c ]._unsafe_to_string)
    );
    let match_hex: Parser U8 = any_char.bind_parser(|c| c._unhex);
    let match_hex4: Parser U16 = 
        match_hex
        .then(keep_both, match_hex)
        .then(keep_both, match_hex)
        .then(keep_both, match_hex)
        .map( |(((a,b),c),d)| 
            let a = a.to_U16.shift_left(12_U16);
            let b = b.to_U16.shift_left(8_U16);
            let c = c.to_U16.shift_left(4_U16);
            let d = d.to_U16.shift_left(0_U16);
            a.bit_or(b).bit_or(c).bit_or(d));
    let encode_utf8: U16 -> String = |ch|
        // FIXME not implemented yet
        [ ch.to_U8 ]._unsafe_to_string;
    let match_u_hex4: Parser String = (
        match_char(_ASCII_LOWER_U)
        .then(keep_right, match_hex4)
        .map(encode_utf8)        
    );

    match_char(_BACKSLASH)
    //.debug_parser(|res| "backslash="+ res.to_string)
    .then(
        keep_right,
        match_escaped
        .or_else(match_u_hex4)
    )
);

_match_str_inner: Parser String;
_match_str_inner = (
    repeat(
        _match_quoted_str
        .or_else(_match_unquoted_str) // 1文字以上にマッチ
    ).map(
        |array| array.to_iter.concat_iter
    )
    .or_else(unit.map(|_| ""))
);

_parse_string: Parser String;
_parse_string = (
    match_char(_DOUBLEQUOTE)
    .then(keep_right, _match_str_inner)
    .then(keep_left, 
        match_char(_DOUBLEQUOTE)
        .or_error("The double quote at the end of the string is missing.")
    )
);

_parse_object: Parser (HashMap String Json);
_parse_object = (
    let member : Parser (String, Json) = 
        _parse_string
        .then(keep_left, _name_separator.or_error("Missing ':'"))
        .then(keep_both, _decode_json);
    let sep_member : Parser (String, Json) =
        _value_separator
        .then(keep_right, member);

    let to_hashmap: Array (String, Json) -> HashMap String Json =
        |kvs| kvs.to_iter.fold(
            HashMap::empty(100),
            |h, (k, v)| h.insert(k, v)
        );
    let body = (
        member
        .then(|(kv, kvs)| [kv].append(kvs), 
            repeat(sep_member))
        .map(to_hashmap)
        .or_else(unit.map(|_| HashMap::empty(0)))
    );

    _begin_object.debug_parser(|_| "_begin_object")
    .then(keep_right, body)
    .then(keep_left, 
        _end_object.or_error("Missing '}'"))
);


_decode_json: Parser Json;
_decode_json = |s| (
    // Make a lazy parser, so that we can avoid stack overflow.
    let parser = (
        _parse_null.map(|_| null())
        .or_else(_parse_bool.map(|b| bool(b)))
        .or_else(_parse_string.map(|str| string(str)))
        .or_else(_parse_object.map(|hash| object(hash)))
    );
    parser.run_parser(s)
);

decode: String -> Result ErrMsg Json;
decode = |str| (
    let p = _wrap_whitespaces(_decode_json)
        .then(keep_left, match_end_of_stream);
    let (json, next) = *(p.run_parser_str(str));
    pure $ json
);
