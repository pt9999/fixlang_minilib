// Montgomery modular multiplication
//
// Using Montgomery form, modular arithmetic becomes faster.
// For details, see [Wikipedia: Montgomery modular multiplication](https://en.wikipedia.org/wiki/Montgomery_modular_multiplication).
//
// Montgomery form is `a * R mod N`, where `N` is the modulus for the target modular arithmetic, and `R` is an integer greater than `N`.
// `R` can be chosen such that the division by `R` is easy.
// In practive, `R` is a power of two. For example, `R = 2^256` or `R = 2^384`.
//
module Minilib.Math.Montgomery;

import Minilib.Common.Assert;
import Minilib.Math.BigInt;
import Minilib.Math.BigNat;
import Minilib.Math.Euclid;
import Minilib.Math.Types;

// Montgomery scheme, which contains several parameters for Montgomery arithmetic.
type MontScheme = unbox struct {
    r_log_base: U64,    // r = 2 ^ (r_log_base * _log2_base)
    n: BigInt,          // the modulus
    m: BigInt,          // n * m = -1 mod r
    r2_mod_n: BigInt,         // r2_mod_n = r^2 mod n
    r3_mod_n: BigInt,         // r3_mod_n = r^3 mod n
};

namespace MontScheme {
    make: U64 -> BigInt -> MontScheme;
    make = |r_log_base, n| (
        let r: BigInt = one.shift_left(r_log_base * _log2_base);
        let (x, y, d) = extended_euclid(r, n);
        assert_lazy(|_| "R and N are not coprime", d == one) $ |_|
        // R * x + _N * y = 1
        // _N * (-y) = -1 mod R
        let m = (-y) % r;
        let m = if m.is_negative { m + r } else { m };

        // r^2 mod n
        let r2: BigInt = one.shift_left(r_log_base * _log2_base * 2_U64);
        let r2_mod_n = r2 % n;

        // r^3 mod n
        let r3: BigInt = one.shift_left(r_log_base * _log2_base * 3_U64);
        let r3_mod_n = r3 % n;

        MontScheme {
            r_log_base: r_log_base,
            n: n,
            m: m,
            r2_mod_n: r2_mod_n,
            r3_mod_n: r3_mod_n,
        }
    );

    mul_R: MontScheme -> BigInt -> BigInt;
    mul_R = |s, a| (
        BigInt::make(a.@sign, Array::fill(s.@r_log_base.to_I64, 0_U32).append(a.@nat))
    );

    mod_R: MontScheme -> BigInt -> BigInt;
    mod_R = |s, a| (
        BigInt::make(a.@sign, a.@nat.truncate(s.@r_log_base.to_I64))
    );

    div_R: MontScheme -> BigInt -> BigInt;
    div_R = |s, a| (
        BigInt::make(a.@sign, a.@nat.get_sub(s.@r_log_base.to_I64, a.@nat.get_size))
    );

    //REDC algorithm
    reduce: MontScheme -> BigInt -> BigInt;
    reduce = |s, aR| (
        let MontScheme { n:n, m:m } = s;
        //assert_lazy(|_| "aR out of range", zero <= aR && aR < one.mul_R(s) * n) $ |_|
        let k: BigInt = (aR.mod_R(s) * m).mod_R(s);
        let a: BigInt = (aR + k * n).div_R(s);
        let a_n = a - n;
        if !a_n.is_negative {
            a_n
        } else {
            a
        }
    );
}

// Montgomery form
type Mont = unbox struct {
    aR: BigInt,                 // a * r mod n
    s: MontScheme         // the scheme
};

impl Mont: ToString {
    to_string = |mont| (
        "Mont { aR=" + mont.@aR.to_string + ", a=" + mont.to_BigInt.to_string + " }"
    );
}

namespace Mont {
    from_BigInt: BigInt -> MontScheme -> Mont;
    from_BigInt = |a, s| (
        assert_lazy(|_| "a out of range: " + a.to_string, zero <= a && a < s.@n) $ |_|
        let aR = (a * s.@r2_mod_n).reduce(s);
        Mont { aR: aR, s: s }
    );

    to_BigInt: Mont -> BigInt;
    to_BigInt = |mont| (
        let Mont { aR: aR, s: s } = mont;
        aR.reduce(s)
    );

    _inverse: Mont -> Mont;
    _inverse = |mont| (
        let Mont { aR: aR, s: s } = mont;
        let MontScheme { n:n, r3_mod_n:r3_mod_n } = s;
        let (aRinv, y, d) = extended_euclid(aR, n);
        assert_lazy(|_| "aR and N are not coprime", d == one) $ |_|
        // aR * aRinv = 1 mod n
        let aRinv = if aRinv.is_negative { aRinv + n } else { aRinv };
        let inv_aR = (aRinv * r3_mod_n).reduce(s);
        Mont { aR: inv_aR, s: s }
    );
}

impl Mont: Add {
    add = |m1, m2| (
        let s = m1.@s;
        let aR = m1.@aR + m2.@aR;
        let aR_n = aR - s.@n;
        let aR = if ! aR_n.is_negative { aR_n } else { aR };
        Mont { aR: aR, s: s }
    );
}

impl Mont: Sub {
    sub = |m1, m2| (
        let s = m1.@s;
        let aR = m1.@aR - m2.@aR;
        let aR = if aR.is_negative { aR + s.@n } else { aR };
        Mont { aR: aR, s: s }
    );
}

impl Mont: Mul {
    mul = |m1, m2| (
        let s = m1.@s;
        let aR = (m1.@aR * m2.@aR).reduce(s);
        Mont { aR: aR, s: s }
    );
}

impl Mont: Div {
    div = |m1, m2| (
        m1 * m2._inverse
    );
}

type Montgomery = unbox union {
    no_mont: BigInt,
    mont: Mont
};

impl Montgomery: ToString {
    to_string = |m| (
        match m {
            no_mont(a) => "no_mont(" + a.to_string + ")",
            mont(m) => "mont(" + m.to_BigInt.to_string + ")",
        }
    );
}

namespace Montgomery {
    from_I64: I64 -> Montgomery;
    from_I64 = |i64| (
        no_mont $ BigInt::from_I64(i64)
    );

    from_BigInt: BigInt -> MontScheme -> Montgomery;
    from_BigInt = |a, s| (
        mont $ Mont::from_BigInt(a, s)
    );

    to_BigInt: Montgomery -> BigInt;
    to_BigInt = |m| (
        match m {
            no_mont(a) => a,
            mont(m) => m.to_BigInt
        }
    );

    _map_op2: (BigInt -> BigInt -> BigInt) -> (Mont -> Mont -> Mont) -> (Montgomery -> Montgomery -> Montgomery);
    _map_op2 = |int_op, mont_op| (
        |a, b|
        match a {
            no_mont(a) => match b {
                no_mont(b) => no_mont $ int_op(a, b),
                mont(b) => mont $ mont_op(from_BigInt(a, b.@s), b)
            },
            mont(a) => match b {
                no_mont(b) => mont $ mont_op(a, from_BigInt(b, a.@s)),
                mont(b) => mont $ mont_op(a, b)
            }
        }
    );
}

impl Montgomery: Add {
    add = _map_op2(add, add);
}

impl Montgomery: Sub {
    sub = _map_op2(sub, sub);
}

impl Montgomery: Mul {
    mul = _map_op2(mul, mul);
}

impl Montgomery: Div {
    div = _map_op2(div, div);
}
