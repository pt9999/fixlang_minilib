module Main;

import AsyncTask;
import Debug;

import Minilib.IO.Channel;
import Minilib.IO.FileSystem;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Thread.Time;

test_send: TestCase;
test_send = (
    make_test("test_send") $ |_|
    let chan = *Channel::make.lift;
    eval *chan.send(1);
    eval *chan.close.lift;
    // send() fails after close
    let res = *chan.send(2).to_result.lift;
    eval *assert_equal("err", err $ Channel::closed_error, res);
    pure()
);

test_send_mux: TestCase;
test_send_mux = (
    make_test("test_send_mux") $ |_|
    let chan = *Channel::make.lift;
    let sender = do {
        Iterator::range(0,5).foreach_m(|i|
            chan.send(i+1)
        )
    }.to_result;
    let receiver = do {
        Iterator::range(0, 10).fold_m(
        0, |sum, _|
           pure $ sum + *chan.recv
        )
    }.to_result;
    let task1 = *AsyncIOTask::make(sender).lift;
    let task2 = *AsyncIOTask::make(sender).lift;
    let task3 = *AsyncIOTask::make(receiver).lift;
    eval *assert_equal("res1", ok(), task1.get);
    eval *assert_equal("res2", ok(), task2.get);
    eval *assert_equal("res3", ok((1+2+3+4+5)*2), task3.get);
    pure()
);

test_send_many_mux: TestCase;
test_send_many_mux = (
    make_test("test_send_many_mux") $ |_|
    let n = 10;
    let chan = *Channel::make.lift;
    let sender = do {
        Iterator::range(0,5).foreach_m(|i|
            chan.send_many(Array::fill(n, i+1))
        )
    }.to_result;
    let receiver = do {
        loop_m(
            0, |sum|
            let res = *chan.recv.to_result.lift;
            if res.is_err {
                if res.as_err != Channel::closed_error {
                    throw $ res.as_err
                };
                break_m $ sum
            };
            let sum = sum + res.as_ok;
            continue_m $ sum
        )
    }.to_result;
    let task1 = *AsyncIOTask::make(sender).lift;
    let task2 = *AsyncIOTask::make(sender).lift;
    let task3 = *AsyncIOTask::make(receiver).lift;
    eval *assert_equal("res1", ok(), task1.get);
    eval *assert_equal("res2", ok(), task2.get);
    eval *chan.close.lift;
    eval *assert_equal("res3", ok((1+2+3+4+5)*2*n), task3.get);
    pure()
);

test_recv: TestCase;
test_recv = (
    make_test("test_recv") $ |_|
    let var = *Var::make(0).lift;
    let chan1: Channel String = *Channel::make.lift;
    let chan2: Channel String = *Channel::make.lift;
    let io1 = do {
        eval *var.Var::set(1).lift;
        let a = *chan1.recv;
        eval *var.Var::set(2).lift;
        eval *chan2.send(a);
        let a = *chan1.recv;
        eval *var.Var::set(3).lift;
        eval *chan2.send(a);
        pure $ ()
    }.to_result;
    let task1 = *AsyncIOTask::make(io1).lift;
    eval *usleep(100000_U32);
    eval *assert_equal("var", 1, *var.get.lift);
    eval *chan1.send("hello");
    eval *chan1.send("world");
    eval *assert_equal("chan2", "hello", *chan2.recv);
    eval *assert_equal("chan2", "world", *chan2.recv);
    eval *assert_equal("var", 3, *var.get.lift);
    eval *assert_equal("res1", ok(), task1.get);
    pure()
);

test_recv_close: TestCase;
test_recv_close = (
    make_test("test_recv_close") $ |_|
    let chan1: Channel String = *Channel::make.lift;
    let io1 = do {
        let a = *chan1.recv;
        pure $ ()
    }.to_result;
    let task1 = *AsyncIOTask::make(io1).lift;
    eval *usleep(100000_U32);
    eval *chan1.close.lift;
    eval *assert_equal("res1", err(Channel::closed_error), task1.get);
    pure()
);

test_recv_mux: TestCase;
test_recv_mux = (
    make_test("test_recv_mux") $ |_|
    let chan = *Channel::make.lift;
    let sender = do {
        Iterator::range(0,10).foreach_m(|i|
            chan.send(i+1)
        )
    }.to_result;
    let receiver = do {
        Iterator::range(0, 5).fold_m(
        0, |sum, _|
           pure $ sum + *chan.recv
        )
    }.to_result;
    let task1 = *AsyncIOTask::make(sender).lift;
    let task2 = *AsyncIOTask::make(receiver).lift;
    let task3 = *AsyncIOTask::make(receiver).lift;
    eval *assert_equal("res1", ok(), task1.get);
    let total2 = task2.get;
    let total3 = task3.get;
    eval *assert_equal("total", 55, total2.as_ok + total3.as_ok);
    pure()
);

test_recv_many_mux: TestCase;
test_recv_many_mux = (
    make_test("test_recv_many_mux") $ |_|
    let n = 100;
    let m = 7;
    let chan = *Channel::make.lift;
    let sender = do {
        Iterator::range(0,10).foreach_m(|i|
            chan.send_many(Array::fill(n, i+1))
        )
    }.to_result;
    let receiver = do {
        loop_m(
            0, |sum|
            let res = *chan.recv_many(m).to_result.lift;
            if res.is_err {
                if res.as_err != Channel::closed_error {
                    throw $ res.as_err
                };
                break_m $ sum
            };
            let sum = sum + res.as_ok.to_iter.Iterator::sum;
            continue_m $ sum
        )
    }.to_result;
    let task1 = *AsyncIOTask::make(sender).lift;
    let task2 = *AsyncIOTask::make(receiver).lift;
    let task3 = *AsyncIOTask::make(receiver).lift;
    eval *assert_equal("res1", ok(), task1.get);
    eval *chan.close.lift;
    let total2 = task2.get;
    let total3 = task3.get;
    eval *assert_equal("total", 55 * n, total2.as_ok + total3.as_ok);
    pure()
);

test_clear: TestCase;
test_clear = (
    make_test("test_clear") $ |_|
    let chan = *Channel::make.lift;
    eval *chan.send(1);
    eval *chan.send(2);
    eval *chan.clear.lift;
    eval *chan.send(3);
    eval *chan.send(4);
    eval *assert_equal("3", 3, *chan.recv);
    eval *assert_equal("4", 4, *chan.recv);
    pure()
);

test_perf_send_recv_many: TestCase;
test_perf_send_recv_many = (
    make_test("test_perf_send_recv_many") $ |_|
    let chan = *Channel::make.lift;
    let n = 1024 * 1024;
    let array = Array::from_map(n, |i| i.to_U8);
    let res = *timeit_io(
        "n=" + n.to_string,
        do {
            eval *pure();
            eval *chan.send_many(array);
            let output = *chan.recv_many(n);
            pure()
        }.to_result
    ).lift;
    pure()
);

main: IO ();
main = (
    [
        test_send,
        test_send_mux,
        test_send_many_mux,
        test_recv,
        test_recv_close,
        test_recv_mux,
        test_recv_many_mux,
        test_clear,
        test_perf_send_recv_many,
        TestCase::empty
    ].run_test_driver
);
