// X.509 Certificate module
//
// RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile
// https://tex2e.github.io/rfc-translater/html/rfc5280.html
module Minilib.Crypto.Cert.X509;

import Hash;
import Debug;

import Minilib.Crypto.Cert.Asn1;
import Minilib.Crypto.Cert.Asn1Der;
import Minilib.Crypto.Cert.X509Time;
import Minilib.Crypto.Cert.OID;
import Minilib.Crypto.Cert.Pem;
import Minilib.Encoding.Binary;
import Minilib.Math.BigInt;
import Minilib.Monad.State;
import Minilib.Monad.Error;
import Minilib.Monad.Trans;
import Minilib.Monad.FunctorM;
import Minilib.Text.StringEx;
import Minilib.Text.Hex;

// ---------------------------------------------------------------------------
// Helper functions
// ---------------------------------------------------------------------------

// Reads a certificate from a certificate file.
// If the file does not contain exactly one certificate, an error will be reported.
// Supported filename extensions: ".pem", ".crt", ".cer", ".der".
read_certificate_from_file: Path -> IOFail Certificate;
read_certificate_from_file = |path| (
    let certificates = *read_certificates_from_file(path);
    if certificates.get_size == 0 {
        throw $ "No certificates found: " + path.to_string
    };
    if certificates.get_size >= 2 {
        throw $ "two or more certificates found: " + path.to_string
    };
    pure $ certificates.@(0)
);

// Reads all certificates from a certificate file.
// Supported filename extensions: ".pem", ".crt", ".cer", ".der".
read_certificates_from_file: Path -> IOFail (Array Certificate);
read_certificates_from_file = |path| (
    let filepath = path.to_string.to_lower;
    if filepath.ends_with(".pem") ||
       filepath.ends_with(".crt") {
        read_certificates_from_pem_file(path)
    };
    if filepath.ends_with(".cer") ||
       filepath.ends_with(".der") {
        read_certificate_from_der_file(path).map(|x|[x])
    };
    throw $ "read_certificates_from_file: unsupported extension: " + filepath
);

// Reads a certificate from a certificate file in DER encoding (".cer", ".der").
read_certificate_from_der_file: Path -> IOFail Certificate;
read_certificate_from_der_file = |path| (
    let bytes = *read_file_bytes(path);
    from_bytes(bytes).from_result
);

// Reads all certificates from a certificate file in PEM encoding (".pem", ".crt").
read_certificates_from_pem_file: Path -> IOFail (Array Certificate);
read_certificates_from_pem_file = |path| (
    let contents = *read_file_string(path);
    let entries = *parse_pem_entries(contents).from_result;
    let certificates = *entries.map_m(|entry|
        from_bytes(entry.@bytes)
    ).from_result;
    pure $ certificates
);

// ---------------------------------------------------------------------------
// X.509 Data Structures
// ---------------------------------------------------------------------------

// 4.1. Basic Certificate Fields

// A X.509 certificate with signature
type Certificate = unbox struct {
    tbs_certificate: TBSCertificate,
    signature_algorithm:   AlgorithmIdentifier,
    signature_value: BitString,
    tbs_certificate_bytes: Array U8,        // DER encoding of tbs_certificate
};

namespace Certificate {
    // Gets the subject name.
    get_subject: Certificate -> Name;
    get_subject = |cert| cert.@tbs_certificate.@subject;

    // Gets the subject public key.
    get_subject_public_key: Certificate -> SubjectPublicKeyInfo;
    get_subject_public_key = |cert| cert.@tbs_certificate.@subject_public_key_info;
}

impl Certificate: ToString {
    to_string = |obj| (
        "Certificate {" +
        "\n tbs_certificate=" + obj.@tbs_certificate.to_string.replace_all("\n", "\n  ") +
        "\n signature_algorithm=" + obj.@signature_algorithm.to_string +
        "\n signature_value=" + obj.@signature_value.to_string +
        "\n }"
    );
}

impl Certificate: FromBytes {
    from_bytes = decode_der_from_bytes;
}

impl Certificate: DecodeDer {
    decode_obj = (
        decode_sequence $ do {

            let start_pos = *get_pos;
            let tbs_certificate = *decode_obj;
            let end_pos = *get_pos;

            // save DER encoding of tbs_certificate for signature validation
            eval *set_pos(start_pos);
            let tbs_certificate_bytes = *decode_contents(end_pos - start_pos);
            eval *set_pos(end_pos);

            let signature_algorithm = *decode_obj;
            let signature_value = *decode_obj;
            pure $ Certificate {
                tbs_certificate: tbs_certificate,
                signature_algorithm: signature_algorithm,
                signature_value: signature_value,
                tbs_certificate_bytes: tbs_certificate_bytes,
            }
        }
    );
}

// Information associated with the subject of the certificate and the issuer.
type TBSCertificate = unbox struct {
    version: Version,
    serial_number: CertificateSerialNumber,
    signature: AlgorithmIdentifier,
    issuer: Name,
    validity: Validity,
    subject: Name,
    subject_public_key_info: SubjectPublicKeyInfo,
    issuer_unique_id: Option UniqueIdentifier,
    subject_unique_id: Option UniqueIdentifier,
    extensions: Option Extensions,
};

impl TBSCertificate: ToString {
    to_string = |obj| (
        "TBSCertificate {" +
        "\n version=" + obj.@version.to_string +
        "\n serial_number=" + obj.@serial_number.to_string +
        "\n signature=" + obj.@signature.to_string +
        "\n issuer=" + obj.@issuer.to_string +
        "\n validity=" + obj.@validity.to_string +
        "\n subject=" + obj.@subject.to_string +
        "\n subject_public_key_info=" + obj.@subject_public_key_info.to_string +
        "\n issuer_unique_id=" + obj.@issuer_unique_id.to_string +
        "\n subject_unique_id=" + obj.@subject_unique_id.to_string +
        "\n extensions=" + obj.@extensions.map(map(|ex| "\n    " + ex.to_string)).to_string +
        "\n }"
    );
}

impl TBSCertificate: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let version = *with_context(0, decode_integer).if_exists;
            let serial_number = *decode_bigint;
            let signature = *decode_obj;
            let issuer = *decode_name;
            let validity = *decode_obj;
            let subject = *decode_name;
            let subject_public_key_info = *decode_obj;
            let issuer_unique_id = *with_context(1, decode_obj).if_exists;
            let subject_unique_id = *with_context(2, decode_obj).if_exists;
            let extensions = *with_context(3, decode_extensions).if_exists;
            pure $ TBSCertificate {
                version: version.as_some_or(0),
                serial_number: serial_number,
                signature: signature,
                issuer: issuer,
                validity: validity,
                subject: subject,
                subject_public_key_info: subject_public_key_info,
                issuer_unique_id: issuer_unique_id,
                subject_unique_id: subject_unique_id,
                extensions: extensions,
            }
        }
    );
}

type Version = Asn1::Integer; // v1(0), v2(1), v3(2)

type CertificateSerialNumber = BigInt;

type Validity = unbox struct {
    not_before: X509Time,
    not_after: X509Time,
};

namespace Validity {
    is_valid_at: X509Time -> Validity -> Bool;
    is_valid_at = |time, validity| (
        validity.@not_before <= time && time <= validity.@not_after
    );
}

impl Validity: ToString {
    to_string = |obj| (
        "Validity {" +
        " not_before=" + obj.@not_before.to_string +
        " not_after=" + obj.@not_after.to_string +
        " }"
    );
}

impl Validity: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let not_before = *decode_obj;
            let not_after = *decode_obj;
            pure $ Validity {
                not_before: not_before,
                not_after: not_after
            }
        }
    );
}


type UniqueIdentifier = Asn1::BitString;

type SubjectPublicKeyInfo = unbox struct {
    algorithm: AlgorithmIdentifier,
    subject_public_key: Asn1::BitString,
};

namespace SubjectPublicKeyInfo {
    get_rsa_public_key: [m: MonadError] SubjectPublicKeyInfo -> m (BigInt, BigInt);
    get_rsa_public_key = |public_key| (
        let pubkey_algorithm: AlgorithmIdentifier = public_key.@algorithm;
        if !pubkey_algorithm.match_name("rsaEncryption") {
            error $ "Public_key algorithm does not match `rsaEncryption`: " + pubkey_algorithm.to_string
        };
        let rsa_pubkey: RSAPublicKey = *decode_der_from_bytes(public_key.@subject_public_key.@data).from_result_t;
        let n = rsa_pubkey.@modulus;
        let e = rsa_pubkey.@public_exponent;
        pure $ (n, e)
    );
}

impl SubjectPublicKeyInfo: ToString {
    to_string = |obj| (
        "SubjectPublicKeyInfo {" +
        " algorithm=" + obj.@algorithm.to_string +
        " subject_public_key=" + obj.@subject_public_key.to_string +
        " }"
    );
}

impl SubjectPublicKeyInfo: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let algorithm = *decode_obj;
            let subject_public_key = *decode_obj;
            pure $ SubjectPublicKeyInfo {
                algorithm: algorithm,
                subject_public_key: subject_public_key
            }
        }
    );
}


// RFC4055 1.2. RSA Public Keys
type RSAPublicKey = unbox struct {
    modulus: BigInt,        // n
    public_exponent: BigInt  // e
};

impl RSAPublicKey: ToString {
    to_string = |obj| (
        "RSAPublicKey {" +
        " modulus=" + obj.@modulus.to_string +
        " public_exponent=" + obj.@public_exponent.to_string +
        " }"
    );
}

impl RSAPublicKey: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let modulus = *decode_obj;
            let public_exponent = *decode_obj;
            pure $ RSAPublicKey {
                modulus: modulus,
                public_exponent: public_exponent
            }
        }
    );
}

// 4.1.2.4. Issuer

type Name = unbox struct {
    data: RDNSequence
};

namespace Name {
    find_common_name: Name -> Option String;
    find_common_name = |name| (
        name._find_attr_value(match_name("cn"))
    );

    _find_attr_value: (AttributeType -> Bool) -> Name -> Option AttributeValue;
    _find_attr_value = |f, name| (
        name.@data.flatten.to_iter.filter(|(ty, val)| f(ty)).get_first.map(|(ty, val)| val)
    );
}


impl Name: Eq {
    eq = |a, b| a.@data == b.@data;
}

impl Name: Hash {
    hash = |obj| obj.@data.hash;
}

impl Name: ToString {
    to_string = |obj| (
        "Name { " +
        obj.@data.map(|rdn|
            rdn.map(|(type_, value)|
                type_.to_string_ldap + "=" + value.to_string
            )
        ).to_string +
        " }"
    );
}

decode_name: [m: MonadReadByte] m Name;
decode_name = (
    pure $ Name {
        data: *decode_RDNSequence
    }
);

type RDNSequence = Array RelativeDistinguishedName;

decode_RDNSequence: [m: MonadReadByte] m RDNSequence;
decode_RDNSequence = (
    decode_sequence_of(decode_RelativeDistinguishedName)
);

type RelativeDistinguishedName = Array AttributeTypeAndValue;

decode_RelativeDistinguishedName: [m: MonadReadByte] m RelativeDistinguishedName;
decode_RelativeDistinguishedName = (
    decode_set_of(decode_AttributeTypeAndValue)
);

type AttributeTypeAndValue = (AttributeType, AttributeValue);

decode_AttributeTypeAndValue: [m: MonadReadByte] m AttributeTypeAndValue;
decode_AttributeTypeAndValue = (
    decode_sequence $ do {
        let type_ = *decode_obj;
        let value = *decode_obj;
        pure $ (type_, value)
    }
);

type AttributeType = Asn1::ObjectIdentifier;

type AttributeValue = String;

type AlgorithmIdentifier = unbox struct {
    algorithm: Asn1::ObjectIdentifier,
    parameters: Array U8,
};

namespace AlgorithmIdentifier {
    match_name: String -> AlgorithmIdentifier -> Bool;
    match_name = |name, algorithm_identifier| (
        algorithm_identifier.@algorithm.match_name(name)
    );
}

impl AlgorithmIdentifier: ToString {
    to_string = |obj| (
        "AlgorithmIdentifier {" +
        " algorithm=" + obj.@algorithm.to_string_with_name +
        " parameters=" + obj.@parameters.to_string_hex +
        " }"
    );
}

impl AlgorithmIdentifier: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let algorithm = *decode_obj;
            let parameters = *do { // ANY DEFINED BY algorithm OPTIONAL
                let start_pos = *get_pos;
                let identifier = *decode_identifier;
                let length = *decode_length;
                let contents = *decode_contents(length);
                let end_pos = *get_pos;
                eval *set_pos(start_pos);
                decode_contents(end_pos - start_pos)
            }.catch(|errmes|
                if errmes == Asn1Der::__Err_EndOfStream { pure $ [] };
                error $ errmes
            );
            pure $ AlgorithmIdentifier {
                algorithm: algorithm,
                parameters: parameters,
            }
        }
    );
}

type Extensions = Array Extension;

decode_extensions:  [m: MonadReadByte] m Extensions;
decode_extensions = (
    decode_sequence_of(decode_obj)
);

type Extension = unbox struct {
    extn_id: Asn1::ObjectIdentifier,
    critical: Asn1::Boolean,
    extn_value: Asn1::OctetString,
};

impl Extension: ToString {
    to_string = |obj| (
        "Extension {" +
        " extn_id=" + obj.@extn_id.to_string_with_name +
        " critical=" + obj.@critical.to_string +
        " extn_value=" + obj.@extn_value.to_string +
        " }"
    );
}

impl Extension: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let extn_id = *decode_obj;
            let critical = (*decode_obj.if_exists).as_some_or(false);
            let extn_value = *decode_obj;
            pure $ Extension {
                extn_id: extn_id,
                critical: critical,
                extn_value: extn_value
            }
        }
    );
}

// RFC3279 2.2.3 ECDSA Signature Algorithm
type EcdsaSigValue = unbox struct {
    r: BigInt,
    s: BigInt
};

impl EcdsaSigValue: ToString {
    to_string = |obj| (
        "EcdsaSigValue {" +
        " r=" + obj.@r.to_string +
        " s=" + obj.@s.to_string +
        " }"
    );
}

impl EcdsaSigValue: DecodeDer {
    decode_obj = (
        decode_sequence $ do {
            let r = *decode_obj;
            let s = *decode_obj;
            pure $ EcdsaSigValue {
                r: r,
                s: s,
            }
        }
    );
}
