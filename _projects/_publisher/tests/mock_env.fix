module Publisher.Tests.MockEnv;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Monad.Error;
import Minilib.Testing.UnitTest;

import Publisher.Common;
import Publisher.Env;
import Publisher.Publish;
import Publisher.ProcessRunner;
import Publisher.Fs;
import Publisher.ConsoleUi;
import Publisher.Tests.MockProcessRunner;
import Publisher.Tests.MockFs;
import Publisher.Tests.MockConsoleUi;

// `make_env_test(testname) $ |env| ...` creates a TestCase which uses an Env.
make_env_test: [e: Env] String -> (e -> IOFail ()) -> TestCase;
make_env_test = |testname, body| (
    make_test(testname) $ |_|
    let env: e = *make_empty_env;
    body(env)
);

type MockEnv = unbox struct {
    runner: IORef MockProcessRunner,
    fs: IORef MockFs,
    console_ui: IORef MockConsoleUi,
};

impl MockEnv: Env {
    make_empty_env = (
        pure $ MockEnv {
            runner: *IORef::make(MockProcessRunner::empty).lift_io,
            fs: *IORef::make(MockFs::empty).lift_io,
            console_ui: *IORef::make(MockConsoleUi::empty).lift_io,
        }
    );
}

namespace MockEnv {
    setup_runner: [m: MonadIO] (MockProcessRunner -> MockProcessRunner) -> MockEnv -> m ();
    setup_runner = setup(@runner);

    setup_fs: [m: MonadIO] (MockFs -> MockFs) -> MockEnv -> m ();
    setup_fs = setup(@fs);

    setup_console_ui: [m: MonadIO] (MockConsoleUi -> MockConsoleUi) -> MockEnv -> m ();
    setup_console_ui = setup(@console_ui);
}

impl MockEnv: HasProcessRunnerApi {
    get_process_runner_api = |e| e.@runner.to_api;
}

impl MockEnv: HasFileSystemApi {
    get_file_system_api = |e| e.@fs.to_api;
}

impl MockEnv: HasConsoleUiApi {
    get_console_ui_api = |e| e.@console_ui.to_api;
}