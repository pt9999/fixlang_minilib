module Main;

import Debug;
import Random;

import Minilib.Math.BigInt;
import Minilib.Math.BigIntPrime;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.Timeit;

namespace Karatsuba {

    _get_sub_or_zero: I64 -> I64 -> Array U32 -> Array U32;
    _get_sub_or_zero = |begin, end, a| (
        eval assert(|_| "invalid range", begin < end);
        let n = a.get_size;
        if begin >= n { BigNat::_zero };
        let end = min(end, n);
        if begin == 0 && end == n { a };
        a.get_sub(begin, end)
    );
    
    // Calculates `a * b`.
    _mul_karatsuba: Array U32 -> Array U32 -> Array U32;
    _mul_karatsuba = |a, b| (
        if a.get_size <= 2 && b.get_size <= 2 {
            _mul(a,b)
        };
        /*
        if a._is_zero || b._is_zero {
            BigNat::_zero
        };
        if a.get_size == 1 {
            _mul_u32(a.@(0), b)
        };
        if b.get_size == 1 {
            _mul_u32(b.@(0), a)
        };
        */
        let n = max(a.get_size, b.get_size);
        let m = (n + 1) / 2;
        let a0 = a._get_sub_or_zero(0, m);
        let a1 = a._get_sub_or_zero(m, n);
        let b0 = b._get_sub_or_zero(0, m);
        let b1 = b._get_sub_or_zero(m, n);
        let z0 = _mul_karatsuba(a0, b0);
        let z2 = _mul_karatsuba(a1, b1);
        let z3 = _mul_karatsuba(_add(a1, a0), _add(b1, b0)); 
        let z1 = _sub(_sub(z3, z2), z0);
        let (z,zoff) = _add_with_offset((z0,0), (z1,m));
        let (z,zoff) = _add_with_offset((z,zoff), (z2,2*m));
        eval assert(|_| "zoff != 0", zoff == 0);
        z
    );


    mul_karatsuba: BigInt -> BigInt -> BigInt;
    mul_karatsuba = |a, b| (
        let nat = _mul_karatsuba(a.@nat, b.@nat);
        let nat = nat._remove_last_zeros;
        BigInt::make(a.@sign * b.@sign, nat)
    );
}

namespace NewtonRaphson {
    _bit_length: Array U32 -> I64;
    _bit_length = |a| (
        let a = a._remove_last_zeros;
        let n = a.get_size;
        let bit_length = n * _log2_base;
        let d = a.@(n-1).to_U64;
        loop(
            (bit_length, _log2_base - 1), |(bit_length, i)|
            if i < 0 { break $ bit_length };
            if d.bit_and(1_U64.shift_left(i)) != 0_U64 {
                break $ bit_length
            };
            continue $ (bit_length - 1, i - 1)
        )
    );
    
    // Calculates `a^n`.
    _pow_by_U64: Array U32 -> U64 -> Array U32;
    _pow_by_U64 = |a, n| (
        loop(
            ([1_U32], a, n), |(prod, a, n)|
            if n == 0_U64 {
                break $ prod
            };
            let prod = if n.bit_and(1_U64) != 0_U64 {
                _mul(prod, a)
            } else { prod };
            continue $ (prod, _mul(a,a), n.shift_right(1_U64))
        )
    );

    _shift_left: U64 -> Array U32 -> Array U32;
    _shift_left = |shift, a| (
        if shift == 0_U64 { a };
        let (off, shift) = _divmod_log2_base(shift);
        let n = a.get_size;
        let a = loop(
            (a, 0_U64, 0), |(a, carry, i)|
            if i >= n {
                break $ if carry != 0_U64 { a.push_back(carry.to_U32) } else { a }
            };
            let d = a.@(i).to_U64;
            let carry2 = d.shift_right(_log2_base - shift);
            let d = d.shift_left(shift).bit_or(carry);
            let a = a.set(i, d.to_U32);
            continue $ (a, carry2, i + 1)
        );
        if off != 0_U64 { Array::fill(off.to_I64, 0_U32).append(a) } else { a }
    );

    _shift_right: U64 -> Array U32 -> Array U32;
    _shift_right = |shift, a| (
        if shift == 0_U64 { a };
        let (off, shift) = _divmod_log2_base(shift);
        let a = if off == 0_U64 { a } 
        else if off.to_I64 < a.get_size { a.get_sub(off.to_I64, a.get_size) }
        else { [0_U32] };
        let n = a.get_size;
        let a = loop(
            (a, 0_U64, n-1), |(a, carry, i)|
            if i < 0 {
                break $ a
            };
            let d = a.@(i).to_U64;
            let carry2 = d.shift_left(_log2_base - shift);
            let d = d.shift_right(shift).bit_or(carry);
            let a = a.set(i, d.to_U32);
            continue $ (a, carry2, i - 1)
        );
        a._remove_last_zeros
    );

    _add_exp: (Array U32, I64) -> (Array U32, I64) -> (Array U32, I64);
    _add_exp = |(a0, exp0), (a1, exp1)| (
        if exp1 < exp0 { _add_exp((a1, exp1), (a0, exp0)) };
        let dexp1 = exp1 - exp0;
        let (off1, dexp1) = _divmod_log2_base(dexp1);
        let a1 = _mul_u32(1_U64.shift_left(dexp1.to_U64).to_U32, a1);
        let (a2, off2) = _add_with_offset((a0, 0), (a1, off1));
        let exp2 = exp0 + off2 * _log2_base;
        (a2, exp2)
    );

    _sub_exp: (Array U32, I64) -> (Array U32, I64) -> Result ErrMsg (Array U32, I64);
    _sub_exp = |(a0, exp0), (a1, exp1)| (
        if exp1 < exp0 {
            let dexp0 = exp0 - exp1;
            let (off0, dexp0) = _divmod_log2_base(dexp0);
            let a0 = _mul_u32(1_U64.shift_left(dexp0.to_U64).to_U32, a0);
            let (a2, off2) = *_sub_with_offset((a0, off0), (a1, 0));
            let exp2 = exp1 + off2 * _log2_base;
            pure $ (a2, exp2)
        };
        let dexp1 = exp1 - exp0;
        let (off1, dexp1) = _divmod_log2_base(dexp1);
        let a1 = _mul_u32(1_U64.shift_left(dexp1.to_U64).to_U32, a1);
        let (a2, off2) = *_sub_with_offset((a0, 0), (a1, off1));
        let exp2 = exp0 + off2 * _log2_base;
        pure $ (a2, exp2)
    );

    _mul_exp: (Array U32, I64) -> (Array U32, I64) -> (Array U32, I64);
    _mul_exp = |(a0, exp0), (a1, exp1)| (
        let a2 = _mul(a0, a1);
        (a2, exp0 + exp1)
    );

    _divmod2: Array U32 -> Array U32 -> (Array U32, Array U32);
    _divmod2 = |a, b| (
        let a = a._remove_last_zeros;
        let b = b._remove_last_zeros;
        abort()
    );

    _goldschmidt: Array U32 -> Array U32 -> Result ErrMsg (Array U32);
    _goldschmidt = |a, b| (
        // scale a and b such that 0.5 <= b < 1
        let b_exp = -b._bit_length;         // exponent of 2
        let a_exp = b_exp;
        let (f, f_exp) = *_sub_exp(([2_U32], 0), (b, b_exp));
        abort()

    );
}

test_prime: IO ();
test_prime = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(time.to_U64);
    let a = pow_by_U64(two, 512_U64);
    let (b, random) = random.generate_range(zero, a);
    //let _ = *println(a.to_string);
    let _ = *loop_m(
        (b, random), |(b, random)|
        // Miller-Rabin Primality test.
        let (ret, random) = miller_rabin(b, random);
        // Solovayâ€“Strassen primality test.
        let (ret2, random) = solovay_strassen(b, random);
        let judge = |b| if b { "prime" } else { "composite" };
        let _ = *println(
            (b, judge(ret), judge(ret2)).format("{}: {}: {}")
        );
        if ret {
            break_m $ ()
        };
        continue_m $ (b + one, random)
    );
    pure()
);

test_probable_prime: IO ();
test_probable_prime = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(time.to_U64);
    loop_m(
        128, |bit_length|
        if bit_length > 512 { break_m $ () };
        let _ = *println("Searching a probable prime of " + bit_length.to_string + " bits...");
        let ((n, random), time) = consumed_time_while(|_|
            probable_prime(bit_length, random)
        , ());
        let _ = *println(n.to_string);
        let _ = *println("time="+time.to_string);
        continue_m $ bit_length + 128
    )
);

test_karatsuba: IO ();
test_karatsuba = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(123_U64); // time.to_U64);
    let bits = 1024;
    let (a, random) = random.generate_bigint(bits);
    let (b, random) = random.generate_bigint(bits);
    let _ = *timeit("a*b", |_| a*b);
    let _ = *timeit("mul_karatsuba(a,b)", |_| mul_karatsuba(a,b));
    eval assert(|_| "not eq", a*b == mul_karatsuba(a,b));
    pure()
);

test_divmod: IO ();
test_divmod = (
    let _ = *pure();
    let _ = CALL_C[() setbuf(Ptr, Ptr), IO::stdout._file_ptr, nullptr];
    let time = CALL_C[I32 time(Ptr), nullptr];
    let random = Random::init_by_seed(123_U64); // time.to_U64);
    let bits = 512;
    let (a, random) = random.generate_bigint(2*bits);
    let (b, random) = random.generate_bigint(bits);
    let _ = *timeit("divmod(a,b)", |_| divmod(a,b));
    pure()
);

test_exp: IO ();
test_exp = (
    let _ = *pure();
    let a = [1_U32];
    let b = [1_U32];
    let _ = *notimeit("_add_exp((a,2),(b,-1))", |_| _add_exp((a,2),(b,-1)));
    let _ = *notimeit("_add_exp((a,2),(b,1))", |_| _add_exp((a,2),(b,1)));
    let _ = *notimeit("_sub_exp((a,2),(b,-1))", |_| _sub_exp((a,2),(b,-1)));
    let _ = *notimeit("_sub_exp((a,-1),(b,2))", |_| _sub_exp((a,-1),(b,2)));
    pure() 
);

test_shift_right: IO ();
test_shift_right = (
    let _ = *pure();
    let random = Random::init_by_seed(123_U64); // time.to_U64);
    let bits = 128;
    let iter = Iterator::generate(random, generate_bigint(bits) >> some).take(3);
    iter.fold_m(
        (), |_, a|
        [1, 3, 31, 32, 33].map(I64::to_U64).to_iter.fold_m(
            (), |_, shift|
            let n = BigInt::make(1, _pow_by_U64([2_U32], shift));
            let b = BigInt::make(1, a.@nat._shift_left(shift));
            let c = a * n;
            let _ = *println(b.to_string).lift;
            let _ = *assert_equal("left", c, b);

            let n = BigInt::make(1, _pow_by_U64([2_U32], shift));
            let b = BigInt::make(1, a.@nat._shift_right(shift));
            let c = a / n;
            let _ = *println(b.to_string).lift;
            let _ = *assert_equal("right", c, b);
            pure()
        )
    ).try(eprintln)
);

main: IO ();
main = test_shift_right;


