// An implementation of simple regular expression.
//
// Currently it only supports patterns below:
// - Character classes: `[xyz]`, `[^xyz]`, `.`, `\d`, `\D`, `\w`, `\W`, `\s`,
//   `\S`, `\t`, `\r`, `\n`, `\v`, `\f`, `[\b]`, x|y
// - Assertions: `^`, `$`
// - Groups: `(x)`
// - Quantifiers: `x*`, `x+`, `x?`, `x{n}`, `x{n,}`, `x{n,m}`
//
// For details, see
// [mdn web docs: Regular expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions).
//
// LIMITATION:
//
// Currently, only single bytes can be specified in character classes. Non-ascii characters
// (U+100 or hier) cannot be specified in character classes.
//
module Main;

import Character;
import Debug;

import SimpleParser;
import StringEx;
import RegExpPattern;
import RegExpNFA;

type RegExp = unbox struct {
    pattern: Pattern,
    flags: String, // TODO: support flags
    nfa: NFA
};

namespace RegExp {

    compile: String -> String -> Result ErrMsg RegExp;
    compile = |pattern, flags| (
        let pattern = *parse_pattern.run_parser_str(pattern).map(|(p,_)| p);
        let pattern = pgroup $ (0, pattern); // since whole pattern is group 0
        let nfa = NFA::compile(pattern);
        eval debug_eprintln(nfa.to_string);
        ok $ RegExp { pattern: pattern, flags: flags, nfa:nfa }
    );

    exec: String -> RegExp -> Result ErrMsg (Array String);
    exec = |target, regexp| (
        let stream: Stream = *from_string(target);
        let opt = regexp.@nfa.execute(stream);
        eval debug_eprintln("regexp.@nfa.execute done");
        if opt.is_none {
            err $ _NotMatch
        };
        let groups: GroupArray = opt.as_some;
        let groups: Array String = groups.to_iter.map(|opt|
            opt.map_or("", 
                |group| 
                if group.@begin < 0 || group.@end < 0 { "" };
                target.substring(group.@begin, group.@end)
            )
        ).to_array;
        ok $ groups
    );
}

check_regexp: String -> String -> Array String -> IO ();
check_regexp = |pattern, target, expected| (
    let _ = *println("===============================================");
    let _ = *println("pattern=" + pattern);
    let _ = *println("target=" + target);

    let res = do {
        let regexp = *RegExp::compile(pattern, "");
        //let res: Result ErrMsg (Array String) = regexp.exec(target);
        let groups: Array String = *regexp.exec(target);
        let lines = groups.to_iter.zip(Iterator::count_up(0)).map(
            |(group, i)| "group[" + i.to_string + "]=" + group.to_string + "\n"
        ).concat_iter;
        let actual = groups;
        let lines = if expected != actual {
            lines + "ERROR: expected="+expected.to_string+" actual="+actual.to_string + "\n"
        } else { lines };
        pure $ lines
    };
    if res.is_ok {
        println(res.as_ok)
    } else {
        println("ERROR: " + res.as_err)
    }
);

main: IO ();
main = (
    let _ = *check_regexp(".*([ade])+", "abcdef", ["abcde", "e"]);
    /*
    let _ = *check_regexp(".*", "abcdef", ["abcdef"]);
    let _ = *check_regexp(".*([ade]+)", "abcdef", ["abcde", "de"]);
    let _ = *check_regexp("\\w+", "abcd,efg", ["abcd"]);
    let _ = *check_regexp("\\s*(\\w+)\\s*", "  abc d,e fg ", ["  abc ", "abc"]);
    let _ = *check_regexp(".*(bc|c*df*e)", "abcccdef", ["abcccde", "de"]);
    */
    pure()
);
