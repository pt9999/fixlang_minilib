module StringEx;

import Debug;
import HashMap;

impl (): ToString {
    to_string = |_| "()";
}

impl [a : ToString, b : ToString, c : ToString] (a, b, c) : ToString {
    to_string = |(l, m, r)| "(" + l.to_string + ", " + m.to_string + ", " + r.to_string + ")";
}

impl [a : ToString, b : ToString, c : ToString, d : ToString] (a, b, c, d) : ToString {
    to_string = |(l, m, m2, r)| "(" + l.to_string + ", " + m.to_string + ", " + m2.to_string + ", " + r.to_string + ")";
}

impl [a: ToString] Option a: ToString {
    to_string = |o| (
        o.map_or(
            "none()",
            |a| "some(" + a.to_string + ")"
        )
    );
}

impl [k: ToString, v: ToString] HashMap k v : ToString {
    to_string = |h| (
        "{" + 
        h.to_iter.map(|(k,v)| k.to_string + ":" + v.to_string).join(",")
        + "}"
    );
}

impl [a: ToString] Array a: ToString {
    to_string = |a| (
        "[" + 
        a.to_iter.map(|x| x.to_string).join(",")
        + "]"
    );
}

_unsafe_to_string: Array U8 -> String;
_unsafe_to_string = |a| (
    String::_unsafe_from_c_str (a.push_back(0_U8))
);

find_byte: U8 -> String -> Option I64;
find_byte = |c, str| (
    let array = str.get_bytes;
    let n = str.get_size;
    loop(
        0, |i|
        if i >= n { 
            break $ none()
        };
        if array.@(i) == c {
            break $ some $ i
        };
        continue $ i + 1
    )
);


string_less_than: (String, String) -> Bool;
string_less_than = |(str1, str2)| (
    let a1 = str1.get_bytes;
    let a2 = str2.get_bytes;
    let n1 = a1.get_size;
    let n2 = a2.get_size;
    loop(0, |i|
        if i >= n1 && i >= n2 {
            break $ false
        };
        if i >= n1 {
            break $ true
        };
        if i >= n2 {
            break $ false
        };
        let c1 = a1.@(i);
        let c2 = a2.@(i);
        if c1 < c2 {
            break $ true
        };
        if c1 > c2 {
            break $ false
        };
        continue $ i + 1
    )
);

// Encode a unicode code point to UTF-8
encode_code_point_to_utf8: U32 -> Array U8 -> Array U8;
encode_code_point_to_utf8 = |code_point, buf| (
    if code_point <= 127_U32 {    // U+0000 .. U+007F
        buf
        .push_back(code_point.to_U8)
    };
    if code_point <= 2047_U32 {    // U+0080 .. U+07FF
        buf
        .push_back(192_U8.bit_or(code_point.shift_right(6_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))
    };
    if code_point <= 65535_U32 {    // U+0800 .. U+FFFF
        buf
        .push_back(224_U8.bit_or(code_point.shift_right(12_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(6_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))        
    };
    if code_point <= 1114111_U32 {  // U+10000 .. U+10FFFF
        buf
        .push_back(240_U8.bit_or(code_point.shift_right(18_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(12_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(6_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))

    };
    eval assert(|_| "code_point out of range: " + code_point.to_string, false);
    buf
);
