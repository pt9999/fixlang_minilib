// With MonadUnliftIO, you can use your monad type in a callback function.
//
// Example:
// You can use `ReaderT` monad in the `body` function.
// ```
// with_file_using_reader_monad: Path -> String -> (IOHandle -> ReaderT e IOFail a) -> ReaderT e IOFail a;
// with_file_using_reader_monad = |path, mode, body| (
//     with_run_in_iofail(|run|
//         with_file(path, mode, body >> run)
//     )
// );
// ```
// More generally, you can use any monad which implements `MonadUnliftIOFail` in the `body` function.
// ```
// with_file_m: [m: MonadUnliftIOFail] Path -> String -> (IOHandle -> m a) -> m a;
// with_file_m = |path, mode, body| (
//     with_run_in_iofail(|run|
//         with_file(path, mode, body >> run)
//     )
// );
// ```
module Minilib.Monad.UnliftIO;

import Minilib.Common.Common;
import Minilib.Functor.Pair;
import Minilib.Monad.Iden;
import Minilib.Monad.IO;
import Minilib.Monad.Reader;
import Minilib.Monad.Writer;
import Minilib.Monad.State;
import Minilib.Monad.Result;

trait MonadUnliftIO = Monad + MonadUnliftIOIF;
trait MonadUnliftIOFail = Monad + MonadUnliftIOIF + MonadUnliftIOFailIF;

trait [m: *->*] m: MonadUnliftIOIF {
    // A functor which is used in the return type of the `run` function and the `body` function.
    // This is a kind of "unlifted" version of the return type.
    // For example, it is like `(e, a)` for the Writer Monad, and `Result ErrMsg a` for the ResultT monad.
    // This is a functor, so you can use `Functor::map` in the `body` function.
    type UnliftedIO m: * -> *;

    // # Parameters
    // - `body`: A function which receives the `run` function as an argument,
    //           and returns an IO monad.
    //           The `run` function converts your monad `m a` into an IO monad of type `UnliftedIO m a`.
    //           You have to return an IO monad of type `UnliftedIO m b` from the `body` function.
    with_run_in_io: ((m a -> IO (UnliftedIO m a)) -> IO (UnliftedIO m b)) -> m b;
}

// This interface is similar to `MonadUnliftIOIF`. 
// The `run` function converts your monad to an `IOFail` monad, not an `IO` monad.
trait [m: *->*] m: MonadUnliftIOFailIF {
    type UnliftedIOFail m: * -> *;
    with_run_in_iofail: ((m a -> IOFail (UnliftedIOFail m a)) -> IOFail (UnliftedIOFail m b)) -> m b;
}

impl IO: MonadUnliftIOIF {
    type UnliftedIO IO = Iden;
    with_run_in_io = |body| body(map(Iden::make)).map(Iden::get);
}

impl IOFail: MonadUnliftIOIF {
    type UnliftedIO IOFail = Result ErrMsg;
    with_run_in_io = |body| body(to_result).from_io_result;
}

impl IOFail: MonadUnliftIOFailIF {
    type UnliftedIOFail IOFail = Iden;
    with_run_in_iofail = |body| body(map(Iden::make)).map(Iden::get);
}

impl [m: MonadUnliftIO] ReaderT e m: MonadUnliftIOIF {
    type UnliftedIO (ReaderT e m) = UnliftedIO m;
    with_run_in_io = |body| (
        reader_t $ |e|
        with_run_in_io(|run|
            body(run_reader_t(e) >> run)
        )
    );
}

impl [m: MonadUnliftIOFail] ReaderT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (ReaderT e m) = UnliftedIOFail m;
    with_run_in_iofail = |body| (
        reader_t $ |e|
        with_run_in_iofail(|run|
            body(run_reader_t(e) >> run)
        )
    );
}

impl [m: MonadUnliftIO] WriterT e m: MonadUnliftIOIF {
    type UnliftedIO (WriterT e m) = PairRT e (UnliftedIO m);
    with_run_in_io = |body| (
        writer_t $
        with_run_in_io(|run|
            body(run_writer_t >> run >> map(PairRT::make)).map(PairRT::get)
        )
    );
}

impl [m: MonadUnliftIOFail] WriterT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (WriterT e m) = PairRT e (UnliftedIOFail m);
    with_run_in_iofail = |body| (
        writer_t $
        with_run_in_iofail(|run|
            body(run_writer_t >> run >> map(PairRT::make)).map(PairRT::get)
        )
    );
}

impl [m: MonadUnliftIO] StateT s m: MonadUnliftIOIF {
    type UnliftedIO (StateT s m) = PairRT s (UnliftedIO m);
    with_run_in_io = |body| (
        state_t $ |s|
        with_run_in_io(|run|
            body(run_state_t(s) >> run >> map(PairRT::make)).map(PairRT::get)
        )
    );
}

impl [m: MonadUnliftIOFail] StateT s m: MonadUnliftIOFailIF {
    type UnliftedIOFail (StateT s m) = PairRT s (UnliftedIOFail m);
    with_run_in_iofail = |body| (
        state_t $ |s|
        with_run_in_iofail(|run|
            body(run_state_t(s) >> run >> map(PairRT::make)).map(PairRT::get)
        )
    );
}

impl [m: MonadUnliftIO] ResultT e m: MonadUnliftIOIF {
    type UnliftedIO (ResultT e m) = ResultT e (UnliftedIO m);
    with_run_in_io = |body| (
        result_t $ 
        with_run_in_io(|run| 
            body(run_result_t >> run >> map(result_t)).map(run_result_t)
        )
    );
}

// TODO: can implement with only [m: MonadUnliftIO]?
impl [m: MonadUnliftIOFail] ResultT e m: MonadUnliftIOFailIF {
    type UnliftedIOFail (ResultT e m) = ResultT e (UnliftedIOFail m);
    with_run_in_iofail = |body| (
        result_t $ 
        with_run_in_iofail(|run| 
            body(run_result_t >> run >> map(result_t)).map(run_result_t)
        )
    );
}
