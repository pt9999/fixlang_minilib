module Publisher.Tests.PublishTest;

import Minilib.Common.IORef;
import Minilib.Monad.Reader;
import Minilib.Monad.IO;
import Minilib.Testing.UnitTest;
import Minilib.Trait.Traversable;

import Publisher.Common;
import Publisher.Publish;
import Publisher.ProcessRunner;
import Publisher.Fs;
import Publisher.ConsoleUi;
import Publisher.Tests.MockProcessRunner;
import Publisher.Tests.MockFs;
import Publisher.Tests.MockConsoleUi;
import Publisher.Tests.MockEnv;

test_check_git_working_tree_ok1: TestCase;
test_check_git_working_tree_ok1 = (
    make_env_test("test_check_git_working_tree_ok1") $ |env: MockEnv|
    env.setup_fs(add_directory(".git"));;
    env.run(check_git_working_tree)
);

test_check_git_working_tree_ok2: TestCase;
test_check_git_working_tree_ok2 = (
    make_env_test("test_check_git_working_tree_ok2") $ |env: MockEnv|
    env.setup_fs(add_file(".git", "some content"));;
    env.run(check_git_working_tree)
);

test_check_git_working_tree_ng: TestCase;
test_check_git_working_tree_ng = (
    make_env_test("test_check_git_working_tree_ng") $ |env: MockEnv|
    let res = *env.run_catch(check_git_working_tree);
    assert_equal("res", err $ "File not found: " + DirName::git, res)
);

test_check_branch_name_ok: TestCase;
test_check_branch_name_ok = (
    make_env_test("test_check_branch_name_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout("  main  "));;
    env.run(check_branch_name("main"));;
    let expected = [
        MockProcess::make(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes))
);

test_check_branch_name_ng: TestCase;
test_check_branch_name_ng = (
    make_env_test("test_check_branch_name_ng") $ |env: MockEnv|
    env.setup_runner(next_stdout("  develop  "));;
    let res = *env.run_catch(check_branch_name("main"));
    assert_equal("res", err $ "The current branch name is not `main`: actual = `develop`", res)
);

test_check_uncommitted_files_ok: TestCase;
test_check_uncommitted_files_ok = (
    make_env_test("test_check_uncommitted_files_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout(""));;
    env.run(check_uncommitted_files);;
    let expected = [
        MockProcess::make(["git", "diff", "--name-only"]).verbose
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes))
);

test_check_uncommitted_files_ng: TestCase;
test_check_uncommitted_files_ng = (
    make_env_test("test_check_uncommitted_files_ng") $ |env: MockEnv|
    env.setup_runner(next_stdout("some_file"));;
    let res = *env.run_catch(check_uncommitted_files);
    assert_equal("res", err $ "Uncommitted file exists", res)
);

test_no_commit_since_latest_ok: TestCase;
test_no_commit_since_latest_ok = (
    make_env_test("test_no_commit_since_latest_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout(""));;
    let result = *env.run(no_commit_since_latest);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", TagName::latest]).verbose
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes));;
    assert_equal("result", true, result)
);

test_no_commit_since_latest_ng: TestCase;
test_no_commit_since_latest_ng = (
    make_env_test("test_no_commit_since_latest_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout("some_commit"));;
    let result = *env.run(no_commit_since_latest);
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", TagName::latest]).verbose
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes));;
    assert_equal("result", false, result)
);

test_reset_fixdeps_lock_ok: TestCase;
test_reset_fixdeps_lock_ok = (
    make_env_test("test_reset_fixdeps_lock_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout("some_commit"));;
    env.run(reset_fixdeps_lock);;
    let expected = [
        MockProcess::make(["git", "checkout", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]).verbose
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes))
);

test_commit_fixdeps_lock_ok: TestCase;
test_commit_fixdeps_lock_ok = (
    make_env_test("test_commit_fixdeps_lock_ok") $ |env: MockEnv|
    env.setup_runner(next_stdout("fixdeps.lock"));;
    env.run(commit_fixdeps_lock);;
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]),
        MockProcess::make(["git", "add", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]).verbose,
        MockProcess::make(["git", "commit", "-m", "update deps", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]).verbose,
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes))
);

test_commit_fixdeps_lock_ng: TestCase;
test_commit_fixdeps_lock_ng = (
    make_env_test("test_commit_fixdeps_lock_ng") $ |env: MockEnv|
    env.setup_runner(next_stdout(""));;
    env.run(commit_fixdeps_lock);;
    let expected = [
        MockProcess::make(["git", "diff", "--name-only", "--", FileName::fixdeps_lock, FileName::fixdeps_test_lock]),
    ];
    assert_equal("processes", expected, *env.gets(@runner, @processes))
);

test_chdir_to_project_dir_ok: TestCase;
test_chdir_to_project_dir_ok = (
    make_env_test("test_check_if_file_exists_ok") $ |env: MockEnv|
    env.setup_fs(add_directory("some/dir"));;
    env.run(chdir_to_project_dir("some/dir"))
);

test_chdir_to_project_dir_ng: TestCase;
test_chdir_to_project_dir_ng = (
    make_env_test("test_chdir_to_project_dir_ng") $ |env: MockEnv|
    let res = *env.run_catch(chdir_to_project_dir("nonexistent/dir"));
    assert_equal("res", err $ "Directory not found: nonexistent/dir", res)
);

test_check_project_file_exists_ok: TestCase;
test_check_project_file_exists_ok = (
    make_env_test("test_check_project_file_exists_ok") $ |env: MockEnv|
    env.setup_fs(add_file(FileName::fixproj_toml, "some_contents"));;
    env.run(check_project_file_exists)
);

test_check_project_file_exists_ng: TestCase;
test_check_project_file_exists_ng = (
    make_env_test("test_check_project_file_exists_ng") $ |env: MockEnv|
    let res = *env.run_catch(check_project_file_exists);
    assert_equal("res", err $ "File not found: " + FileName::fixproj_toml, res)
);

test_check_if_file_exists_ok: TestCase;
test_check_if_file_exists_ok = (
    make_env_test("test_check_if_file_exists_ok") $ |env: MockEnv|
    env.setup_fs(add_file("some_file", "some_contents"));;
    env.run(check_if_file_exists("some_file"))
);

test_check_if_file_exists_ng: TestCase;
test_check_if_file_exists_ng = (
    make_env_test("test_check_if_file_exists_ng") $ |env: MockEnv|
    env.setup_fs(add_file("some_file", "some_contents"));;
    let res = *env.run_catch(check_if_file_exists("some_file2"));
    assert_equal("res", err $ "File not found: some_file2", res)
);

test_check_if_directory_exists_ok: TestCase;
test_check_if_directory_exists_ok = (
    make_env_test("test_check_if_directory_exists_ok") $ |env: MockEnv|
    env.setup_fs(add_directory("some_directory"));;
    env.run(check_if_directory_exists("some_directory"))
);

test_check_if_directory_exists_ng: TestCase;
test_check_if_directory_exists_ng = (
    make_env_test("test_check_if_directory_exists_ng") $ |env: MockEnv|
    env.setup_fs(add_directory("some_directory"));;
    let res = *env.run_catch(check_if_directory_exists("some_directory2"));
    assert_equal("res", err $ "Directory not found: some_directory2", res)
);

make_publish_fixture: PublishArgs -> MockEnv -> IOFail MockEnv;
make_publish_fixture = |args, env| (
    env.setup_fs(|fs| fs.add_directory(".git"));;
    env.setup_fs(|fs| fs.add_directory("proj1"));;
    let project_file_path = "fixproj.toml";
    let project_file_contents = "[general]\nname = \"project1\"\nversion = \"0.1.0\"\n";
    env.setup_fs(|fs| fs.add_file(project_file_path, project_file_contents));;

    // current branch is main
    env.setup_runner(match_cmdline("git rev-parse --abbrev-ref HEAD").then_print("main").add_action);;
    // some commit exists since latest
    env.setup_runner(match_cmdline("git diff --name-only latest").then_print("some_commit").add_action);;

    //env.setup_console_ui(set_input("0.2.0\nyes\n"));;
    pure $ env
);

test_do_publish: TestCase;
test_do_publish = (
    make_env_test("test_do_publish") $ |env: MockEnv|
    let args = PublishArgs::empty.set_project_dir("proj1").set_confirm(false).set_commit(true).set_push(true).set_tag(true).set_update_document(true);
    let env = *env.make_publish_fixture(args);
    env.run(do_publish(args));;
    let expected = args.@project_dir;
    assert_equal("cwd", expected, *env.gets(@fs, @cwd));;
    let processes = *env.gets(@runner, @processes);
    let cmdlines = processes.to_iter.map(get_cmdline).to_array;
    //cmdlines.to_iter.foreach_m(eprintln).lift;;
    assert_true("push origin vertag", cmdlines.contains("git push origin 0.1.1"));;
    assert_true("push origin latest", cmdlines.contains("git push origin latest -f"));;
    let project_file = *env.gets(@fs, get_file("fixproj.toml"));
    assert_true("project_file", project_file.map(find("version = \"0.1.1\"",0)).is_some);;
    pure()
);

// TODO: add tests for do_publish

testsuite: TestCase;
testsuite = (
    [
        test_check_git_working_tree_ok1,
        test_check_git_working_tree_ok2,
        test_check_git_working_tree_ng,
        test_check_branch_name_ok,
        test_check_branch_name_ng,
        test_check_uncommitted_files_ok,
        test_check_uncommitted_files_ng,
        test_no_commit_since_latest_ok,
        test_no_commit_since_latest_ng,
        test_reset_fixdeps_lock_ok,
        test_commit_fixdeps_lock_ok,
        test_commit_fixdeps_lock_ng,
        test_chdir_to_project_dir_ok,
        test_chdir_to_project_dir_ng,
        test_check_project_file_exists_ok,
        test_check_project_file_exists_ng,
        test_check_if_file_exists_ok,
        test_check_if_file_exists_ng,
        test_check_if_directory_exists_ok,
        test_check_if_directory_exists_ng,
        test_do_publish,
    ]
    .run_tests
);